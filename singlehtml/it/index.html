<!DOCTYPE html>

<html lang="it" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>C++ Core Guidelines Maggio 2024 documentazione</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/translations.js"></script>
    <link rel="index" title="Indice" href="genindex.html" />
    <link rel="search" title="Cerca" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="welcome-to-c-core-guidelines-italiano-s-documentation">
<h1>Benvenuti nelle C++ Core Guidelines (Italiano)!<a class="headerlink" href="#welcome-to-c-core-guidelines-italiano-s-documentation" title="Link to this heading">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-README"></span><p><a class="reference external" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines"><img alt="C++ Core Guidelines in italiano" src="_images/cpp_core_guidelines_logo_text.png" /></a></p>
<blockquote>
<div><p>«All’interno del C++ c’è un più piccolo, semplice e sicuro linguaggio, che lotta per uscire fuori».
– <cite>Bjarne Stroustrup</cite></p>
</div></blockquote>
<p>Le <a class="reference internal" href="#document-CppCoreGuidelines"><span class="std std-doc">C++ Core Guidelines</span></a> costituiscono  un lavoro di gruppo guidato da Bjarne Stroustrup, proprio come lo stesso linguaggio C++. Sono il risultato di molti anni-uomo di discussione e progettazione in diverse organizzazioni. Per come sono progettate incoraggiano una generale applicabilità ed un’ampia adozione ma si possono liberamente copiare e modificare per soddisfare le esigenze della propria organizzazione.</p>
<section id="getting-started">
<h2>Per iniziare<a class="headerlink" href="#getting-started" title="Link to this heading">¶</a></h2>
<p>Le stesse «guidelines» si trovano in <a class="reference internal" href="#document-CppCoreGuidelines"><span class="std std-doc">CppCoreGuidelines</span></a>. Il documento è in <a class="reference external" href="https://github.github.com/gfm/">GH-flavored MarkDown</a>. Viene intenzionalmente mantenuto semplice, principalmente in ASCII, per consentire un post-processing automatico come la traduzione e la riformattazione. I redattori ne mantengono una <a class="reference external" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">versione formattata per la lettura</a>. Si noti che viene integrato manualmente e può essere leggermente più datato della versione nel branch principale. (NDT: La versione formattata in italiano è facilmente ottenibile con <a class="reference external" href="https://pandoc.org">Pandoc</a>. Cfr. <a class="reference external" href="https://github.com/BravoBaldo/CppCoreGuidelines_Ita">Readme.md</a>).</p>
<p>Le Linee-guida costituiscono un documento in continua evoluzione senza una rigida cadenza di «rilasci». Bjarne Stroustrup rivede periodicamente il documento incrementando il numero della versione nell’introduzione. <a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/releases">I checkin che incrementano il numero della versione</a> vengono taggati in git.</p>
<p>Molte delle linee-guida usano l’header unico della Guidelines Support Library. Un’implementazione è disponibile su <a class="reference external" href="https://github.com/Microsoft/GSL">GSL: Guidelines Support Library</a>.</p>
</section>
<section id="background-and-scope">
<h2>Background e scopo<a class="headerlink" href="#background-and-scope" title="Link to this heading">¶</a></h2>
<p>Lo scopo delle linee-guida è quello di aiutare le persone ad usare il C++ moderno in modo efficace. Per «C++ moderno» si intende il C++11 e versioni successive. In altre parole, come vorreste che fosse il vostro codice tra 5 anni, potendo iniziare adesso? E tra 10 anni?</p>
<p>Le linee-guida si concentrano sulle questioni di livello relativamente più alto, come le interfacce, la gestione delle risorse, la gestione della memorie e la concorrenza. Queste regole riguardano l’applicazione dell’architettura e il design della libreria. Seguire le regole porterà ad un codice staticamente type-safe, senza leak [perdite] di risorse, e che intercetta molti più errori logici di programmazione di quanto avvenga nel normale codice oggi. E girerà velocemente – ci si può permettere di fare le cose nel modo giusto.</p>
<p>Ci si occupa un po” meno dei problemi di basso livello, come le convenzioni sui nomi e lo stile della indentazione. Tuttavia, niente di ciò che può aiutare il programmatore è fuori luogo.</p>
<p>Il gruppo iniziale di regole enfatizza la sicurezza (sotto varie forme) e la semplicità. Potrebbero essere fin troppo severe. Ci si aspetta di dover introdurre più eccezioni per venire meglio incontro alle esigenze del mondo reale. Altre regole sono necessarie.</p>
<p>Alcune delle regole risulteranno contrarie alle proprie aspettative e persino contrarie alla propria esperienza. Se non vi abbiamo convinto a modificare in alcun modo lo stile del vostro codice, abbiamo fallito! Provate a verificare o confutare le regole! In particolare, si vorrebbe davvero avere su alcune regole un sostegno con misure ed esempi migliori.</p>
<p>Alcune regole risulteranno ovvie o addirittura banali. Si ricordi che lo scopo di una linea-guida è quello di aiutare qualcuno che ha meno esperienza o che proviene da un diverso background o da un diverso linguaggio, a mettersi al passo.</p>
<p>Le regole sono progettate per essere supportate da uno strumento di analisi. Le violazioni alle regole verranno contrassegnate con riferimenti (o link) alla regola violata. Non ci aspettiamo che memorizziate tutte le regole senza aver prima provato a scrivere il codice.</p>
<p>Le regole sono pensate per essere introdotte gradualmente in un codice. Per questo c’è in programma la realizzazione di tool e si spera che anche altri lo facciano.</p>
</section>
<section id="contributions-and-license">
<h2>Contributi e LICENZA<a class="headerlink" href="#contributions-and-license" title="Link to this heading">¶</a></h2>
<p>I commenti e i suggerimenti per migliorare sono sempre benvenuti. Si prevede di modificare ed estendere questo documento man mano che migliora la nostra comprensione, il linguaggio o l’insieme delle librerie disponibili. Ulteriori dettagli si trovano su <a class="reference internal" href="#document-CONTRIBUTING"><span class="std std-doc">CONTRIBUTI</span></a> e <a class="reference download internal" download="" href="_downloads/9879d6db96fd29134fc802214163b95a/LICENSE"><span class="xref download myst">LICENZA</span></a>.</p>
<p>Grazie alla <a class="reference external" href="https://www.digitalocean.com/?refcode=32f291566cf7&amp;amp;utm_campaign=Referral_Invite&amp;amp;utm_medium=Referral_Program&amp;amp;utm_source=CopyPaste">DigitalOcean</a> per ospitare il sito web della Standard C++ Foundation.</p>
</section>
<span id="document-CppCoreGuidelines"></span><section id="c-core-guidelines">
<h2><a name="main"></a>C++ Core Guidelines<a class="headerlink" href="#c-core-guidelines" title="Link to this heading">¶</a></h2>
<p>11 Maggio 2024</p>
<p>Editori:</p>
<ul class="simple">
<li><p><a class="reference external" href="http://www.stroustrup.com">Bjarne Stroustrup</a></p></li>
<li><p><a class="reference external" href="http://herbsutter.com/">Herb Sutter</a> Traduzione: <a class="reference external" href="https://github.com/BravoBaldo/CppCoreGuidelines_Ita">Baldassarre Cesarano</a></p></li>
</ul>
<p>Questo è un documento vivo in costante miglioramento. Se fosse stato un progetto open-source (software), starebbe alla release 0.8. La copia, l’uso, la modifica e la creazione di opere derivate da questo progetto sono concesse con una licenza simile a quella del MIT. Per contribuire a questo progetto si richiede l’accettazione di una «Licenza per Collaboratori» [Contributor License]. Per i dettagli, vedere il file <a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/LICENSE">LICENSE</a>. Questo progetto è a disposizione degli «utenti amichevoli» per usarlo, copiarlo, modificarlo e ricavarne altri lavori, sperando in input costruttivi.</p>
<p>I commenti e i suggerimenti per migliorare sono sempre benvenuti. Si prevede di modificare ed estendere questo documento man mano che migliora la nostra comprensione, il linguaggio o l’insieme delle librerie disponibili. Nel commentare, si tenga presente <a class="reference internal" href="#S-introduction"><span class="xref myst">l’introduzione</span></a> che delinea i nostri obiettivi e l’approccio generale. L’elenco dei contributori si trova <a class="reference internal" href="#SS-ack"><span class="xref myst">qui</span></a>.</p>
<p>Problemi:</p>
<ul class="simple">
<li><p>I gruppi di regole non sono stati totalmente controllati per quanto riguarda la completezza, la consistenza e l’obbligatorietà.</p></li>
<li><p>Tre punti interrogativi (???) contrassegnano la riconosciuta mancanza di informazioni</p></li>
<li><p>Le sezioni dei riferimenti [reference] sono aggiornate; molte fonti antecedenti al C++11 sono troppo vecchie.</p></li>
<li><p>Per un elenco più o meno aggiornato di cose da fare: <a class="reference internal" href="#S-unclassified"><span class="xref myst">To-do: Proto-regole non classificate</span></a></p></li>
</ul>
<p>Si può <a class="reference internal" href="#S-abstract"><span class="xref myst">leggere una spiegazione dello scopo e sulla struttura di questa Guida</span></a> o semplicemente proseguire oltre:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#S-introduction"><span class="xref myst">In: Introduzione</span></a></p></li>
<li><p><a class="reference internal" href="#S-philosophy"><span class="xref myst">P: Filosofia</span></a></p></li>
<li><p><a class="reference internal" href="#S-interfaces"><span class="xref myst">I: Interfacce</span></a></p></li>
<li><p><a class="reference internal" href="#S-functions"><span class="xref myst">F: Funzioni</span></a></p></li>
<li><p><a class="reference internal" href="#S-class"><span class="xref myst">C: Classi e gerarchie di classi</span></a></p></li>
<li><p><a class="reference internal" href="#S-enum"><span class="xref myst">Enum: Enumerazioni</span></a></p></li>
<li><p><a class="reference internal" href="#S-resource"><span class="xref myst">R: Gestione delle risorse</span></a></p></li>
<li><p><a class="reference internal" href="#S-expr"><span class="xref myst">ES: Espressioni e istruzioni</span></a></p></li>
<li><p><a class="reference internal" href="#S-performance"><span class="xref myst">Per: Prestazione</span></a></p></li>
<li><p><a class="reference internal" href="#S-concurrency"><span class="xref myst">CP: Concorrenza e parallelismo</span></a></p></li>
<li><p><a class="reference internal" href="#S-errors"><span class="xref myst">E: Gestione degli errori</span></a></p></li>
<li><p><a class="reference internal" href="#S-const"><span class="xref myst">Con: Costanti e immutabilità</span></a></p></li>
<li><p><a class="reference internal" href="#S-templates"><span class="xref myst">T: Template e programmazione generica</span></a></p></li>
<li><p><a class="reference internal" href="#S-cpl"><span class="xref myst">CPL: Programmazione C-style</span></a></p></li>
<li><p><a class="reference internal" href="#S-source"><span class="xref myst">SF: File sorgenti</span></a></p></li>
<li><p><a class="reference internal" href="#sl-the-standard-library"><span class="xref myst">SL: La Libreria Standard</span></a></p></li>
</ul>
<p>Sezioni di supporto:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#S-A"><span class="xref myst">A: Idee architetturali</span></a></p></li>
<li><p><a class="reference internal" href="#S-not"><span class="xref myst">NR: Non-Regole e miti</span></a></p></li>
<li><p><a class="reference internal" href="#S-references"><span class="xref myst">RF: Riferimenti</span></a></p></li>
<li><p><a class="reference internal" href="#S-profile"><span class="xref myst">Pro: Profili</span></a></p></li>
<li><p><a class="reference internal" href="#gsl-guidelines-support-library"><span class="xref myst">GSL: Libreria di Supporto alle Linee-guida</span></a></p></li>
<li><p><a class="reference internal" href="#S-naming"><span class="xref myst">NL: Suggerimenti per la nomenclatura e il layout</span></a></p></li>
<li><p><a class="reference internal" href="#S-faq"><span class="xref myst">FAQ: Risposte a domande frequenti</span></a></p></li>
<li><p><a class="reference internal" href="#S-libraries"><span class="xref myst">Appendix A: Librerie</span></a></p></li>
<li><p><a class="reference internal" href="#S-modernizing"><span class="xref myst">Appendix B: Modernizzazione del codice</span></a></p></li>
<li><p><a class="reference internal" href="#S-discussion"><span class="xref myst">Appendice C: Discussione</span></a></p></li>
<li><p><a class="reference internal" href="#S-tools"><span class="xref myst">Appendice D: Tool di supporto</span></a></p></li>
<li><p><a class="reference internal" href="#S-glossary"><span class="xref myst">Glossario</span></a></p></li>
<li><p><a class="reference internal" href="#S-unclassified"><span class="xref myst">To-do: Proto-regole non classificate</span></a></p></li>
</ul>
<p>Si possono provare le regole per delle specifiche funzionalità del linguaggio:</p>
<ul class="simple">
<li><p>assignment: <a class="reference internal" href="#Rc-regular"><span class="xref myst">tipi regolari</span></a> – <a class="reference internal" href="#Rc-initialize"><span class="xref myst">preferire l’inizializzazione</span></a> – <a class="reference internal" href="#Rc-copy-semantic"><span class="xref myst">copia</span></a> – <a class="reference internal" href="#Rc-move-semantic"><span class="xref myst">spostamento</span></a> – <a class="reference internal" href="#Rc-matched"><span class="xref myst">altre operazioni</span></a> – <a class="reference internal" href="#Rc-eqdefault"><span class="xref myst">default</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">class</span></code>: <a class="reference internal" href="#Rc-org"><span class="xref myst">dato</span></a> – <a class="reference internal" href="#Rc-struct"><span class="xref myst">invariante</span></a> – <a class="reference internal" href="#Rc-member"><span class="xref myst">membri</span></a> – <a class="reference internal" href="#Rc-helper"><span class="xref myst">helper</span></a> – <a class="reference internal" href="#SS-concrete"><span class="xref myst">tipi concreti</span></a> – <a class="reference internal" href="#S-ctor"><span class="xref myst">cistruttori, =, e distruttori</span></a> – <a class="reference internal" href="#SS-hier"><span class="xref myst">gerarchia</span></a> – <a class="reference internal" href="#SS-overload"><span class="xref myst">operatori</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">concetto</span></code>: <a class="reference internal" href="#SS-concepts"><span class="xref myst">rules</span></a> – <a class="reference internal" href="#Rt-raise"><span class="xref myst">nella programmazione generica</span></a> – <a class="reference internal" href="#Rt-concepts"><span class="xref myst">argomenti template</span></a> – <a class="reference internal" href="#Rt-low"><span class="xref myst">semantica</span></a></p></li>
<li><p>construttore: <a class="reference internal" href="#Rc-struct"><span class="xref myst">invariante</span></a> – <a class="reference internal" href="#Rc-ctor"><span class="xref myst">stabilire l’invariante</span></a> – <a class="reference internal" href="#Rc-throw"><span class="xref myst">eccezioni <code class="docutils literal notranslate"><span class="pre">throw</span></code></span></a> – <a class="reference internal" href="#Rc-default0"><span class="xref myst">default</span></a> – <a class="reference internal" href="#Rc-default"><span class="xref myst">non necessario</span></a> – <a class="reference internal" href="#Rc-explicit"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">esplicito</span></code></span></a> – <a class="reference internal" href="#Rc-delegating"><span class="xref myst">delegante</span></a> – <a class="reference internal" href="#Rc-ctor-virtual"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">virtuale</span></code></span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">classe</span></code> derivata: <a class="reference internal" href="#Rh-domain"><span class="xref myst">quando usarla</span></a> – <a class="reference internal" href="#Rh-abstract"><span class="xref myst">come interfaccia</span></a> – <a class="reference internal" href="#Rh-dtor"><span class="xref myst">distruttori</span></a> – <a class="reference internal" href="#Rh-copy"><span class="xref myst">copia</span></a> – <a class="reference internal" href="#Rh-get"><span class="xref myst">getter e setter</span></a> – <a class="reference internal" href="#Rh-mi-interface"><span class="xref myst">ereditarietà multipla</span></a> – <a class="reference internal" href="#Rh-using"><span class="xref myst">overloading</span></a> – <a class="reference internal" href="#Rc-copy-virtual"><span class="xref myst">slicing</span></a> – <a class="reference internal" href="#Rh-dynamic_cast"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code></span></a></p></li>
<li><p>distruttore: <a class="reference internal" href="#Rc-matched"><span class="xref myst">e costruttori</span></a> – <a class="reference internal" href="#Rc-dtor"><span class="xref myst">quando è necessario?</span></a> – <a class="reference internal" href="#Rc-dtor-fail"><span class="xref myst">non deve fallire</span></a></p></li>
<li><p>eccezione: <a class="reference internal" href="#S-errors"><span class="xref myst">errori</span></a> – <a class="reference internal" href="#Re-throw"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">throw</span></code></span></a> – <a class="reference internal" href="#Re-errors"><span class="xref myst">solo per gli errori</span></a> – <a class="reference internal" href="#Re-noexcept"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">noexcept</span></code></span></a> – <a class="reference internal" href="#Re-catch"><span class="xref myst">minimizzare i <code class="docutils literal notranslate"><span class="pre">try</span></code></span></a> – <a class="reference internal" href="#Re-no-throw-codes"><span class="xref myst">e se non ci fossero eccezioni?</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">for</span></code>: <a class="reference internal" href="#Res-for-range"><span class="xref myst">range-for e for</span></a> – <a class="reference internal" href="#Res-for-while"><span class="xref myst">for e while</span></a> – <a class="reference internal" href="#Res-for-init"><span class="xref myst">for-initializer</span></a> – <a class="reference internal" href="#Res-empty"><span class="xref myst">body vuoto</span></a> – <a class="reference internal" href="#Res-loop-counter"><span class="xref myst">variabile del loop</span></a> – <a class="reference internal" href="#Res-???"><span class="xref myst">tipo della variabile del loop ???</span></a></p></li>
<li><p>funzione: <a class="reference internal" href="#Rf-package"><span class="xref myst">nomenclatura</span></a> – <a class="reference internal" href="#Rf-logical"><span class="xref myst">operazione singola</span></a> – <a class="reference internal" href="#Rf-noexcept"><span class="xref myst">senza throw</span></a> – <a class="reference internal" href="#Rf-smart"><span class="xref myst">argomenti</span></a> – <a class="reference internal" href="#Rf-conventional"><span class="xref myst">passaggio di argomenti</span></a> – <a class="reference internal" href="#Rf-out-multi"><span class="xref myst">valori di ritorno multipli</span></a> – <a class="reference internal" href="#Rf-return-ptr"><span class="xref myst">puntatori</span></a> – <a class="reference internal" href="#Rf-capture-vs-overload"><span class="xref myst">lambda</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inline</span></code>: <a class="reference internal" href="#Rf-inline"><span class="xref myst">piccole funzioni</span></a> – <a class="reference internal" href="#Rs-inline"><span class="xref myst">negli header</span></a></p></li>
<li><p>inizializzazione: <a class="reference internal" href="#Res-always"><span class="xref myst">sempre</span></a> – <a class="reference internal" href="#Res-list"><span class="xref myst">preferire <code class="docutils literal notranslate"><span class="pre">{}</span></code></span></a> – <a class="reference internal" href="#Res-lambda-init"><span class="xref myst">lambda</span></a> – <a class="reference internal" href="#Rc-in-class-initializer"><span class="xref myst">inizializzatori membro di default</span></a> – <a class="reference internal" href="#Rc-initialize"><span class="xref myst">membri della classe</span></a> – <a class="reference internal" href="#Rc-factory"><span class="xref myst">funzioni factory</span></a></p></li>
<li><p>espressione lambda: <a class="reference internal" href="#SS-lambdas"><span class="xref myst">quando usarla</span></a></p></li>
<li><p>operatore: <a class="reference internal" href="#Ro-conventional"><span class="xref myst">convenzionale</span></a> – <a class="reference internal" href="#Ro-conversion"><span class="xref myst">evitare la conversione degli operatori</span></a> – <a class="reference internal" href="#Ro-lambda"><span class="xref myst">e le lambda</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">public</span></code>, <code class="docutils literal notranslate"><span class="pre">private</span></code>, e <code class="docutils literal notranslate"><span class="pre">protected</span></code>: <a class="reference internal" href="#Rc-private"><span class="xref myst">occultamento delle informazioni</span></a> – <a class="reference internal" href="#Rh-public"><span class="xref myst">consistenza</span></a> – <a class="reference internal" href="#Rh-protected"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">protected</span></code></span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">static_assert</span></code>: <a class="reference internal" href="#Rp-compile-time"><span class="xref myst">controllo in fase di compilazione</span></a> – <a class="reference internal" href="#Rt-check-class"><span class="xref myst">e concetti</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">struct</span></code>: <a class="reference internal" href="#Rc-org"><span class="xref myst">per organizzare i dati</span></a> – <a class="reference internal" href="#Rc-struct"><span class="xref myst">usare se non sono invarianti</span></a> – <a class="reference internal" href="#Rc-class"><span class="xref myst">senza membri privati</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">template</span></code>: <a class="reference internal" href="#Rt-raise"><span class="xref myst">astrazione</span></a> – <a class="reference internal" href="#Rt-cont"><span class="xref myst">contenitori</span></a> – <a class="reference internal" href="#Rt-concepts"><span class="xref myst">concetti</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unsigned</span></code>: <a class="reference internal" href="#Res-mix"><span class="xref myst">e signed</span></a> – <a class="reference internal" href="#Res-unsigned"><span class="xref myst">manipolazione dei bit</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">virtual</span></code>: <a class="reference internal" href="#Ri-abstract"><span class="xref myst">interfacce</span></a> – <a class="reference internal" href="#Rc-concrete"><span class="xref myst">non <code class="docutils literal notranslate"><span class="pre">virtual</span></code></span></a> – <a class="reference internal" href="#Rc-dtor-virtual"><span class="xref myst">distruttore</span></a> – <a class="reference internal" href="#Rc-dtor-fail"><span class="xref myst">mai fallire</span></a></p></li>
</ul>
<p>Potete vedere le bozze dei progetti usati per esprimere le regole:</p>
<ul class="simple">
<li><p>assertion: ???</p></li>
<li><p>error: ???</p></li>
<li><p>eccezione: garanzia dell’eccezione (???)</p></li>
<li><p>failure: ???</p></li>
<li><p>invariante: ???</p></li>
<li><p>leak: ???</p></li>
<li><p>libreria: ???</p></li>
<li><p>precondizione: ???</p></li>
<li><p>post-condizione: ???</p></li>
<li><p>risorsa: ???</p></li>
</ul>
</section>
<section id="abstract">
<h2><a name="S-abstract"></a>Sommario<a class="headerlink" href="#abstract" title="Link to this heading">¶</a></h2>
<p>Questo documento è un insieme di linee-guida sul buon uso del C++. Lo scopo delle linee-guida è quello di aiutare le persone ad usare il C++ moderno in modo efficace. Per «C++ moderno» si intende l’uso efficace del C++ standard ISO (attualmente C++17, ma quasi tutte le raccomandazioni si applicano anche al C++17, C++14 e al C++11). In altre parole, come vorreste che fosse il vostro codice tra 5 anni, potendo iniziare adesso? E tra 10 anni?</p>
<p>Le linee-guida si concentrano sulle questioni di livello relativamente più alto, come le interfacce, la gestione delle risorse, la gestione della memoria e la concorrenza. Queste regole riguardano l’applicazione dell’architettura e il design della libreria. Seguire le regole porterà ad un codice staticamente type-safe, senza leak [perdite] di risorse, e che intercetta molti più errori logici di programmazione di quanto avvenga nel normale codice oggi. E girerà velocemente – ci si può permettere di fare le cose nel modo giusto.</p>
<p>Ci si occupa un po” meno dei problemi di basso livello, come le convenzioni sui nomi e lo stile della indentazione. Tuttavia, niente di ciò che può aiutare il programmatore è fuori luogo.</p>
<p>Il gruppo iniziale di regole enfatizza la sicurezza (sotto varie forme) e la semplicità. Potrebbero benissimo essere troppo severe. Ci si aspetta di dover introdurre più eccezioni per venire meglio incontro alle esigenze del mondo reale. Altre regole sono necessarie.</p>
<p>Alcune delle regole risulteranno contrarie alle proprie aspettative e persino contrarie alla propria esperienza. Se non vi abbiamo suggerito di modificare in alcun modo di cambiare lo stile del vostro codice, abbiamo fallito! Provate a verificare o confutare le regole! In particolare, si vorrebbe davvero avere su alcune regole un sostegno con misure ed esempi migliori.</p>
<p>Alcune regole risulteranno ovvie o addirittura banali. Si ricordi che lo scopo di una linea-guida è quello di aiutare qualcuno che ha meno esperienza o che proviene da un diverso background o da un diverso linguaggio, a mettersi al passo.</p>
<p>Molte delle regole sono progettate per essere supportate da un tool di analisi. Le violazioni alle regole verranno contrassegnate con riferimenti (o link) alla regola violata. Non ci aspettiamo che memorizziate tutte le regole senza aver prima provato a scrivere il codice. Un modo di vedere queste linee-guida è come a una specifica per dei tool, ma leggibile dagli umani.</p>
<p>Le regole sono pensate per essere introdotte gradualmente in un codice. Per questo c’è in programma la realizzazione di tool e si spera che anche altri lo facciano.</p>
<p>I commenti e i suggerimenti per migliorare sono sempre benvenuti. Si prevede di modificare ed estendere questo documento man mano che migliora la nostra comprensione, il linguaggio o l’insieme delle librerie disponibili.</p>
</section>
<section id="in-introduction">
<h2><a name="S-introduction"></a>In: Introduzione<a class="headerlink" href="#in-introduction" title="Link to this heading">¶</a></h2>
<p>Questa è una serie di linee-guida basilari per il C++ moderno (attualmente il C++20 e il C++17) che tengono conto sia dei possibili futuri miglioramenti che delle ISO Technical Specifications (TS). L’obiettivo è quello di aiutare i programmatori C++ a scrivere codice più semplice, più efficiente e più manutenibile.</p>
<p>Sommario dell’introduzione:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#SS-readers"><span class="xref myst">In.target: Chi sono i lettori?</span></a></p></li>
<li><p><a class="reference internal" href="#SS-aims"><span class="xref myst">In.aims: Obiettivi</span></a></p></li>
<li><p><a class="reference internal" href="#SS-non"><span class="xref myst">In.not: Non-obiettivi</span></a></p></li>
<li><p><a class="reference internal" href="#SS-force"><span class="xref myst">In.force: Imposizione</span></a></p></li>
<li><p><a class="reference internal" href="#SS-struct"><span class="xref myst">In.struct: La struttura di questo documento</span></a></p></li>
<li><p><a class="reference internal" href="#SS-sec"><span class="xref myst">In.sec: Sezioni principali</span></a></p></li>
</ul>
<section id="in-target-target-readership">
<h3><a name="SS-readers"></a>In.target: Chi sono i lettori?<a class="headerlink" href="#in-target-target-readership" title="Link to this heading">¶</a></h3>
<p>Tutti i programmatori C++. Tra cui <a class="reference internal" href="#S-cpl"><span class="xref myst">i programmatori che potrebbero prendere in considerazione il C</span></a>.</p>
</section>
<section id="in-aims-aims">
<h3><a name="SS-aims"></a>In.aims: Obiettivi<a class="headerlink" href="#in-aims-aims" title="Link to this heading">¶</a></h3>
<p>Lo scopo delle linee-guida è quello di aiutare gli sviluppatori ad adottare il C++ moderno (attualmente il C++20 e C++17) e per ottenere uno stile più uniforme nel codice.</p>
<p>Non ci si illude di vedere effettivamente applicate ognuna di queste regole a qualsiasi codice. L’aggiornamento dei vecchi sistemi è difficile. Tuttavia, si crede che un programma che usi una regola sia meno soggetto ad errori e più manutenibile di uno che non lo faccia. Spesso, le regole portano anche ad uno sviluppo iniziale più veloce/facile. Per quanto si sa, queste regole conducono ad un codice che funziona altrettanto bene, se non meglio, di quello più vecchio, con tecniche più convenzionali; sono pensate per seguire il principio dello «zero-overhead» («quello che non si usa, non si paga» e «quando si usa bene un meccanismo di astrazione, si ottengono almeno le stesse buone prestazioni di quelle col codice scritto manualmente utilizzando i costrutti del linguaggio di livello più basso»). Si considerino queste regole ideali per il nuovo codice, un’opportunità da sfruttare quando si lavora su vecchio codice e si tenti di avvicinarsi il più possibile a tali ideali. Da ricordare:</p>
<section id="in-0-don-t-panic">
<h4><a name="R0"></a>In.0: Non farsi prendere dal panico!<a class="headerlink" href="#in-0-don-t-panic" title="Link to this heading">¶</a></h4>
<p>Ci si prenda il tempo necessario per capire le implicazioni di una regola di una linea-guida per il proprio programma.</p>
<p>Queste linee-guida sono progettate secondo il principio del «sottoinsieme di un insieme» (<a class="reference internal" href="#Stroustrup05"><span class="xref myst">Stroustrup05</span></a>). Non definiscono semplicemente un sottoinsieme del C++ da usare (per affidabilità, prestazioni o altro). Esse, invece, raccomandano fermamente l’uso di alcune semplici «estensioni» (<a class="reference internal" href="#gsl-guidelines-support-library"><span class="xref myst">componenti della libreria</span></a>) che rendono ridondanti le funzionalità più soggette ad errori del C++, in modo che possano essere vietate (nel nostro set di regole).</p>
<p>Le regole enfatizzano la sicurezza del tipo statico e la sicurezza delle risorse. Per questo motivo, enfatizzano le possibilità di controllo del range, per evitare la de-referenziazione <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>, per evitare il dangling [penzolamento] dei puntatori, e l’uso sistematico delle eccezioni (tramite il RAII). In parte per questo, e in parte per minimizzare la confusione nel codice come fonte di errori, le regole enfatizzano anche la semplicità e il dover nascondere la complessità necessaria dietro interfacce ben definite.</p>
<p>Molte delle regole sono normative. Ci si trova a disagio con regole che dicono semplicemente «non fare questo!» senza dare un’alternativa. Una conseguenza di ciò è che alcune regole possono essere supportate solo dall’euristica, anziché da controlli precisi e meccanicamente verificabili. Altre regole esprimono principi generali. Per queste regole più generali, di quelle più dettagliate e specifiche, si fornisce un controllo parziale.</p>
<p>Queste linee-guida riguardano il nucleo [core] del C++ e il suo utilizzo. Ci si aspetta che le maggiori organizzazioni, le specifiche aree applicative e persino i grandi progetti avranno bisogno di altre regole, forse di altre restrizioni e di un ulteriore supporto della libreria. Per esempio, i programmatori [hard-real-time] solitamente non possono usare liberamente il [free store] (memoria dinamica) e sono limitati nella scelta delle librerie. Noi incoraggiamo lo sviluppo di regole più specifiche da aggiungere a queste «core guidelines». Costruite le piccole basi della vostra libreria ideale ed usatela, anziché abbassare il livello di programmazione al glorificato codice assembly.</p>
<p>Le regole sono progettate per consentirne una <a class="reference internal" href="#S-modernizing"><span class="xref myst">graduale adozione</span></a>.</p>
<p>Alcune regole mirano ad aumentare le varie forme di sicurezza mentre altre tendono a ridurre la probabilità di incidenti, molte fanno entrambe le cose. Le linee-guida volte alla prevenzione di incidenti spesso vietano codice C++ perfettamente legale. Tuttavia, quando ci sono due modi per esprimere un’idea e uno si è mostrato una comune fonte di errori e l’altro no, proviamo a guidare i programmatori verso quest’ultima.</p>
</section>
</section>
<section id="in-not-non-aims">
<h3><a name="SS-non"></a>In.not: Non-obiettivi<a class="headerlink" href="#in-not-non-aims" title="Link to this heading">¶</a></h3>
<p>Le regole non intendono essere minime o ortogonali. In particolare, le regole generali possono essere semplici, ma impossibili da imporre. Inoltre, spesso è difficile comprendere le implicazioni di una regola generale. Regole più specializzate sono spesso più facili da capire e da applicare, ma senza regole generali si formerebbe solo un lungo elenco di casi speciali. Si forniscono regole volte ad aiutare i principianti ma anche regole a supporto degli esperti. Alcune delle regole si possono completamente imporre, ma altre sono basate sull’euristica.</p>
<p>Queste regole non sono pensate per essere lette in sequenza, come un libro. Si possono consultare usando i link. Tuttavia, il loro uso principale previsto è quello di essere usate per i tool. Cioè, un tool cerca le violazioni per poi restituire i link alle regole violate. Le regole quindi forniscono ragioni, esempi di potenziali conseguenze della violazione e suggeriscono rimedi.</p>
<p>Queste linee-guida non intendono sostituire un tutorial C++. Se serve un tutorial per un certo livello di esperienza, si consultino <a class="reference internal" href="#S-references"><span class="xref myst">i riferimenti</span></a>.</p>
<p>Questa non è una guida su come convertire del vecchio codice C++ in un codice più moderno. Essa ha lo scopo di articolare in modo concreto le idee per il nuovo codice. Tuttavia, si veda <a class="reference internal" href="#S-modernizing"><span class="xref myst">la sezione sulla modernizzazione</span></a> per alcuni possibili approcci alla modernizzazione/ringiovanimento/aggiornamento. È importante sottolineare che le regole supportano l’adozione graduale: in genere è impossibile convertire completamente una grande quantità di codice in una volta sola.</p>
<p>Queste linee guida non sono pensate per essere complete ed esatte in ogni dettaglio tecnico-linguistico. Per l’ultima parola sui problemi di definizione del linguaggio, comprese tutte le eccezioni alle regole generali e ogni funzionalità, si veda lo standard ISO del C++.</p>
<p>Le regole non sono intese per obbligare a scrivere in un sottoinsieme impoverito del C++. Esse sono <em>enfaticamente</em> non intese per definire, per esempio, un sottoinsieme simil-Java del C++. Non sono intese a definire un unico «vero linguaggio C++». Apprezziamo espressività e prestazioni senza compromessi.</p>
<p>Le regole non sono indipendenti dal valore. Hanno lo scopo di rendere il codice più semplice e più corretto/più sicuro della maggior parte del codice C++ esistente, senza perdita di prestazioni. Hanno lo scopo di inibire del codice C++ perfettamente valido ma correlato ad errori, complessità superflua o basse prestazioni.</p>
<p>Le regole non sono precise al punto in cui una persona (o una macchina) le possa seguire senza riflettere. Le parti che lo impongono cercano di farlo, ma preferiremmo lasciare una regola o una definizione un po” vaga ed aperta all’interpretazione anziché specificare qualcosa di preciso e sbagliato. A volte, la precisione arriva solo col tempo e l’esperienza. Il progetto non è (ancora) un formalismo matematico.</p>
<p>Le regole non sono perfette. Una regola può nuocere vietando qualcosa di utile in una determinata situazione. Una regola può nuocere non riuscendo a proibire qualcosa che apre la strada ad un errore grave in una determinata situazione. Una regola può causare molti danni essendo vaga, ambigua, inapplicabile o abilitando ogni soluzione a un problema. È impossibile soddisfare completamente il criterio del «non danneggiare». L’obiettivo, invece, è meno ambizioso: «Fai del tuo meglio per la maggior parte dei programmatori»; se non puoi vivere con una regola, contestala, ignorala, ma non diluirla fino a farle perdere di significato. Inoltre, suggerisci un miglioramento.</p>
</section>
<section id="in-force-enforcement">
<h3><a name="SS-force"></a>In.force: Imposizione<a class="headerlink" href="#in-force-enforcement" title="Link to this heading">¶</a></h3>
<p>Le regole senza un’imposizione non sono gestibili per grandi basi di codice. L’imposizione di tutte le regole è possibile solo per un piccolo insieme di semplici regole o per una specifica comunità di utenti.</p>
<ul class="simple">
<li><p>Ma vogliamo molte regole e vogliamo regole che tutti possano usare.</p></li>
<li><p>Ma persone diverse hanno esigenze diverse.</p></li>
<li><p>Ma alle persone non piace leggere molte regole.</p></li>
<li><p>Ma la gente non ricorda molte regole.</p></li>
</ul>
<p>Quindi, abbiamo bisogno di una suddivisione per soddisfare le tante esigenze.</p>
<ul class="simple">
<li><p>Ma una suddivisione arbitraria porta al caos.</p></li>
</ul>
<p>Vogliamo linee-guida che aiutino molte persone, rendano il codice più uniforme e incoraggino fortemente le persone a modernizzare il loro codice. Vogliamo incoraggiare le migliori pratiche, anziché lasciare tutto alle scelte individuali e alle pressioni del management. L’ideale è usare tutte le regole; questo porta i maggiori benefici.</p>
<p>Questo aggiunge parecchi interrogativi. Cerchiamo di risolvere quelli che utilizzano i tool. Ogni regola ha una sezione <strong>Imposizione</strong> [Enforcement] che elenca le idee per imporla. L’imposizione si può ottenere con la revisione del codice, l’analisi statica, col compilatore o con dei controlli durante l’esecuzione. Ove possibile, preferiamo il controllo «meccanico» (gli umani sono lenti, inaccurati e si annoiano facilmente) e quello statico. I controlli a run-time vengono suggeriti solo raramente laddove non esiste un’alternativa; non si desidera introdurre codice extra distribuito. Se opportuno, etichettiamo una regola (nelle sezioni <strong>Imposizione</strong>) col nome di gruppi di regole correlate (dette «profili»). Una regola può far parte di più profili o di nessuno. Per cominciare, abbiamo alcuni profili corrispondenti ai bisogni comuni (desideri, ideali):</p>
<ul class="simple">
<li><p><strong>type</strong>: Nessuna violazione del tipo (reinterpretando una <code class="docutils literal notranslate"><span class="pre">T</span></code> come una <code class="docutils literal notranslate"><span class="pre">U</span></code> tramite i cast, le union o le vararg)</p></li>
<li><p><strong>bounds</strong>: Nessuna violazione dei limiti [bound] (accedere oltre il range di un array)</p></li>
<li><p><strong>lifetime</strong>: Nessun leak (non riuscire ad eseguire un <code class="docutils literal notranslate"><span class="pre">delete</span></code> o eseguire <code class="docutils literal notranslate"><span class="pre">delete</span></code> multipli) e nessun accesso ad oggetti invalidi (de-referenziazione di <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>, usando un riferimento dangling [penzolante]).</p></li>
</ul>
<p>I profili sono intesi per essere utilizzati dai tool, ma servono anche come aiuto per il lettore umano. Non limitiamo il nostro commento nelle sezioni <strong>Imposizione</strong> alle cose che sappiamo come imporre; alcuni commenti sono semplici desideri che potrebbero ispirare qualche produttore di tool.</p>
<p>I tool che implementano queste regole devono rispettare la sintassi seguente per sopprimere esplicitamente una regola:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[[gsl::suppress(&quot;tag&quot;)]]
</pre></div>
</div>
<p>e facoltativamente con un messaggio (seguendo la solita sintassi degli attributi dello standard C++11):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[[gsl::suppress(&quot;tag&quot;, justification: &quot;message&quot;)]]
</pre></div>
</div>
<p>dove</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;tag&quot;</span></code> è una stringa letterale con il nome dell’ancora [anchor] dell’elemento in cui appare la regola di [Enforcement] (ad esempio, per <a class="reference internal" href="#Rh-public"><span class="xref myst">C.134</span></a> è «Rh-public»), il nome di un gruppo di regole di profilo («type», «bounds» o «lifetime»), o una regola specifica in un profilo (<a class="reference internal" href="#Pro-type-cstylecast"><span class="xref myst">type.4</span></a>, o <a class="reference internal" href="#Pro-bounds-arrayindex"><span class="xref myst">bounds.2</span></a>). Qualsiasi testo che non rientri tra questi dovrebbe essere rigettato.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;message&quot;</span></code> è una stringa letterale</p></li>
</ul>
</section>
<section id="in-struct-the-structure-of-this-document">
<h3><a name="SS-struct"></a>In.struct: La struttura di questo documento<a class="headerlink" href="#in-struct-the-structure-of-this-document" title="Link to this heading">¶</a></h3>
<p>Ogni regola (linea-guida, suggerimento) può avere diverse parti:</p>
<ul class="simple">
<li><p>La regola stessa – p.es., <strong>nessun semplice <code class="docutils literal notranslate"><span class="pre">new</span></code></strong></p></li>
<li><p>Un numero di riferimento alla regola – p.es., <strong>C.7</strong> (la regola 7 relativa alle classi). Poiché le sezioni principali non sono intrinsecamente ordinate, utilizziamo le lettere come prima parte del «numero» di riferimento della regola. Lasciamo dei salti nella numerazione per ridurre al minimo le «interruzioni» nell’aggiungere o rimuovere regole.</p></li>
<li><p><strong>Motivi</strong> (ragioni, razionale, logica) – perché i programmatori hanno difficoltà a seguire regole che non capiscono</p></li>
<li><p><strong>Esempi</strong> – perché le regole sono difficili da capire in astratto; può essere positivo o negativo</p></li>
<li><p><strong>Alternative</strong> – per le regole del tipo «da non fare»</p></li>
<li><p><strong>Eccezioni</strong> – preferiamo semplici regole generali. Tuttavia, molte regole si applicano ampiamente, ma non universalmente, quindi è necessario elencare le eccezioni</p></li>
<li><p><strong>Imposizione</strong> – idee su come la regola potrebbe essere controllata «meccanicamente»</p></li>
<li><p><strong>Si veda anche</strong> – riferimenti a regole correlate e/o ulteriori discussioni (in questo documento o altrove)</p></li>
<li><p><strong>Note</strong> (commenti) – qualcosa che deve essere detto e che non rientra nelle altre classificazioni</p></li>
<li><p><strong>Discussione</strong> – riferimenti a motivazioni più ampie e/o esempi posti al di fuori delle liste principali di regole</p></li>
</ul>
<p>Alcune regole sono difficili da verificare meccanicamente, ma tutte soddisfano i criteri minimi con cui un esperto programmatore possa individuare molte violazioni senza troppi problemi. Si spera che i tool «meccanici» migliorino col tempo per approssimare quello che nota un programmatore esperto. Si assume, inoltre, che le regole vengano perfezionate nel tempo per renderle più precise e verificabili.</p>
<p>Una regola mira ad essere semplice, piuttosto che essere ben formulata menzionando ogni caso alternativo e speciale. Tali informazioni si trovano nei paragrafi <strong>Alternativa</strong> e nelle sezioni <a class="reference internal" href="#S-discussion"><span class="xref myst">Discussione</span></a>. Se non si capisce una regola o non la si condivide, se ne visiti la <strong>Discussione</strong>. Se si ritiene che manchi una discussione o sia incompleta, si inserisci un <a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/issues">Issue</a> [problema] spiegando le proprie motivazioni e possibilmente una corrispondente PR [Pull Request].</p>
<p>Gli esempi sono scritti per illustrare le regole.</p>
<ul class="simple">
<li><p>Gli esempi non pretendono di avere una qualità da produzione né intendono sostituire i vari tutorial. Per esempio, molti esempi sono tecnico-linguistici ed usano nomi come <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">base</span></code> e <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p>Cerchiamo di assicurarci che i «buoni» esempi seguano le «Core Guidelines».</p></li>
<li><p>I commenti che illustrano le regole spesso sarebbero inutili e/o distraenti in un «codice reale».</p></li>
<li><p>Si presuppone la conoscenza della libreria standard. Per esempio, usiamo il semplice <code class="docutils literal notranslate"><span class="pre">vector</span></code> anziché <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>.</p></li>
</ul>
<p>Questo non è un manuale del linguaggio. È pensato per essere utile, anziché completo, accuratissimo sui dettagli tecnici, o una guida al codice esistente. Le fonti di informazioni consigliate sono disponibili nei <a class="reference internal" href="#S-references"><span class="xref myst">riferimenti</span></a>.</p>
</section>
<section id="in-sec-major-sections">
<h3><a name="SS-sec"></a>In.sec: Sezioni principali<a class="headerlink" href="#in-sec-major-sections" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><a class="reference internal" href="#S-introduction"><span class="xref myst">In: Introduzione</span></a></p></li>
<li><p><a class="reference internal" href="#S-philosophy"><span class="xref myst">P: Filosofia</span></a></p></li>
<li><p><a class="reference internal" href="#S-interfaces"><span class="xref myst">I: Interfacce</span></a></p></li>
<li><p><a class="reference internal" href="#S-functions"><span class="xref myst">F: Funzioni</span></a></p></li>
<li><p><a class="reference internal" href="#S-class"><span class="xref myst">C: Classi e gerarchie di classi</span></a></p></li>
<li><p><a class="reference internal" href="#S-enum"><span class="xref myst">Enum: Enumerazioni</span></a></p></li>
<li><p><a class="reference internal" href="#S-resource"><span class="xref myst">R: Gestione delle risorse</span></a></p></li>
<li><p><a class="reference internal" href="#S-expr"><span class="xref myst">ES: Espressioni e istruzioni</span></a></p></li>
<li><p><a class="reference internal" href="#S-performance"><span class="xref myst">Per: Prestazione</span></a></p></li>
<li><p><a class="reference internal" href="#S-concurrency"><span class="xref myst">CP: Concorrenza e parallelismo</span></a></p></li>
<li><p><a class="reference internal" href="#S-errors"><span class="xref myst">E: Gestione degli errori</span></a></p></li>
<li><p><a class="reference internal" href="#S-const"><span class="xref myst">Con: Costanti e immutabilità</span></a></p></li>
<li><p><a class="reference internal" href="#S-templates"><span class="xref myst">T: Template e programmazione generica</span></a></p></li>
<li><p><a class="reference internal" href="#S-cpl"><span class="xref myst">CPL: Programmazione C-style</span></a></p></li>
<li><p><a class="reference internal" href="#S-source"><span class="xref myst">SF: File sorgenti</span></a></p></li>
<li><p><a class="reference internal" href="#sl-the-standard-library"><span class="xref myst">SL: La Libreria Standard</span></a></p></li>
</ul>
<p>Sezioni di supporto:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#S-A"><span class="xref myst">A: Idee architetturali</span></a></p></li>
<li><p><a class="reference internal" href="#S-not"><span class="xref myst">NR: Non-Regole e miti</span></a></p></li>
<li><p><a class="reference internal" href="#S-references"><span class="xref myst">RF: Riferimenti</span></a></p></li>
<li><p><a class="reference internal" href="#S-profile"><span class="xref myst">Pro: Profili</span></a></p></li>
<li><p><a class="reference internal" href="#gsl-guidelines-support-library"><span class="xref myst">GSL: Libreria di Supporto alle Linee-guida</span></a></p></li>
<li><p><a class="reference internal" href="#S-naming"><span class="xref myst">NL: Suggerimenti per la nomenclatura e il layout</span></a></p></li>
<li><p><a class="reference internal" href="#S-faq"><span class="xref myst">FAQ: Risposte a domande frequenti</span></a></p></li>
<li><p><a class="reference internal" href="#S-libraries"><span class="xref myst">Appendix A: Librerie</span></a></p></li>
<li><p><a class="reference internal" href="#S-modernizing"><span class="xref myst">Appendix B: Modernizzazione del codice</span></a></p></li>
<li><p><a class="reference internal" href="#S-discussion"><span class="xref myst">Appendice C: Discussione</span></a></p></li>
<li><p><a class="reference internal" href="#S-tools"><span class="xref myst">Appendice D: Tool di supporto</span></a></p></li>
<li><p><a class="reference internal" href="#S-glossary"><span class="xref myst">Glossario</span></a></p></li>
<li><p><a class="reference internal" href="#S-unclassified"><span class="xref myst">To-do: Proto-regole non classificate</span></a></p></li>
</ul>
<p>Queste sezioni non sono ortogonali.</p>
<p>Ogni sezione (p.es., «P» per «Filosofia») e ogni sottosezione (p.es., «C.hier» per «Gerarchie di classi (OOP)») ha un’abbreviazione per facilitarne la ricerca ed il riferimento. Le abbreviazioni della sezione principale sono utilizzate anche nei numeri delle regole (p.es., «C.11» per «Rendere concreti i tipi regolari»).</p>
</section>
</section>
<section id="p-philosophy">
<h2><a name="S-philosophy"></a>P: Filosofia<a class="headerlink" href="#p-philosophy" title="Link to this heading">¶</a></h2>
<p>Le regole in questa sezione sono molto generali.</p>
<p>Riepilogo delle regole sulla Filosofia:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rp-direct"><span class="xref myst">P.1: Esprimere le idee direttamente nel codice</span></a></p></li>
<li><p><a class="reference internal" href="#Rp-Cplusplus"><span class="xref myst">P.2: Scrivere in C++ Standard ISO</span></a></p></li>
<li><p><a class="reference internal" href="#Rp-what"><span class="xref myst">P.3: Esprimere le intenzioni</span></a></p></li>
<li><p><a class="reference internal" href="#Rp-typesafe"><span class="xref myst">P.4: Idealmente, un programma dovrebbe essere staticamente «type safe»</span></a></p></li>
<li><p><a class="reference internal" href="#Rp-compile-time"><span class="xref myst">P.5: Preferire il controllo durante la compilazione a quello durante l’esecuzione</span></a></p></li>
<li><p><a class="reference internal" href="#Rp-run-time"><span class="xref myst">P.6: Ciò che non può essere verificato in fase di compilazione dovrebbe essere verificabile in fase di esecuzione</span></a></p></li>
<li><p><a class="reference internal" href="#Rp-early"><span class="xref myst">P.7: Rilevare gli errori prima al run-time</span></a></p></li>
<li><p><a class="reference internal" href="#Rp-leak"><span class="xref myst">P.8: Non perdere alcuna risorsa [leak]</span></a></p></li>
<li><p><a class="reference internal" href="#Rp-waste"><span class="xref myst">P.9: Non sprecare tempo o spazio</span></a></p></li>
<li><p><a class="reference internal" href="#Rp-mutable"><span class="xref myst">P.10: Preferire dati immutabili ai dati mutabili</span></a></p></li>
<li><p><a class="reference internal" href="#Rp-library"><span class="xref myst">P.11: Incapsulare costrutti disordinati, anziché distribuirli nel codice</span></a></p></li>
<li><p><a class="reference internal" href="#Rp-tools"><span class="xref myst">P.12: Usare tool appropriati</span></a></p></li>
<li><p><a class="reference internal" href="#Rp-lib"><span class="xref myst">P.13: Usare librerie di supporto appropriate</span></a></p></li>
</ul>
<p>Le regole filosofiche non sono generalmente controllabili meccanicamente. Tuttavia, sono le singole regole che riflettono questi temi filosofici. Senza una base filosofica, le regole più concrete/specifiche/verificabili mancano di logica.</p>
<section id="p-1-express-ideas-directly-in-code">
<h3><a name="Rp-direct"></a>P.1: Esprimere le idee direttamente nel codice<a class="headerlink" href="#p-1-express-ideas-directly-in-code" title="Link to this heading">¶</a></h3>
<section id="reason">
<h4>Motivo<a class="headerlink" href="#reason" title="Link to this heading">¶</a></h4>
<p>I compilatori non leggono i commenti (né i documenti dei progetti) e nemmeno molti programmatori (coerentemente). Ciò che è espresso nel codice ne ha definito la semantica e (in linea di principio) può essere verificato da compilatori e altri strumenti.</p>
</section>
<section id="example">
<h4>Esempio<a class="headerlink" href="#example" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Date {
public:
    Month month() const;  // do
    int month();          // don&#39;t
    // ...
};
</pre></div>
</div>
<p>La prima dichiarazione di <code class="docutils literal notranslate"><span class="pre">month</span></code> è esplicita sul fatto che restituisce un <code class="docutils literal notranslate"><span class="pre">Month</span></code> e che non modifica lo stato dell’oggetto <code class="docutils literal notranslate"><span class="pre">Date</span></code>. La seconda versione lascia indovinare al lettore e si espone a più possibilità di bug non rilevati.</p>
</section>
<section id="example-bad">
<h4>Esempio, cattivo<a class="headerlink" href="#example-bad" title="Link to this heading">¶</a></h4>
<p>Questo loop è una versione ridotta di <code class="docutils literal notranslate"><span class="pre">std::find</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(vector&lt;string&gt;&amp; v)
{
    string val;
    cin &gt;&gt; val;
    // ...
    int index = -1;                    // bad, plus should use gsl::index
    for (int i = 0; i &lt; v.size(); ++i) {
        if (v[i] == val) {
            index = i;
            break;
        }
    }
    // ...
}
</pre></div>
</div>
</section>
<section id="example-good">
<h4>Esempio, buono<a class="headerlink" href="#example-good" title="Link to this heading">¶</a></h4>
<p>Un’espressione di intenti molto più chiara sarebbe:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(vector&lt;string&gt;&amp; v)
{
    string val;
    cin &gt;&gt; val;
    // ...
    auto p = find(begin(v), end(v), val);  // better
    // ...
}
</pre></div>
</div>
<p>Una libreria ben progettata esprime l’intento (cosa si deve fare, piuttosto che come si sta facendo qualcosa) molto meglio dell’uso diretto delle funzionalità del linguaggio.</p>
<p>Un programmatore C++ dovrebbe conoscere le basi della libreria standard e usarla dove appropriato. Qualsiasi programmatore dovrebbe conoscere le basi delle librerie fondamentali del progetto su cui si sta lavorando e usarle in modo appropriato. Qualsiasi programmatore che utilizza queste linee-guida deve conoscere la <a class="reference internal" href="#gsl-guidelines-support-library"><span class="xref myst">guidelines support library</span></a> [Libreria di Supporto delle linee-guida] e usarla in modo appropriato.</p>
</section>
<section id="id1">
<h4>Esempio<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>change_speed(double s);   // bad: what does s signify?
// ...
change_speed(2.3);
</pre></div>
</div>
<p>Un approccio migliore deve essere esplicito sul significato del double (nuova velocità o delta rispetto alla velocità precedente?) e all’unità di misura usata:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>change_speed(Speed s);    // better: the meaning of s is specified
// ...
change_speed(2.3);        // error: no unit
change_speed(23_m / 10s);  // meters per second
</pre></div>
</div>
<p>Avremmo potuto accettare un semplice <code class="docutils literal notranslate"><span class="pre">double</span></code> (senza unità di misura) come delta, ma sarebbe stato soggetto a errori. Se avessimo voluto sia la velocità assoluta che i delta, avremmo definito un tipo <code class="docutils literal notranslate"><span class="pre">Delta</span></code>.</p>
</section>
<section id="enforcement">
<h4>Imposizione<a class="headerlink" href="#enforcement" title="Link to this heading">¶</a></h4>
<p>In generale molto difficile.</p>
<ul class="simple">
<li><p>usare <code class="docutils literal notranslate"><span class="pre">const</span></code> in modo coerente (controllare se le funzioni membro modificano il loro oggetto; controllare se le funzioni modificano gli argomenti passati per puntatore o per riferimento)</p></li>
<li><p>scarso uso dei cast (cast di sistema di tipo neutro)</p></li>
<li><p>rilevare il codice che imita la libreria standard (difficile)</p></li>
</ul>
</section>
</section>
<section id="p-2-write-in-iso-standard-c">
<h3><a name="Rp-Cplusplus"></a>P.2: Scrivere in C++ Standard ISO<a class="headerlink" href="#p-2-write-in-iso-standard-c" title="Link to this heading">¶</a></h3>
<section id="id2">
<h4>Motivo<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h4>
<p>Questo è un insieme di linee-guida per la scrittura secondo il C++ Standard ISO.</p>
</section>
<section id="note">
<h4>Nota<a class="headerlink" href="#note" title="Link to this heading">¶</a></h4>
<p>Esistono ambienti in cui sono necessarie estensioni, ad esempio per accedere alle risorse di sistema. In questi casi, localizzare l’uso delle estensioni necessarie e controllarne l’uso con le Coding Guidelines non-core.  Se possibile, creare interfacce che incapsulino le estensioni in modo che possano essere disattivate e compilate su sistemi che non supportano tali estensioni.</p>
<p>Le estensioni spesso non hanno una semantica rigorosamente definita.  Anche le estensioni comuni o implementate da più compilatori potrebbero avere comportamenti leggermente diversi e un diverso comportamento del caso limite come diretta conseguenza del <em>non</em> avere una definizione standard rigorosa.  Con un sufficiente uso di una di queste estensioni, ci si dovrà aspettare un impatto sulla portabilità.</p>
</section>
<section id="id3">
<h4>Nota<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h4>
<p>L’uso di un C++ ISO valido non ne garantisce la portabilità (per non parlare della correttezza). Evitare la dipendenza dai comportamenti indefiniti (p.es., <a class="reference internal" href="#Res-order"><span class="xref myst">ordine di valutazione indefinito</span></a>) ed essere consapevoli dei costrutti con significato definito dall’implementazione (p.es., <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span></code>).</p>
</section>
<section id="id4">
<h4>Nota<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h4>
<p>Esistono ambienti in cui sono necessarie restrizioni sull’uso del linguaggio C++ standard e o delle funzionalità di libreria, p.es., per evitare l’allocazione dinamica della memoria come richiesto dagli standard del software di controllo degli aerei. In questi casi, controllarne l”(ab)uso con un’estensione a queste «Coding Guidelines» personalizzate per lo specifico ambiente.</p>
</section>
<section id="id5">
<h4>Imposizione<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h4>
<p>Utilizzare un compilatore C++ aggiornato (attualmente C++20 o C++17) con una serie di opzioni che non accettano le estensioni.</p>
</section>
</section>
<section id="p-3-express-intent">
<h3><a name="Rp-what"></a>P.3: Esprimere le intenzioni<a class="headerlink" href="#p-3-express-intent" title="Link to this heading">¶</a></h3>
<section id="id6">
<h4>Motivo<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h4>
<p>A meno che non venga dichiarato l’intento di parte del codice (p.es., nei nomi o nei commenti), è impossibile stabilire se il codice fa quello che dovrebbe fare.</p>
</section>
<section id="id7">
<h4>Esempio<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gsl::index i = 0;
while (i &lt; v.size()) {
    // ... do something with v[i] ...
}
</pre></div>
</div>
<p>Lo scopo del «solo» ciclare sugli elementi di <code class="docutils literal notranslate"><span class="pre">v</span></code> qui non è espresso. I dettagli di implementazione di un indice sono esposti (quindi se ne può abusare), e <code class="docutils literal notranslate"><span class="pre">i</span></code> sopravvive allo scope del ciclo, che potrebbe o meno essere voluto. Il lettore non può capire solo da questo pezzo di codice.</p>
<p>Meglio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (const auto&amp; x : v) { /* do something with the value of x */ }
</pre></div>
</div>
<p>Ora, non vi è alcuna menzione esplicita del meccanismo di iterazione e il ciclo opera su un riferimento <code class="docutils literal notranslate"><span class="pre">const</span></code> agli elementi in modo che non possano verificarsi modifiche accidentali. Se si desidera la modifica, si scrive così:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (auto&amp; x : v) { /* modify x */ }
</pre></div>
</div>
<p>Per ulteriori dettagli dell’istruzione fo, cfr. <a class="reference internal" href="#Res-for-range"><span class="xref myst">ES.71</span></a>. Talvolta è meglio usare un algoritmo predefinito con nome significativo. Questo esempio usa il <code class="docutils literal notranslate"><span class="pre">for_each</span></code> per i Range TS perché esprime direttamente lo scopo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for_each(v, [](int x) { /* do something with the value of x */ });
for_each(par, v, [](int x) { /* do something with the value of x */ });
</pre></div>
</div>
<p>L’ultima variante chiarisce che non si è interessati all’ordine con cui vengono gestiti gli elementi di <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p>Un programmatore dovrebbe avere familiarità con</p>
<ul class="simple">
<li><p><a class="reference internal" href="#gsl-guidelines-support-library"><span class="xref myst">Libreria di Supporto alle Linee-guida</span></a></p></li>
<li><p><a class="reference internal" href="#sl-the-standard-library"><span class="xref myst">La Libreria Standard C++ ISO</span></a></p></li>
<li><p>Qualunque libreria fondamentale si usi nel progetto corrente</p></li>
</ul>
</section>
<section id="id8">
<h4>Nota<a class="headerlink" href="#id8" title="Link to this heading">¶</a></h4>
<p>Formula alternativa: dire cosa dovrebbe essere fatto, anziché solamente come lo si dovrebbe fare.</p>
</section>
<section id="id9">
<h4>Nota<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h4>
<p>Alcuni costrutti del linguaggio esprimono le intenzioni meglio di altri.</p>
</section>
<section id="id10">
<h4>Esempio<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h4>
<p>Se due <code class="docutils literal notranslate"><span class="pre">int</span></code> sono pensati per rappresentare le coordinate di un punto 2D, lo si dica:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>draw_line(int, int, int, int);  // obscure: (x1,y1,x2,y2)? (x,y,h,w)? ...?
                                // need to look up documentation to know

draw_line(Point, Point);        // clearer
</pre></div>
</div>
</section>
<section id="id11">
<h4>Imposizione<a class="headerlink" href="#id11" title="Link to this heading">¶</a></h4>
<p>Cercare schemi comuni per i quali esistono alternative migliori</p>
<ul class="simple">
<li><p>semplici cicli <code class="docutils literal notranslate"><span class="pre">for</span></code> rispetto ai cicli range-<code class="docutils literal notranslate"><span class="pre">for</span></code></p></li>
<li><p>interfacce <code class="docutils literal notranslate"><span class="pre">f(T*,</span> <span class="pre">int)</span></code> rispetto a interfacce <code class="docutils literal notranslate"><span class="pre">f(span&lt;T&gt;)</span></code></p></li>
<li><p>variabili dei loop in uno scope troppo ampio</p></li>
<li><p>direttamente <code class="docutils literal notranslate"><span class="pre">new</span></code> e <code class="docutils literal notranslate"><span class="pre">delete</span></code></p></li>
<li><p>funzioni con molti parametri di tipi nativi</p></li>
</ul>
<p>Vi è un ampio margine per l’intelligenza e una trasformazione semi-automatica del programma.</p>
</section>
</section>
<section id="p-4-ideally-a-program-should-be-statically-type-safe">
<h3><a name="Rp-typesafe"></a>P.4: Idealmente, un programma dovrebbe essere staticamente type safe<a class="headerlink" href="#p-4-ideally-a-program-should-be-statically-type-safe" title="Link to this heading">¶</a></h3>
<section id="id12">
<h4>Motivo<a class="headerlink" href="#id12" title="Link to this heading">¶</a></h4>
<p>Idealmente, un programma dovrebbe essere completamente staticamente (durante la compilazione) type safe. Sfortunatamente, ciò non è possibile. Le aree problematiche sono:</p>
<ul class="simple">
<li><p>union</p></li>
<li><p>cast</p></li>
<li><p>decadimento di array [array decay]</p></li>
<li><p>errori dei range</p></li>
<li><p>Conversioni con riduzione [narrowing conversions]</p></li>
</ul>
</section>
<section id="id13">
<h4>Nota<a class="headerlink" href="#id13" title="Link to this heading">¶</a></h4>
<p>Queste aree sono fonte di gravi problemi (p.es., crash e violazioni della sicurezza). Cerchiamo di fornire tecniche alternative.</p>
</section>
<section id="id14">
<h4>Imposizione<a class="headerlink" href="#id14" title="Link to this heading">¶</a></h4>
<p>Possiamo vietare, limitare o rilevare le singole categorie di problemi separatamente, come richiesto e fattibile per i singoli programmi. Suggerire sempre un’alternativa. Per esempio:</p>
<ul class="simple">
<li><p>unioni – usare <code class="docutils literal notranslate"><span class="pre">variant</span></code> (in C++17)</p></li>
<li><p>cast – minimizzarne l’uso; i template possono aiutare</p></li>
<li><p>array decay – usare <code class="docutils literal notranslate"><span class="pre">span</span></code> (dalle GSL)</p></li>
<li><p>errori range – usare <code class="docutils literal notranslate"><span class="pre">span</span></code></p></li>
<li><p>conversioni narrowing – minimizzarne l’uso utilizzando <code class="docutils literal notranslate"><span class="pre">narrow</span></code> o <code class="docutils literal notranslate"><span class="pre">narrow_cast</span></code> (dalle GSL) dove sono necessarie</p></li>
</ul>
</section>
</section>
<section id="p-5-prefer-compile-time-checking-to-run-time-checking">
<h3><a name="Rp-compile-time"></a>P.5: Preferire il controllo durante la compilazione a quello durante l’esecuzione<a class="headerlink" href="#p-5-prefer-compile-time-checking-to-run-time-checking" title="Link to this heading">¶</a></h3>
<section id="id15">
<h4>Motivo<a class="headerlink" href="#id15" title="Link to this heading">¶</a></h4>
<p>Chiarezza del codice e prestazioni. Non è necessario scrivere «error handler» per gli errori rilevati durante la compilazione.</p>
</section>
<section id="id16">
<h4>Esempio<a class="headerlink" href="#id16" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Int is an alias used for integers
int bits = 0;         // don&#39;t: avoidable code
for (Int i = 1; i; i &lt;&lt;= 1)
    ++bits;
if (bits &lt; 32)
    cerr &lt;&lt; &quot;Int too small\n&quot;;
</pre></div>
</div>
<p>Questo esempio non riesce a fare ciò che sta cercando di fare (perché l’overflow è indefinito) e lo si dovrebbe sostituire con un semplice <code class="docutils literal notranslate"><span class="pre">static_assert</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Int is an alias used for integers
static_assert(sizeof(Int) &gt;= 4);    // do: compile-time check
</pre></div>
</div>
<p>O, meglio ancora, basta usare il sistema dei tipi e sostituire <code class="docutils literal notranslate"><span class="pre">Int</span></code> con <code class="docutils literal notranslate"><span class="pre">int32_t</span></code>.</p>
</section>
<section id="id17">
<h4>Esempio<a class="headerlink" href="#id17" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void read(int* p, int n);   // read max n integers into *p

int a[100];
read(a, 1000);    // bad, off the end
</pre></div>
</div>
<p>Meglio</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void read(span&lt;int&gt; r); // read into the range of integers r

int a[100];
read(a);        // better: let the compiler figure out the number of elements
</pre></div>
</div>
<p><strong>Formula alternativa</strong>: Non rimandare al tempo dell’esecuzione ciò che si può fare bene in fase di compilazione.</p>
</section>
<section id="id18">
<h4>Imposizione<a class="headerlink" href="#id18" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Cercare gli argomenti puntatori.</p></li>
<li><p>Cercare i check a run-time per le violazioni di range.</p></li>
</ul>
</section>
</section>
<section id="p-6-what-cannot-be-checked-at-compile-time-should-be-checkable-at-run-time">
<h3><a name="Rp-run-time"></a>P.6: Ciò che non può essere verificato in fase di compilazione dovrebbe essere verificabile in fase di esecuzione<a class="headerlink" href="#p-6-what-cannot-be-checked-at-compile-time-should-be-checkable-at-run-time" title="Link to this heading">¶</a></h3>
<section id="id19">
<h4>Motivo<a class="headerlink" href="#id19" title="Link to this heading">¶</a></h4>
<p>Lasciare errori difficili-da-rilevare in un programma espone a crash e risultati sbagliati.</p>
</section>
<section id="id20">
<h4>Nota<a class="headerlink" href="#id20" title="Link to this heading">¶</a></h4>
<p>Idealmente, si rilevano tutti gli errori (quelli che non sono errori logici del programmatore) in fase di compilazione o di esecuzione. È impossibile rilevare tutti gli errori in fase di compilazione e spesso non è conveniente rilevare tutti gli altri errori in fase di esecuzione. Tuttavia, si dovrebbe cercare di scrivere programmi che in linea di principio possano essere controllati, con sufficienti risorse (programmi di analisi, controlli a run-time, risorse-macchina, tempo).</p>
</section>
<section id="id21">
<h4>Esempio, cattivo<a class="headerlink" href="#id21" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// separately compiled, possibly dynamically loaded
extern void f(int* p);

void g(int n)
{
    // bad: the number of elements is not passed to f()
    f(new int[n]);
}
</pre></div>
</div>
<p>Qui, una parte cruciale delle informazioni (il numero degli elementi) è stato così accuratamente «oscurato» che l’analisi statica probabilmente non lo rileva e il controllo dinamico può risultare difficile quando <code class="docutils literal notranslate"><span class="pre">f()</span></code> è parte di un ABI [Application Binary Interface] che non fa «esaminare» questo puntatore. Si potrebbero includere informazioni utili nel [free store], ma richiederebbe modifiche globali e forse al compilatore. Quello che abbiamo qui è un progetto che rende molto difficile il rilevamento degli errori.</p>
</section>
<section id="id22">
<h4>Esempio, cattivo<a class="headerlink" href="#id22" title="Link to this heading">¶</a></h4>
<p>Ovviamente si può passare il numero di elementi insieme al puntatore:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// separately compiled, possibly dynamically loaded
extern void f2(int* p, int n);

void g2(int n)
{
    f2(new int[n], m);  // bad: a wrong number of elements can be passed to f()
}
</pre></div>
</div>
<p>Passare il numero di elementi come argomento è meglio (e molto più comune) che passare solo il puntatore e fare affidamento su una convenzione (non dichiarata) per conoscere o scoprire il numero di elementi. Tuttavia (come mostrato), un semplice errore di battitura può introdurre un grave errore. La connessione tra i due argomenti di <code class="docutils literal notranslate"><span class="pre">f2()</span></code> è convenzionale, anziché esplicita.</p>
<p>Inoltre, è implicito che <code class="docutils literal notranslate"><span class="pre">f2()</span></code> dovrebbe eseguire un <code class="docutils literal notranslate"><span class="pre">delete</span></code> del suo argomento (o il chiamante ha fatto un secondo errore?).</p>
</section>
<section id="id23">
<h4>Esempio, cattivo<a class="headerlink" href="#id23" title="Link to this heading">¶</a></h4>
<p>I puntatori di gestione della libreria standard non riescono a passare la dimensione quando puntano ad un oggetto:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// separately compiled, possibly dynamically loaded
// NB: this assumes the calling code is ABI-compatible, using a
// compatible C++ compiler and the same stdlib implementation
extern void f3(unique_ptr&lt;int[]&gt;, int n);

void g3(int n)
{
    f3(make_unique&lt;int[]&gt;(n), m);    // bad: pass ownership and size separately
}
</pre></div>
</div>
</section>
<section id="id24">
<h4>Esempio<a class="headerlink" href="#id24" title="Link to this heading">¶</a></h4>
<p>Si deve passare il puntatore e il numero di elementi come un unico oggetto:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>extern void f4(vector&lt;int&gt;&amp;);   // separately compiled, possibly dynamically loaded
extern void f4(span&lt;int&gt;);      // separately compiled, possibly dynamically loaded
                                // NB: this assumes the calling code is ABI-compatible, using a
                                // compatible C++ compiler and the same stdlib implementation

void g3(int n)
{
    vector&lt;int&gt; v(n);
    f4(v);                     // pass a reference, retain ownership
    f4(span&lt;int&gt;{v});          // pass a view, retain ownership
}
</pre></div>
</div>
<p>Questo progetto porta il numero di elementi come parte integrata di un oggetto, quindi gli errori sono improbabili e il controllo dinamico (a run-time) è sempre possibile, se non sempre conveniente.</p>
</section>
<section id="id25">
<h4>Esempio<a class="headerlink" href="#id25" title="Link to this heading">¶</a></h4>
<p>Come possiamo trasferire sia la proprietà [ownership] che tutte le informazioni necessarie a validarne l’uso?</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;int&gt; f5(int n)    // OK: move
{
    vector&lt;int&gt; v(n);
    // ... initialize v ...
    return v;
}

unique_ptr&lt;int[]&gt; f6(int n)    // bad: loses n
{
    auto p = make_unique&lt;int[]&gt;(n);
    // ... initialize *p ...
    return p;
}

owner&lt;int*&gt; f7(int n)    // bad: loses n and we might forget to delete
{
    owner&lt;int*&gt; p = new int[n];
    // ... initialize *p ...
    return p;
}
</pre></div>
</div>
</section>
<section id="id26">
<h4>Esempio<a class="headerlink" href="#id26" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>???</p></li>
<li><p>mostrare come dei possibili check sono evitati dalle interfacce che passano classi base polimorfiche, quando in effetti sanno di cosa hanno bisogno? O le stringhe come opzioni «free-style»</p></li>
</ul>
</section>
<section id="id27">
<h4>Imposizione<a class="headerlink" href="#id27" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare interfacce di tipo (puntatore, conteggio) (ciò evidenzierà un sacco di esempi che non si possono aggiustare per una questione di compatibilità)</p></li>
<li><p>???</p></li>
</ul>
</section>
</section>
<section id="p-7-catch-run-time-errors-early">
<h3><a name="Rp-early"></a>P.7: Rilevamento degli errori a run-time all’inizio<a class="headerlink" href="#p-7-catch-run-time-errors-early" title="Link to this heading">¶</a></h3>
<section id="id28">
<h4>Motivo<a class="headerlink" href="#id28" title="Link to this heading">¶</a></h4>
<p>Evitare i crash «misteriosi». Evitare errori che portano a risultati sbagliati (forse non riconosciuti).</p>
</section>
<section id="id29">
<h4>Esempio<a class="headerlink" href="#id29" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void increment1(int* p, int n)    // bad: error-prone
{
    for (int i = 0; i &lt; n; ++i) ++p[i];
}

void use1(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment1(a, m);   // maybe typo, maybe m &lt;= n is supposed
                        // but assume that m == 20
    // ...
}
</pre></div>
</div>
<p>Qui abbiamo fatto un piccolo errore in <code class="docutils literal notranslate"><span class="pre">use1</span></code> che porterà a dei dati corrotti o a un crash. L’interfaccia di tipo (puntatore, conteggio) lascia <code class="docutils literal notranslate"><span class="pre">increment1()</span></code> senza un modo realistico per potersi difendere da errori out-of-range. Se si potessero controllare gli indici per l’accesso oltre i limiti, allora l’errore non verrebbe scoperto finché non si accedesse a <code class="docutils literal notranslate"><span class="pre">p[10]</span></code>. Si potrebbe controllare in anticipo migliorando il codice:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void increment2(span&lt;int&gt; p)
{
    for (int&amp; x : p) ++x;
}

void use2(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment2({a, m});    // maybe typo, maybe m &lt;= n is supposed
    // ...
}
</pre></div>
</div>
<p>Ora, <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code> si può verificare nel punto della chiamata (in anticipo) anziché dopo. Se fosse stato solo un errore di battitura intendendo usare <code class="docutils literal notranslate"><span class="pre">n</span></code> come limite, il codice si potrebbe ulteriormente semplificare (eliminando la possibilità di un errore):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use3(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment2(a);   // the number of elements of a need not be repeated
    // ...
}
</pre></div>
</div>
</section>
<section id="id30">
<h4>Esempio, cattivo<a class="headerlink" href="#id30" title="Link to this heading">¶</a></h4>
<p>Non controllare ripetutamente lo stesso valore. Non passare dati strutturati come stringhe:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Date read_date(istream&amp; is);    // read date from istream

Date extract_date(const string&amp; s);    // extract date from string

void user1(const string&amp; date)    // manipulate date
{
    auto d = extract_date(date);
    // ...
}

void user2()
{
    Date d = read_date(cin);
    // ...
    user1(d.to_string());
    // ...
}
</pre></div>
</div>
<p>La data viene validata due volte (dal costruttore <code class="docutils literal notranslate"><span class="pre">Date</span></code>) e passata come stringa di caratteri (dati non strutturati).</p>
</section>
<section id="id31">
<h4>Esempio<a class="headerlink" href="#id31" title="Link to this heading">¶</a></h4>
<p>L’eccesso di controlli può essere costoso. Ci sono casi in cui il controllo anticipato è inefficiente perché si potrebbe non aver mai bisogno del valore o se ne potrebbe aver bisogno solo di una parte che sia più facile da testare rispetto all’intero valore.  Allo stesso modo, non aggiungere controlli di validità che cambiano il comportamento asintotico della propria interfaccia (p.es., non aggiungere un check <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> ad un’interfaccia con una complessità media di <code class="docutils literal notranslate"><span class="pre">O(1)</span></code>).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Jet {    // Physics says: e * e &lt; x * x + y * y + z * z
    float x;
    float y;
    float z;
    float e;
public:
    Jet(float x, float y, float z, float e)
        :x(x), y(y), z(z), e(e)
    {
        // Should I check here that the values are physically meaningful?
    }

    float m() const
    {
        // Should I handle the degenerate case here?
        return sqrt(x * x + y * y + z * z - e * e);
    }

    ???
};
</pre></div>
</div>
<p>La legge fisica per un jet (<code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">*</span> <span class="pre">e</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">z</span> <span class="pre">*</span> <span class="pre">z</span></code>) non è un’invariante a causa della possibilità di errori di misura.</p>
<p>???</p>
</section>
<section id="id32">
<h4>Imposizione<a class="headerlink" href="#id32" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Cercare puntatori ed array: Eseguire un preventivo controllo del range e non ripetutamente</p></li>
<li><p>Cercare le conversioni: Eliminare o segnare le conversioni [narrowing]</p></li>
<li><p>Cercare i valori non controllati provenienti dall’input</p></li>
<li><p>Cercare i dati strutturati (oggetti o classi con degli invarianti) che vengono convertiti in stringhe</p></li>
<li><p>???</p></li>
</ul>
</section>
</section>
<section id="p-8-don-t-leak-any-resources">
<h3><a name="Rp-leak"></a>P.8: Non perdere alcuna risorsa [leak]<a class="headerlink" href="#p-8-don-t-leak-any-resources" title="Link to this heading">¶</a></h3>
<section id="id33">
<h4>Motivo<a class="headerlink" href="#id33" title="Link to this heading">¶</a></h4>
<p>Anche una poco crescente richiesta di risorse, col tempo, ne esaurirà la disponibilità. Questo è particolarmente importante per i programmi che girano a lungo, ma è un elemento essenziale del comportamento responsabile della programmazione.</p>
</section>
<section id="id34">
<h4>Esempio, cattivo<a class="headerlink" href="#id34" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(char* name)
{
    FILE* input = fopen(name, &quot;r&quot;);
    // ...
    if (something) return;   // bad: if something == true, a file handle is leaked
    // ...
    fclose(input);
}
</pre></div>
</div>
<p>Preferire il <a class="reference internal" href="#Rr-raii"><span class="xref myst">RAII</span></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(char* name)
{
    ifstream input {name};
    // ...
    if (something) return;   // OK: no leak
    // ...
}
</pre></div>
</div>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#S-resource"><span class="xref myst">La sezione Gestione delle risorse</span></a></p>
</section>
<section id="id35">
<h4>Nota<a class="headerlink" href="#id35" title="Link to this heading">¶</a></h4>
<p>Un leak è colloquialmente «qualsiasi cosa che non viene pulito». La classificazione più importante è «tutto ciò che non può più essere ripulito». Per esempio, allocare un oggetto sull’heap e poi perdere l’ultimo puntatore che punta a tale allocazione. Questa regola non dovrebbe essere presa come obbligatoria, perché tutte le allocazioni di oggetti di lunga durata devono essere restituite alla chiusura del programma. Per esempio, affidarsi al cleanup garantito dal sistema, come la chiusura del file o la deallocazione della memoria all’arresto del processo, può semplificare il codice. Tuttavia, fare affidamento su astrazioni che ripuliscono implicitamente può essere altrettanto semplice e spesso più sicuro.</p>
</section>
<section id="id36">
<h4>Nota<a class="headerlink" href="#id36" title="Link to this heading">¶</a></h4>
<p>Imporre <a class="reference internal" href="#SS-lifetime"><span class="xref myst">il profilo di sicurezza a tutto il ciclo di vita</span></a> elimina i leak. Se combinato con la sicurezza delle risorse fornita dal <a class="reference internal" href="#Rr-raii"><span class="xref myst">RAII</span></a>, elimina la necessità di «garbage collection» (non generando garbage [immondizia]). Combinarlo con l’applicazione dei <a class="reference internal" href="#SS-force"><span class="xref myst">profili di tipo e bound</span></a> ottenendo una completa sicurezza sui tipi e sulle risorse, garantita dai tool.</p>
</section>
<section id="id37">
<h4>Imposizione<a class="headerlink" href="#id37" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Cercare i puntatori: Classificarli in non-proprietari (il default) e proprietari [owner]. Laddove possibile, sostituire i proprietari con handle di risorse della libreria standard (come nell’esempio precedente). In alternativa, contrassegnare un proprietario come tale utilizzando <code class="docutils literal notranslate"><span class="pre">owner</span></code> dalla <a class="reference internal" href="#gsl-guidelines-support-library"><span class="xref myst">GSL</span></a>.</p></li>
<li><p>Cercare i <code class="docutils literal notranslate"><span class="pre">new</span></code> e i <code class="docutils literal notranslate"><span class="pre">delete</span></code></p></li>
<li><p>Cercare le funzioni note di allocazione delle risorse che restituiscono puntatori semplici (come <code class="docutils literal notranslate"><span class="pre">fopen</span></code>, <code class="docutils literal notranslate"><span class="pre">malloc</span></code> e <code class="docutils literal notranslate"><span class="pre">strdup</span></code>)</p></li>
</ul>
</section>
</section>
<section id="p-9-don-t-waste-time-or-space">
<h3><a name="Rp-waste"></a>P.9: Non sprecare tempo o spazio<a class="headerlink" href="#p-9-don-t-waste-time-or-space" title="Link to this heading">¶</a></h3>
<section id="id38">
<h4>Motivo<a class="headerlink" href="#id38" title="Link to this heading">¶</a></h4>
<p>Questo è il C++.</p>
</section>
<section id="id39">
<h4>Nota<a class="headerlink" href="#id39" title="Link to this heading">¶</a></h4>
<p>Il tempo e lo spazio spesi bene per raggiungere un obiettivo (p.es., rapidità nello sviluppo, sicurezza delle risorse, o semplificazione dei test) non vengono persi. «Un altro vantaggio della ricerca dell’efficienza è che il processo costringe a comprendere il problema in modo più approfondito». - Alex Stepanov</p>
</section>
<section id="id40">
<h4>Esempio, cattivo<a class="headerlink" href="#id40" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct X {
    char ch;
    int i;
    string s;
    char ch2;

    X&amp; operator=(const X&amp; a);
    X(const X&amp;);
};

X waste(const char* p)
{
    if (!p) throw Nullptr_error{};
    int n = strlen(p);
    auto buf = new char[n];
    if (!buf) throw Allocation_error{};
    for (int i = 0; i &lt; n; ++i) buf[i] = p[i];
    // ... manipulate buffer ...
    X x;
    x.ch = &#39;a&#39;;
    x.s = string(n);    // give x.s space for *p
    for (gsl::index i = 0; i &lt; x.s.size(); ++i) x.s[i] = buf[i];  // copy buf into x.s
    delete[] buf;
    return x;
}

void driver()
{
    X x = waste(&quot;Typical argument&quot;);
    // ...
}
</pre></div>
</div>
<p>Sì, questa è una caricatura, ma abbiamo visto ognuno di questi errori in codice di produzione, e anche di peggio. Si noti che il layout di <code class="docutils literal notranslate"><span class="pre">X</span></code> garantisce la perdita di almeno 6 byte (e molto probabilmente di più). La definizione spuria delle operazioni di copia disabilita la semantica del move rallentando l’operazione di ritorno (si noti che il Return Value Optimization [Ottimizzazione del Valore di Ritorno], RVO, qui non è garantita). L’uso di <code class="docutils literal notranslate"><span class="pre">new</span></code> e <code class="docutils literal notranslate"><span class="pre">delete</span></code> per <code class="docutils literal notranslate"><span class="pre">buf</span></code> è ridondante; se c’è davvero bisogno di una stringa locale, si dovrebbe usare una <code class="docutils literal notranslate"><span class="pre">string</span></code>. Ci sono molti altri bug prestazionali e complicazioni gratuite.</p>
</section>
<section id="id41">
<h4>Esempio, cattivo<a class="headerlink" href="#id41" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void lower(zstring s)
{
    for (int i = 0; i &lt; strlen(s); ++i) s[i] = tolower(s[i]);
}
</pre></div>
</div>
<p>Questo è in effetti un esempio di un codice di produzione. Possiamo vedere che nelle nostre condizioni abbiamo <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">strlen(s)</span></code>. Questa espressione verrà valutata su ogni iterazione del ciclo, il che significa che <code class="docutils literal notranslate"><span class="pre">strlen</span></code> deve scorrere la stringa in ogni ciclo per scoprirne la lunghezza. Mentre il contenuto della stringa cambia, si presume che <code class="docutils literal notranslate"><span class="pre">tolower</span></code> non ne influenzerà la lunghezza, quindi è meglio memorizzare nella cache la lunghezza all’esterno del ciclo e non sostenere il costo a ogni iterazione.</p>
</section>
<section id="id42">
<h4>Nota<a class="headerlink" href="#id42" title="Link to this heading">¶</a></h4>
<p>Un singolo esempio di spreco è raramente significativo e, laddove lo fosse, viene in genere facilmente eliminato da un esperto. Tuttavia, gli sprechi diffusi su tutto il codice possono diventare facilmente significativi e gli esperti non sono sempre disponibili come si vorrebbe. Lo scopo di questa regola (e le regole più specifiche che la supportano) è quello di eliminare la maggior parte degli sprechi sull’uso del C++ prima che avvengano. Successivamente, si possono esaminare gli sprechi relativi agli algoritmi e ai requisiti, ma questo va oltre lo scopo di queste linee-guida.</p>
</section>
<section id="id43">
<h4>Imposizione<a class="headerlink" href="#id43" title="Link to this heading">¶</a></h4>
<p>Molte regole più specifiche mirano agli obiettivi generali della semplicità e dell’eliminazione di sprechi.</p>
<ul class="simple">
<li><p>Contrassegnare un valore di ritorno inutilizzato da una funzione postfix «definita dall’utente, non-di-default» <code class="docutils literal notranslate"><span class="pre">operator++</span></code> o <code class="docutils literal notranslate"><span class="pre">operator--</span></code> function. Preferire invece l’uso della forma prefissa. (Nota: «Definita dall’utente, non-di-default» ha lo scopo di ridurre la confusione. Rivedere questa imposizione se si rivela ancora confusa nella pratica).</p></li>
</ul>
</section>
</section>
<section id="p-10-prefer-immutable-data-to-mutable-data">
<h3><a name="Rp-mutable"></a>P.10: Preferire dati immutabili ai dati mutabili<a class="headerlink" href="#p-10-prefer-immutable-data-to-mutable-data" title="Link to this heading">¶</a></h3>
<section id="id44">
<h4>Motivo<a class="headerlink" href="#id44" title="Link to this heading">¶</a></h4>
<p>È più facile ragionare sulle costanti che sulle variabili. Qualcosa di immutabile non può cambiare inaspettatamente. A volte l’immutabilità consente una migliore ottimizzazione Non si può avere un conflitto su una costante.</p>
<p>Vedere <a class="reference internal" href="#S-const"><span class="xref myst">Con: Costanti e immutabilità</span></a></p>
</section>
</section>
<section id="p-11-encapsulate-messy-constructs-rather-than-spreading-through-the-code">
<h3><a name="Rp-library"></a>P.11: Incapsulare costrutti disordinati, anziché distribuirli nel codice<a class="headerlink" href="#p-11-encapsulate-messy-constructs-rather-than-spreading-through-the-code" title="Link to this heading">¶</a></h3>
<section id="id45">
<h4>Motivo<a class="headerlink" href="#id45" title="Link to this heading">¶</a></h4>
<p>Il codice disordinato ha maggiori probabilità di nascondere bug ed è più difficile da scrivere. Una buona interfaccia è più semplice e sicura da usare. Codice disordinato, e di basso livello, genera più codice.</p>
</section>
<section id="id46">
<h4>Esempio<a class="headerlink" href="#id46" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int sz = 100;
int* p = (int*) malloc(sizeof(int) * sz);
int count = 0;
// ...
for (;;) {
    // ... read an int into x, exit loop if end of file is reached ...
    // ... check that x is valid ...
    if (count == sz)
        p = (int*) realloc(p, sizeof(int) * sz * 2);
    p[count++] = x;
    // ...
}
</pre></div>
</div>
<p>Questo è di basso livello, prolisso e soggetto a errori. Per esempio, si «dimentica» di testare l’esaurimento della memoria. Invece, si potrebbe usare <code class="docutils literal notranslate"><span class="pre">vector</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;int&gt; v;
v.reserve(100);
// ...
for (int x; cin &gt;&gt; x; ) {
    // ... check that x is valid ...
    v.push_back(x);
}
</pre></div>
</div>
</section>
<section id="id47">
<h4>Nota<a class="headerlink" href="#id47" title="Link to this heading">¶</a></h4>
<p>Le librerie standard e la GSL sono esempi di questa filosofia. Ad esempio, invece di fare confusione con le matrici, le union, i cast, i problemi coi cicli di vita, <code class="docutils literal notranslate"><span class="pre">gsl::owner</span></code>, ecc., che sono necessari per implementare astrazioni chiave, come <code class="docutils literal notranslate"><span class="pre">vector</span></code>, <code class="docutils literal notranslate"><span class="pre">span</span></code>, <code class="docutils literal notranslate"><span class="pre">lock_guard</span></code> e <code class="docutils literal notranslate"><span class="pre">future</span></code>, si usano le librerie progettate ed implementate da gente con molto più tempo ed esperienza di quanto solitamente si ha. Allo stesso modo, possiamo e dobbiamo progettare e implementare librerie più specializzate, piuttosto che lasciare agli utenti (spesso a noi stessi) il compito di ottenere ripetutamente un buon codice di basso livello. Questa è una variante del <a class="reference internal" href="#R0"><span class="xref myst">principio del sottoinsieme di un insieme</span></a> che sta alla base di queste linee-guida.</p>
</section>
<section id="id48">
<h4>Imposizione<a class="headerlink" href="#id48" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Cercare il «codice disordinato» come la gestione complessa di un puntatore e casting al di fuori dell’implementazione delle astrazioni.</p></li>
</ul>
</section>
</section>
<section id="p-12-use-supporting-tools-as-appropriate">
<h3><a name="Rp-tools"></a>P.12: Usare tool appropriati<a class="headerlink" href="#p-12-use-supporting-tools-as-appropriate" title="Link to this heading">¶</a></h3>
<section id="id49">
<h4>Motivo<a class="headerlink" href="#id49" title="Link to this heading">¶</a></h4>
<p>Ci sono molte cose che vengono fatte meglio «dalla macchina». I computer non si stancano né si annoiano a causa delle attività ripetitive. In genere abbiamo cose migliori da fare rispetto a svolgere ripetutamente attività di routine.</p>
</section>
<section id="id50">
<h4>Esempio<a class="headerlink" href="#id50" title="Link to this heading">¶</a></h4>
<p>Far girare un analizzatore statico per verificare che il codice segua le linee-guida che si desidera che seguano.</p>
</section>
<section id="id51">
<h4>Nota<a class="headerlink" href="#id51" title="Link to this heading">¶</a></h4>
<p>Cfr.</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis">Tool di analisi statica</a></p></li>
<li><p><a class="reference internal" href="#Rconc-tools"><span class="xref myst">Tool sulla concorrenza</span></a></p></li>
<li><p><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/tree/master">Tool per il test</a></p></li>
</ul>
<p>Esistono molti altri tipi di strumenti, come repository di sorgenti, tool per la compilazione, ecc., ma questi vanno oltre lo scopo di queste linee-guida.</p>
</section>
<section id="id52">
<h4>Nota<a class="headerlink" href="#id52" title="Link to this heading">¶</a></h4>
<p>Fare attenzione a non dipendere da catene di tool troppo elaborati o troppo specializzati. Potrebbero rendere il codice non-portabile.</p>
</section>
</section>
<section id="p-13-use-support-libraries-as-appropriate">
<h3><a name="Rp-lib"></a>P.13: Usare librerie di supporto appropriate<a class="headerlink" href="#p-13-use-support-libraries-as-appropriate" title="Link to this heading">¶</a></h3>
<section id="id53">
<h4>Motivo<a class="headerlink" href="#id53" title="Link to this heading">¶</a></h4>
<p>L’uso di una libreria ben progettata, ben documentata e ben supportata consente di risparmiare tempo e fatica; tali qualità e documentazione sono probabilmente maggiori di quelle che si potrebbe fare se la maggior parte del tempo si dovesse impiegare in un’implementazione. Il costo (tempo, fatica, denaro, ecc.) di una libreria può essere suddiviso tra molti utenti. È più probabile che una libreria largamente utilizzata venga mantenuta aggiornata e trasferita su nuovi sistemi rispetto a una singola applicazione. La conoscenza di una biblioteca ampiamente utilizzata può far risparmiare tempo su altri/futuri progetti. Pertanto, se esiste una libreria adatta per il dominio dell’applicazione, utilizzarla.</p>
</section>
<section id="id54">
<h4>Esempio<a class="headerlink" href="#id54" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>std::sort(begin(v), end(v), std::greater&lt;&gt;());
</pre></div>
</div>
<p>A meno che non si sia un esperto di algoritmi di ordinamento e si abbia un sacco di tempo, è più probabile che sia corretto e che funzioni più velocemente di qualsiasi cosa si scriva per un’applicazione specifica. È necessario un motivo per non utilizzare la libreria standard (o qualsiasi libreria di base utilizzata dall’applicazione) piuttosto che un motivo per utilizzarla.</p>
</section>
<section id="id55">
<h4>Nota<a class="headerlink" href="#id55" title="Link to this heading">¶</a></h4>
<p>Per default usare</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sl-the-standard-library"><span class="xref myst">La Libreria Standard C++ ISO</span></a></p></li>
<li><p>La <a class="reference internal" href="#gsl-guidelines-support-library"><span class="xref myst">Libreria di Supporto alle Linee-guida</span></a></p></li>
</ul>
</section>
<section id="id56">
<h4>Nota<a class="headerlink" href="#id56" title="Link to this heading">¶</a></h4>
<p>Se non esiste una libreria ben progettata, ben documentata e ben supportata per un dominio importante, forse si dovrebbe progettarla e implementarla, per poi utilizzarla.</p>
</section>
</section>
</section>
<section id="i-interfaces">
<h2><a name="S-interfaces"></a>I: Interfacce<a class="headerlink" href="#i-interfaces" title="Link to this heading">¶</a></h2>
<p>Un’interfaccia è un contratto tra due parti di un programma. Indica con precisione cosa ci si aspetta da un fornitore di un servizio e un utente per cui quel servizio è essenziale. Avere buone interfacce (di facile comprensione, che ne incoraggino un uso efficiente, non soggette a errori, col supporto di test, ecc.) è probabilmente il solo aspetto più importante dell’organizzazione del codice.</p>
<p>Riepilogo delle regole sulle interfacce:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Ri-explicit"><span class="xref myst">I.1: Rendere esplicite le interfacce</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-global"><span class="xref myst">I.2: Evitare variabili globali non-<code class="docutils literal notranslate"><span class="pre">const</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Ri-singleton"><span class="xref myst">I.3: Evitare i singleton</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-typed"><span class="xref myst">I.4: Creare interfacce precisamente e fortemente tipizzate</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-pre"><span class="xref myst">I.5: Precondizioni dello stato (se c’è)</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-expects"><span class="xref myst">I.6: Preferire <code class="docutils literal notranslate"><span class="pre">Expects()</span></code> per esprimere le precondizioni</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-post"><span class="xref myst">I.7: Postcondizioni dello stato</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-ensures"><span class="xref myst">I.8: Preferire <code class="docutils literal notranslate"><span class="pre">Ensures()</span></code> per esprimere le postcondizioni</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-concepts"><span class="xref myst">I.9: Se un’interfaccia è un template, documentarne i parametri usando i concetti</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-except"><span class="xref myst">I.10: Usare le eccezioni per segnalare un errore nell’eseguire un compito richiesto</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-raw"><span class="xref myst">I.11: Mai trasferire la proprietà con un semplice puntatore (<code class="docutils literal notranslate"><span class="pre">T*</span></code>) o un riferimento (<code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>)</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-nullptr"><span class="xref myst">I.12: Dichiarare un puntatore che non dev’essere null con <code class="docutils literal notranslate"><span class="pre">not_null</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Ri-array"><span class="xref myst">I.13: Non passare un array come singolo puntatore</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-global-init"><span class="xref myst">I.22: Evitare complesse inizializzazioni di oggetti globali</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-nargs"><span class="xref myst">I.23: Mantenere basso il numero degli argomenti di una funzione</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-unrelated"><span class="xref myst">I.24: Evitare parametri adiacenti che possono essere invocati dagli stessi argomenti in qualsiasi ordine con un diverso significato</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-abstract"><span class="xref myst">I.25: Preferire classi astratte vuote come interfacce alle gerarchie di classi</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-abi"><span class="xref myst">I.26: Se si vuole un cross-compiler ABI, si usi un sottoinsieme in stile C</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-pimpl"><span class="xref myst">I.27: Per una libreria ABI stabile, si consideri l’idioma Pimpl</span></a></p></li>
<li><p><a class="reference internal" href="#Ri-encapsulate"><span class="xref myst">I.30: Incapsulare le violazioni alla regola</span></a></p></li>
</ul>
<p><strong>Si veda anche</strong>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#S-functions"><span class="xref myst">F: Funzioni</span></a></p></li>
<li><p><a class="reference internal" href="#SS-concrete"><span class="xref myst">C.concrete: Tipi concreti</span></a></p></li>
<li><p><a class="reference internal" href="#SS-hier"><span class="xref myst">C.hier: Gerarchie di classi</span></a></p></li>
<li><p><a class="reference internal" href="#SS-overload"><span class="xref myst">C.over: Overloading e operatori overloaded</span></a></p></li>
<li><p><a class="reference internal" href="#SS-containers"><span class="xref myst">C.con: Contenitori ed altri gestori di risorse</span></a></p></li>
<li><p><a class="reference internal" href="#S-errors"><span class="xref myst">E: Gestione degli errori</span></a></p></li>
<li><p><a class="reference internal" href="#S-templates"><span class="xref myst">T: Template e programmazione generica</span></a></p></li>
</ul>
<section id="i-1-make-interfaces-explicit">
<h3><a name="Ri-explicit"></a>I.1: Rendere esplicite le interfacce<a class="headerlink" href="#i-1-make-interfaces-explicit" title="Link to this heading">¶</a></h3>
<section id="id57">
<h4>Motivo<a class="headerlink" href="#id57" title="Link to this heading">¶</a></h4>
<p>Correttezza. I presupposti non indicati in un’interfaccia sono facilmente trascurati e difficili da testare.</p>
</section>
<section id="id58">
<h4>Esempio, cattivo<a class="headerlink" href="#id58" title="Link to this heading">¶</a></h4>
<p>Il controllo del comportamento di una funzione attraverso una variabile globale (scope del namespace) (una modalità di chiamata) è implicita e potenzialmente confusa. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int round(double d)
{
    return (round_up) ? ceil(d) : d;    // don&#39;t: &quot;invisible&quot; dependency
}
</pre></div>
</div>
<p>Non sarà ovvio ad un chiamante che il significato di due chiamate a <code class="docutils literal notranslate"><span class="pre">round(7.2)</span></code> possa avere risultati diversi.</p>
</section>
<section id="exception">
<h4>Eccezione<a class="headerlink" href="#exception" title="Link to this heading">¶</a></h4>
<p>A volte si controllano i dettagli di un insieme di operazioni tramite una variabile d’ambiente, p.es. output normale anziché verboso o debug anziché ottimizzato. L’uso di un controllo-non-locale è potenzialmente confuso, ma regola solo i dettagli implementativi di una semantica che sarebbe altrimenti fissa.</p>
</section>
<section id="id59">
<h4>Esempio, cattivo<a class="headerlink" href="#id59" title="Link to this heading">¶</a></h4>
<p>Il reporting tramite variabili non locali  (p.es., <code class="docutils literal notranslate"><span class="pre">errno</span></code>) viene facilmente ignorato. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// don&#39;t: no test of fprintf&#39;s return value
fprintf(connection, &quot;logging: %d %d %d\n&quot;, x, y, s);
</pre></div>
</div>
<p>Cosa succede se la connessione si interrompe così che non si produca alcun output del log? Cfr. I.???.</p>
<p><strong>Alternativa</strong>: Sollevare un’eccezione. Un’eccezione non può essere ignorata.</p>
<p><strong>Formula alternativa</strong>: Evitare il passaggio di informazioni tramite un’interfaccia attraverso uno stato non-locale o implicito. Notare che le funzioni membro non-<code class="docutils literal notranslate"><span class="pre">const</span></code> passano le informazioni ad altre funzioni membro tramite lo stato del loro oggetto.</p>
<p><strong>Formula alternativa</strong>: Un’interfaccia dovrebbe essere una funzione o un insieme di funzioni. Le funzioni possono essere funzioni template e gruppi di funzioni possono essere classi o classi template.</p>
</section>
<section id="id60">
<h4>Imposizione<a class="headerlink" href="#id60" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>(Semplice) Una funzione non dovrebbe prendere decisioni sul flusso di controllo in base ai valori delle variabili dichiarate nello scope del namespace.</p></li>
<li><p>(Semplice) Una funzione non dovrebbe scrivere nelle variabili dichiarate nello scope del namespace</p></li>
</ul>
</section>
</section>
<section id="i-2-avoid-non-const-global-variables">
<h3><a name="Ri-global"></a>I.2: Evitare variabili globali non-<code class="docutils literal notranslate"><span class="pre">const</span></code><a class="headerlink" href="#i-2-avoid-non-const-global-variables" title="Link to this heading">¶</a></h3>
<section id="id61">
<h4>Motivo<a class="headerlink" href="#id61" title="Link to this heading">¶</a></h4>
<p>Le variabili globali non-<code class="docutils literal notranslate"><span class="pre">const</span></code> nascondono le dipendenze rendendole soggette a modifiche imprevedibili.</p>
</section>
<section id="id62">
<h4>Esempio<a class="headerlink" href="#id62" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Data {
    // ... lots of stuff ...
} data;            // non-const data

void compute()     // don&#39;t
{
    // ... use data ...
}

void output()     // don&#39;t
{
    // ... use data ...
}
</pre></div>
</div>
<p>Chi altri potrebbe modificare <code class="docutils literal notranslate"><span class="pre">data</span></code>?</p>
<p><strong>Attenzione</strong>: L’inizializzazione degli oggetti globali non è completamente ordinata. Se si usa un oggetto globale, lo si inizializzi con una costante. Si noti che è possibile avere un’inizializzazione indefinita anche per oggetti <code class="docutils literal notranslate"><span class="pre">const</span></code>.</p>
</section>
<section id="id63">
<h4>Eccezione<a class="headerlink" href="#id63" title="Link to this heading">¶</a></h4>
<p>Un oggetto globale spesso è meglio di un singleton.</p>
</section>
<section id="id64">
<h4>Nota<a class="headerlink" href="#id64" title="Link to this heading">¶</a></h4>
<p>Le costanti globali sono utili.</p>
</section>
<section id="id65">
<h4>Nota<a class="headerlink" href="#id65" title="Link to this heading">¶</a></h4>
<p>La regola contro le variabili globali si applica anche alle variabili nello scope del namespace.</p>
<p><strong>Alternativa</strong>: Se si usano dati globali (più in generale nello scope del namespace) per evitarne la copia, si prenda in considerazione il passare i dati come un oggetto per riferimento a <code class="docutils literal notranslate"><span class="pre">const</span></code>. Un’altra soluzione è quella di definire i dati come lo stato di alcuni oggetti e le operazioni come funzioni membro.</p>
<p><strong>Warning</strong>: Attenzione ai conflitti sui dati: Se un thread può accedere a dati non-locali (o dati passati per riferimento) mentre un altro thread esegue il chiamato, si può avere un conflitto. Ogni puntatore o riferimento a dati mutabili è un potenziale conflitto.</p>
<p>L’uso di puntatori o riferimenti globali per accedere e modificare i dati non-costanti e, in caso contrario, non-globali, non è un’alternativa migliore alle variabili globali non-costanti poiché ciò non risolve il problema delle dipendenze nascoste o delle potenziali condizioni di conflitti dei dati.</p>
</section>
<section id="id66">
<h4>Nota<a class="headerlink" href="#id66" title="Link to this heading">¶</a></h4>
<p>Non è possibile avere una condizione di conflitto su dati immutabili.</p>
<p><strong>Riferimenti</strong>: Si vedano le <a class="reference internal" href="#SS-call"><span class="xref myst">regole per chiamate a funzioni</span></a>.</p>
</section>
<section id="id67">
<h4>Nota<a class="headerlink" href="#id67" title="Link to this heading">¶</a></h4>
<p>La regola è «evitare», non «non usare». Naturalmente ci saranno (rare) eccezioni, come <code class="docutils literal notranslate"><span class="pre">cin</span></code>, <code class="docutils literal notranslate"><span class="pre">cout</span></code> e <code class="docutils literal notranslate"><span class="pre">cerr</span></code>.</p>
</section>
<section id="id68">
<h4>Imposizione<a class="headerlink" href="#id68" title="Link to this heading">¶</a></h4>
<p>(Semplice) Riportare tutte le variabili non-<code class="docutils literal notranslate"><span class="pre">const</span></code> dichiarate nello scope del namespace e i puntatori/riferimenti globali a dati non-const.</p>
</section>
</section>
<section id="i-3-avoid-singletons">
<h3><a name="Ri-singleton"></a>I.3: Evitare i singleton<a class="headerlink" href="#i-3-avoid-singletons" title="Link to this heading">¶</a></h3>
<section id="id69">
<h4>Motivo<a class="headerlink" href="#id69" title="Link to this heading">¶</a></h4>
<p>I singleton sono fondamentalmente complicati oggetti globali sotto mentite spoglie.</p>
</section>
<section id="id70">
<h4>Esempio<a class="headerlink" href="#id70" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Singleton {
    // ... lots of stuff to ensure that only one Singleton object is created,
    // that it is initialized properly, etc.
};
</pre></div>
</div>
<p>Esistono molte varianti dell’idea di singleton. Questo è parte del problema.</p>
</section>
<section id="id71">
<h4>Nota<a class="headerlink" href="#id71" title="Link to this heading">¶</a></h4>
<p>Se non si desidera modificare un oggetto globale, dichiararlo <code class="docutils literal notranslate"><span class="pre">const</span></code> o <code class="docutils literal notranslate"><span class="pre">constexpr</span></code>.</p>
</section>
<section id="id72">
<h4>Eccezione<a class="headerlink" href="#id72" title="Link to this heading">¶</a></h4>
<p>È possibile utilizzare il più semplice «singleton» (così semplice che spesso non viene considerato un singleton) per ottenerne l’inizializzazione al primo utilizzo, se presente:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X&amp; myX()
{
    static X my_x {3};
    return my_x;
}
</pre></div>
</div>
<p>Questa è una delle soluzioni più efficaci ai problemi relativi all’ordine di inizializzazione. In un ambiente multi-thread, l’inizializzazione dell’oggetto statico non introduce un conflitto (a meno che non si acceda con noncuranza a un oggetto shared dal suo costruttore).</p>
<p>Si noti che l’inizializzazione di uno <code class="docutils literal notranslate"><span class="pre">static</span></code> locale non implica una condizione di conflitto. Tuttavia, se la distruzione di <code class="docutils literal notranslate"><span class="pre">X</span></code> implica un’operazione che dev’essere sincronizzata, si deve usare una soluzione meno semplice. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X&amp; myX()
{
    static auto p = new X {3};
    return *p;  // potential leak
}
</pre></div>
</div>
<p>Ora qualcuno deve eseguire il <code class="docutils literal notranslate"><span class="pre">delete</span></code> di quest’oggetto quell’oggetto in modo opportunamente sicuro per essere thread-safe. Questo è soggetto a errori, quindi questa tecnica non va usata a meno che</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">myX</span></code> stia in un codice multi-threaded,</p></li>
<li><p>che l’oggetto <code class="docutils literal notranslate"><span class="pre">X</span></code> debba essere distrutto (p.es., perché rilascia una risorsa), e</p></li>
<li><p>il codice del distruttore di <code class="docutils literal notranslate"><span class="pre">X</span></code> deve essere sincronizzato.</p></li>
</ul>
<p>Se, come molti fanno, si definisce un singleton come una classe per cui viene creato un solo oggetto, funzioni come <code class="docutils literal notranslate"><span class="pre">myX</span></code> non sono dei singleton, e questa utile tecnica non fa eccezione alla regola no-singleton.</p>
</section>
<section id="id73">
<h4>Imposizione<a class="headerlink" href="#id73" title="Link to this heading">¶</a></h4>
<p>In generale molto difficile.</p>
<ul class="simple">
<li><p>Cercare le classi con <code class="docutils literal notranslate"><span class="pre">singleton</span></code> nel nome.</p></li>
<li><p>Cercare classi per le quali viene creato un solo oggetto (contando gli oggetti o esaminando i costruttori).</p></li>
<li><p>Se una classe X ha una funzione statica pubblica che contiene una funzione statica locale del tipo X della classe e restituisce un puntatore o un riferimento ad essa, vietarlo.</p></li>
</ul>
</section>
</section>
<section id="i-4-make-interfaces-precisely-and-strongly-typed">
<h3><a name="Ri-typed"></a>I.4: Creare interfacce precisamente e fortemente tipizzate<a class="headerlink" href="#i-4-make-interfaces-precisely-and-strongly-typed" title="Link to this heading">¶</a></h3>
<section id="id74">
<h4>Motivo<a class="headerlink" href="#id74" title="Link to this heading">¶</a></h4>
<p>I tipi costituiscono la più semplice e ottimale documentazione, migliorano la leggibilità grazie al loro significato ben definito e vengono controllati al momento della compilazione. Inoltre, il codice tipizzato con precisione viene spesso meglio ottimizzato.</p>
</section>
<section id="example-don-t">
<h4>Esempio, da non fare<a class="headerlink" href="#example-don-t" title="Link to this heading">¶</a></h4>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void pass(void* data);    // weak and under qualified type void* is suspicious
</pre></div>
</div>
<p>I chiamanti non sono sicuri di quali tipi siano ammessi e se i dati possano essere mutati come <code class="docutils literal notranslate"><span class="pre">const</span></code> se non specificato. Si noti che tutti i tipi di puntatori vengono convertiti implicitamente in <code class="docutils literal notranslate"><span class="pre">void*</span></code>, quindi è facile per i chiamanti fornire questo valore.</p>
<p>Il chiamato deve eseguire un <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> dei dati ad un tipo non verificato per usarlo. Questo è soggetto a errori ed è prolisso.</p>
<p>Utilizzare solo <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void*</span></code> per passare i dati in progetti che sono indescrivibili in C++. Si consideri invece l’uso di un <code class="docutils literal notranslate"><span class="pre">variant</span></code> o un puntatore alla base.</p>
<p><strong>Alternativa</strong>: Spesso, un parametro template può eliminare il <code class="docutils literal notranslate"><span class="pre">void*</span></code> trasformandolo in un <code class="docutils literal notranslate"><span class="pre">T*</span></code> o in un <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>. Per il codice generico questi <code class="docutils literal notranslate"><span class="pre">T</span></code> possono essere parametri di template generali o vincolati al «concetto».</p>
</section>
<section id="id75">
<h4>Esempio, cattivo<a class="headerlink" href="#id75" title="Link to this heading">¶</a></h4>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>draw_rect(100, 200, 100, 500); // what do the numbers specify?

draw_rect(p.x, p.y, 10, 20); // what units are 10 and 20 in?
</pre></div>
</div>
<p>È chiaro che il chiamante sta descrivendo un rettangolo, ma non è chiaro a quali parti si riferisca. Inoltre, un <code class="docutils literal notranslate"><span class="pre">int</span></code> può rappresentare forme arbitrarie di informazioni, compresi i valori di molte unità, quindi dobbiamo indovinare il significato dei quattro <code class="docutils literal notranslate"><span class="pre">int</span></code>. Molto probabilmente, i primi due sono una coppia di coordinate <code class="docutils literal notranslate"><span class="pre">x</span></code>,<code class="docutils literal notranslate"><span class="pre">y</span></code> ma cosa rappresentano gli ultimi due?</p>
<p>Commenti e nomi di parametri possono essere d’aiuto, ma si può essere espliciti:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void draw_rectangle(Point top_left, Point bottom_right);
void draw_rectangle(Point top_left, Size height_width);

draw_rectangle(p, Point{10, 20});  // two corners
draw_rectangle(p, Size{10, 20});   // one corner and a (height, width) pair
</pre></div>
</div>
<p>Ovviamente, non si possono rilevare tutti gli errori attraverso il sistema dei tipi statici (p.es., il fatto che un primo argomento sia considerato un punto in alto a sinistra è lasciato alla convenzione (nomenclatura e commenti)).</p>
</section>
<section id="id76">
<h4>Esempio, cattivo<a class="headerlink" href="#id76" title="Link to this heading">¶</a></h4>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set_settings(true, false, 42); // what do the numbers specify?
</pre></div>
</div>
<p>I tipi dei parametri e i loro valori non comunicano quali impostazioni vengono specificate o cosa significano quei valori.</p>
<p>Questo progetto è più esplicito, sicuro e leggibile:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>alarm_settings s{};
s.enabled = true;
s.displayMode = alarm_settings::mode::spinning_light;
s.frequency = alarm_settings::every_10_seconds;
set_settings(s);
</pre></div>
</div>
<p>Nel caso di un insieme di valori booleani prendere in considerazione l’uso di un flag <code class="docutils literal notranslate"><span class="pre">enum</span></code>; un costrutto (pattern) che esprima un insieme di valori booleani.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enable_lamp_options(lamp_option::on | lamp_option::animate_state_transitions);
</pre></div>
</div>
</section>
<section id="id77">
<h4>Esempio, cattivo<a class="headerlink" href="#id77" title="Link to this heading">¶</a></h4>
<p>Nel seguente esempio, dall’interfaccia non è chiaro cosa significhi <code class="docutils literal notranslate"><span class="pre">time_to_blink</span></code>: Secondi? Millisecondi?</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void blink_led(int time_to_blink) // bad -- the unit is ambiguous
{
    // ...
    // do something with time_to_blink
    // ...
}

void use()
{
    blink_led(2);
}
</pre></div>
</div>
</section>
<section id="id78">
<h4>Esempio, buono<a class="headerlink" href="#id78" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">std::chrono::duration</span></code> i tipi aiutano a rendere esplicita l’unità di durata del tempo.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void blink_led(milliseconds time_to_blink) // good -- the unit is explicit
{
    // ...
    // do something with time_to_blink
    // ...
}

void use()
{
    blink_led(1500ms);
}
</pre></div>
</div>
<p>La funzione può anche essere scritta in modo tale da accettare qualsiasi unità di durata.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class rep, class period&gt;
void blink_led(duration&lt;rep, period&gt; time_to_blink) // good -- accepts any unit
{
    // assuming that millisecond is the smallest relevant unit
    auto milliseconds_to_blink = duration_cast&lt;milliseconds&gt;(time_to_blink);
    // ...
    // do something with milliseconds_to_blink
    // ...
}

void use()
{
    blink_led(2s);
    blink_led(1500ms);
}
</pre></div>
</div>
</section>
<section id="id79">
<h4>Imposizione<a class="headerlink" href="#id79" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>(Semplice) Segnalare l’uso di <code class="docutils literal notranslate"><span class="pre">void*</span></code> come parametro o tipo di ritorno.</p></li>
<li><p>(Semplice) Segnalare l’uso di più di un parametro <code class="docutils literal notranslate"><span class="pre">bool</span></code>.</p></li>
<li><p>(Difficile da fare bene) Cercare le funzioni che usano troppi argomenti di tipo primitivo.</p></li>
</ul>
</section>
</section>
<section id="i-5-state-preconditions-if-any">
<h3><a name="Ri-pre"></a>I.5: Precondizioni dello stato (se c’è)<a class="headerlink" href="#i-5-state-preconditions-if-any" title="Link to this heading">¶</a></h3>
<section id="id80">
<h4>Motivo<a class="headerlink" href="#id80" title="Link to this heading">¶</a></h4>
<p>Gli argomenti hanno un significato che potrebbe limitarne l’uso corretto nel chiamato.</p>
</section>
<section id="id81">
<h4>Esempio<a class="headerlink" href="#id81" title="Link to this heading">¶</a></h4>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double sqrt(double x);
</pre></div>
</div>
<p>Qui <code class="docutils literal notranslate"><span class="pre">x</span></code> dev’essere non-negativo. Il sistema dei tipi non può esprimerlo (facilmente e naturalmente), quindi si devono usare altri mezzi. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double sqrt(double x); // x must be non-negative
</pre></div>
</div>
<p>Alcune precondizioni possono essere espresse come asserzioni. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double sqrt(double x) { Expects(x &gt;= 0); /* ... */ }
</pre></div>
</div>
<p>Idealmente, quell”<code class="docutils literal notranslate"><span class="pre">Expects(x</span> <span class="pre">&gt;=</span> <span class="pre">0)</span></code> dovrebbe far parte dell’interfaccia di <code class="docutils literal notranslate"><span class="pre">sqrt()</span></code> ma ciò non si fa facilmente. Per ora, lo si inserisce nella definizione (corpo della funzione).</p>
<p><strong>Riferimenti</strong>: <code class="docutils literal notranslate"><span class="pre">Expects()</span></code> è descritto nella <a class="reference internal" href="#gsl-guidelines-support-library"><span class="xref myst">GSL</span></a>.</p>
</section>
<section id="id82">
<h4>Nota<a class="headerlink" href="#id82" title="Link to this heading">¶</a></h4>
<p>Preferire una specifica formale dei requisiti, come <code class="docutils literal notranslate"><span class="pre">Expects(p);</span></code>. Se ciò non è possibile, utilizzare il testo inglese nei commenti, ad esempio <code class="docutils literal notranslate"><span class="pre">//</span> <span class="pre">the</span> <span class="pre">sequence</span> <span class="pre">[p:q)</span> <span class="pre">is</span> <span class="pre">ordered</span> <span class="pre">using</span> <span class="pre">&lt;</span></code>.</p>
</section>
<section id="id83">
<h4>Nota<a class="headerlink" href="#id83" title="Link to this heading">¶</a></h4>
<p>La maggior parte delle funzioni membro ha come precondizione alcune invarianti della classe. Tale invariante è stabilito da un costruttore e deve essere ristabilito all’uscita da ogni funzione membro chiamata dall’esterno della classe. Non è necessario menzionarlo per ciascuna funzione membro.</p>
</section>
<section id="id84">
<h4>Imposizione<a class="headerlink" href="#id84" title="Link to this heading">¶</a></h4>
<p>(Non imponibile)</p>
<p><strong>Si veda anche</strong>: Le regole per il passaggio dei puntatori. ???</p>
</section>
</section>
<section id="i-6-prefer-expects-for-expressing-preconditions">
<h3><a name="Ri-expects"></a>I.6: Preferire <code class="docutils literal notranslate"><span class="pre">Expects()</span></code> per esprimere le precondizioni<a class="headerlink" href="#i-6-prefer-expects-for-expressing-preconditions" title="Link to this heading">¶</a></h3>
<section id="id85">
<h4>Motivo<a class="headerlink" href="#id85" title="Link to this heading">¶</a></h4>
<p>Per chiarire che la condizione è una precondizione e per abilitare l’uso del tool.</p>
</section>
<section id="id86">
<h4>Esempio<a class="headerlink" href="#id86" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int area(int height, int width)
{
    Expects(height &gt; 0 &amp;&amp; width &gt; 0);            // good
    if (height &lt;= 0 || width &lt;= 0) my_error();   // obscure
    // ...
}
</pre></div>
</div>
</section>
<section id="id87">
<h4>Nota<a class="headerlink" href="#id87" title="Link to this heading">¶</a></h4>
<p>Le precondizioni si possono stabilire in molti modi, inclusi i commenti, istruzioni <code class="docutils literal notranslate"><span class="pre">if</span></code> e <code class="docutils literal notranslate"><span class="pre">assert()</span></code>. Questo può rendere arduo distinguerle dal normale codice, difficile da aggiornarle, difficile da gestirle con tool, e potrebbero avere la semantica sbagliata (si vuol sempre abortire in debug e mai controllare durante l’esecuzione in produzione?).</p>
</section>
<section id="id88">
<h4>Nota<a class="headerlink" href="#id88" title="Link to this heading">¶</a></h4>
<p>Le precondizioni dovrebbero far parte dell’interfaccia anziché far parte dell’implementazione, ma non c’è ancora il supporto del linguaggio per farlo. Quando sarà disponibile il supporto del linguaggio (p.es., si veda <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf">contract proposal</a>) si adotterà la versione standard delle precondizioni, delle postcondizioni e delle asserzioni.</p>
</section>
<section id="id89">
<h4>Nota<a class="headerlink" href="#id89" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">Expects()</span></code> si può usare anche per controllare una condizione in mezzo ad un algoritmo.</p>
</section>
<section id="id90">
<h4>Nota<a class="headerlink" href="#id90" title="Link to this heading">¶</a></h4>
<p>No, l’uso di <code class="docutils literal notranslate"><span class="pre">unsigned</span></code> non è un buon modo per bypassare il problema per <a class="reference internal" href="#Res-nonnegative"><span class="xref myst">assicurarsi che il valore sia non-negativo</span></a>.</p>
</section>
<section id="id91">
<h4>Imposizione<a class="headerlink" href="#id91" title="Link to this heading">¶</a></h4>
<p>(Non imponibile) Trovare i diversi modi con cui asserire le precondizioni non è fattibile. Attenzione a quelli facilmente identificabili (<code class="docutils literal notranslate"><span class="pre">assert()</span></code>) ha un valore discutibile in assenza del supporto del linguaggio.</p>
</section>
</section>
<section id="i-7-state-postconditions">
<h3><a name="Ri-post"></a>I.7: Postcondizioni dello stato<a class="headerlink" href="#i-7-state-postconditions" title="Link to this heading">¶</a></h3>
<section id="id92">
<h4>Motivo<a class="headerlink" href="#id92" title="Link to this heading">¶</a></h4>
<p>Per rilevare incomprensioni sul risultato e forse catturare implementazioni errate.</p>
</section>
<section id="id93">
<h4>Esempio, cattivo<a class="headerlink" href="#id93" title="Link to this heading">¶</a></h4>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int area(int height, int width) { return height * width; }  // bad
</pre></div>
</div>
<p>Qui, abbiamo (incautamente) escluso la specifica della precondizione, quindi non è esplicito che altezza e larghezza debbano essere positive. Abbiamo anche tralasciato la specifica della postcondizione, quindi non è ovvio che l’algoritmo (<code class="docutils literal notranslate"><span class="pre">height</span> <span class="pre">*</span> <span class="pre">width</span></code>) sia sbagliato per le aree più grandi dell’intero più grande. Può capitare un overflow. Si consideri di usare:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int area(int height, int width)
{
    auto res = height * width;
    Ensures(res &gt; 0);
    return res;
}
</pre></div>
</div>
</section>
<section id="id94">
<h4>Esempio, cattivo<a class="headerlink" href="#id94" title="Link to this heading">¶</a></h4>
<p>Si prenda in considerazione un famoso bug di sicurezza:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()    // problematic
{
    char buffer[MAX];
    // ...
    memset(buffer, 0, sizeof(buffer));
}
</pre></div>
</div>
<p>Non è stata dichiarata alcuna postcondizione che il buffer dev’essere ripulito e l’ottimizzatore ha eliminato le apparentemente ridondanti chiamate a <code class="docutils literal notranslate"><span class="pre">memset()</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()    // better
{
    char buffer[MAX];
    // ...
    memset(buffer, 0, sizeof(buffer));
    Ensures(buffer[0] == 0);
}
</pre></div>
</div>
</section>
<section id="id95">
<h4>Nota<a class="headerlink" href="#id95" title="Link to this heading">¶</a></h4>
<p>Le postcondizioni sono spesso dichiarate in modo informale in un commento che indica lo scopo di una funzione; si può usare <code class="docutils literal notranslate"><span class="pre">Ensures()</span></code> per renderlo più sistematico, visibile e verificabile.</p>
</section>
<section id="id96">
<h4>Nota<a class="headerlink" href="#id96" title="Link to this heading">¶</a></h4>
<p>Le postcondizioni sono particolarmente importanti quando si riferiscono a qualcosa che non si riflette direttamente in un risultato restituito.</p>
</section>
<section id="id97">
<h4>Esempio<a class="headerlink" href="#id97" title="Link to this heading">¶</a></h4>
<p>Si consideri una funzione che gestisce un <code class="docutils literal notranslate"><span class="pre">Record</span></code>, con un <code class="docutils literal notranslate"><span class="pre">mutex</span></code> per evitare conflitti:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mutex m;

void manipulate(Record&amp; r)    // don&#39;t
{
    m.lock();
    // ... no m.unlock() ...
}
</pre></div>
</div>
<p>Qui abbiamo «dimenticato» di dichiarare che il <code class="docutils literal notranslate"><span class="pre">mutex</span></code> dovrebbe essere rilasciato, quindi non sappiamo se il fallimento per assicurare il rilascio del <code class="docutils literal notranslate"><span class="pre">mutex</span></code> fosse un bug o voluto. Il dichiarare la postcondizione lo avrebbe chiarito:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void manipulate(Record&amp; r)    // postcondition: m is unlocked upon exit
{
    m.lock();
    // ... no m.unlock() ...
}
</pre></div>
</div>
<p>Il bug ora è ovvio (ma solo ad un umano che legga i commenti).</p>
<p>Meglio ancora, usare il <a class="reference internal" href="#Rr-raii"><span class="xref myst">RAII</span></a> per assicurarsi che la postcondizione («il lock dev’essere rilasciato») sia scolpita nel codice:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void manipulate(Record&amp; r)    // best
{
    lock_guard&lt;mutex&gt; _ {m};
    // ...
}
</pre></div>
</div>
</section>
<section id="id98">
<h4>Nota<a class="headerlink" href="#id98" title="Link to this heading">¶</a></h4>
<p>Idealmente, le postcondizioni sono indicate nell’interfaccia/dichiarazione in modo che gli utenti possano facilmente vederle. Nell’interfaccia è possibile specificare solo le postcondizioni relative agli utenti. Le postcondizioni relative solo allo stato interno, appartengono alla definizione/implementazione.</p>
</section>
<section id="id99">
<h4>Imposizione<a class="headerlink" href="#id99" title="Link to this heading">¶</a></h4>
<p>(Non imponibile) Questa è una linea-guida filosofica che è impossibile da controllare direttamente nel caso generale. Controlli specifici al dominio (come i controlli per la ritenzione del lock) esistono in molti tool.</p>
</section>
</section>
<section id="i-8-prefer-ensures-for-expressing-postconditions">
<h3><a name="Ri-ensures"></a>I.8: Preferire <code class="docutils literal notranslate"><span class="pre">Ensures()</span></code> per esprimere le postcondizioni<a class="headerlink" href="#i-8-prefer-ensures-for-expressing-postconditions" title="Link to this heading">¶</a></h3>
<section id="id100">
<h4>Motivo<a class="headerlink" href="#id100" title="Link to this heading">¶</a></h4>
<p>Per chiarire che la condizione è una postcondizione e per consentire l’uso di tool.</p>
</section>
<section id="id101">
<h4>Esempio<a class="headerlink" href="#id101" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    char buffer[MAX];
    // ...
    memset(buffer, 0, MAX);
    Ensures(buffer[0] == 0);
}
</pre></div>
</div>
</section>
<section id="id102">
<h4>Nota<a class="headerlink" href="#id102" title="Link to this heading">¶</a></h4>
<p>Le postcondizioni possono essere dichiarate in molti modi, inclusi i commenti, istruzioni <code class="docutils literal notranslate"><span class="pre">if</span></code> e <code class="docutils literal notranslate"><span class="pre">assert()</span></code>. Questo può rendere arduo distinguerle dal normale codice, difficile da aggiornarle, difficile da gestirle con tool e potrebbero avere la semantica sbagliata.</p>
<p><strong>Alternativa</strong>: Le post-condizioni di tipo «questa risorsa dev’essere rilasciata» si esprimono meglio col <a class="reference internal" href="#Rr-raii"><span class="xref myst">RAII</span></a>.</p>
</section>
<section id="id103">
<h4>Nota<a class="headerlink" href="#id103" title="Link to this heading">¶</a></h4>
<p>Idealmente, questo <code class="docutils literal notranslate"><span class="pre">Ensures</span></code> dovrebbe far parte dell’interfaccia, ma ciò non è facile da fare. Per ora, lo si inserisce nella definizione (corpo della funzione). Quando sarà disponibile il supporto del linguaggio (p.es., si veda <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf">contract proposal</a>) si adotterà la versione standard delle precondizioni, delle postcondizioni e delle asserzioni.</p>
</section>
<section id="id104">
<h4>Imposizione<a class="headerlink" href="#id104" title="Link to this heading">¶</a></h4>
<p>(Non imponibile) Trovare i diversi modi con cui asserire le postcondizioni non è fattibile. Attenzione a quelli facilmente identificabili (<code class="docutils literal notranslate"><span class="pre">assert()</span></code>) ha un valore discutibile in assenza del supporto del linguaggio.</p>
</section>
</section>
<section id="i-9-if-an-interface-is-a-template-document-its-parameters-using-concepts">
<h3><a name="Ri-concepts"></a>I.9: Se un’interfaccia è un template, documentarne i parametri usando i concetti<a class="headerlink" href="#i-9-if-an-interface-is-a-template-document-its-parameters-using-concepts" title="Link to this heading">¶</a></h3>
<section id="id105">
<h4>Motivo<a class="headerlink" href="#id105" title="Link to this heading">¶</a></h4>
<p>Rendere l’interfaccia esattamente specificata e controllabile durante la compilazione in un (non molto distante) futuro.</p>
</section>
<section id="id106">
<h4>Esempio<a class="headerlink" href="#id106" title="Link to this heading">¶</a></h4>
<p>Usare lo stile C++20 della specifica dei requisiti. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename Iter, typename Val&gt;
  requires input_iterator&lt;Iter&gt; &amp;&amp; equality_comparable_with&lt;iter_value_t&lt;Iter&gt;, Val&gt;
Iter find(Iter first, Iter last, Val v)
{
    // ...
}
</pre></div>
</div>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#SS-GP"><span class="xref myst">Programmazione generica</span></a>  <a class="reference internal" href="#SS-concepts"><span class="xref myst">concetti</span></a>.</p>
</section>
<section id="id107">
<h4>Imposizione<a class="headerlink" href="#id107" title="Link to this heading">¶</a></h4>
<p>Viene emesso un warning se un parametro template non-variadic non è vincolato [constrained] da un «concept» (nella sua dichiarazione o menzionato in una clausola <code class="docutils literal notranslate"><span class="pre">requires</span></code>.</p>
</section>
</section>
<section id="i-10-use-exceptions-to-signal-a-failure-to-perform-a-required-task">
<h3><a name="Ri-except"></a>I.10: Usare le eccezioni per segnalare un errore nell’eseguire un compito richiesto<a class="headerlink" href="#i-10-use-exceptions-to-signal-a-failure-to-perform-a-required-task" title="Link to this heading">¶</a></h3>
<section id="id108">
<h4>Motivo<a class="headerlink" href="#id108" title="Link to this heading">¶</a></h4>
<p>Non dovrebbe essere possibile ignorare un errore perché ciò potrebbe lasciare il sistema o una elaborazione in uno stato indefinito (o imprevisto). Questa è una delle principali fonti di errori.</p>
</section>
<section id="id109">
<h4>Esempio<a class="headerlink" href="#id109" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int printf(const char* ...);    // bad: return negative number if output fails

template&lt;class F, class ...Args&gt;
// good: throw system_error if unable to start the new thread
explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);
</pre></div>
</div>
</section>
<section id="id110">
<h4>Nota<a class="headerlink" href="#id110" title="Link to this heading">¶</a></h4>
<p>Che cos’è un errore?</p>
<p>Un errore indica che la funzione non può raggiungere lo scopo dichiarato (incluse l’instaurazione delle postcondizioni). Chiamare del codice che ignora un errore può portare a risultati errati o a uno stato indefinito del sistema. Ad esempio, non essere in grado di connettersi a un server remoto non è di per sé un errore: il server può rifiutare una connessione per tutta una serie di motivi, quindi la cosa naturale è quella di restituire un risultato che il chiamante dovrebbe sempre controllare. Tuttavia, se il non riuscire a stabilire una connessione viene considerato un errore, allora tale errore dovrebbe generare un’eccezione.</p>
</section>
<section id="id111">
<h4>Eccezione<a class="headerlink" href="#id111" title="Link to this heading">¶</a></h4>
<p>Molte funzioni di interfacce (p.es., gli handler dei signal di UNIX) usano codici di errore (p.es., <code class="docutils literal notranslate"><span class="pre">errno</span></code>) per segnalare quali sono realmente i codici dello stato, piuttosto che degli errori. Se non si ha una buona alternativa all’uso di questi, allora il chiamarli non viola la regola.</p>
</section>
<section id="alternative">
<h4>Alternativa<a class="headerlink" href="#alternative" title="Link to this heading">¶</a></h4>
<p>Se non si possono usare le eccezioni (p.es., perché il proprio codice è pieno di puntatori vecchio stile o perché ci sono seri vincoli di real-time), si considera l’uso di uno stile che restituisca una coppia di valori:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val;
int error_code;
tie(val, error_code) = do_something();
if (error_code) {
    // ... handle the error or exit ...
}
// ... use val ...
</pre></div>
</div>
<p>Questo stile sfortunatamente porta a variabili non inizializzate. A partire da C++17 si può usare la funzionalità delle «structured bindings» per inizializzare le variabili direttamente dai valori di ritorno:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto [val, error_code] = do_something();
if (error_code) {
    // ... handle the error or exit ...
}
// ... use val ...
</pre></div>
</div>
</section>
<section id="id112">
<h4>Nota<a class="headerlink" href="#id112" title="Link to this heading">¶</a></h4>
<p>Non consideriamo le «prestazioni» un motivo valido per non usare le eccezioni.</p>
<ul class="simple">
<li><p>Spesso, il controllo e la gestione esplicita degli errori consumano tanto tempo e spazio quanto la gestione delle eccezioni.</p></li>
<li><p>Spesso, un codice più pulito produce migliori prestazioni con le eccezioni (semplificando la tracciabilità dei percorsi attraverso il programma e la loro ottimizzazione).</p></li>
<li><p>Una buona regola per le prestazioni del codice critico è quella di spostare il controllo all’esterno della parte <a class="reference internal" href="#Rper-critical"><span class="xref myst">critica</span></a> del codice.</p></li>
<li><p>Alla lunga, un codice più regolare si ottimizza meglio.</p></li>
<li><p><a class="reference internal" href="#Rper-measure"><span class="xref myst">Misurare</span></a> sempre e accuratamente prima di lamentarsi delle prestazioni.</p></li>
</ul>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Ri-pre"><span class="xref myst">I.5</span></a> e <a class="reference internal" href="#Ri-post"><span class="xref myst">I.7</span></a> per riportare violazioni di pre-condizione e post-condizione.</p>
</section>
<section id="id113">
<h4>Imposizione<a class="headerlink" href="#id113" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>(Non imponibile) Questa è una linea-guida filosofica che è impossibile da controllare direttamente.</p></li>
<li><p>Cercare <code class="docutils literal notranslate"><span class="pre">errno</span></code>.</p></li>
</ul>
</section>
</section>
<section id="i-11-never-transfer-ownership-by-a-raw-pointer-t-or-reference-t">
<h3><a name="Ri-raw"></a>I.11: Mai trasferire la proprietà con un semplice puntatore (<code class="docutils literal notranslate"><span class="pre">T*</span></code>) o un riferimento (<code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>)<a class="headerlink" href="#i-11-never-transfer-ownership-by-a-raw-pointer-t-or-reference-t" title="Link to this heading">¶</a></h3>
<section id="id114">
<h4>Motivo<a class="headerlink" href="#id114" title="Link to this heading">¶</a></h4>
<p>In caso di dubbi sul fatto che sia il chiamante o il chiamato a possedere un oggetto, si possono avere dei leak o una prematura distruzione.</p>
</section>
<section id="id115">
<h4>Esempio<a class="headerlink" href="#id115" title="Link to this heading">¶</a></h4>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X* compute(args)    // don&#39;t
{
    X* res = new X{};
    // ...
    return res;
}
</pre></div>
</div>
<p>Chi esegue il delete dell”<code class="docutils literal notranslate"><span class="pre">X</span></code> restituito? Il problema sarebbe più difficile da individuare se <code class="docutils literal notranslate"><span class="pre">compute</span></code> restituisse un riferimento. Si valuti di restituire il risultato per valore (si usa la semantica move se il risultato e grande):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;double&gt; compute(args)  // good
{
    vector&lt;double&gt; res(10000);
    // ...
    return res;
}
</pre></div>
</div>
<p><strong>Alternativa</strong>: <a class="reference internal" href="#Rr-smartptrparam"><span class="xref myst">Passaggio della proprietà</span></a> usando uno «smart pointer», come un <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> (per l’ownership esclusiva) e <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> (per una proprietà condivisa). Tuttavia, è meno elegante e spesso meno efficiente rispetto al restituire l’oggetto stesso, quindi usare gli smart pointer solo se è necessaria la semantica del riferimento.</p>
<p><strong>Alternativa</strong>: Talvolta il codice pre-esistente non si può modificare a causa dei requisiti di compatibilità ABI o per mancanza di risorse. In tal caso, contrassegnare i puntatori proprietari utilizzando <code class="docutils literal notranslate"><span class="pre">owner</span></code> dalla <a class="reference internal" href="#gsl-guidelines-support-library"><span class="xref myst">guidelines support library</span></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>owner&lt;X*&gt; compute(args)    // It is now clear that ownership is transferred
{
    owner&lt;X*&gt; res = new X{};
    // ...
    return res;
}
</pre></div>
</div>
<p>Questo dice ai tool di analisi che <code class="docutils literal notranslate"><span class="pre">res</span></code> è un owner [proprietario]. Cioè, il suo valore deve subire un <code class="docutils literal notranslate"><span class="pre">delete</span></code> o dev’essere trasferito ad un altro owner, come viene fatto qui dal <code class="docutils literal notranslate"><span class="pre">return</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">owner</span></code> viene utilizzato in modo simile nell’implementazione degli handle delle risorse.</p>
</section>
<section id="id116">
<h4>Nota<a class="headerlink" href="#id116" title="Link to this heading">¶</a></h4>
<p>Si presume che ogni oggetto passato come semplice puntatore (o iteratore) sia proprietà del chiamante, in modo che il suo ciclo di vita sia gestito dal chiamante. In altri termini: le API che trasferiscono la proprietà sono relativamente rare rispetto alle API che passano puntatori, quindi il default è «nessun trasferimento della proprietà».</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Rf-conventional"><span class="xref myst">Passaggio di argomenti</span></a>, <a class="reference internal" href="#Rr-smartptrparam"><span class="xref myst">uso di argomenti smart pointer</span></a> e <a class="reference internal" href="#Rf-value-return"><span class="xref myst">valore di ritorno</span></a>.</p>
</section>
<section id="id117">
<h4>Imposizione<a class="headerlink" href="#id117" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>(Semplice) Un warning su un <code class="docutils literal notranslate"><span class="pre">delete</span></code> di un puntatore semplice che non sia un <code class="docutils literal notranslate"><span class="pre">owner&lt;T&gt;</span></code>. Suggeriamo l’uso dell’handle delle risorse della libreria standard o l’uso di <code class="docutils literal notranslate"><span class="pre">owner&lt;T&gt;</span></code>.</p></li>
<li><p>(Semplice) Un warning o in caso di errore del <code class="docutils literal notranslate"><span class="pre">reset</span></code> o l’esplicito <code class="docutils literal notranslate"><span class="pre">delete</span></code> di un puntatore <code class="docutils literal notranslate"><span class="pre">owner</span></code> su ogni percorso del codice.</p></li>
<li><p>(Semplice) Un warning se il valore di ritorno di un <code class="docutils literal notranslate"><span class="pre">new</span></code> o il valore di ritorno <code class="docutils literal notranslate"><span class="pre">owner</span></code> di una chiamata a una funzione viene assegnato ad un puntatore o ad un riferimento non-<code class="docutils literal notranslate"><span class="pre">owner</span></code>.</p></li>
</ul>
</section>
</section>
<section id="i-12-declare-a-pointer-that-must-not-be-null-as-not-null">
<h3><a name="Ri-nullptr"></a>I.12: Dichiarare un puntatore che non dev’essere null con <code class="docutils literal notranslate"><span class="pre">not_null</span></code><a class="headerlink" href="#i-12-declare-a-pointer-that-must-not-be-null-as-not-null" title="Link to this heading">¶</a></h3>
<section id="id118">
<h4>Motivo<a class="headerlink" href="#id118" title="Link to this heading">¶</a></h4>
<p>Per evitare la de-referenziazione degli errori <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>. Per migliorare le prestazioni evitando controlli ridondanti per <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</p>
</section>
<section id="id119">
<h4>Esempio<a class="headerlink" href="#id119" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int length(const char* p);            // it is not clear whether length(nullptr) is valid

length(nullptr);                      // OK?

int length(not_null&lt;const char*&gt; p);  // better: we can assume that p cannot be nullptr

int length(const char* p);            // we must assume that p can be nullptr
</pre></div>
</div>
<p>Dichiarando l’intento nel sorgente, gli implementatori e i tool possono eseguire una diagnostica migliore, come la ricerca di alcune classi di errore con l’analisi statica ed eseguire delle ottimizzazioni quali la rimozione di branch e test nulli.</p>
</section>
<section id="id120">
<h4>Nota<a class="headerlink" href="#id120" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">not_null</span></code> è definito nella <a class="reference internal" href="#gsl-guidelines-support-library"><span class="xref myst">guidelines support library</span></a>.</p>
</section>
<section id="id121">
<h4>Nota<a class="headerlink" href="#id121" title="Link to this heading">¶</a></h4>
<p>L’assunzione che il puntatore a <code class="docutils literal notranslate"><span class="pre">char</span></code> punti ad una stringa C-style (una stringa di caratteri terminata con zero) era ancora implicita ed una potenziale sorgente di confusione e di errori. Usare <code class="docutils literal notranslate"><span class="pre">czstring</span></code> preferendola a <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// we can assume that p cannot be nullptr
// we can assume that p points to a zero-terminated array of characters
int length(not_null&lt;czstring&gt; p);
</pre></div>
</div>
<p>Nota: <code class="docutils literal notranslate"><span class="pre">length()</span></code> è, ovviamente, uno <code class="docutils literal notranslate"><span class="pre">std::strlen()</span></code> in incognito.</p>
</section>
<section id="id122">
<h4>Imposizione<a class="headerlink" href="#id122" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>(Semplice) ((Foundation)) Se una funzione controlla se un parametro puntatore è <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> prima di accedervi, su tutti i percorsi del flusso di controllo, allora si emette un warning sul fatto che dovrebbe essere dichiarato <code class="docutils literal notranslate"><span class="pre">not_null</span></code>.</p></li>
<li><p>(Complesso) Se una funzione con puntatore come valore di ritorno si accerta che non sia <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> su tutti i path di ritorno, allora si emette un warning sul fatto che il tipo restituito si dovrebbe dichiarare <code class="docutils literal notranslate"><span class="pre">not_null</span></code>.</p></li>
</ul>
</section>
</section>
<section id="i-13-do-not-pass-an-array-as-a-single-pointer">
<h3><a name="Ri-array"></a>I.13: Non passare un array come singolo puntatore<a class="headerlink" href="#i-13-do-not-pass-an-array-as-a-single-pointer" title="Link to this heading">¶</a></h3>
<section id="id123">
<h4>Motivo<a class="headerlink" href="#id123" title="Link to this heading">¶</a></h4>
<p>Le interfacce di tipo (puntatore, dimensione) sono soggette ad errori. Inoltre, un semplice puntatore (ad un array) deve fare affidamento su una convenzione per consentire al chiamato di determinarne la dimensione.</p>
</section>
<section id="id124">
<h4>Esempio<a class="headerlink" href="#id124" title="Link to this heading">¶</a></h4>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void copy_n(const T* p, T* q, int n); // copy from [p:p+n) to [q:q+n)
</pre></div>
</div>
<p>Cosa succede se sono presenti meno di <code class="docutils literal notranslate"><span class="pre">n</span></code> elementi nell’array puntato da <code class="docutils literal notranslate"><span class="pre">q</span></code>? Allora, probabilmente si sovrascrive della memoria esterna. Cosa succede se sono presenti meno di <code class="docutils literal notranslate"><span class="pre">n</span></code> elementi nell’array puntato da <code class="docutils literal notranslate"><span class="pre">p</span></code>? Allora, probabilmente, si leggerà da una memoria esterna. O è un comportamento indefinito o un bug potenzialmente molto pericoloso.</p>
</section>
<section id="id125">
<h4>Alternativa<a class="headerlink" href="#id125" title="Link to this heading">¶</a></h4>
<p>Si consideri l’uso di uno span esplicito:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void copy(span&lt;const T&gt; r, span&lt;T&gt; r2); // copy r to r2
</pre></div>
</div>
</section>
<section id="id126">
<h4>Esempio, cattivo<a class="headerlink" href="#id126" title="Link to this heading">¶</a></h4>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void draw(Shape* p, int n);  // poor interface; poor code
Circle arr[10];
// ...
draw(arr, 10);
</pre></div>
</div>
<p>Passare <code class="docutils literal notranslate"><span class="pre">10</span></code> per l’argomento <code class="docutils literal notranslate"><span class="pre">n</span></code> potrebbe risultare un errore: la convenzione più comune è assumere <code class="docutils literal notranslate"><span class="pre">[0:n)</span></code> ma non è scritto da nessuna parte. Peggio ancora è che la chiamata a <code class="docutils literal notranslate"><span class="pre">draw()</span></code> non viene compilata affatto: c’è stata una conversione implicita da un array a un puntatore (array decay) e poi un’altra conversione implicita da <code class="docutils literal notranslate"><span class="pre">Circle</span></code> a <code class="docutils literal notranslate"><span class="pre">Shape</span></code>. Non è possibile che <code class="docutils literal notranslate"><span class="pre">draw()</span></code> possa iterare in sicurezza per tutto quell’array: non ha modo di conoscere la dimensione degli elementi.</p>
<p><strong>Alternativa</strong>: Utilizzare una classe di supporto per garantire che il numero di elementi sia corretto e per prevenire conversioni implicite pericolose. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void draw2(span&lt;Circle&gt;);
Circle arr[10];
// ...
draw2(span&lt;Circle&gt;(arr));  // deduce the number of elements
draw2(arr);    // deduce the element type and array size

void draw3(span&lt;Shape&gt;);
draw3(arr);    // error: cannot convert Circle[10] to span&lt;Shape&gt;
</pre></div>
</div>
<p>Questo <code class="docutils literal notranslate"><span class="pre">draw2()</span></code> passa la stessa quantità di informazioni a <code class="docutils literal notranslate"><span class="pre">draw()</span></code>, ma rende esplicito il fatto che si supponga essere un range di <code class="docutils literal notranslate"><span class="pre">Circle</span></code>. Cfr. ???.</p>
</section>
<section id="id127">
<h4>Eccezione<a class="headerlink" href="#id127" title="Link to this heading">¶</a></h4>
<p>Usare <code class="docutils literal notranslate"><span class="pre">zstring</span></code> e <code class="docutils literal notranslate"><span class="pre">czstring</span></code> per rappresentare stringhe C-style e zero-terminated. Ma quando lo si fa, si usa <code class="docutils literal notranslate"><span class="pre">std::string_view</span></code> o <code class="docutils literal notranslate"><span class="pre">span&lt;char&gt;</span></code> della <a class="reference internal" href="#gsl-guidelines-support-library"><span class="xref myst">GSL</span></a> per evitare errori di range.</p>
</section>
<section id="id128">
<h4>Imposizione<a class="headerlink" href="#id128" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>(Semplice) ((Bounds)) Segnalare un warning per ogni espressione che si baserebbe sulla conversione implicita da un tipo di array ad un tipo di puntatore. Consentire delle eccezioni per tipi di puntatori zstring/czstring.</p></li>
<li><p>(Semplice) ((Bounds)) Segnalare un warning per ogni operazione aritmetica o espressione di tipo puntatore che risulti nel valore di un tipo puntatore. Consentire delle eccezioni per tipi di puntatori zstring/czstring.</p></li>
</ul>
</section>
</section>
<section id="i-22-avoid-complex-initialization-of-global-objects">
<h3><a name="Ri-global-init"></a>I.22: Evitare complesse inizializzazioni di oggetti globali<a class="headerlink" href="#i-22-avoid-complex-initialization-of-global-objects" title="Link to this heading">¶</a></h3>
<section id="id129">
<h4>Motivo<a class="headerlink" href="#id129" title="Link to this heading">¶</a></h4>
<p>Una inizializzazione complessa può portare ad un ordine indefinito di esecuzione.</p>
</section>
<section id="id130">
<h4>Esempio<a class="headerlink" href="#id130" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// file1.c

extern const X x;

const Y y = f(x);   // read x; write y

// file2.c

extern const Y y;

const X x = g(y);   // read y; write x
</pre></div>
</div>
<p>Poiché <code class="docutils literal notranslate"><span class="pre">x</span></code> e <code class="docutils literal notranslate"><span class="pre">y</span></code> stanno in unità di traduzione diverse, l’ordine delle chiamate a <code class="docutils literal notranslate"><span class="pre">f()</span></code> e <code class="docutils literal notranslate"><span class="pre">g()</span></code> non è definito; si accederà ad un <code class="docutils literal notranslate"><span class="pre">const</span></code> non inizializzato. Ciò dimostra che il problema dell’ordine di inizializzazione per gli oggetti globali  (scope del namespace) non è limitato alle <em>variabili</em> globali.</p>
</section>
<section id="id131">
<h4>Nota<a class="headerlink" href="#id131" title="Link to this heading">¶</a></h4>
<p>I problemi sull’ordine di inizializzazione diventano particolarmente difficili da gestire nel codice concorrente. Di solito è meglio evitare del tutto gli oggetti globali (scope del namespace).</p>
</section>
<section id="id132">
<h4>Imposizione<a class="headerlink" href="#id132" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare gli inizializzatori dei globali che chiamano funzioni non-<code class="docutils literal notranslate"><span class="pre">constexpr</span></code></p></li>
<li><p>Segnalare gli inizializzatori dei globali che accedono ad oggetti <code class="docutils literal notranslate"><span class="pre">extern</span></code></p></li>
</ul>
</section>
</section>
<section id="i-23-keep-the-number-of-function-arguments-low">
<h3><a name="Ri-nargs"></a>I.23: Mantenere basso il numero degli argomenti di una funzione<a class="headerlink" href="#i-23-keep-the-number-of-function-arguments-low" title="Link to this heading">¶</a></h3>
<section id="id133">
<h4>Motivo<a class="headerlink" href="#id133" title="Link to this heading">¶</a></h4>
<p>Avere molti argomenti espone a delle opportunità di confusione. Passare molti argomenti spesso è costoso rispetto a delle alternative.</p>
</section>
<section id="discussion">
<h4>Discussione<a class="headerlink" href="#discussion" title="Link to this heading">¶</a></h4>
<p>I due motivi più comuni del perché le funzioni hanno troppi parametri sono:</p>
<ol class="arabic simple">
<li><p><em>Mancanza di un’astrazione</em>. Manca un’astrazione, quindi è un valore composto passato come singoli elementi anziché come un singolo oggetto che impone un invariante. Questo non solo espande la lista dei parametri, ma porta ad errori perché i valori dei componenti non sono più protetti da un invariante imposto.</p></li>
<li><p><em>Violazione di «una funzione, una responsabilità»</em>. La funzione sta tentando di fare di più di una cosa e probabilmente necessita di un refactoring.</p></li>
</ol>
</section>
<section id="id134">
<h4>Esempio<a class="headerlink" href="#id134" title="Link to this heading">¶</a></h4>
<p>La funzione <code class="docutils literal notranslate"><span class="pre">merge()</span></code> della standard-library è al limite di ciò che si può gestire comodamente:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result, Compare comp);
</pre></div>
</div>
<p>Si noti che ciò è dovuto al problema 1 precedente – mancanza di un’astrazione. Anziché passare un range (astrazione), la STL passa una coppia di iteratori (valori non incapsulati dei componenti).</p>
<p>Qui, si hanno quattro argomenti template e sei argomenti funzione. Per semplificarne gli usi più frequenti e più semplici, si può assegnare, per default, l’argomento di confronto <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result);
</pre></div>
</div>
<p>Ciò non riduce la complessità totale, ma riduce la complessità di superficie presentata a molti utenti. Per ridurre davvero il numero di argomenti, si devono raggruppare gli argomenti in astrazioni ad un livello più alto:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class InputRange1, class InputRange2, class OutputIterator&gt;
OutputIterator merge(InputRange1 r1, InputRange2 r2, OutputIterator result);
</pre></div>
</div>
<p>Raggruppare gli argomenti in «bundle» è una tecnica generale per ridurre il numero degli argomenti e per aumentare la possibilità di controllo.</p>
<p>In alternativa, potremmo utilizzare un concetto di libreria standard per definire la nozione di tre tipi che devono essere utilizzabili per il “merge”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class In1, class In2, class Out&gt;
  requires mergeable&lt;In1, In2, Out&gt;
Out merge(In1 r1, In2 r2, Out result);
</pre></div>
</div>
</section>
<section id="id135">
<h4>Esempio<a class="headerlink" href="#id135" title="Link to this heading">¶</a></h4>
<p>I “Profili” di sicurezza consigliano di sostituire</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int* some_ints, int some_ints_length);  // BAD: C style, unsafe
</pre></div>
</div>
<p>con</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(gsl::span&lt;int&gt; some_ints);              // GOOD: safe, bounds-checked
</pre></div>
</div>
<p>Qui, l’utilizzo di un’astrazione presenta vantaggi in termini di sicurezza e robustezza e riduce naturalmente anche il numero dei parametri.</p>
</section>
<section id="id136">
<h4>Nota<a class="headerlink" href="#id136" title="Link to this heading">¶</a></h4>
<p>Quanti parametri sono troppi? Provare ad usarne meno di quattro (4) parametri. Ci sono funzioni che vengono meglio espresse con quattro parametri singoli, ma non di più.</p>
<p><strong>Alternativa</strong>: Usare un’astrazione migliore: Raggruppare gli argomenti in oggetti significativi e passare gli oggetti (per valore o per riferimento).</p>
<p><strong>Alternativa</strong>: Usare gli argomenti di default o gli overload per consentire le forme più comuni di chiamate da effettuarsi con pochi argomenti.</p>
</section>
<section id="id137">
<h4>Imposizione<a class="headerlink" href="#id137" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Avvisare quando una funzione dichiara due iteratori (compresi i puntatori) dello stesso tipo anziché un range o una view.</p></li>
<li><p>(Non imponibile) Questa è una linea-guida filosofica che è impossibile da controllare direttamente.</p></li>
</ul>
</section>
</section>
<section id="i-24-avoid-adjacent-parameters-that-can-be-invoked-by-the-same-arguments-in-either-order-with-different-meaning">
<h3><a name="Ri-unrelated"></a>I.24: Evitare parametri adiacenti che possono essere invocati dagli stessi argomenti in qualsiasi ordine con un diverso significato<a class="headerlink" href="#i-24-avoid-adjacent-parameters-that-can-be-invoked-by-the-same-arguments-in-either-order-with-different-meaning" title="Link to this heading">¶</a></h3>
<section id="id138">
<h4>Motivo<a class="headerlink" href="#id138" title="Link to this heading">¶</a></h4>
<p>Argomenti adiacenti dello stesso tipo si possono facilmente scambiare per errore.</p>
</section>
<section id="id139">
<h4>Esempio, cattivo<a class="headerlink" href="#id139" title="Link to this heading">¶</a></h4>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void copy_n(T* p, T* q, int n);  // copy from [p:p + n) to [q:q + n)
</pre></div>
</div>
<p>Questa è una brutta variante dell’interfaccia in stile K&amp;R C. È facile invertire gli argomenti «to» e «from».</p>
<p>Usare <code class="docutils literal notranslate"><span class="pre">const</span></code> per l’argomento «from»:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void copy_n(const T* p, T* q, int n);  // copy from [p:p + n) to [q:q + n)
</pre></div>
</div>
</section>
<section id="id140">
<h4>Eccezione<a class="headerlink" href="#id140" title="Link to this heading">¶</a></h4>
<p>Se l’ordine dei parametri non è importante, non ci sono problemi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int max(int a, int b);
</pre></div>
</div>
</section>
<section id="id141">
<h4>Alternativa<a class="headerlink" href="#id141" title="Link to this heading">¶</a></h4>
<p>Non passare array come puntatori, passare un oggetto rappresentante un range (p.es., uno <code class="docutils literal notranslate"><span class="pre">span</span></code>):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void copy_n(span&lt;const T&gt; p, span&lt;T&gt; q);  // copy from p to q
</pre></div>
</div>
</section>
<section id="id142">
<h4>Alternativa<a class="headerlink" href="#id142" title="Link to this heading">¶</a></h4>
<p>Definire una <code class="docutils literal notranslate"><span class="pre">struct</span></code> come il tipo del parametro e denominare adeguatamente i campi di tali parametri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct SystemParams {
    string config_file;
    string output_path;
    seconds timeout;
};
void initialize(SystemParams p);
</pre></div>
</div>
<p>Questo tende a renderne chiare le invocazioni ai futuri lettori, poiché i parametri vengono spesso compilati per nome dal lato della chiamata.</p>
</section>
<section id="id143">
<h4>Nota<a class="headerlink" href="#id143" title="Link to this heading">¶</a></h4>
<p>Solo il progettista dell’interfaccia può affrontare adeguatamente la fonte delle violazioni di questa linea guida.</p>
</section>
<section id="enforcement-strategy">
<h4>Strategia di applicazione<a class="headerlink" href="#enforcement-strategy" title="Link to this heading">¶</a></h4>
<p>(Semplice) Sollevare un warning se due parametri consecutivi condividono lo stesso tipo</p>
<p>Stiamo ancora cercando un’applicazione meno semplice.</p>
</section>
</section>
<section id="i-25-prefer-empty-abstract-classes-as-interfaces-to-class-hierarchies">
<h3><a name="Ri-abstract"></a>I.25: Preferire classi astratte vuote come interfacce alle gerarchie di classi<a class="headerlink" href="#i-25-prefer-empty-abstract-classes-as-interfaces-to-class-hierarchies" title="Link to this heading">¶</a></h3>
<section id="id144">
<h4>Motivo<a class="headerlink" href="#id144" title="Link to this heading">¶</a></h4>
<p>Le classi astratte vuote (non hanno dati membri non-statici) hanno maggiori probabilità di essere stabili rispetto alle classi base con uno stato.</p>
</section>
<section id="id145">
<h4>Esempio, cattivo<a class="headerlink" href="#id145" title="Link to this heading">¶</a></h4>
<p>Si sapeva che <code class="docutils literal notranslate"><span class="pre">Shape</span></code> sarebbe comparso da qualche parte :-)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Shape {  // bad: interface class loaded with data
public:
    Point center() const { return c; }
    virtual void draw() const;
    virtual void rotate(int);
    // ...
private:
    Point c;
    vector&lt;Point&gt; outline;
    Color col;
};
</pre></div>
</div>
<p>Ciò costringerà ogni classe derivata a calcolare un centro, anche se non è un’operazione banale e se il centro non viene mai utilizzato. Similmente, non tutte le <code class="docutils literal notranslate"><span class="pre">Shape</span></code> hanno un <code class="docutils literal notranslate"><span class="pre">Color</span></code>, e molte <code class="docutils literal notranslate"><span class="pre">Shape</span></code> vengono meglio rappresentate senza un contorno definito come una sequenza di <code class="docutils literal notranslate"><span class="pre">Point</span></code>. Usare una classe astratta è meglio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Shape {    // better: Shape is a pure interface
public:
    virtual Point center() const = 0;   // pure virtual functions
    virtual void draw() const = 0;
    virtual void rotate(int) = 0;
    // ...
    // ... no data members ...
    // ...
    virtual ~Shape() = default;
};
</pre></div>
</div>
</section>
<section id="id146">
<h4>Imposizione<a class="headerlink" href="#id146" title="Link to this heading">¶</a></h4>
<p>(Semplice) Avvisare se un puntatore/riferimento ad una classe <code class="docutils literal notranslate"><span class="pre">C</span></code> viene assegnata ad un puntatore/riferimento ad una base di <code class="docutils literal notranslate"><span class="pre">C</span></code> e la classe base contiene dai dati membro.</p>
</section>
</section>
<section id="i-26-if-you-want-a-cross-compiler-abi-use-a-c-style-subset">
<h3><a name="Ri-abi"></a>I.26: Se si vuole un cross-compiler ABI, si usi un sottoinsieme in stile C<a class="headerlink" href="#i-26-if-you-want-a-cross-compiler-abi-use-a-c-style-subset" title="Link to this heading">¶</a></h3>
<section id="id147">
<h4>Motivo<a class="headerlink" href="#id147" title="Link to this heading">¶</a></h4>
<p>Compilatori diversi implementano layout binari diversi per le classi, la gestione delle eccezioni, i nomi delle funzioni e altri dettagli di implementazione.</p>
</section>
<section id="id148">
<h4>Eccezione<a class="headerlink" href="#id148" title="Link to this heading">¶</a></h4>
<p>Su alcune piattaforme stanno emergendo delle ABI comuni (Application Binary Interface) [Interfacce Binarie di Applicazioni] che liberano dalle restrizioni più draconiane (rigorose).</p>
</section>
<section id="id149">
<h4>Nota<a class="headerlink" href="#id149" title="Link to this heading">¶</a></h4>
<p>Se si usa un solo compilatore, si può usare pienamente il C++ nelle interfacce. Ciò potrebbe richiedere la ricompilazione dopo un aggiornamento a una nuova versione del compilatore.</p>
</section>
<section id="id150">
<h4>Imposizione<a class="headerlink" href="#id150" title="Link to this heading">¶</a></h4>
<p>(Non imponibile) È difficile identificare in modo affidabile dove un’interfaccia faccia parte di un ABI.</p>
</section>
</section>
<section id="i-27-for-stable-library-abi-consider-the-pimpl-idiom">
<h3><a name="Ri-pimpl"></a>I.27: Per una libreria ABI stabile, si consideri l’idioma Pimpl<a class="headerlink" href="#i-27-for-stable-library-abi-consider-the-pimpl-idiom" title="Link to this heading">¶</a></h3>
<section id="id151">
<h4>Motivo<a class="headerlink" href="#id151" title="Link to this heading">¶</a></h4>
<p>Dato che i dati-membro privati partecipano al layout di una classe e le funzioni-membro private partecipano alla risoluzione degli overload, la modifica di tali dettagli implementativi richiede la ricompilazione di tutti i chiamanti della classe. Una classe interfaccia non polimorfica contenente un puntatore ad un’implementazione (Pimpl [Pointer to implementation]) può isolare i chiamanti della classe dalle modifiche della sua implementazione al costo di un indirizzamento.</p>
</section>
<section id="id152">
<h4>Esempio<a class="headerlink" href="#id152" title="Link to this heading">¶</a></h4>
<p>interfaccia (widget.h)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class widget {
    class impl;
    std::unique_ptr&lt;impl&gt; pimpl;
public:
    void draw(); // public API that will be forwarded to the implementation
    widget(int); // defined in the implementation file
    ~widget();   // defined in the implementation file, where impl is a complete type
    widget(widget&amp;&amp;) noexcept; // defined in the implementation file
    widget(const widget&amp;) = delete;
    widget&amp; operator=(widget&amp;&amp;) noexcept; // defined in the implementation file
    widget&amp; operator=(const widget&amp;) = delete;
};
</pre></div>
</div>
<p>implementazione (widget.cpp)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class widget::impl {
    int n; // private data
public:
    void draw(const widget&amp; w) { /* ... */ }
    impl(int n) : n(n) {}
};
void widget::draw() { pimpl-&gt;draw(*this); }
widget::widget(int n) : pimpl{std::make_unique&lt;impl&gt;(n)} {}
widget::widget(widget&amp;&amp;) noexcept = default;
widget::~widget() = default;
widget&amp; widget::operator=(widget&amp;&amp;) noexcept = default;
</pre></div>
</div>
</section>
<section id="notes">
<h4>Note<a class="headerlink" href="#notes" title="Link to this heading">¶</a></h4>
<p>Cfr. <a class="reference external" href="https://herbsutter.com/gotw/_100/">GOTW #100</a> e <a class="reference external" href="http://en.cppreference.com/w/cpp/language/pimpl">cppreference</a> per valutazioni [trade-offs] e ulteriori dettagli implementativi associati a questo idioma.</p>
</section>
<section id="id153">
<h4>Imposizione<a class="headerlink" href="#id153" title="Link to this heading">¶</a></h4>
<p>(Non imponibile) È difficile identificare in modo affidabile dove un’interfaccia faccia parte di un ABI.</p>
</section>
</section>
<section id="i-30-encapsulate-rule-violations">
<h3><a name="Ri-encapsulate"></a>I.30: Incapsulare le violazioni alla regola<a class="headerlink" href="#i-30-encapsulate-rule-violations" title="Link to this heading">¶</a></h3>
<section id="id154">
<h4>Motivo<a class="headerlink" href="#id154" title="Link to this heading">¶</a></h4>
<p>Per mantenere il codice semplice e sicuro. A volte sono necessarie tecniche brutte, insicure o soggette a errori per motivi logici o prestazionali. In tal caso, si mantengono locali, anziché «infettare» le interfacce in modo che gruppi più grandi di programmatori abbiano a che fare con i particolari. La complessità dell’implementazione non dovrebbe, se possibile, attraverso le interfacce passare nel codice utente.</p>
</section>
<section id="id155">
<h4>Esempio<a class="headerlink" href="#id155" title="Link to this heading">¶</a></h4>
<p>Si consideri un programma che, a seconda di una qualche forma di input (p.es., gli argomenti di <code class="docutils literal notranslate"><span class="pre">main</span></code>), dovrebbe prendere l’input da un file, dalla riga di comando o dallo standard input. Si potrebbe scrivere</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool owned;
owner&lt;istream*&gt; inp;
switch (source) {
case std_in:        owned = false; inp = &amp;cin;                       break;
case command_line:  owned = true;  inp = new istringstream{argv[2]}; break;
case file:          owned = true;  inp = new ifstream{argv[2]};      break;
}
istream&amp; in = *inp;
</pre></div>
</div>
<p>Ciò viola la regola <a class="reference internal" href="#Res-always"><span class="xref myst">contro le variabili non inizializzate</span></a>, la regola contro <a class="reference internal" href="#Ri-raw"><span class="xref myst">il trascurare la proprietà</span></a>, e la regola <a class="reference internal" href="#Res-magic"><span class="xref myst">contro le costanti magiche</span></a>. In particolare, qualcuno si deve ricordare di scrivere da qualche parte</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (owned) delete inp;
</pre></div>
</div>
<p>Si potrebbe gestire questo particolare esempio con <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> con uno speciale deleter che non fa niente per <code class="docutils literal notranslate"><span class="pre">cin</span></code>, ma è complicato per i principianti (che possono facilmente incappare in questo problema) e l’esempio è per un più generale problema dove la proprietà che si vorrebbe considerare statica (qui, l’ownership) talvolta deve essere affrontata in fase di esecuzione. Gli esempi più comuni, più frequenti e più sicuri si possono gestire staticamente, quindi non vi si vuol aggiungere un costo o complessità. Ma si deve far fronte anche ai casi rari, meno sicuri e necessariamente più costosi. Tali esempi sono discussi in <a class="reference external" href="http://www.stroustrup.com/resource-model.pdf">[Str15]</a>.</p>
<p>Quindi, si scrive una classe</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Istream { [[gsl::suppress(&quot;lifetime&quot;)]]
public:
    enum Opt { from_line = 1 };
    Istream() { }
    Istream(czstring p) : owned{true}, inp{new ifstream{p}} {}            // read from file
    Istream(czstring p, Opt) : owned{true}, inp{new istringstream{p}} {}  // read from command line
    ~Istream() { if (owned) delete inp; }
    operator istream&amp;() { return *inp; }
private:
    bool owned = false;
    istream* inp = &amp;cin;
};
</pre></div>
</div>
<p>Ora, la natura dinamica della proprietà di <code class="docutils literal notranslate"><span class="pre">istream</span></code> è stata incapsulata. Presumibilmente, si dovranno aggiungere in un codice reale un po” di controlli per i potenziali errori.</p>
</section>
<section id="id156">
<h4>Imposizione<a class="headerlink" href="#id156" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Difficile, è difficile decidere quale codice rompi-regola sia essenziale</p></li>
<li><p>Si segnala la soppressione della regola che abilita la violazione della regola attraverso le interfacce</p></li>
</ul>
</section>
</section>
</section>
<section id="f-functions">
<h2><a name="S-functions"></a>F: Funzioni<a class="headerlink" href="#f-functions" title="Link to this heading">¶</a></h2>
<p>Una funzione specifica un’azione o un calcolo che porta il sistema da uno stato consistente al successivo. È l’elemento fondamentale dei programmi.</p>
<p>Dovrebbe essere possibile dare un nome significativo a una funzione, specificare i requisiti dei suoi argomenti e indicare chiaramente la relazione tra gli argomenti e il risultato. Un’implementazione non è una specifica. Si provi a pensare a cosa fa una funzione e a come lo fa. Le funzioni costituiscono la parte più critica nella maggior parte delle interfacce, quindi si vedano le regole per le interfacce.</p>
<p>Riepilogo delle regole sulle funzioni:</p>
<p>Regole di definizione di una funzione:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rf-package"><span class="xref myst">F.1: «Impacchettare» le operazioni significative in funzioni dando loro un nome adeguato</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-logical"><span class="xref myst">F.2: Una funzione dovrebbe eseguire una sola operazione logica</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-single"><span class="xref myst">F.3: Le funzioni devono essere brevi e semplici</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-constexpr"><span class="xref myst">F.4: Se una funzione potrebbe essere valutata in fase di compilazione, la si dichiara <code class="docutils literal notranslate"><span class="pre">constexpr</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rf-inline"><span class="xref myst">F.5: Se una funzione è molto piccola e time-critical, la si dichiara inline</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-noexcept"><span class="xref myst">F.6: Se la funzione non deve sollevare errori, dichiararla <code class="docutils literal notranslate"><span class="pre">noexcept</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rf-smart"><span class="xref myst">F.7: Per un uso generale, si prendono gli argomenti <code class="docutils literal notranslate"><span class="pre">T*</span></code> o <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> anziché gli smart pointer</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-pure"><span class="xref myst">F.8: Preferire le funzioni pure</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-unused"><span class="xref myst">F.9: I parametri inutilizzati devono essere senza nome</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-name"><span class="xref myst">F.10: Se un’operazione può essere riutilizzata, le si assegna un nome</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-lambda"><span class="xref myst">F.11: Usare una lambda anonima se c’è bisogno di un semplice oggetto funzione in un posto soltanto</span></a></p></li>
</ul>
<p>Regole per l’espressione del passaggio dei parametri:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rf-conventional"><span class="xref myst">F.15: Preferire metodi semplici e convenzionali per il passaggio delle informazioni</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-in"><span class="xref myst">F.16: Per i parametri «in», si passano i tipi copiati “a buon prezzo” per valore e gli altri per riferimento a <code class="docutils literal notranslate"><span class="pre">const</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rf-inout"><span class="xref myst">F.17: I parametri «in-out», si passano per riferimento a non-<code class="docutils literal notranslate"><span class="pre">const</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rf-consume"><span class="xref myst">F.18: I parametri «si-sposterà-da», si passano per <code class="docutils literal notranslate"><span class="pre">X&amp;&amp;</span></code> e <code class="docutils literal notranslate"><span class="pre">std::move</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rf-forward"><span class="xref myst">F.19: Per i parametri «forward», si passano per <code class="docutils literal notranslate"><span class="pre">TP&amp;&amp;</span></code> si esegue <code class="docutils literal notranslate"><span class="pre">std::forward</span></code> solo per il parametro</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-out"><span class="xref myst">F.20: Per i valori «out» output values, preferire i valori di ritorno ai parametri di output</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-out-multi"><span class="xref myst">F.21: Per il return di valori «out» multipli, preferire la restituzione di una struct</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-ptr-ref"><span class="xref myst">F.60: Preferire <code class="docutils literal notranslate"><span class="pre">T*</span></code> a <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> quando «nessun argomento» è una valida opzione</span></a></p></li>
</ul>
<p>Regole sulla semantica del passaggio dei parametri:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rf-ptr"><span class="xref myst">F.22: Utilizzare <code class="docutils literal notranslate"><span class="pre">T*</span></code> o <code class="docutils literal notranslate"><span class="pre">owner&lt;T*&gt;</span></code> per designare un singolo oggetto</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-nullptr"><span class="xref myst">F.23: Utilizzare <code class="docutils literal notranslate"><span class="pre">not_null&lt;T&gt;</span></code> per indicare che «null» non è un valore valido</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-range"><span class="xref myst">F.24: Utilizzare <code class="docutils literal notranslate"><span class="pre">span&lt;T&gt;</span></code> o <code class="docutils literal notranslate"><span class="pre">span_p&lt;T&gt;</span></code> per indicare una sequenza semiaperta</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-zstring"><span class="xref myst">F.25: Utilizzare <code class="docutils literal notranslate"><span class="pre">zstring</span></code> o <code class="docutils literal notranslate"><span class="pre">not_null&lt;zstring&gt;</span></code> per indicare una stringa C-style</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-unique_ptr"><span class="xref myst">F.26: Utilizzare <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;T&gt;</span></code> per trasferire l’ownership dove è necessario un puntatore</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-shared_ptr"><span class="xref myst">F.27: Utilizzare <code class="docutils literal notranslate"><span class="pre">shared_ptr&lt;T&gt;</span></code> per condividere l’ownership</span></a></p></li>
</ul>
<p><a name="Rf-value-return"></a>Regole sulla semantica del valore di ritorno::</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rf-return-ptr"><span class="xref myst">F.42: Restituire <code class="docutils literal notranslate"><span class="pre">T*</span></code> per indicare (solo) una posizione</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-dangle"><span class="xref myst">F.43: Mai (direttamente o indirettamente) restituire un puntatore o un riferimento ad un oggetto locale</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-return-ref"><span class="xref myst">F.44: Restituire <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> quando la copia è indesiderabile e non è necessario «restituire nessun oggetto»</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-return-ref-ref"><span class="xref myst">F.45: Non restituire un <code class="docutils literal notranslate"><span class="pre">T&amp;&amp;</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rf-main"><span class="xref myst">F.46: <code class="docutils literal notranslate"><span class="pre">int</span></code> è il tipo restituito da <code class="docutils literal notranslate"><span class="pre">main()</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rf-assignment-op"><span class="xref myst">F.47: Restituire <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> dagli operatori di assegnamento</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-return-move-local"><span class="xref myst">F.48: Non restituire <code class="docutils literal notranslate"><span class="pre">std::move(local)</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rf-return-const"><span class="xref myst">F.49: Non restituire un <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T</span></code></span></a></p></li>
</ul>
<p>Altre regole sulle funzioni:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rf-capture-vs-overload"><span class="xref myst">F.50: Usare una lambda quando non è possibile una funzione (per acquisire le variabili locali o scrivere una funzione locale))</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-default-args"><span class="xref myst">F.51: Potendo scegliere, si preferiscano gli argomenti con default rispetto all’overloading</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-reference-capture"><span class="xref myst">F.52: Preferire l’acquisizione per riferimento nelle lambda da usare localmente, compresi quelli passati  agli algoritmi</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-value-capture"><span class="xref myst">F.53: Evitare l’acquisizione per riferimento nelle lambda che non si useranno localmente, compresi quelli restituiti, memorizzati nell’heap o passati da un altro thread</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-this-capture"><span class="xref myst">F.54: Quando si scrive una lambda che cattura <code class="docutils literal notranslate"><span class="pre">this</span></code> o qualsiasi dato membro di classe, non usare il «default capture» <code class="docutils literal notranslate"><span class="pre">[=]</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#F-varargs"><span class="xref myst">F.55: Non usare gli argomenti <code class="docutils literal notranslate"><span class="pre">va_arg</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#F-nesting"><span class="xref myst">F.56: Evitare inutili condizioni di annidamento</span></a></p></li>
</ul>
<p>Le funzioni hanno forti somiglianze con le lambda e gli oggetti funzione.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#SS-lambdas"><span class="xref myst">C.lambdas: Oggetti funzione e lambda</span></a></p>
<section id="f-def-function-definitions">
<h3><a name="SS-fct-def"></a>F.def: Definizioni di funzioni<a class="headerlink" href="#f-def-function-definitions" title="Link to this heading">¶</a></h3>
<p>Una definizione di funzione è una dichiarazione di una funzione che specifica anche l’implementazione della funzione, il corpo della funzione.</p>
<section id="f-1-package-meaningful-operations-as-carefully-named-functions">
<h4><a name="Rf-package"></a>F.1: «Impacchettare» le operazioni significative in funzioni dando loro un nome adeguato<a class="headerlink" href="#f-1-package-meaningful-operations-as-carefully-named-functions" title="Link to this heading">¶</a></h4>
<section id="id157">
<h5>Motivo<a class="headerlink" href="#id157" title="Link to this heading">¶</a></h5>
<p>Escludere il le parti in comune rende il codice più leggibile, più riutilizzabile e limita gli errori del codice complicato. Se qualcosa è un’azione ben specificata, la si separa dal codice circostante e gli si da un nome.</p>
</section>
<section id="id158">
<h5>Esempio, da non fare<a class="headerlink" href="#id158" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void read_and_print(istream&amp; is)    // read and print an int
{
    int x;
    if (is &gt;&gt; x)
        cout &lt;&lt; &quot;the int is &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;;
    else
        cerr &lt;&lt; &quot;no int on input\n&quot;;
}
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">read_and_print</span></code> è sbagliato quasi tutto. Legge, scrive (su un <code class="docutils literal notranslate"><span class="pre">ostream</span></code> fisso), scrive i messaggi di errore (su un <code class="docutils literal notranslate"><span class="pre">ostream</span></code> fisso), gestisce solo degli <code class="docutils literal notranslate"><span class="pre">int</span></code>. Non c’è nulla da riutilizzare, le operazioni separate logicamente sono mischiate e le variabili locali restano visibili dopo l’uso. Per un piccolo esempio, questo sembra OK, ma se l’operazione di input, quella di output e la gestione degli errori fossero state più complicate, il groviglio potrebbe diventare difficile da capire.</p>
</section>
<section id="id159">
<h5>Nota<a class="headerlink" href="#id159" title="Link to this heading">¶</a></h5>
<p>Se si scrive una lambda non banale che potenzialmente si possa utilizzare in più posti, le si dà un nome e la si assegna ad una variabile (di solito non locale).</p>
</section>
<section id="id160">
<h5>Esempio<a class="headerlink" href="#id160" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sort(a, b, [](T x, T y) { return x.rank() &lt; y.rank() &amp;&amp; x.value() &lt; y.value(); });
</pre></div>
</div>
<p>Dando un nome alla lambda, si spezza l’espressione nelle sue parti logiche fornendo un forte spunto al senso della lambda.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto lessT = [](T x, T y) { return x.rank() &lt; y.rank() &amp;&amp; x.value() &lt; y.value(); };

sort(a, b, lessT);
</pre></div>
</div>
<p>Il codice più breve non è sempre il migliore per prestazioni o manutenibilità.</p>
</section>
<section id="id161">
<h5>Eccezione<a class="headerlink" href="#id161" title="Link to this heading">¶</a></h5>
<p>I corpi dei loop, comprese le lambda usate come corpi dei loop, raramente necessitano di avere un nome. Tuttavia, grandi loop (p.es., decine di righe o decine di pagine) possono costituire un problema. La regola <a class="reference internal" href="#Rf-single"><span class="xref myst">Le funzioni devono essere brevi e semplici</span></a> implica «I corpi dei loop devono essere brevi». Allo stesso modo, le lambda usate come argomenti di callback talvolta non sono banali, ma è improbabile che siano riutilizzabili.</p>
</section>
<section id="id162">
<h5>Imposizione<a class="headerlink" href="#id162" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Cfr. <a class="reference internal" href="#Rf-single"><span class="xref myst">Le funzioni devono essere brevi e semplici</span></a></p></li>
<li><p>Evidenziare le lambda identiche, o molto simili, utilizzate in più posti.</p></li>
</ul>
</section>
</section>
<section id="f-2-a-function-should-perform-a-single-logical-operation">
<h4><a name="Rf-logical"></a>F.2: Una funzione dovrebbe eseguire una sola operazione logica<a class="headerlink" href="#f-2-a-function-should-perform-a-single-logical-operation" title="Link to this heading">¶</a></h4>
<section id="id163">
<h5>Motivo<a class="headerlink" href="#id163" title="Link to this heading">¶</a></h5>
<p>Una funzione che esegue una sola operazione è più semplice da comprendere, testare e riutilizzare.</p>
</section>
<section id="id164">
<h5>Esempio<a class="headerlink" href="#id164" title="Link to this heading">¶</a></h5>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void read_and_print()    // bad
{
    int x;
    cin &gt;&gt; x;
    // check for errors
    cout &lt;&lt; x &lt;&lt; &quot;\n&quot;;
}
</pre></div>
</div>
<p>Questo è un monolite che ha a che fare con uno specifico input e non avrà mai un altro (diverso) uso. Invece, suddividiamo le funzioni in parti logiche appropriate e parametrizzate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int read(istream&amp; is)    // better
{
    int x;
    is &gt;&gt; x;
    // check for errors
    return x;
}

void print(ostream&amp; os, int x)
{
    os &lt;&lt; x &lt;&lt; &quot;\n&quot;;
}
</pre></div>
</div>
<p>In questo modo si può riutilizzare dove necessario:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void read_and_print()
{
    auto x = read(cin);
    print(cout, x);
}
</pre></div>
</div>
<p>Se fosse necessario, si potrebbero ulteriormente «templatizzare» <code class="docutils literal notranslate"><span class="pre">read()</span></code> e <code class="docutils literal notranslate"><span class="pre">print()</span></code> sul tipo di dato, il meccanismo di I/O, la risposta agli errori, ecc. Esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto read = [](auto&amp; input, auto&amp; value)    // better
{
    input &gt;&gt; value;
    // check for errors
};

void print(auto&amp; output, const auto&amp; value)
{
    output &lt;&lt; value &lt;&lt; &quot;\n&quot;;
}
</pre></div>
</div>
</section>
<section id="id165">
<h5>Imposizione<a class="headerlink" href="#id165" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Sospettare delle funzioni con più di un parametro «out». Utilizzare, invece, i valori di ritorno, comprese le <code class="docutils literal notranslate"><span class="pre">tuple</span></code> per restituire valori multipli.</p></li>
<li><p>Sospettare delle «grandi» funzioni che non rientrano in una schermata dell’editor. Si consideri di riscrivere la funzione come sotto-operazioni più piccole e con dei nomi adeguati.</p></li>
<li><p>Si considerino sospette le funzioni con più di 7 parametri.</p></li>
</ul>
</section>
</section>
<section id="f-3-keep-functions-short-and-simple">
<h4><a name="Rf-single"></a>F.3: Le funzioni devono essere brevi e semplici<a class="headerlink" href="#f-3-keep-functions-short-and-simple" title="Link to this heading">¶</a></h4>
<section id="id166">
<h5>Motivo<a class="headerlink" href="#id166" title="Link to this heading">¶</a></h5>
<p>Le funzioni di grandi dimensioni sono difficili da leggere, hanno maggiori probabilità di contenere codice complesso e hanno maggiori probabilità di avere variabili in vita oltre il loro scope. Le funzioni con strutture di controllo complesse hanno maggiori probabilità di essere lunghe e hanno maggiori probabilità di nascondere errori logici.</p>
</section>
<section id="id167">
<h5>Esempio<a class="headerlink" href="#id167" title="Link to this heading">¶</a></h5>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double simple_func(double val, int flag1, int flag2)
    // simple_func: takes a value and calculates the expected ASIC output,
    // given the two mode flags.
{
    double intermediate;
    if (flag1 &gt; 0) {
        intermediate = func1(val);
        if (flag2 % 2)
             intermediate = sqrt(intermediate);
    }
    else if (flag1 == -1) {
        intermediate = func1(-val);
        if (flag2 % 2)
             intermediate = sqrt(-intermediate);
        flag1 = -flag1;
    }
    if (abs(flag2) &gt; 10) {
        intermediate = func2(intermediate);
    }
    switch (flag2 / 10) {
    case 1: if (flag1 == -1) return finalize(intermediate, 1.171);
            break;
    case 2: return finalize(intermediate, 13.1);
    default: break;
    }
    return finalize(intermediate, 0.);
}
</pre></div>
</div>
<p>Questo è troppo complicato. Come essere certi di aver gestito correttamente tutte le possibili alternative? Sì, infrange anche altre regole.</p>
<p>Si può riscrivere:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double func1_muon(double val, int flag)
{
    // ???
}

double func1_tau(double val, int flag1, int flag2)
{
    // ???
}

double simple_func(double val, int flag1, int flag2)
    // simple_func: takes a value and calculates the expected ASIC output,
    // given the two mode flags.
{
    if (flag1 &gt; 0)
        return func1_muon(val, flag2);
    if (flag1 == -1)
        // handled by func1_tau: flag1 = -flag1;
        return func1_tau(-val, flag1, flag2);
    return 0.;
}
</pre></div>
</div>
</section>
<section id="id168">
<h5>Nota<a class="headerlink" href="#id168" title="Link to this heading">¶</a></h5>
<p>«Non rientra nello schermo» è spesso una buona definizione pratica di «troppo grande». Le funzioni tra una e cinque righe dovrebbero considerarsi la norma.</p>
</section>
<section id="id169">
<h5>Nota<a class="headerlink" href="#id169" title="Link to this heading">¶</a></h5>
<p>Suddividere le grandi funzioni in funzioni più piccole e con nomi significativi. Le funzioni piccole e semplici si mettono facilmente inline laddove il costo di una call è significativo.</p>
</section>
<section id="id170">
<h5>Imposizione<a class="headerlink" href="#id170" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare le funzioni che non «rientrano nello schermo». Quanto è grande uno schermo? Provare 60 righe per 140 caratteri; questo è all’incirca il massimo di una comoda pagina di un libro.</p></li>
<li><p>Segnalare le funzioni troppo complesse. Quanto è complesso il troppo complesso? Si potrebbe usare la complessità ciclomatica. Provare «più di 10 percorsi logici». Un semplice switch vale un percorso.</p></li>
</ul>
</section>
</section>
<section id="f-4-if-a-function-might-have-to-be-evaluated-at-compile-time-declare-it-constexpr">
<h4><a name="Rf-constexpr"></a>F.4: Se una funzione potrebbe essere valutata in fase di compilazione, la si dichiara <code class="docutils literal notranslate"><span class="pre">constexpr</span></code><a class="headerlink" href="#f-4-if-a-function-might-have-to-be-evaluated-at-compile-time-declare-it-constexpr" title="Link to this heading">¶</a></h4>
<section id="id171">
<h5>Motivo<a class="headerlink" href="#id171" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">constexpr</span></code> serve per dire al compilatore di consentirne la valutazione durante la compilazione.</p>
</section>
<section id="id172">
<h5>Esempio<a class="headerlink" href="#id172" title="Link to this heading">¶</a></h5>
<p>Il famoso o famigerato fattoriale:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>constexpr int fac(int n)
{
    constexpr int max_exp = 17;      // constexpr enables max_exp to be used in Expects
    Expects(0 &lt;= n &amp;&amp; n &lt; max_exp);  // prevent silliness and overflow
    int x = 1;
    for (int i = 2; i &lt;= n; ++i) x *= i;
    return x;
}
</pre></div>
</div>
<p>Questo è C++14. Per il C++11, si usa una formulazione ricorsiva di <code class="docutils literal notranslate"><span class="pre">fac()</span></code>.</p>
</section>
<section id="id173">
<h5>Nota<a class="headerlink" href="#id173" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">constexpr</span></code> non garantisce la valutazione in fase di compilazione; garantisce solo che la funzione può essere valutata al momento della compilazione per degli argomenti costanti se il programmatore lo richiede o se il compilatore decide di farlo per ottimizzare.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>constexpr int min(int x, int y) { return x &lt; y ? x : y; }

void test(int v)
{
    int m1 = min(-1, 2);            // probably compile-time evaluation
    constexpr int m2 = min(-1, 2);  // compile-time evaluation
    int m3 = min(-1, v);            // run-time evaluation
    constexpr int m4 = min(-1, v);  // error: cannot evaluate at compile time
}
</pre></div>
</div>
</section>
<section id="id174">
<h5>Nota<a class="headerlink" href="#id174" title="Link to this heading">¶</a></h5>
<p>Non cercare di rendere tutte le funzioni <code class="docutils literal notranslate"><span class="pre">constexpr</span></code>. La maggior parte dei calcoli viene fatta meglio durante l’esecuzione.</p>
</section>
<section id="id175">
<h5>Nota<a class="headerlink" href="#id175" title="Link to this heading">¶</a></h5>
<p>Qualsiasi API che potrebbe eventualmente dipendere da una configurazione a run-time di alto livello o da logiche aziendali non dovrebbe essere <code class="docutils literal notranslate"><span class="pre">constexpr</span></code>. Tale personalizzazione non può essere valutata dal compilatore, e qualsiasi funzione <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> che dipenda da quell’API dovrebbe essere riscritta o non dev’essere <code class="docutils literal notranslate"><span class="pre">constexpr</span></code>.</p>
</section>
<section id="id176">
<h5>Imposizione<a class="headerlink" href="#id176" title="Link to this heading">¶</a></h5>
<p>Impossibile e non necessario. Il compilatore genera un errore se viene chiamata una funzione non-<code class="docutils literal notranslate"><span class="pre">constexpr</span></code> dove è richiesta una costante.</p>
</section>
</section>
<section id="f-5-if-a-function-is-very-small-and-time-critical-declare-it-inline">
<h4><a name="Rf-inline"></a>F.5: Se una funzione è molto piccola e time-critical, la si dichiara <code class="docutils literal notranslate"><span class="pre">inline</span></code><a class="headerlink" href="#f-5-if-a-function-is-very-small-and-time-critical-declare-it-inline" title="Link to this heading">¶</a></h4>
<section id="id177">
<h5>Motivo<a class="headerlink" href="#id177" title="Link to this heading">¶</a></h5>
<p>Alcuni ottimizzatori riescono a mettere inline senza tale suggerimento del programmatore, ma è meglio non farci affidamento. Misurare! Negli ultimi 40 anni circa, ci sono stati promessi compilatori che mettessero inline meglio degli umani senza alcun suggerimento. Stiamo ancora aspettando. Specificando inline (esplicitamente, o implicitamente quando si scrivono funzioni membro nella definizione di una classe) si invoglia il compilatore a fare un lavoro migliore.</p>
</section>
<section id="id178">
<h5>Esempio<a class="headerlink" href="#id178" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>inline string cat(const string&amp; s, const string&amp; s2) { return s + s2; }
</pre></div>
</div>
</section>
<section id="id179">
<h5>Eccezione<a class="headerlink" href="#id179" title="Link to this heading">¶</a></h5>
<p>Non mettere <code class="docutils literal notranslate"><span class="pre">inline</span></code> una funzione in quella che dovrebbe essere un’interfaccia stabile a meno di non essere certi che non cambierà. Una funzione inline è parte dell’ABI [Application Binary Interface].</p>
</section>
<section id="id180">
<h5>Nota<a class="headerlink" href="#id180" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">constexpr</span></code> implica <code class="docutils literal notranslate"><span class="pre">inline</span></code>.</p>
</section>
<section id="id181">
<h5>Nota<a class="headerlink" href="#id181" title="Link to this heading">¶</a></h5>
<p>Le funzioni membro definite nella classe sono per default <code class="docutils literal notranslate"><span class="pre">inline</span></code>.</p>
</section>
<section id="id182">
<h5>Eccezione<a class="headerlink" href="#id182" title="Link to this heading">¶</a></h5>
<p>Le funzioni template (comprese le funzioni membro delle classi template <code class="docutils literal notranslate"><span class="pre">A&lt;T&gt;::function()</span></code> e le funzioni template membro <code class="docutils literal notranslate"><span class="pre">A::function&lt;T&gt;()</span></code>) vengono di norma definite negli header e quindi sono inline.</p>
</section>
<section id="id183">
<h5>Imposizione<a class="headerlink" href="#id183" title="Link to this heading">¶</a></h5>
<p>Segnalare le funzioni <code class="docutils literal notranslate"><span class="pre">inline</span></code> che hanno più di tre istruzioni e che potrebbero essere dichiarate non inline (come le funzioni membro delle classi).</p>
</section>
</section>
<section id="f-6-if-your-function-must-not-throw-declare-it-noexcept">
<h4><a name="Rf-noexcept"></a>F.6: Se la funzione non deve andare in errore, la si dichiara <code class="docutils literal notranslate"><span class="pre">noexcept</span></code><a class="headerlink" href="#f-6-if-your-function-must-not-throw-declare-it-noexcept" title="Link to this heading">¶</a></h4>
<section id="id184">
<h5>Motivo<a class="headerlink" href="#id184" title="Link to this heading">¶</a></h5>
<p>Se non si suppone che venga generata un’eccezione, non si può assumere che il programma la gestisca e dev’essere terminato al più presto. Dichiarando una funzione <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> si aiutano gli ottimizzatori a ridurre il numero di percorsi di esecuzione alternativi. Si accelera anche l’uscita dopo un errore.</p>
</section>
<section id="id185">
<h5>Esempio<a class="headerlink" href="#id185" title="Link to this heading">¶</a></h5>
<p>Si inserisce <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> su tutte le funzioni scritte totalmente in C o un qualsiasi altro linguaggio che non gestisca le eccezioni. La C++ Standard Library lo fa implicitamente per tutte le funzioni nella C Standard Library.</p>
</section>
<section id="id186">
<h5>Nota<a class="headerlink" href="#id186" title="Link to this heading">¶</a></h5>
<p>Le funzioni <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> possono andare in errore quando vengono valutate a runtime, quindi potrebbe essere necessario un <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> condizionale per alcune di esse.</p>
</section>
<section id="id187">
<h5>Esempio<a class="headerlink" href="#id187" title="Link to this heading">¶</a></h5>
<p>Si può usare <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> anche su funzioni che possono andare in errore:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;string&gt; collect(istream&amp; is) noexcept
{
    vector&lt;string&gt; res;
    for (string s; is &gt;&gt; s;)
        res.push_back(s);
    return res;
}
</pre></div>
</div>
<p>Se <code class="docutils literal notranslate"><span class="pre">collect()</span></code> esaurisce la memoria, il programma va in crash. A meno che il programma non sia concepito per sopravvivere all’esaurimento della memoria, questa potrebbe essere la cosa giusta da fare; <code class="docutils literal notranslate"><span class="pre">terminate()</span></code> potrebbe generare delle adeguate informazioni sugli errori (ma con la memoria esaurita è difficile fare qualcosa di intelligente).</p>
</section>
<section id="id188">
<h5>Nota<a class="headerlink" href="#id188" title="Link to this heading">¶</a></h5>
<p>Si deve essere consapevoli dell’ambiente di esecuzione in cui gira il proprio codice quando si decide di dichiarare una funzione <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>, specialmente per i problemi causati dagli errori e dalle allocazioni.  Un codice per essere perfettamente generale (come la libreria standard ed il codice di altre utility simili) deve supportare ambienti dove un’eccezione <code class="docutils literal notranslate"><span class="pre">bad_alloc</span></code> potrebbe essere gestita in modo significativo. Tuttavia, la maggior parte dei programmi e degli ambienti di esecuzione non è in grado di gestire in modo significativo un errore di allocazione e, in quei casi, l’interruzione del programma è la risposta più pulita e semplice a un errore di allocazione.  Se si sa che il codice non possa rispondere ad un errore di allocazione, potrebbe essere opportuno aggiungere <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> anche alle funzioni che allocano.</p>
<p>In altri termini: Nella maggior parte dei programmi, la maggior parte delle funzioni può andare in errore (p.es., perché usano <code class="docutils literal notranslate"><span class="pre">new</span></code>, chiamano funzioni che lo fanno o usano funzioni di libreria che riportano un errore da gestire), quindi non ci si limiti a spargere i <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> dappertutto senza considerare se sia possibile gestire gli errori.</p>
<p><code class="docutils literal notranslate"><span class="pre">noexcept</span></code> è più utile (e chiaramente più corretta) per le funzioni a basso livello usate di frequente.</p>
</section>
<section id="id189">
<h5>Nota<a class="headerlink" href="#id189" title="Link to this heading">¶</a></h5>
<p>I distruttori, le funzioni <code class="docutils literal notranslate"><span class="pre">swap</span></code>, le operazioni move, e i costruttori di default non dovrebbero mai sollevare eccezioni. Si veda anche <a class="reference internal" href="#Rc-default00"><span class="xref myst">C.44</span></a>.</p>
</section>
<section id="id190">
<h5>Imposizione<a class="headerlink" href="#id190" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare le funzioni non <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>, ma che non sollevano errori.</p></li>
<li><p>Segnalare gli <code class="docutils literal notranslate"><span class="pre">swap</span></code>, i <code class="docutils literal notranslate"><span class="pre">move</span></code>, i distruttori e i costruttori di default.</p></li>
</ul>
</section>
</section>
<section id="f-7-for-general-use-take-t-or-t-arguments-rather-than-smart-pointers">
<h4><a name="Rf-smart"></a>F.7: Per un uso generale, si prendono gli argomenti <code class="docutils literal notranslate"><span class="pre">T*</span></code> o <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> anziché gli smart pointer<a class="headerlink" href="#f-7-for-general-use-take-t-or-t-arguments-rather-than-smart-pointers" title="Link to this heading">¶</a></h4>
<section id="id191">
<h5>Motivo<a class="headerlink" href="#id191" title="Link to this heading">¶</a></h5>
<p>Il passaggio di uno smart pointer trasferisce o condivide la proprietà e deve essere utilizzato solo quando si intende la semantica della proprietà. Una funzione che non gestisce il ciclo di vita dovrebbe, invece, accettare dei puntatori semplici o dei riferimenti.</p>
<p>Il passaggio tramite smart pointer limita l’uso di una funzione ai chiamanti che usano gli smart pointer. Una funzione che necessita di un <code class="docutils literal notranslate"><span class="pre">widget</span></code> dovrebbe essere in grado di accettare qualsiasi oggetto <code class="docutils literal notranslate"><span class="pre">widget</span></code>, non solo quelli la cui durata è gestita da un particolare tipo di smart pointer.</p>
<p>Il passaggio di uno smart pointer shared (p.es., <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code>) implica un costo a run-time.</p>
</section>
<section id="id192">
<h5>Esempio<a class="headerlink" href="#id192" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// accepts any int*
void f(int*);

// can only accept ints for which you want to transfer ownership
void g(unique_ptr&lt;int&gt;);

// can only accept ints for which you are willing to share ownership
void g(shared_ptr&lt;int&gt;);

// doesn&#39;t change ownership, but requires a particular ownership of the caller
void h(const unique_ptr&lt;int&gt;&amp;);

// accepts any int
void h(int&amp;);
</pre></div>
</div>
</section>
<section id="id193">
<h5>Esempio, cattivo<a class="headerlink" href="#id193" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// callee
void f(shared_ptr&lt;widget&gt;&amp; w)
{
    // ...
    use(*w); // only use of w -- the lifetime is not used at all
    // ...
};

// caller
shared_ptr&lt;widget&gt; my_widget = /* ... */;
f(my_widget);

widget stack_widget;
f(stack_widget); // error
</pre></div>
</div>
</section>
<section id="id194">
<h5>Esempio, buono<a class="headerlink" href="#id194" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// callee
void f(widget&amp; w)
{
    // ...
    use(w);
    // ...
};

// caller
shared_ptr&lt;widget&gt; my_widget = /* ... */;
f(*my_widget);

widget stack_widget;
f(stack_widget); // ok -- now this works
</pre></div>
</div>
</section>
<section id="id195">
<h5>Nota<a class="headerlink" href="#id195" title="Link to this heading">¶</a></h5>
<p>Si possono catturare molti casi comuni di puntatori «appesi» [dangling] staticamente (cfr. <a class="reference internal" href="#SS-lifetime"><span class="xref myst">profilo di sicurezza sul ciclo-di-vita [lifetime safety]</span></a>). Gli argomenti delle funzioni vivono naturalmente per tutta la durata della chiamata alla funzione e quindi hanno meno problemi di durata.</p>
</section>
<section id="id196">
<h5>Imposizione<a class="headerlink" href="#id196" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Semplice) Avvisare se una funzione accetta come parametro un tipo di puntatore intelligente (che sovraccarica [overload] <code class="docutils literal notranslate"><span class="pre">operator-&gt;</span></code> o <code class="docutils literal notranslate"><span class="pre">operator*</span></code>) che è copiabile ma la funzione chiama solo uno tra: <code class="docutils literal notranslate"><span class="pre">operator*</span></code>, <code class="docutils literal notranslate"><span class="pre">operator-&gt;</span></code> o <code class="docutils literal notranslate"><span class="pre">get()</span></code>. Suggerire, invece, di usare <code class="docutils literal notranslate"><span class="pre">T*</span></code> o <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>.</p></li>
<li><p>Segnalare un parametro di tipo smart pointer (un tipo che sovraccarica [overload] <code class="docutils literal notranslate"><span class="pre">operator-&gt;</span></code> o <code class="docutils literal notranslate"><span class="pre">operator*</span></code>) che è copiabile/spostabile ma non viene mai copiato/spostato nel corpo della funzione, che non viene mai modificato, e che non viene passato ad un’altra funzione che potrebbe farlo. Questo vuol dire che non viene usata la semantica della proprietà [ownership]. Suggerire, invece, di usare <code class="docutils literal notranslate"><span class="pre">T*</span></code> o <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>.</p></li>
</ul>
<p><strong>Si veda anche</strong>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rf-ptr-ref"><span class="xref myst">Preferire <code class="docutils literal notranslate"><span class="pre">T*</span></code> a <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> quando «nessun argomento» è una valida opzione</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-summary-smartptrs"><span class="xref myst">Riepilogo delle regole sugli smart pointer</span></a></p></li>
</ul>
</section>
</section>
<section id="f-8-prefer-pure-functions">
<h4><a name="Rf-pure"></a>F.8: Preferire le funzioni pure<a class="headerlink" href="#f-8-prefer-pure-functions" title="Link to this heading">¶</a></h4>
<section id="id197">
<h5>Motivo<a class="headerlink" href="#id197" title="Link to this heading">¶</a></h5>
<p>Sulle funzioni pure è più facile ragionarci, a volte sono più facili da ottimizzare (ed anche da parallelizzare), e talvolta si possono memoizzare [!=memorizzare].</p>
</section>
<section id="id198">
<h5>Esempio<a class="headerlink" href="#id198" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class T&gt;
auto square(T t) { return t * t; }
</pre></div>
</div>
</section>
<section id="id199">
<h5>Imposizione<a class="headerlink" href="#id199" title="Link to this heading">¶</a></h5>
<p>Non è possibile.</p>
</section>
</section>
<section id="f-9-unused-parameters-should-be-unnamed">
<h4><a name="Rf-unused"></a>F.9: I parametri inutilizzati devono essere senza nome<a class="headerlink" href="#f-9-unused-parameters-should-be-unnamed" title="Link to this heading">¶</a></h4>
<section id="id200">
<h5>Motivo<a class="headerlink" href="#id200" title="Link to this heading">¶</a></h5>
<p>Leggibilità. Soppressione dei warning sui parametri inutilizzati.</p>
</section>
<section id="id201">
<h5>Esempio<a class="headerlink" href="#id201" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>widget* find(const set&lt;widget&gt;&amp; s, const widget&amp; w, Hint);   // once upon a time, a hint was used
</pre></div>
</div>
</section>
<section id="id202">
<h5>Nota<a class="headerlink" href="#id202" title="Link to this heading">¶</a></h5>
<p>La possibilità di avere parametri senza nome è stata introdotta all’inizio del 1980 per risolvere questo problema.</p>
<p>Se i parametri sono condizionalmente inutilizzati, dichiararli con l’attributo <code class="docutils literal notranslate"><span class="pre">[[maybe_unused]]</span></code>. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template &lt;typename Value&gt;
Value* find(const set&lt;Value&gt;&amp; s, const Value&amp; v, [[maybe_unused]] Hint h)
{
    if constexpr (sizeof(Value) &gt; CacheSize)
    {
        // a hint is used only if Value is of a certain size
    }
}
</pre></div>
</div>
</section>
<section id="id203">
<h5>Imposizione<a class="headerlink" href="#id203" title="Link to this heading">¶</a></h5>
<p>Segnalare i nomi dei parametri inutilizzati.</p>
</section>
</section>
<section id="f-10-if-an-operation-can-be-reused-give-it-a-name">
<h4><a name="Rf-name"></a>F.10: Se un’operazione può essere riutilizzata, le si assegna un nome<a class="headerlink" href="#f-10-if-an-operation-can-be-reused-give-it-a-name" title="Link to this heading">¶</a></h4>
<section id="id204">
<h5>Motivo<a class="headerlink" href="#id204" title="Link to this heading">¶</a></h5>
<p>Documentazione, leggibilità, possibilità di riutilizzo.</p>
</section>
<section id="id205">
<h5>Esempio<a class="headerlink" href="#id205" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Rec {
    string name;
    string addr;
    int id;         // unique identifier
};

bool same(const Rec&amp; a, const Rec&amp; b)
{
    return a.id == b.id;
}

vector&lt;Rec*&gt; find_id(const string&amp; name);    // find all records for &quot;name&quot;

auto x = find_if(vr.begin(), vr.end(),
    [&amp;](Rec&amp; r) {
        if (r.name.size() != n.size()) return false; // name to compare to is in n
        for (int i = 0; i &lt; r.name.size(); ++i)
            if (tolower(r.name[i]) != tolower(n[i])) return false;
        return true;
    }
);
</pre></div>
</div>
<p>Qui c’è una funzione nascosta (confronto «case insensitive» di stringhe), come spesso accade quando gli argomenti della lambda diventano grandi.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool compare_insensitive(const string&amp; a, const string&amp; b)
{
    if (a.size() != b.size()) return false;
    for (int i = 0; i &lt; a.size(); ++i) if (tolower(a[i]) != tolower(b[i])) return false;
    return true;
}

auto x = find_if(vr.begin(), vr.end(),
    [&amp;](Rec&amp; r) { return compare_insensitive(r.name, n); }
);
</pre></div>
</div>
<p>O forse (se si preferisce evitare il nome implicito legato a n):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto cmp_to_n = [&amp;n](const string&amp; a) { return compare_insensitive(a, n); };

auto x = find_if(vr.begin(), vr.end(),
    [](const Rec&amp; r) { return cmp_to_n(r.name); }
);
</pre></div>
</div>
</section>
<section id="id206">
<h5>Nota<a class="headerlink" href="#id206" title="Link to this heading">¶</a></h5>
<p>Se funzioni, lambda o operatori.</p>
</section>
<section id="id207">
<h5>Eccezione<a class="headerlink" href="#id207" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Le lambda usate logicamente solo localmente, come un argomento di <code class="docutils literal notranslate"><span class="pre">for_each</span></code> e algoritmi simili per il controllo del flusso.</p></li>
<li><p>Le lambda come <a class="reference internal" href="#???"><span class="xref myst">inizializzatori</span></a></p></li>
</ul>
</section>
<section id="id208">
<h5>Imposizione<a class="headerlink" href="#id208" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(difficile) segnalare le lambda simili</p></li>
<li><p>???</p></li>
</ul>
</section>
</section>
<section id="f-11-use-an-unnamed-lambda-if-you-need-a-simple-function-object-in-one-place-only">
<h4><a name="Rf-lambda"></a>F.11: Usare una lambda anonima se c’è bisogno di un semplice oggetto funzione in un posto soltanto<a class="headerlink" href="#f-11-use-an-unnamed-lambda-if-you-need-a-simple-function-object-in-one-place-only" title="Link to this heading">¶</a></h4>
<section id="id209">
<h5>Motivo<a class="headerlink" href="#id209" title="Link to this heading">¶</a></h5>
<p>Questo rende il codice conciso e offre una località migliore delle alternative.</p>
</section>
<section id="id210">
<h5>Esempio<a class="headerlink" href="#id210" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto earlyUsersEnd = std::remove_if(users.begin(), users.end(),
                                    [](const User &amp;a) { return a.id &gt; 100; });
</pre></div>
</div>
</section>
<section id="id211">
<h5>Eccezione<a class="headerlink" href="#id211" title="Link to this heading">¶</a></h5>
<p>Dare un nome ad una lambda può essere utile per chiarezza anche se viene usata una sola volta.</p>
</section>
<section id="id212">
<h5>Imposizione<a class="headerlink" href="#id212" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Cercare lambda identiche o quasi identiche (da sostituire con nomi di funzioni o nomi di lambda).</p></li>
</ul>
</section>
</section>
</section>
<section id="f-call-parameter-passing">
<h3><a name="SS-call"></a>F.call: Passaggio di parametri<a class="headerlink" href="#f-call-parameter-passing" title="Link to this heading">¶</a></h3>
<p>Esistono vari modi per passare i parametri ad una funzione e per restituire dei valori.</p>
<section id="f-15-prefer-simple-and-conventional-ways-of-passing-information">
<h4><a name="Rf-conventional"></a>F.15: Preferire metodi semplici e convenzionali per il passaggio delle informazioni<a class="headerlink" href="#f-15-prefer-simple-and-conventional-ways-of-passing-information" title="Link to this heading">¶</a></h4>
<section id="id213">
<h5>Motivo<a class="headerlink" href="#id213" title="Link to this heading">¶</a></h5>
<p>L’uso di tecniche «insolite e ingegnose» provoca sorpresa, rallenta la comprensione da parte di altri programmatori e favorisce i bug. Se si sente veramente il bisogno di un’ottimizzazione al di là delle comuni tecniche, effettuare delle misure per essere sicuri che sia un effettivo miglioramento e si documenti/commenti perché la miglioria potrebbe non essere portabile.</p>
<p>Le seguenti tabelle riassumono i consigli nelle linee-guida seguenti, F.16-21.</p>
<p>Passaggio di parametri normale:</p>
<p><img alt="Tabella dei normali passaggi di parametri" src="_images/param-passing-normal.png" /></p>
<p>Passaggio di parametri avanzato:</p>
<p><img alt="Tabella dei passaggi di parametri avanzati" src="_images/param-passing-advanced.png" /></p>
<p>Utilizzare le tecniche avanzate solo dopo averne dimostrato la necessità documentandola in un commento.</p>
<p>Per il passaggio di sequenze di caratteri, cfr. <a class="reference internal" href="#SS-string"><span class="xref myst">String</span></a>.</p>
</section>
<section id="id214">
<h5>Eccezione<a class="headerlink" href="#id214" title="Link to this heading">¶</a></h5>
<p>Per esprimere la proprietà condivisa utilizzando i tipi <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>, anziché seguire le linee guida F.16-21, seguire la <a class="reference internal" href="#Rr-sharedptrparam-owner"><span class="xref myst">R.34</span></a>, la <a class="reference internal" href="#Rr-sharedptrparam"><span class="xref myst">R.35</span></a> e la <a class="reference internal" href="#Rr-sharedptrparam-const"><span class="xref myst">R.36</span></a>.</p>
</section>
</section>
<section id="f-16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const">
<h4><a name="Rf-in"></a>F.16: Per i parametri «in», si passano i tipi copiati “a buon prezzo” per valore e gli altri per riferimento a <code class="docutils literal notranslate"><span class="pre">const</span></code><a class="headerlink" href="#f-16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const" title="Link to this heading">¶</a></h4>
<section id="id215">
<h5>Motivo<a class="headerlink" href="#id215" title="Link to this heading">¶</a></h5>
<p>Entrambi comunicano al chiamante che una funzione non modificherà l’argomento ed entrambi consentono l’inizializzazione per rvalue.</p>
<p>Quello che è «economico da copiare» dipende dall’architettura della macchina, ma due o tre word (double, puntatori, riferimenti) solitamente è meglio passarli per valore. Quando la copia è economica, nulla ne batte la semplicità e la sicurezza e per gli oggetti piccoli (fino a due o tre word) è anche più veloce del passaggio per riferimento perché non richiede, alla funzione, una indirezione extra per l’accesso.</p>
</section>
<section id="id216">
<h5>Esempio<a class="headerlink" href="#id216" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f1(const string&amp; s);  // OK: pass by reference to const; always cheap

void f2(string s);         // bad: potentially expensive

void f3(int x);            // OK: Unbeatable

void f4(const int&amp; x);     // bad: overhead on access in f4()
</pre></div>
</div>
<p>Per i (soli) usi avanzati, dove c’è davvero bisogno di ottimizzare gli rvalue passati come parametri «input-only»:</p>
<ul class="simple">
<li><p>Se la funzione eseguirà incondizionatamente un move dell’argomento, prenderlo per <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>. Cfr. <a class="reference internal" href="#Rf-consume"><span class="xref myst">F.18</span></a>.</p></li>
<li><p>Se la funzione manterrà una copia modificabile localmente dell’argomento solo per il proprio uso locale, prenderla per valore va bene</p></li>
<li><p>Se la funzione manterrà una copia dell’argomento da passare a un’altra destinazione (a un’altra funzione o da archiviare in una posizione non locale), oltre a passare <code class="docutils literal notranslate"><span class="pre">const&amp;</span></code> (per lvalue), si aggiunge un overload che passa il parametro tramite <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> (per rvalue) e nel corpo <code class="docutils literal notranslate"><span class="pre">std::move</span></code> lo porta alla sua destinazione. In sostanza, questi overload aggiungono un «si-sposterà-da»; cfr. <a class="reference internal" href="#Rf-consume"><span class="xref myst">F.18</span></a>.</p></li>
<li><p>In casi speciali, come i parametri «input + copia» multipli, si considera l’uso del “perfect forwarding”. Cfr. <a class="reference internal" href="#Rf-forward"><span class="xref myst">F.19</span></a>.</p></li>
</ul>
</section>
<section id="id217">
<h5>Esempio<a class="headerlink" href="#id217" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int multiply(int, int); // just input ints, pass by value

// suffix is input-only but not as cheap as an int, pass by const&amp;
string&amp; concatenate(string&amp;, const string&amp; suffix);

void sink(unique_ptr&lt;widget&gt;);  // input only, and moves ownership of the widget
</pre></div>
</div>
<p>Evitare «tecniche esoteriche» come il passaggio di argomenti come <code class="docutils literal notranslate"><span class="pre">T&amp;&amp;</span></code> «per efficienza». La maggior parte delle voci sulle prestazione del passaggio per <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> sono false o deboli (ma si vedano <a class="reference internal" href="#Rf-consume"><span class="xref myst">F.18</span></a> e <a class="reference internal" href="#Rf-forward"><span class="xref myst">F.19</span></a>).</p>
</section>
<section id="id218">
<h5>Note<a class="headerlink" href="#id218" title="Link to this heading">¶</a></h5>
<p>Si può assumere che un riferimento riguardi un oggetto valido  (regola de linguaggio). Non esiste un (legittimo) «riferimento null». Se si necessita della nozione di un valore opzionale, si usa un puntatore, <code class="docutils literal notranslate"><span class="pre">std::optional</span></code> o un valore speciale usato per denotare «nessun valore».</p>
</section>
<section id="id219">
<h5>Imposizione<a class="headerlink" href="#id219" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Semplice) ((Foundation)) Si emette un warning quando un parametro che viene passato per valore ha una dimensione maggiore di <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">sizeof(void*)</span></code>. Suggerire di usare, invece, un riferimento a <code class="docutils literal notranslate"><span class="pre">const</span></code>.</p></li>
<li><p>(Semplice) ((Foundation)) Si emette un warning quando un parametro passato per riferimento a <code class="docutils literal notranslate"><span class="pre">const</span></code> ha una dimensione inferiore a <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">sizeof(void*)</span></code>. Suggerire, invece, di passare per valore.</p></li>
<li><p>(Semplice) ((Foundation)) Si emette un warning quando un parametro passato per riferimento a <code class="docutils literal notranslate"><span class="pre">const</span></code>, subisce un <code class="docutils literal notranslate"><span class="pre">move</span></code>.</p></li>
</ul>
</section>
<section id="id220">
<h5>Eccezione<a class="headerlink" href="#id220" title="Link to this heading">¶</a></h5>
<p>Per esprimere la proprietà condivisa utilizzando i tipi <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>, seguire <a class="reference internal" href="#Rr-sharedptrparam-owner"><span class="xref myst">R.34</span></a> o <a class="reference internal" href="#Rr-sharedptrparam-const"><span class="xref myst">R.36</span></a>, a seconda che la funzione accetti o meno incondizionatamente un riferimento all’argomento.</p>
</section>
</section>
<section id="f-17-for-in-out-parameters-pass-by-reference-to-non-const">
<h4><a name="Rf-inout"></a>F.17: I parametri «in-out», si passano per riferimento non-<code class="docutils literal notranslate"><span class="pre">const</span></code><a class="headerlink" href="#f-17-for-in-out-parameters-pass-by-reference-to-non-const" title="Link to this heading">¶</a></h4>
<section id="id221">
<h5>Motivo<a class="headerlink" href="#id221" title="Link to this heading">¶</a></h5>
<p>Ciò chiarisce ai chiamanti che si presuppone che l’oggetto verrà modificato.</p>
</section>
<section id="id222">
<h5>Esempio<a class="headerlink" href="#id222" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void update(Record&amp; r);  // assume that update writes to r
</pre></div>
</div>
</section>
<section id="id223">
<h5>Nota<a class="headerlink" href="#id223" title="Link to this heading">¶</a></h5>
<p>Alcuni tipi user-defined e della libreria standard, come <code class="docutils literal notranslate"><span class="pre">span&lt;T&gt;</span></code> e gli iteratori sono <a class="reference internal" href="#Rf-in"><span class="xref myst">economici da copiare</span></a> e si possono passare per valore, così facendo ha una semantica di riferimento «mutable» (in-out):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void increment_all(span&lt;int&gt; a)
{
  for (auto&amp;&amp; e : a)
    ++e;
}
</pre></div>
</div>
</section>
<section id="id224">
<h5>Nota<a class="headerlink" href="#id224" title="Link to this heading">¶</a></h5>
<p>Un argomento <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> può passare informazioni ad una funzione così come estrarne. Quindi <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> potrebbe essere un parametro-in-out. Questo di per sé può essere un problema e una fonte di errori:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(string&amp; s)
{
    s = &quot;New York&quot;;  // non-obvious error
}

void g()
{
    string buffer = &quot;.................................&quot;;
    f(buffer);
    // ...
}
</pre></div>
</div>
<p>Qui, chi ha scritto <code class="docutils literal notranslate"><span class="pre">g()</span></code> sta fornendo un buffer a <code class="docutils literal notranslate"><span class="pre">f()</span></code> da riempire, ma <code class="docutils literal notranslate"><span class="pre">f()</span></code> semplicemente lo sostituisce (ad un costo leggermente superiore della semplice copia dei caratteri). Un brutto errore logico può aversi se chi scrive <code class="docutils literal notranslate"><span class="pre">g()</span></code> assume erroneamente la dimensione del <code class="docutils literal notranslate"><span class="pre">buffer</span></code>.</p>
</section>
<section id="id225">
<h5>Imposizione<a class="headerlink" href="#id225" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Moderato) ((Foundation)) Emette un warning per le funzioni relative a riferimenti di parametri non-<code class="docutils literal notranslate"><span class="pre">const</span></code> che <em>not</em> scrivono in essi.</p></li>
<li><p>(Semplice) ((Foundation)) Emette un warning quando un parametro non-<code class="docutils literal notranslate"><span class="pre">const</span></code> passato per riferimento [viene spostato] ne viene fatto un <code class="docutils literal notranslate"><span class="pre">move</span></code>.</p></li>
</ul>
</section>
</section>
<section id="f-18-for-will-move-from-parameters-pass-by-x-and-std-move-the-parameter">
<h4><a name="Rf-consume"></a>F.18: I parametri «si-sposterà-da», si passano per <code class="docutils literal notranslate"><span class="pre">X&amp;&amp;</span></code> o con <code class="docutils literal notranslate"><span class="pre">std::move</span></code> the parameter<a class="headerlink" href="#f-18-for-will-move-from-parameters-pass-by-x-and-std-move-the-parameter" title="Link to this heading">¶</a></h4>
<section id="id226">
<h5>Motivo<a class="headerlink" href="#id226" title="Link to this heading">¶</a></h5>
<p>È efficiente ed elimina i bug dal lato della chiamata: <code class="docutils literal notranslate"><span class="pre">X&amp;&amp;</span></code> si lega [bind] agli rvalue, cosa che richiede una esplicita <code class="docutils literal notranslate"><span class="pre">std::move</span></code> dal lato del chiamante se si passa un lvalue.</p>
</section>
<section id="id227">
<h5>Esempio<a class="headerlink" href="#id227" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void sink(vector&lt;int&gt;&amp;&amp; v)  // sink takes ownership of whatever the argument owned
{
    // usually there might be const accesses of v here
    store_somewhere(std::move(v));
    // usually no more use of v here; it is moved-from
}
</pre></div>
</div>
<p>Si noti che <code class="docutils literal notranslate"><span class="pre">std::move(v)</span></code> consente a <code class="docutils literal notranslate"><span class="pre">store_somewhere()</span></code> di lasciare <code class="docutils literal notranslate"><span class="pre">v</span></code> in uno stato spostato [moved-from]. <a class="reference internal" href="#Rc-move-semantic"><span class="xref myst">Questo potrebbe essere pericoloso</span></a>.</p>
</section>
<section id="id228">
<h5>Eccezione<a class="headerlink" href="#id228" title="Link to this heading">¶</a></h5>
<p>I tipi a proprietà unica che sono move-only ed economici-da-spostare, come <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code>, si possono passare anche per valore, cosa che è più semplice da scrivere e si ha lo stesso effetto. Passando per valore si genera un’operazione extra (economica) di move, ma è da preferire innanzitutto la semplicità e la chiarezza.</p>
<p>Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class T&gt;
void sink(std::unique_ptr&lt;T&gt; p)
{
    // use p ... possibly std::move(p) onward somewhere else
}   // p gets destroyed
</pre></div>
</div>
</section>
<section id="id229">
<h5>Eccezione<a class="headerlink" href="#id229" title="Link to this heading">¶</a></h5>
<p>Se il parametro «si-sposterà-da» è uno <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> seguire <a class="reference internal" href="#Rr-sharedptrparam-owner"><span class="xref myst">R.34</span></a> e passare <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> per valore.</p>
</section>
<section id="id230">
<h5>Imposizione<a class="headerlink" href="#id230" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare tutti i parametri <code class="docutils literal notranslate"><span class="pre">X&amp;&amp;</span></code> (dove <code class="docutils literal notranslate"><span class="pre">X</span></code> non è il nome di un parametro di tipo template) dove il corpo della funzione li usa senza <code class="docutils literal notranslate"><span class="pre">std::move</span></code>.</p></li>
<li><p>Segnalare l’accesso a oggetti spostati [moved-from].</p></li>
<li><p>Non spostare condizionalmente oggetti</p></li>
</ul>
</section>
</section>
<section id="f-19-for-forward-parameters-pass-by-tp-and-only-std-forward-the-parameter">
<h4><a name="Rf-forward"></a>F.19: Per i parametri «forward», si passano per <code class="docutils literal notranslate"><span class="pre">TP&amp;&amp;</span></code> e si esegue <code class="docutils literal notranslate"><span class="pre">std::forward</span></code> solo per il parametro<a class="headerlink" href="#f-19-for-forward-parameters-pass-by-tp-and-only-std-forward-the-parameter" title="Link to this heading">¶</a></h4>
<section id="id231">
<h5>Motivo<a class="headerlink" href="#id231" title="Link to this heading">¶</a></h5>
<p>Se l’oggetto deve essere passato ad altro codice e non direttamente usato da questa funzione, si vuol rendere questa funzione agnostica rispetto all’argomento <code class="docutils literal notranslate"><span class="pre">const</span></code> e rvalue.</p>
<p>In quel caso, e solo in quel caso, si rende il parametro <code class="docutils literal notranslate"><span class="pre">TP&amp;&amp;</span></code> dove <code class="docutils literal notranslate"><span class="pre">TP</span></code> è un parametro di tipo template – esso contemporaneamente <em>ignora</em> e <em>preserva</em> l’essere <code class="docutils literal notranslate"><span class="pre">const</span></code> e rvalue. Pertanto, qualsiasi codice che utilizza un <code class="docutils literal notranslate"><span class="pre">TP&amp;&amp;</span></code> dichiara implicitamente non prende in considerazione che le variabili siano <code class="docutils literal notranslate"><span class="pre">const</span></code> o rvalue (perché lo ignora), ma che intende passare il valore ad un altro codice che si occuperà dell’essere <code class="docutils literal notranslate"><span class="pre">const</span></code> o rvalue (dato che è preservato). Se usato come parametro <code class="docutils literal notranslate"><span class="pre">TP&amp;&amp;</span></code> è sicuro perché qualsiasi oggetto temporaneo passato dal chiamante vivrà per tutta la durata della chiamata alla funzione. Un parametro di tipo <code class="docutils literal notranslate"><span class="pre">TP&amp;&amp;</span></code> deve essenzialmente essere sempre inoltrato tramite  <code class="docutils literal notranslate"><span class="pre">std::forward</span></code> nel corpo della funzione.</p>
</section>
<section id="id232">
<h5>Esempio<a class="headerlink" href="#id232" title="Link to this heading">¶</a></h5>
<p>Di solito si inoltra l’intero parametro (o pacchetto di parametri, utilizzando <code class="docutils literal notranslate"><span class="pre">...</span></code>) esattamente una volta su ogni percorso di flusso di controllo statico:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class F, class... Args&gt;
inline decltype(auto) invoke(F&amp;&amp; f, Args&amp;&amp;... args)
{
    return forward&lt;F&gt;(f)(forward&lt;Args&gt;(args)...);
}
</pre></div>
</div>
</section>
<section id="id233">
<h5>Esempio<a class="headerlink" href="#id233" title="Link to this heading">¶</a></h5>
<p>A volte si può inoltrare [forward] un parametro composito a pezzi, un sotto-oggetto per volta per ogni percorso di flusso di controllo statico:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class PairLike&gt;
inline auto test(PairLike&amp;&amp; pairlike)
{
    // ...
    f1(some, args, and, forward&lt;PairLike&gt;(pairlike).first);           // forward .first
    f2(and, forward&lt;PairLike&gt;(pairlike).second, in, another, call);   // forward .second
}
</pre></div>
</div>
</section>
<section id="id234">
<h5>Imposizione<a class="headerlink" href="#id234" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Si segnala una funzione che prende un parametro <code class="docutils literal notranslate"><span class="pre">TP&amp;&amp;</span></code> (dove <code class="docutils literal notranslate"><span class="pre">TP</span></code> è il nome di un parametro di tipo template) e ci fa qualsiasi cosa che non sia <code class="docutils literal notranslate"><span class="pre">std::forward</span></code> esattamente una sola volta su ogni percorso statico, o <code class="docutils literal notranslate"><span class="pre">std::forward</span></code> inviandolo più di una volta ma qualificato con un membro dati diverso esattamente una volta su ciascun percorso statico.</p></li>
</ul>
</section>
</section>
<section id="f-20-for-out-output-values-prefer-return-values-to-output-parameters">
<h4><a name="Rf-out"></a>F.20: Per i valori «out», preferire i valori di ritorno ai parametri di output<a class="headerlink" href="#f-20-for-out-output-values-prefer-return-values-to-output-parameters" title="Link to this heading">¶</a></h4>
<section id="id235">
<h5>Motivo<a class="headerlink" href="#id235" title="Link to this heading">¶</a></h5>
<p>Un valore restituito è auto-documentante, mentre un <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> potrebbe essere sia in-out che solo-out e potrebbe essere usato erroneamente.</p>
<p>Ciò include anche grandi oggetti come i contenitori standard che usano operazioni implicite di spostamento [move] per una questione di prestazioni e per evitare una esplicita gestione della memoria.</p>
<p>Se ci sono più valori da restituire, si <a class="reference internal" href="#Rf-out-multi"><span class="xref myst">usa una tuple</span></a> o un simile tipo multi-membro.</p>
</section>
<section id="id236">
<h5>Esempio<a class="headerlink" href="#id236" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// OK: return pointers to elements with the value x
vector&lt;const int*&gt; find_all(const vector&lt;int&gt;&amp;, int x);

// Bad: place pointers to elements with value x in-out
void find_all(const vector&lt;int&gt;&amp;, vector&lt;const int*&gt;&amp; out, int x);
</pre></div>
</div>
</section>
<section id="id237">
<h5>Nota<a class="headerlink" href="#id237" title="Link to this heading">¶</a></h5>
<p>Una <code class="docutils literal notranslate"><span class="pre">struct</span></code> di molti (singolarmente economici per il move) elementi potrebbe risultare costosa per il move.</p>
</section>
<section id="exceptions">
<h5>Eccezioni<a class="headerlink" href="#exceptions" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Per i tipi «non-concreti», come quelli in una gerarchia di ereditarietà, si restituisce un oggetto con <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> o con <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>.</p></li>
<li><p>Se un tipo è costoso da spostare (p.es., <code class="docutils literal notranslate"><span class="pre">array&lt;BigTrivial&gt;</span></code>), si consideri di allocarlo nel [free store] e restituirne un handle (p.es., <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code>), o passandolo in un riferimento ad un oggetto destinazione non-<code class="docutils literal notranslate"><span class="pre">const</span></code> da riempire (da usarsi come parametro di uscita).</p></li>
<li><p>Per riutilizzare un oggetto che porta il suo contenuto (p.es., <code class="docutils literal notranslate"><span class="pre">std::string</span></code>, <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>) attraverso più chiamate alla funzione in un loop interno: lo si <a class="reference internal" href="#Rf-out-multi"><span class="xref myst">tratta come un parametro in/out e lo si passa per riferimento</span></a>.</p></li>
</ul>
</section>
<section id="id238">
<h5>Esempio<a class="headerlink" href="#id238" title="Link to this heading">¶</a></h5>
<p>Supponendo che <code class="docutils literal notranslate"><span class="pre">Matrix</span></code> abbia le operazioni move (probabilmente mantenendo i suoi elementi in un <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Matrix operator+(const Matrix&amp; a, const Matrix&amp; b)
{
    Matrix res;
    // ... fill res with the sum ...
    return res;
}

Matrix x = m1 + m2;  // move constructor

y = m3 + m3;         // move assignment
</pre></div>
</div>
</section>
<section id="id239">
<h5>Nota<a class="headerlink" href="#id239" title="Link to this heading">¶</a></h5>
<p>L’ottimizzazione del valore di ritorno non gestisce il caso dell’assegnazione, ma l’assegnazione move lo fa.</p>
</section>
<section id="id240">
<h5>Esempio<a class="headerlink" href="#id240" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Package {      // exceptional case: expensive-to-move object
    char header[16];
    char load[2024 - 16];
};

Package fill();       // Bad: large return value
void fill(Package&amp;);  // OK

int val();            // OK
void val(int&amp;);       // Bad: Is val reading its argument
</pre></div>
</div>
</section>
<section id="id241">
<h5>Imposizione<a class="headerlink" href="#id241" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare il riferimento a parametri non-<code class="docutils literal notranslate"><span class="pre">const</span></code> che non vengono letti prima di essere scritti e sono di un tipo economico da restituire; questi dovrebbero essere valori di ritorno in «out».</p></li>
</ul>
</section>
</section>
<section id="f-21-to-return-multiple-out-values-prefer-returning-a-struct">
<h4><a name="Rf-out-multi"></a>F.21: Per il return di valori «out» multipli, preferire la restituzione di una struct<a class="headerlink" href="#f-21-to-return-multiple-out-values-prefer-returning-a-struct" title="Link to this heading">¶</a></h4>
<section id="id242">
<h5>Motivo<a class="headerlink" href="#id242" title="Link to this heading">¶</a></h5>
<p>Un valore di ritorno si auto-dichiara come valore «output-only». Si noti che il C++ ha valori multipli restituiti, per convenzione utilizzando tipi simili a tuple (<code class="docutils literal notranslate"><span class="pre">struct</span></code>, <code class="docutils literal notranslate"><span class="pre">array</span></code>, <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, ecc.), possibilmente con la comodità aggiuntiva dei [binding] strutturati (C++17) nel sito della chiamata. Se possibile, preferire l’uso di una <code class="docutils literal notranslate"><span class="pre">struct</span></code> con un nome. Altrimenti, è utile una <code class="docutils literal notranslate"><span class="pre">tuple</span></code> nei template variadici.</p>
</section>
<section id="id243">
<h5>Esempio<a class="headerlink" href="#id243" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// BAD: output-only parameter documented in a comment
int f(const string&amp; input, /*output only*/ string&amp; output_data)
{
    // ...
    output_data = something();
    return status;
}

// GOOD: self-documenting
struct f_result { int status; string data; };

f_result f(const string&amp; input)
{
    // ...
    return {status, something()};
}
</pre></div>
</div>
<p>La libreria standard di C++98 utilizzava questo stile in alcuni punti, restituendo <code class="docutils literal notranslate"><span class="pre">pair</span></code> [coppie] in alcune funzioni. Per esempio, dato un <code class="docutils literal notranslate"><span class="pre">set&lt;string&gt;</span> <span class="pre">my_set</span></code>, si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// C++98
pair&lt;set::iterator, bool&gt; result = my_set.insert(&quot;Hello&quot;);
if (result.second)
    do_something_with(result.first);    // workaround
</pre></div>
</div>
<p>Con C++17 siamo in grado di utilizzare «binding strutturati» per assegnare un nome a ciascun membro:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (auto [ iter, success ] = my_set.insert(&quot;Hello&quot;); success)
    do_something_with(iter);
</pre></div>
</div>
<p>Una <code class="docutils literal notranslate"><span class="pre">struct</span></code> con nomi significativi è più comune nel moderno C++. Vedere per esempio <code class="docutils literal notranslate"><span class="pre">ranges::min_max_result</span></code>, <code class="docutils literal notranslate"><span class="pre">from_chars_result</span></code>, e altri.</p>
</section>
<section id="id244">
<h5>Eccezione<a class="headerlink" href="#id244" title="Link to this heading">¶</a></h5>
<p>A volte c’è bisogno di passare un oggetto ad una funzione per modificarne lo stato. In questi casi, passare l’oggetto per riferimento <a class="reference internal" href="#Rf-inout"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">T&amp;</span></code></span></a> è solitamente la tecnica giusta. Restituire esplicitamente un parametro in-out  ancora come valore di ritorno spesso non è necessario. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>istream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s);    // much like std::operator&gt;&gt;()

for (string s; in &gt;&gt; s; ) {
    // do something with line
}
</pre></div>
</div>
<p>Qui, sia <code class="docutils literal notranslate"><span class="pre">s</span></code> che <code class="docutils literal notranslate"><span class="pre">in</span></code> vengono usati come parametri in-out. Si passa <code class="docutils literal notranslate"><span class="pre">in</span></code> per riferimento (non-<code class="docutils literal notranslate"><span class="pre">const</span></code>)  per essere in grado di modificarne lo stato. Si passa <code class="docutils literal notranslate"><span class="pre">s</span></code> per evitare ripetute allocazioni. Riutilizzando <code class="docutils literal notranslate"><span class="pre">s</span></code> (passato per riferimento), si alloca nuova memoria solo quando è necessario espandere la capacità di <code class="docutils literal notranslate"><span class="pre">s</span></code>. Questa tecnica è talvolta detta schema di «out allocato-dal-chiamante» ed è particolarmente utile per i tipi, come <code class="docutils literal notranslate"><span class="pre">string</span></code> e <code class="docutils literal notranslate"><span class="pre">vector</span></code>, che eseguono allocazioni nel [free store].</p>
<p>Per fare un confronto, se distribuissimo tutti i valori come valori di ritorno, scriveremmo qualcosa del genere:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct get_string_result { istream&amp; in; string s; };

get_string_result get_string(istream&amp; in)  // not recommended
{
    string s;
    in &gt;&gt; s;
    return { in, move(s) };
}

for (auto [in, s] = get_string(cin); in; s = get_string(in).s) {
    // do something with string
}
</pre></div>
</div>
<p>Si ritiene che sia notevolmente meno elegante e con prestazioni significativamente meno performanti.</p>
<p>Per una lettura veramente rigorosa di questa regola (F.21), l’eccezione non è realmente un’eccezione perché si basa su parametri in-out, anziché su parametri di out citati nella regola. Tuttavia, si preferisce essere espliciti, piuttosto che criptici.</p>
</section>
<section id="id245">
<h5>Nota<a class="headerlink" href="#id245" title="Link to this heading">¶</a></h5>
<p>Nella maggior parte dei casi, è utile restituire un tipo specifico, definito dall’utente. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Distance {
    int value;
    int unit = 1;   // 1 means meters
};

Distance d1 = measure(obj1);        // access d1.value and d1.unit
auto d2 = measure(obj2);            // access d2.value and d2.unit
auto [value, unit] = measure(obj3); // access value and unit; somewhat redundant
                                    // to people who know measure()
auto [x, y] = measure(obj4);        // don&#39;t; it&#39;s likely to be confusing
</pre></div>
</div>
<p>Le eccessivamente generiche <code class="docutils literal notranslate"><span class="pre">pair</span></code> e <code class="docutils literal notranslate"><span class="pre">tuple</span></code> dovrebbero essere utilizzate solo quando il valore restituito rappresenta entità indipendenti invece che un’astrazione.</p>
<p>Un’altra possibilità è quella di usare <code class="docutils literal notranslate"><span class="pre">optional&lt;T&gt;</span></code> o <code class="docutils literal notranslate"><span class="pre">expected&lt;T,</span> <span class="pre">error_code&gt;</span></code>, invece di <code class="docutils literal notranslate"><span class="pre">pair</span></code> e <code class="docutils literal notranslate"><span class="pre">tuple</span></code>. Se utilizzati in modo appropriato, questi tipi trasmettono più informazioni su cosa significano i membri rispetto a <code class="docutils literal notranslate"><span class="pre">pair&lt;T,</span> <span class="pre">bool&gt;</span></code> e a <code class="docutils literal notranslate"><span class="pre">pair&lt;T,</span> <span class="pre">error_code&gt;</span></code>.</p>
</section>
<section id="id246">
<h5>Nota<a class="headerlink" href="#id246" title="Link to this heading">¶</a></h5>
<p>Quando l’oggetto da restituire viene inizializzato da variabili locali che sono costose da copiare, un <code class="docutils literal notranslate"><span class="pre">move</span></code> esplicito può essere utile per evitare la copia:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pair&lt;LargeObject, LargeObject&gt; f(const string&amp; input)
{
    LargeObject large1 = g(input);
    LargeObject large2 = h(input);
    // ...
    return { move(large1), move(large2) }; // no copies
}
</pre></div>
</div>
<p>Alternativamente,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pair&lt;LargeObject, LargeObject&gt; f(const string&amp; input)
{
    // ...
    return { g(input), h(input) }; // no copies, no moves
}
</pre></div>
</div>
<p>Si noti che questo è diverso da <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">move(...)</span></code> dell’anti-pattern dall”<a class="reference internal" href="#Res-move"><span class="xref myst">ES.56</span></a></p>
</section>
<section id="id247">
<h5>Imposizione<a class="headerlink" href="#id247" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>I parametri di output devono essere sostituiti da valori di ritorno. Un parametro di output è quello in cui la funzione scrive, invoca una funzione membro non-<code class="docutils literal notranslate"><span class="pre">const</span></code> o lo passa come non-<code class="docutils literal notranslate"><span class="pre">const</span></code>.</p></li>
<li><p>I tipi restituiti <code class="docutils literal notranslate"><span class="pre">pair</span></code> e <code class="docutils literal notranslate"><span class="pre">tuple</span></code> dovrebbero essere sostituiti da <code class="docutils literal notranslate"><span class="pre">struct</span></code>, quando possibile. Nei template variadici, <code class="docutils literal notranslate"><span class="pre">tuple</span></code> è spesso inevitabile.</p></li>
</ul>
</section>
</section>
<section id="f-60-prefer-t-over-t-when-no-argument-is-a-valid-option">
<h4><a name="Rf-ptr-ref"></a>F.60: Preferire <code class="docutils literal notranslate"><span class="pre">T*</span></code> a <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> quando «nessun argomento» è una valida opzione<a class="headerlink" href="#f-60-prefer-t-over-t-when-no-argument-is-a-valid-option" title="Link to this heading">¶</a></h4>
<section id="id248">
<h5>Motivo<a class="headerlink" href="#id248" title="Link to this heading">¶</a></h5>
<p>Un puntatore (<code class="docutils literal notranslate"><span class="pre">T*</span></code>) può essere un <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> mentre un riferimento (<code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>) non può, non c’è nessun valido «riferimento null». A volte avere <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>, anziché indicare «nessun oggetto», è utile, ma in caso contrario, un riferimento è una notazione più semplice e può produrre un codice migliore.</p>
</section>
<section id="id249">
<h5>Esempio<a class="headerlink" href="#id249" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>string zstring_to_string(zstring p) // zstring is a char*; that is a C-style string
{
    if (!p) return string{};    // p might be nullptr; remember to check
    return string{p};
}

void print(const vector&lt;int&gt;&amp; r)
{
    // r refers to a vector&lt;int&gt;; no check needed
}
</pre></div>
</div>
</section>
<section id="id250">
<h5>Nota<a class="headerlink" href="#id250" title="Link to this heading">¶</a></h5>
<p>È possibile, ma non è un valido C++, costruire un riferimento che sia essenzialmente un <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> (p.es., <code class="docutils literal notranslate"><span class="pre">T*</span> <span class="pre">p</span> <span class="pre">=</span> <span class="pre">nullptr;</span> <span class="pre">T&amp;</span> <span class="pre">r</span> <span class="pre">=</span> <span class="pre">*p;</span></code>). Questo errore è molto raro.</p>
</section>
<section id="id251">
<h5>Nota<a class="headerlink" href="#id251" title="Link to this heading">¶</a></h5>
<p>Se si preferisce la notazione del puntatore (<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> e/o <code class="docutils literal notranslate"><span class="pre">*</span></code> rispetto a <code class="docutils literal notranslate"><span class="pre">.</span></code>), <code class="docutils literal notranslate"><span class="pre">not_null&lt;T*&gt;</span></code> fornisce le stesse garanzie di <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>.</p>
</section>
<section id="id252">
<h5>Imposizione<a class="headerlink" href="#id252" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare ???</p></li>
</ul>
</section>
</section>
<section id="f-22-use-t-or-owner-t-to-designate-a-single-object">
<h4><a name="Rf-ptr"></a>F.22: Utilizzare <code class="docutils literal notranslate"><span class="pre">T*</span></code> o <code class="docutils literal notranslate"><span class="pre">owner&lt;T*&gt;</span></code> per designare un singolo oggetto<a class="headerlink" href="#f-22-use-t-or-owner-t-to-designate-a-single-object" title="Link to this heading">¶</a></h4>
<section id="id253">
<h5>Motivo<a class="headerlink" href="#id253" title="Link to this heading">¶</a></h5>
<p>Leggibilità: chiarisce il significato di un semplice puntatore. Consente un significativo supporto di tool.</p>
</section>
<section id="id254">
<h5>Nota<a class="headerlink" href="#id254" title="Link to this heading">¶</a></h5>
<p>Nel tradizionale codice C e C++, si usa un semplice <code class="docutils literal notranslate"><span class="pre">T*</span></code> per molti scopi e molto diversi, come:</p>
<ul class="simple">
<li><p>Identificare un (singolo) oggetto (da non cancellare in questa funzione)</p></li>
<li><p>Puntare ad un oggetto allocato nel [free store] (e cancellarlo in seguito)</p></li>
<li><p>Contenere il <code class="docutils literal notranslate"><span class="pre">nullptr</span></code></p></li>
<li><p>Identificare una stringa C-style (array di caratteri “zero-terminated”)</p></li>
<li><p>Identificare un array con una lunghezza specificata separatamente</p></li>
<li><p>Identificare una posizione in un array</p></li>
</ul>
<p>Questo rende difficile capire cosa fa il codice e cosa dovrebbe fare. Complica il controllo e il supporto dei tool.</p>
</section>
<section id="id255">
<h5>Esempio<a class="headerlink" href="#id255" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use(int* p, int n, char* s, int* q)
{
    p[n - 1] = 666; // Bad: we don&#39;t know if p points to n elements;
                    // assume it does not or use span&lt;int&gt;
    cout &lt;&lt; s;      // Bad: we don&#39;t know if that s points to a zero-terminated array of char;
                    // assume it does not or use zstring
    delete q;       // Bad: we don&#39;t know if *q is allocated on the free store;
                    // assume it does not or use owner
}
</pre></div>
</div>
<p>Meglio</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use2(span&lt;int&gt; p, zstring s, owner&lt;int*&gt; q)
{
    p[p.size() - 1] = 666; // OK, a range error can be caught
    cout &lt;&lt; s; // OK
    delete q;  // OK
}
</pre></div>
</div>
</section>
<section id="id256">
<h5>Nota<a class="headerlink" href="#id256" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">owner&lt;T*&gt;</span></code> rappresenta la proprietà [ownership], <code class="docutils literal notranslate"><span class="pre">zstring</span></code> rappresenta una stringa C-style.</p>
<p><strong>Inoltre</strong>: Si suppone che un <code class="docutils literal notranslate"><span class="pre">T*</span></code> ottenuto da uno smart pointer a <code class="docutils literal notranslate"><span class="pre">T</span></code> (p.es., <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;T&gt;</span></code>) punti ad un singolo elemento.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#gsl-guidelines-support-library"><span class="xref myst">Support library</span></a></p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Ri-array"><span class="xref myst">Non passare un array come singolo puntatore</span></a></p>
</section>
<section id="id257">
<h5>Imposizione<a class="headerlink" href="#id257" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Semplice) ((Bounds)) Segnalare un warning per ogni operazione aritmetica o espressione di tipo puntatore che risulti nel valore di un tipo puntatore.</p></li>
</ul>
</section>
</section>
<section id="f-23-use-a-not-null-t-to-indicate-that-null-is-not-a-valid-value">
<h4><a name="Rf-nullptr"></a>F.23: Utilizzare <code class="docutils literal notranslate"><span class="pre">not_null&lt;T&gt;</span></code> per indicare che «null» non è un valore valido<a class="headerlink" href="#f-23-use-a-not-null-t-to-indicate-that-null-is-not-a-valid-value" title="Link to this heading">¶</a></h4>
<section id="id258">
<h5>Motivo<a class="headerlink" href="#id258" title="Link to this heading">¶</a></h5>
<p>Chiarezza. Una funzione con un parametro <code class="docutils literal notranslate"><span class="pre">not_null&lt;T&gt;</span></code> chiarisce che il chiamante della funzione è responsabile di tutti i controlli <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> che potrebbero essere necessari. Allo stesso modo, una funzione con un valore di ritorno <code class="docutils literal notranslate"><span class="pre">not_null&lt;T&gt;</span></code> chiarisce che il chiamante della funzione non deve controllare per <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</p>
</section>
<section id="id259">
<h5>Esempio<a class="headerlink" href="#id259" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">not_null&lt;T*&gt;</span></code> rende ovvio ad un lettore (umano o una macchina) che un test per <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> non è necessario prima di dereferenziare. Inoltre, durante il debug, <code class="docutils literal notranslate"><span class="pre">owner&lt;T*&gt;</span></code> e <code class="docutils literal notranslate"><span class="pre">not_null&lt;T&gt;</span></code> si possono automatizzare per il controllo della correttezza.</p>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int length(Record* p);
</pre></div>
</div>
<p>Quando si chiama <code class="docutils literal notranslate"><span class="pre">length(p)</span></code> si deve prima verificare se <code class="docutils literal notranslate"><span class="pre">p</span></code> sia <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>? L’implementazione di <code class="docutils literal notranslate"><span class="pre">length()</span></code> dovrebbe verificare se <code class="docutils literal notranslate"><span class="pre">p</span></code> è <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>?</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// it is the caller&#39;s job to make sure p != nullptr
int length(not_null&lt;Record*&gt; p);

// the implementor of length() must assume that p == nullptr is possible
int length(Record* p);
</pre></div>
</div>
</section>
<section id="id260">
<h5>Nota<a class="headerlink" href="#id260" title="Link to this heading">¶</a></h5>
<p>Si presume che un <code class="docutils literal notranslate"><span class="pre">not_null&lt;T*&gt;</span></code> non sia <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>; un <code class="docutils literal notranslate"><span class="pre">T*</span></code> potrebbe essere il <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>; entrambi si possono rappresentare in memoria come un <code class="docutils literal notranslate"><span class="pre">T*</span></code> (quindi non è implicito alcun overhead a run-time).</p>
</section>
<section id="id261">
<h5>Nota<a class="headerlink" href="#id261" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">not_null</span></code> non è solo per i puntatori nativi [built-in]. Funziona con <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code>, <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>, ed altri tipi di puntatori.</p>
</section>
<section id="id262">
<h5>Imposizione<a class="headerlink" href="#id262" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Semplice) Emette un warning se un puntatore semplice [raw] viene de-referenziato senza essere testato contro i <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> (o equivalente) in una funzione, suggerendo che, invece, sia dichiarato <code class="docutils literal notranslate"><span class="pre">not_null</span></code>.</p></li>
<li><p>(Semplice) Solleva un errore se un puntatore [raw] viene a volte dereferenziato dopo un test per <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> (o equivalente) in una funzione e talvolta non lo è.</p></li>
<li><p>(Semplice) Emette un warning se un puntatore <code class="docutils literal notranslate"><span class="pre">not_null</span></code> viene testato per <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> in una funzione.</p></li>
</ul>
</section>
</section>
<section id="f-24-use-a-span-t-or-a-span-p-t-to-designate-a-half-open-sequence">
<h4><a name="Rf-range"></a>F.24: Utilizzare <code class="docutils literal notranslate"><span class="pre">span&lt;T&gt;</span></code> o <code class="docutils literal notranslate"><span class="pre">span_p&lt;T&gt;</span></code> per indicare una sequenza semiaperta<a class="headerlink" href="#f-24-use-a-span-t-or-a-span-p-t-to-designate-a-half-open-sequence" title="Link to this heading">¶</a></h4>
<section id="id263">
<h5>Motivo<a class="headerlink" href="#id263" title="Link to this heading">¶</a></h5>
<p>Intervalli informali/non-espliciti sono fonte di errori.</p>
</section>
<section id="id264">
<h5>Esempio<a class="headerlink" href="#id264" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X* find(span&lt;X&gt; r, const X&amp; v);    // find v in r

vector&lt;X&gt; vec;
// ...
auto p = find({vec.begin(), vec.end()}, X{});  // find X{} in vec
</pre></div>
</div>
</section>
<section id="id265">
<h5>Nota<a class="headerlink" href="#id265" title="Link to this heading">¶</a></h5>
<p>Gli intervalli sono estremamente comuni nel codice C++. In genere, sono impliciti e il loro corretto utilizzo è molto difficile da garantire. In particolare, data una coppia di argomenti <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">n)</span></code> che designa un array <code class="docutils literal notranslate"><span class="pre">[p:p+n)</span></code>, è generalmente impossibile sapere se ci sono davvero <code class="docutils literal notranslate"><span class="pre">n</span></code> elementi a cui accedere dopo <code class="docutils literal notranslate"><span class="pre">*p</span></code>. <code class="docutils literal notranslate"><span class="pre">span&lt;T&gt;</span></code> e <code class="docutils literal notranslate"><span class="pre">span_p&lt;T&gt;</span></code> sono semplici classi di supporto [helper] che designano, rispettivamente, un intervallo [range] <code class="docutils literal notranslate"><span class="pre">[p:q)</span></code> e un intervallo che inizia con <code class="docutils literal notranslate"><span class="pre">p</span></code> e termina con il primo elemento per cui un predicato è vero.</p>
</section>
<section id="id266">
<h5>Esempio<a class="headerlink" href="#id266" title="Link to this heading">¶</a></h5>
<p>Uno <code class="docutils literal notranslate"><span class="pre">span</span></code> rappresenta un intervallo di elementi, ma come si possono manipolare gli elementi di quell’intervallo?</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(span&lt;int&gt; s)
{
    // range traversal (guaranteed correct)
    for (int x : s) cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;

    // C-style traversal (potentially checked)
    for (gsl::index i = 0; i &lt; s.size(); ++i) cout &lt;&lt; s[i] &lt;&lt; &#39;\n&#39;;

    // random access (potentially checked)
    s[7] = 9;

    // extract pointers (potentially checked)
    std::sort(&amp;s[0], &amp;s[s.size() / 2]);
}
</pre></div>
</div>
</section>
<section id="id267">
<h5>Nota<a class="headerlink" href="#id267" title="Link to this heading">¶</a></h5>
<p>Un oggetto <code class="docutils literal notranslate"><span class="pre">span&lt;T&gt;</span></code> non possiede i suoi elementi ed è così piccolo che si può passare per valore.</p>
<p>Passare un oggetto <code class="docutils literal notranslate"><span class="pre">span</span></code> come argomento è esattamente tanto efficiente quanto passare, come argomenti, una coppia di puntatori o passare un puntatore ed un contatore intero.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#gsl-guidelines-support-library"><span class="xref myst">Support library</span></a></p>
</section>
<section id="id268">
<h5>Imposizione<a class="headerlink" href="#id268" title="Link to this heading">¶</a></h5>
<p>(Complicato) Sollevare un warning dove gli accessi ai parametri puntatore sono limitati da altri parametri che siano di tipo intero e suggerire che si dovrebbe, invece, usare <code class="docutils literal notranslate"><span class="pre">span</span></code>.</p>
</section>
</section>
<section id="f-25-use-a-zstring-or-a-not-null-zstring-to-designate-a-c-style-string">
<h4><a name="Rf-zstring"></a>F.25: Utilizzare <code class="docutils literal notranslate"><span class="pre">zstring</span></code> o <code class="docutils literal notranslate"><span class="pre">not_null&lt;zstring&gt;</span></code> per indicare una stringa C-style<a class="headerlink" href="#f-25-use-a-zstring-or-a-not-null-zstring-to-designate-a-c-style-string" title="Link to this heading">¶</a></h4>
<section id="id269">
<h5>Motivo<a class="headerlink" href="#id269" title="Link to this heading">¶</a></h5>
<p>Le stringhe in stile C sono onnipresenti. Sono definite per convenzione: array di caratteri terminate con zero. Si deve far distinzione tra le stringhe C-style e i puntatori ad un singolo carattere o i puntatori vecchio stile ad un array di caratteri.</p>
<p>Se non c’è bisogno della terminazione null, si usa <code class="docutils literal notranslate"><span class="pre">string_view</span></code>.</p>
</section>
<section id="id270">
<h5>Esempio<a class="headerlink" href="#id270" title="Link to this heading">¶</a></h5>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int length(const char* p);
</pre></div>
</div>
<p>Quando si chiama <code class="docutils literal notranslate"><span class="pre">length(s)</span></code> si deve controllare prima se <code class="docutils literal notranslate"><span class="pre">s</span></code> è <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>? L’implementazione di <code class="docutils literal notranslate"><span class="pre">length()</span></code> dovrebbe verificare se <code class="docutils literal notranslate"><span class="pre">p</span></code> è <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>?</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// the implementor of length() must assume that p == nullptr is possible
int length(zstring p);

// it is the caller&#39;s job to make sure p != nullptr
int length(not_null&lt;zstring&gt; p);
</pre></div>
</div>
</section>
<section id="id271">
<h5>Nota<a class="headerlink" href="#id271" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">zstring</span></code> non rappresenta la proprietà [ownership].</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#gsl-guidelines-support-library"><span class="xref myst">Support library</span></a></p>
</section>
</section>
<section id="f-26-use-a-unique-ptr-t-to-transfer-ownership-where-a-pointer-is-needed">
<h4><a name="Rf-unique_ptr"></a>F.26: Utilizzare <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;T&gt;</span></code> per trasferire l’ownership dove è necessario un puntatore<a class="headerlink" href="#f-26-use-a-unique-ptr-t-to-transfer-ownership-where-a-pointer-is-needed" title="Link to this heading">¶</a></h4>
<section id="id272">
<h5>Motivo<a class="headerlink" href="#id272" title="Link to this heading">¶</a></h5>
<p>L’uso di <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> è il modo più economico per passare un puntatore in modo sicuro.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Rc-factory"><span class="xref myst">C.50</span></a> a proposito di quando restituire uno <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> da una factory.</p>
</section>
<section id="id273">
<h5>Esempio<a class="headerlink" href="#id273" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unique_ptr&lt;Shape&gt; get_shape(istream&amp; is)  // assemble shape from input stream
{
    auto kind = read_header(is); // read header and identify the next shape on input
    switch (kind) {
    case kCircle:
        return make_unique&lt;Circle&gt;(is);
    case kTriangle:
        return make_unique&lt;Triangle&gt;(is);
    // ...
    }
}
</pre></div>
</div>
</section>
<section id="id274">
<h5>Nota<a class="headerlink" href="#id274" title="Link to this heading">¶</a></h5>
<p>Bisogna passare un puntatore anziché un oggetto se quello che si sta trasferendo è un oggetto di una gerarchia di classi che deve essere usato attraverso un’interfaccia (classe base).</p>
</section>
<section id="id275">
<h5>Imposizione<a class="headerlink" href="#id275" title="Link to this heading">¶</a></h5>
<p>(Semplice) Solleva un warning se una funzione restituisce un semplice puntatore allocato localmente. Suggerire, invece, di usare o <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> o <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> instead.</p>
</section>
</section>
<section id="f-27-use-a-shared-ptr-t-to-share-ownership">
<h4><a name="Rf-shared_ptr"></a>F.27: Utilizzare <code class="docutils literal notranslate"><span class="pre">shared_ptr&lt;T&gt;</span></code> per condividere l’ownership<a class="headerlink" href="#f-27-use-a-shared-ptr-t-to-share-ownership" title="Link to this heading">¶</a></h4>
<section id="id276">
<h5>Motivo<a class="headerlink" href="#id276" title="Link to this heading">¶</a></h5>
<p>L’uso dello <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code> è il modo standard per rappresentare la proprietà [ownership] condivisa. Ovvero, l’ultimo proprietario cancella l’oggetto.</p>
</section>
<section id="id277">
<h5>Esempio<a class="headerlink" href="#id277" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    shared_ptr&lt;const Image&gt; im { read_image(somewhere) };

    std::thread t0 {shade, args0, top_left, im};
    std::thread t1 {shade, args1, top_right, im};
    std::thread t2 {shade, args2, bottom_left, im};
    std::thread t3 {shade, args3, bottom_right, im};

    // detaching threads requires extra care (e.g., to join before
    // main ends), but even if we do detach the four threads here ...
}
// ... shared_ptr ensures that eventually the last thread to
//     finish safely deletes the image
</pre></div>
</div>
</section>
<section id="id278">
<h5>Nota<a class="headerlink" href="#id278" title="Link to this heading">¶</a></h5>
<p>Preferire un <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> rispetto a uno <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> se non c’è mai più di un solo proprietario per volta. <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> è per la proprietà condivisa [shared].</p>
<p>Si noti che l’uso pervasivo di <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> ha un costo (le operazioni atomiche sul contatore dei riferimenti dello <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> hanno un costo globale misurabile).</p>
</section>
<section id="id279">
<h5>Alternativa<a class="headerlink" href="#id279" title="Link to this heading">¶</a></h5>
<p>Avere un solo oggetto proprietario dell’oggetto condiviso (p.es. un oggetto in uno scope) e distruggerlo (preferibilmente implicitamente) quando tutte le utenze sono completate.</p>
</section>
<section id="id280">
<h5>Imposizione<a class="headerlink" href="#id280" title="Link to this heading">¶</a></h5>
<p>(Non imponibile) Questo è un pattern troppo complesso per essere rilevato affidabilmente.</p>
</section>
</section>
<section id="f-42-return-a-t-to-indicate-a-position-only">
<h4><a name="Rf-return-ptr"></a>F.42: Restituire <code class="docutils literal notranslate"><span class="pre">T*</span></code> per indicare (solo) una posizione<a class="headerlink" href="#f-42-return-a-t-to-indicate-a-position-only" title="Link to this heading">¶</a></h4>
<section id="id281">
<h5>Motivo<a class="headerlink" href="#id281" title="Link to this heading">¶</a></h5>
<p>Ecco a cosa servono i puntatori. Restituire un <code class="docutils literal notranslate"><span class="pre">T*</span></code> per trasferire la proprietà è un uso improprio.</p>
</section>
<section id="id282">
<h5>Esempio<a class="headerlink" href="#id282" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Node* find(Node* t, const string&amp; s)  // find s in a binary tree of Nodes
{
    if (!t || t-&gt;name == s) return t;
    if ((auto p = find(t-&gt;left, s))) return p;
    if ((auto p = find(t-&gt;right, s))) return p;
    return nullptr;
}
</pre></div>
</div>
<p>Se non è <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>, il puntatore restituito da <code class="docutils literal notranslate"><span class="pre">find</span></code> indica un <code class="docutils literal notranslate"><span class="pre">Node</span></code> contenente <code class="docutils literal notranslate"><span class="pre">s</span></code>. È importante sottolineare che ciò non implica un trasferimento della proprietà dell’oggetto puntato al chiamante.</p>
</section>
<section id="id283">
<h5>Nota<a class="headerlink" href="#id283" title="Link to this heading">¶</a></h5>
<p>Le posizioni possono anche essere trasferite da iteratori, indici e riferimenti. Un riferimento è spesso un’alternativa superiore ad un puntatore <a class="reference internal" href="#Rf-ptr-ref"><span class="xref myst">se non c’è bisogno di usare <code class="docutils literal notranslate"><span class="pre">nullptr</span></code></span></a> o <a class="reference internal" href="#S-const"><span class="xref myst">se l’oggetto a cui si fa riferimento non deve cambiare</span></a>.</p>
</section>
<section id="id284">
<h5>Nota<a class="headerlink" href="#id284" title="Link to this heading">¶</a></h5>
<p>Non restituire un puntatore a qualcosa che non rientra nello scope del chiamante; cfr. <a class="reference internal" href="#Rf-dangle"><span class="xref myst">F.43</span></a>.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#???"><span class="xref myst">discussione sulla prevenzione dei puntatori “appesi” [dangling]</span></a></p>
</section>
<section id="id285">
<h5>Imposizione<a class="headerlink" href="#id285" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare i <code class="docutils literal notranslate"><span class="pre">delete</span></code>, <code class="docutils literal notranslate"><span class="pre">std::free()</span></code>, ecc. applicati a un semplice <code class="docutils literal notranslate"><span class="pre">T*</span></code>. Solo i proprietari [owner] possono cancellare.</p></li>
<li><p>Segnalare i <code class="docutils literal notranslate"><span class="pre">new</span></code>, <code class="docutils literal notranslate"><span class="pre">malloc()</span></code>, ecc. assegnati a semplici <code class="docutils literal notranslate"><span class="pre">T*</span></code>. Solo i proprietari dovrebbero essere responsabili della cancellazione.</p></li>
</ul>
</section>
</section>
<section id="f-43-never-directly-or-indirectly-return-a-pointer-or-a-reference-to-a-local-object">
<h4><a name="Rf-dangle"></a>F.43: Mai (direttamente o indirettamente) restituire un puntatore o un riferimento ad un oggetto locale<a class="headerlink" href="#f-43-never-directly-or-indirectly-return-a-pointer-or-a-reference-to-a-local-object" title="Link to this heading">¶</a></h4>
<section id="id286">
<h5>Motivo<a class="headerlink" href="#id286" title="Link to this heading">¶</a></h5>
<p>Per evitare i crash e la corruzione dei dati che avviene a causa dei puntatori “appesi” [dangling].</p>
</section>
<section id="id287">
<h5>Esempio, cattivo<a class="headerlink" href="#id287" title="Link to this heading">¶</a></h5>
<p>All’uscita da una funzione i suoi oggetti locali non esistono più:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int* f()
{
    int fx = 9;
    return &amp;fx;  // BAD
}

void g(int* p)   // looks innocent enough
{
    int gx;
    cout &lt;&lt; &quot;*p == &quot; &lt;&lt; *p &lt;&lt; &#39;\n&#39;;
    *p = 999;
    cout &lt;&lt; &quot;gx == &quot; &lt;&lt; gx &lt;&lt; &#39;\n&#39;;
}

void h()
{
    int* p = f();
    int z = *p;  // read from abandoned stack frame (bad)
    g(p);        // pass pointer to abandoned stack frame to function (bad)
}
</pre></div>
</div>
<p>Qui su una popolare implementazione si ottiene l’output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*p == 999
gx == 999
</pre></div>
</div>
<p>C’era da aspettarselo in quanto la chiamata a <code class="docutils literal notranslate"><span class="pre">g()</span></code> riutilizza lo spazio abbandonato dello stack della chiamata a <code class="docutils literal notranslate"><span class="pre">f()</span></code> quindi <code class="docutils literal notranslate"><span class="pre">*p</span></code> fa riferimento ad uno spazio occupato, ora, da <code class="docutils literal notranslate"><span class="pre">gx</span></code>.</p>
<ul class="simple">
<li><p>Si immagini cosa accadrebbe se <code class="docutils literal notranslate"><span class="pre">fx</span></code> e <code class="docutils literal notranslate"><span class="pre">gx</span></code> fossero di tipi diversi.</p></li>
<li><p>Si immagini cosa accadrebbe se <code class="docutils literal notranslate"><span class="pre">fx</span></code> e <code class="docutils literal notranslate"><span class="pre">gx</span></code> fossero di un tipo con un invariante.</p></li>
<li><p>Si immagini cosa accadrebbe se si passassero più puntatori “appesi” [dangling] in un gruppo più esteso di funzioni.</p></li>
<li><p>Si immagini cosa potrebbe fare un cracker con quel puntatore “appeso” [dangling].</p></li>
</ul>
<p>Fortunatamente, la maggior parte (tutti?) i moderni compilatori intercettano ed avvisano se capita questo semplice caso.</p>
</section>
<section id="id288">
<h5>Nota<a class="headerlink" href="#id288" title="Link to this heading">¶</a></h5>
<p>Questo vale anche per i riferimenti:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int&amp; f()
{
    int x = 7;
    // ...
    return x;  // Bad: returns reference to object that is about to be destroyed
}
</pre></div>
</div>
</section>
<section id="id289">
<h5>Nota<a class="headerlink" href="#id289" title="Link to this heading">¶</a></h5>
<p>Questo vale solo per le variabili locali non-<code class="docutils literal notranslate"><span class="pre">static</span></code>. Tutte le variabili <code class="docutils literal notranslate"><span class="pre">static</span></code> sono (come indica il nome) allocate staticamente, quindi i puntatori ad esse non possono essere “appesi”.</p>
</section>
<section id="id290">
<h5>Esempio, cattivo<a class="headerlink" href="#id290" title="Link to this heading">¶</a></h5>
<p>Non tutti gli esempi di perdita [leaking] di un puntatore ad una variabile locale sono così ovvi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int* glob;       // global variables are bad in so many ways

template&lt;class T&gt;
void steal(T x)
{
    glob = x();  // BAD
}

void f()
{
    int i = 99;
    steal([&amp;] { return &amp;i; });
}

int main()
{
    f();
    cout &lt;&lt; *glob &lt;&lt; &#39;\n&#39;;
}
</pre></div>
</div>
<p>Qui si riesce a leggere la locazione abbandonata dalla chiamata a <code class="docutils literal notranslate"><span class="pre">f</span></code>. Il puntatore memorizzato in <code class="docutils literal notranslate"><span class="pre">glob</span></code> potrebbe essere utilizzato molto più tardi provocando problemi imprevedibili.</p>
</section>
<section id="id291">
<h5>Nota<a class="headerlink" href="#id291" title="Link to this heading">¶</a></h5>
<p>L’indirizzo di una variabile locale si può «restituire»/persa: con un comando return, con un parametro di out <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>, come membro di un oggetto restituito, come elemento di un array restituito ed in altri modi.</p>
</section>
<section id="id292">
<h5>Nota<a class="headerlink" href="#id292" title="Link to this heading">¶</a></h5>
<p>Esempi simili si possono costruire «appendendo» [leaking] un puntatore da uno scope più interno verso uno più esterno; tali esempi vengono gestiti in modo equivalente ai [leak] dei puntatori uscendo da una funzione.</p>
<p>Una variante leggermente diversa del problema consiste nel piazzare i puntatori in un contenitore che sopravvive agli oggetti a cui punta.</p>
<p><strong>Si veda anche</strong>: Un altro modo per ottenere puntatori appesi [dangling] è l”<a class="reference internal" href="#???"><span class="xref myst">invalidazione del puntatore</span></a>. Si può rilevare/prevenire con tecniche simili.</p>
</section>
<section id="id293">
<h5>Imposizione<a class="headerlink" href="#id293" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>I compilatori tendono ad intercettare il return di un riferimento ad un valore locale e in molti casi anche il rilevamento di puntatori a valori locali.</p></li>
<li><p>L’analisi statica può rilevare molti pattern comuni sull’uso dei puntatori che si riferiscono a delle posizioni (eliminando, quindi, i puntatori appesi [dangling])</p></li>
</ul>
</section>
</section>
<section id="f-44-return-a-t-when-copy-is-undesirable-and-returning-no-object-isn-t-needed">
<h4><a name="Rf-return-ref"></a>F.44: Restituire <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> quando la copia è indesiderabile e non è necessario «restituire nessun oggetto»<a class="headerlink" href="#f-44-return-a-t-when-copy-is-undesirable-and-returning-no-object-isn-t-needed" title="Link to this heading">¶</a></h4>
<section id="id294">
<h5>Motivo<a class="headerlink" href="#id294" title="Link to this heading">¶</a></h5>
<p>Il linguaggio garantisce che un <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> faccia riferimento ad un oggetto, quindi non è necessario il test per il <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</p>
<p><strong>Si veda anche</strong>: La restituzione di un riferimento non implica il trasferimento della proprietà: <a class="reference internal" href="#???"><span class="xref myst">discussione sulla prevenzione dei puntatori “appesi” [dangling]</span></a> e <a class="reference internal" href="#???"><span class="xref myst">discussione sulla proprietà [ownership]</span></a>.</p>
</section>
<section id="id295">
<h5>Esempio<a class="headerlink" href="#id295" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Car
{
    array&lt;wheel, 4&gt; w;
    // ...
public:
    wheel&amp; get_wheel(int i) { Expects(i &lt; w.size()); return w[i]; }
    // ...
};

void use()
{
    Car c;
    wheel&amp; w0 = c.get_wheel(0); // w0 has the same lifetime as c
}
</pre></div>
</div>
</section>
<section id="id296">
<h5>Imposizione<a class="headerlink" href="#id296" title="Link to this heading">¶</a></h5>
<p>Si evidenziano le funzioni dove nessuna espressione <code class="docutils literal notranslate"><span class="pre">return</span></code> potrebbe restituire <code class="docutils literal notranslate"><span class="pre">nullptr</span></code></p>
</section>
</section>
<section id="f-45-don-t-return-a-t">
<h4><a name="Rf-return-ref-ref"></a>F.45: Non restituire un <code class="docutils literal notranslate"><span class="pre">T&amp;&amp;</span></code><a class="headerlink" href="#f-45-don-t-return-a-t" title="Link to this heading">¶</a></h4>
<section id="id297">
<h5>Motivo<a class="headerlink" href="#id297" title="Link to this heading">¶</a></h5>
<p>Si sta chiedendo di restituire un riferimento a un oggetto temporaneo distrutto. Un <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> è una calamita per gli oggetti temporanei.</p>
</section>
<section id="id298">
<h5>Esempio<a class="headerlink" href="#id298" title="Link to this heading">¶</a></h5>
<p>Un riferimento a rvalue restituito esce dallo scope alla fine di tutta l’espressione da cui viene restituito:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto&amp;&amp; x = max(0, 1);   // OK, so far
foo(x);                 // Undefined behavior
</pre></div>
</div>
<p>Questo tipo di utilizzo è una frequente fonte di bug, spesso è erroneamente segnalato come un bug del compilatore. Un implementatore di una funzione dovrebbe evitare queste trappole agli utenti.</p>
<p>Il <a class="reference internal" href="#SS-lifetime"><span class="xref myst">profilo di sicurezza della durata</span></a> (quando è completamente implementato) intercetterà questi problemi.</p>
</section>
<section id="id299">
<h5>Esempio<a class="headerlink" href="#id299" title="Link to this heading">¶</a></h5>
<p>Restituire un riferimento rvalue va bene quando il riferimento all’oggetto temporaneo viene passato «all’interno» di una chiamata; in quel caso, è garantito che il temporaneo sopravviva alla chiamata a funzione (cfr. <a class="reference internal" href="#Rf-consume"><span class="xref myst">F.18</span></a> e <a class="reference internal" href="#Rf-forward"><span class="xref myst">F.19</span></a>). Tuttavia, non va bene quando si passa questo riferimento «salendo» verso uno scope più ampio. Per le funzioni passanti [passthrough] che trasferiscono i parametri (per normale riferimento o un perfetto forwarding) e vogliono restituire dei valori, si restituisce il semplice tipo dedotto da <code class="docutils literal notranslate"><span class="pre">auto</span></code> (non <code class="docutils literal notranslate"><span class="pre">auto&amp;&amp;</span></code>).</p>
<p>Si supponga che <code class="docutils literal notranslate"><span class="pre">F</span></code> ritorni per valore:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class F&gt;
auto&amp;&amp; wrapper(F f)
{
    log_call(typeid(f)); // or whatever instrumentation
    return f();          // BAD: returns a reference to a temporary
}
</pre></div>
</div>
<p>Meglio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class F&gt;
auto wrapper(F f)
{
    log_call(typeid(f)); // or whatever instrumentation
    return f();          // OK
}
</pre></div>
</div>
</section>
<section id="id300">
<h5>Eccezione<a class="headerlink" href="#id300" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">std::move</span></code> e <code class="docutils literal notranslate"><span class="pre">std::forward</span></code> restituiscono <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>, ma quelli sono solo cast – usati per convenzione solo in contesti di espressioni dove un riferimento ad un oggetto temporaneo viene passato nella stessa espressione prima che il temporaneo venga distrutto. Non si conoscono altri buoni esempi per restituire <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>.</p>
</section>
<section id="id301">
<h5>Imposizione<a class="headerlink" href="#id301" title="Link to this heading">¶</a></h5>
<p>Segnalare qualsiasi uso di <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> come tipo di ritorno, eccetto in <code class="docutils literal notranslate"><span class="pre">std::move</span></code> e <code class="docutils literal notranslate"><span class="pre">std::forward</span></code>.</p>
</section>
</section>
<section id="f-46-int-is-the-return-type-for-main">
<h4><a name="Rf-main"></a>F.46: <code class="docutils literal notranslate"><span class="pre">int</span></code> è il tipo restituito da <code class="docutils literal notranslate"><span class="pre">main()</span></code><a class="headerlink" href="#f-46-int-is-the-return-type-for-main" title="Link to this heading">¶</a></h4>
<section id="id302">
<h5>Motivo<a class="headerlink" href="#id302" title="Link to this heading">¶</a></h5>
<p>È una regola del linguaggio ma violata con delle «estensioni al linguaggio» così spesso che vale la pena citarla. Dichiarare il <code class="docutils literal notranslate"><span class="pre">main</span></code> (l’unico <code class="docutils literal notranslate"><span class="pre">main</span></code> globale di un programma) <code class="docutils literal notranslate"><span class="pre">void</span></code> limita la portabilità.</p>
</section>
<section id="id303">
<h5>Esempio<a class="headerlink" href="#id303" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    void main() { /* ... */ };  // bad, not C++

    int main()
    {
        std::cout &lt;&lt; &quot;This is the way to do it\n&quot;;
    }
</pre></div>
</div>
</section>
<section id="id304">
<h5>Nota<a class="headerlink" href="#id304" title="Link to this heading">¶</a></h5>
<p>Ne parliamo solo a causa della persistenza di questo errore nella comunità. Si noti che, nonostante il tipo restituito non-void, la funzione principale non richiede un’istruzione di ritorno esplicita.</p>
</section>
<section id="id305">
<h5>Imposizione<a class="headerlink" href="#id305" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Dovrebbe farlo il compilatore</p></li>
<li><p>Se il compilatore non lo fa, lasciare che lo segnalino i tools</p></li>
</ul>
</section>
</section>
<section id="f-47-return-t-from-assignment-operators">
<h4><a name="Rf-assignment-op"></a>F.47: Restituire <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> dagli operatori di assegnamento<a class="headerlink" href="#f-47-return-t-from-assignment-operators" title="Link to this heading">¶</a></h4>
<section id="id306">
<h5>Motivo<a class="headerlink" href="#id306" title="Link to this heading">¶</a></h5>
<p>La convenzione per gli operatori di overload (specie sui tipi concreti) è per <code class="docutils literal notranslate"><span class="pre">operator=(const</span> <span class="pre">T&amp;)</span></code> per eseguire l’assegnazione e poi ritornare (non-<code class="docutils literal notranslate"><span class="pre">const</span></code>) <code class="docutils literal notranslate"><span class="pre">*this</span></code>.  Ciò garantisce la coerenza con i tipi della libreria standard e segue il principio «fa come fanno gli int».</p>
</section>
<section id="id307">
<h5>Nota<a class="headerlink" href="#id307" title="Link to this heading">¶</a></h5>
<p>Storicamente c’erano alcune indicazioni per fare in modo che l’operatore di assegnazione restituisse <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T&amp;</span></code>. Questo principalmente per evitare il codice nella forma di <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">=</span> <span class="pre">b)</span> <span class="pre">=</span> <span class="pre">c</span></code> – tale codice non è abbastanza comune da giustificare la violazione della coerenza con i tipi standard.</p>
</section>
<section id="id308">
<h5>Esempio<a class="headerlink" href="#id308" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Foo
{
 public:
    ...
    Foo&amp; operator=(const Foo&amp; rhs)
    {
      // Copy members.
      ...
      return *this;
    }
};
</pre></div>
</div>
</section>
<section id="id309">
<h5>Imposizione<a class="headerlink" href="#id309" title="Link to this heading">¶</a></h5>
<p>Dovrebbe essere imposto dai tool controllando il tipo di ritorno (e il valore di ritorno) di qualsiasi operatore di assegnamento.</p>
</section>
</section>
<section id="f-48-don-t-return-std-move-local">
<h4><a name="Rf-return-move-local"></a>F.48: Non fare <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">std::move(local)</span></code><a class="headerlink" href="#f-48-don-t-return-std-move-local" title="Link to this heading">¶</a></h4>
<section id="id310">
<h5>Motivo<a class="headerlink" href="#id310" title="Link to this heading">¶</a></h5>
<p>La restituzione di una variabile locale la sposta implicitamente comunque. Un <code class="docutils literal notranslate"><span class="pre">std::move</span></code> esplicito è sempre peggiorativo, perché impedisce l’ottimizzazione del valore di ritorno [Return Value Optimization ] (RVO),</p>
</section>
<section id="id311">
<h5>Esempio, cattivo<a class="headerlink" href="#id311" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>S bad()
{
  S result;
  return std::move(result);
}
</pre></div>
</div>
</section>
<section id="id312">
<h5>Esempio, buono<a class="headerlink" href="#id312" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>S good()
{
  S result;
  // Named RVO: move elision at best, move construction at worst
  return result;
}
</pre></div>
</div>
</section>
<section id="id313">
<h5>Imposizione<a class="headerlink" href="#id313" title="Link to this heading">¶</a></h5>
<p>Questo dovrebbe essere imposto con dei tool controllando l’espressione del return.</p>
</section>
</section>
<section id="f-49-don-t-return-const-t">
<h4><a name="Rf-return-const"></a>F.49: Non restituire un <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T</span></code><a class="headerlink" href="#f-49-don-t-return-const-t" title="Link to this heading">¶</a></h4>
<section id="id314">
<h5>Motivo<a class="headerlink" href="#id314" title="Link to this heading">¶</a></h5>
<p>Non è consigliabile restituire un valore <code class="docutils literal notranslate"><span class="pre">const</span></code>. Un consiglio così vecchio è ormai obsoleto; non aggiunge valore e interferisce con la semantica di move.</p>
</section>
<section id="id315">
<h5>Esempio<a class="headerlink" href="#id315" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const vector&lt;int&gt; fct();    // bad: that &quot;const&quot; is more trouble than it is worth

void g(vector&lt;int&gt;&amp; vx)
{
    // ...
    fct() = vx;   // prevented by the &quot;const&quot;
    // ...
    vx = fct(); // expensive copy: move semantics suppressed by the &quot;const&quot;
    // ...
}
</pre></div>
</div>
<p>L’argomento per aggiungere <code class="docutils literal notranslate"><span class="pre">const</span></code> ad un valore di ritorno è che impedisce (rarissimamente) accessi accidentali a un elemento temporaneo. L’argomento contrario è che impedisce (molto di frequente) l’uso della semantica di move.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Rf-out"><span class="xref myst">F.20, l’argomento generale sulla «restituzione» dei valori in output</span></a></p>
</section>
<section id="id316">
<h5>Imposizione<a class="headerlink" href="#id316" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare la restituzione di un valore <code class="docutils literal notranslate"><span class="pre">const</span></code>. Per risolvere il problema: Rimuovere <code class="docutils literal notranslate"><span class="pre">const</span></code> nel restituire un valore non-<code class="docutils literal notranslate"><span class="pre">const</span></code>.</p></li>
</ul>
</section>
</section>
<section id="f-50-use-a-lambda-when-a-function-won-t-do-to-capture-local-variables-or-to-write-a-local-function">
<h4><a name="Rf-capture-vs-overload"></a>F.50: Usare una lambda quando una funzione non lo fa (per acquisire le variabili locali o scrivere una funzione locale)<a class="headerlink" href="#f-50-use-a-lambda-when-a-function-won-t-do-to-capture-local-variables-or-to-write-a-local-function" title="Link to this heading">¶</a></h4>
<section id="id317">
<h5>Motivo<a class="headerlink" href="#id317" title="Link to this heading">¶</a></h5>
<p>Le funzioni non possono acquisire variabili locali o essere definite nello scope locale; se ce n’è bisogno, è preferibile una lambda dove possibile altrimenti un oggetto funzione apposito. D’altra parte, lambda e oggetti funzione non consentono l’overload; se c’è bisogno dell’overload, è preferibile una funzione (le scappatoie per avere l’overload delle lambda sono tantissime). Se funzionano entrambi, è preferibile la scrittura di una funzione; si usa il tool necessario più semplice.</p>
</section>
<section id="id318">
<h5>Esempio<a class="headerlink" href="#id318" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// writing a function that should only take an int or a string
// -- overloading is natural
void f(int);
void f(const string&amp;);

// writing a function object that needs to capture local state and appear
// at statement or expression scope -- a lambda is natural
vector&lt;work&gt; v = lots_of_work();
for (int tasknum = 0; tasknum &lt; max; ++tasknum) {
    pool.run([=, &amp;v] {
        /*
        ...
        ... process 1 / max - th of v, the tasknum - th chunk
        ...
        */
    });
}
pool.join();
</pre></div>
</div>
</section>
<section id="id319">
<h5>Eccezione<a class="headerlink" href="#id319" title="Link to this heading">¶</a></h5>
<p>Le generiche lambda offrono un modo conciso di scrivere funzioni template e quindi possono risultare utili quando una normale funzione template farebbe lo stesso ma con un po” più di sintassi. Questo vantaggio probabilmente scomparirà in futuro quando tutte le funzioni avranno la possibilità di avere i parametri Concept.</p>
</section>
<section id="id320">
<h5>Imposizione<a class="headerlink" href="#id320" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Genera un warning quando c’è il nome di una non-generica lambda (p.es., <code class="docutils literal notranslate"><span class="pre">auto</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">[](int</span> <span class="pre">i)</span> <span class="pre">{</span> <span class="pre">/*...*/;</span> <span class="pre">};</span></code>) che non cattura niente ed appare nello scope globale. Scrivere, invece, una normale funzione.</p></li>
</ul>
</section>
</section>
<section id="f-51-where-there-is-a-choice-prefer-default-arguments-over-overloading">
<h4><a name="Rf-default-args"></a>F.51: Potendo scegliere, si preferiscano gli argomenti con default rispetto all’overloading<a class="headerlink" href="#f-51-where-there-is-a-choice-prefer-default-arguments-over-overloading" title="Link to this heading">¶</a></h4>
<section id="id321">
<h5>Motivo<a class="headerlink" href="#id321" title="Link to this heading">¶</a></h5>
<p>I default degli argomenti forniscono semplicemente delle interfacce alternative ad una singola implementazione. Non esiste alcuna garanzia che un insieme di funzioni sovraccaricate [overloaded] implementino tutte la stessa semantica. L’uso degli argomenti con default può evitare la replica del codice.</p>
</section>
<section id="id322">
<h5>Nota<a class="headerlink" href="#id322" title="Link to this heading">¶</a></h5>
<p>È possibile scegliere tra utilizzare l’argomento di default e l’overloading quando le alternative vengono da un set di argomenti con gli stessi tipi. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void print(const string&amp; s, format f = {});
</pre></div>
</div>
<p>oppure</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void print(const string&amp; s);  // use default format
void print(const string&amp; s, format f);
</pre></div>
</div>
<p>Non c’è scelta quando un set di funzioni viene utilizzato per eseguire un’operazione semanticamente equivalente a un insieme di tipi. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void print(const char&amp;);
void print(int);
void print(zstring);
</pre></div>
</div>
</section>
<section id="see-also">
<h5>Si veda anche<a class="headerlink" href="#see-also" title="Link to this heading">¶</a></h5>
<p><a class="reference internal" href="#Rh-virtual-default-arg"><span class="xref myst">Argomenti di default per funzioni virtuali</span></a></p>
</section>
<section id="id323">
<h5>Imposizione<a class="headerlink" href="#id323" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Solleva un warning su un insieme di overload dove questi hanno gli stessi parametri iniziali (p.es., <code class="docutils literal notranslate"><span class="pre">f(int)</span></code>, <code class="docutils literal notranslate"><span class="pre">f(int,</span> <span class="pre">const</span> <span class="pre">string&amp;)</span></code>, <code class="docutils literal notranslate"><span class="pre">f(int,</span> <span class="pre">const</span> <span class="pre">string&amp;,</span> <span class="pre">double)</span></code>). (Nota: Rivedere questa imposizione [enforcement] se è troppo confuso nella pratica).</p></li>
</ul>
</section>
</section>
<section id="f-52-prefer-capturing-by-reference-in-lambdas-that-will-be-used-locally-including-passed-to-algorithms">
<h4><a name="Rf-reference-capture"></a>F.52: Preferire l’acquisizione per riferimento nelle lambda da usare localmente, compresi quelle passate  agli algoritmi<a class="headerlink" href="#f-52-prefer-capturing-by-reference-in-lambdas-that-will-be-used-locally-including-passed-to-algorithms" title="Link to this heading">¶</a></h4>
<section id="id324">
<h5>Motivo<a class="headerlink" href="#id324" title="Link to this heading">¶</a></h5>
<p>Per efficienza e correttezza, si deve quasi sempre acquisire per riferimento quando si usa la lambda localmente. Questo comprende anche quando si scrivono o si chiamano algoritmi paralleli che sono locali perché si uniscono [join] prima di tornare.</p>
</section>
<section id="id325">
<h5>Discussione<a class="headerlink" href="#id325" title="Link to this heading">¶</a></h5>
<p>La considerazione sull’efficienza è che la maggior parte dei tipi sono più economici da passare per riferimento che per valore.</p>
<p>La considerazione sulla correttezza è che molte chiamate hanno degli effetti collaterali sull’oggetto originale dal lato del chiamante (si veda l’esempio sotto). Questo si evita col passaggio per valore.</p>
</section>
<section id="id326">
<h5>Nota<a class="headerlink" href="#id326" title="Link to this heading">¶</a></h5>
<p>Sfortunatamente, non esiste un modo semplice per acquisire per riferimento a <code class="docutils literal notranslate"><span class="pre">const</span></code> per ottenere l’efficienza di una chiamata locale ma per prevenire anche gli effetti collaterali.</p>
</section>
<section id="id327">
<h5>Esempio<a class="headerlink" href="#id327" title="Link to this heading">¶</a></h5>
<p>Qui, un oggetto di grandi dimensioni (un messaggio di rete) viene passato a un algoritmo iterativo e non è efficiente né corretto copiarlo (e potrebbe non essere copiabile):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>std::for_each(begin(sockets), end(sockets), [&amp;message](auto&amp; socket)
{
    socket.send(message);
});
</pre></div>
</div>
</section>
<section id="id328">
<h5>Esempio<a class="headerlink" href="#id328" title="Link to this heading">¶</a></h5>
<p>Questa è una semplice pipeline parallela a tre stadi. Ogni oggetto <code class="docutils literal notranslate"><span class="pre">stage</span></code> [stadio] incapsula un thread worker ed una coda [queue], ha una funzione <code class="docutils literal notranslate"><span class="pre">process</span></code> per accodare il lavoro [work] e nel suo distruttore si blocca automaticamente aspettando lo svuotamento della coda prima di completare il thread.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void send_packets(buffers&amp; bufs)
{
    stage encryptor([](buffer&amp; b) { encrypt(b); });
    stage compressor([&amp;](buffer&amp; b) { compress(b); encryptor.process(b); });
    stage decorator([&amp;](buffer&amp; b) { decorate(b); compressor.process(b); });
    for (auto&amp; b : bufs) { decorator.process(b); }
}  // automatically blocks waiting for pipeline to finish
</pre></div>
</div>
</section>
<section id="id329">
<h5>Imposizione<a class="headerlink" href="#id329" title="Link to this heading">¶</a></h5>
<p>Segnalare una lambda che cattura per riferimento, ma viene usata non solo localmente nello scope della funzione o viene passata ad una funzione per riferimento. (Nota: Questa regola è un’approssimazione, segnala i passaggi per puntatore simili a quelli memorizzati dal chiamato, scrivendo in una locazione dell’heap cui si accede tramite un parametro, restituendo la lambda, ecc. Le regole [Lifetime] forniranno anche regole generali che segnalano i puntatori in fuga [escaping] e i riferimenti compresi quelli tramite le lambda).</p>
</section>
</section>
<section id="f-53-avoid-capturing-by-reference-in-lambdas-that-will-be-used-non-locally-including-returned-stored-on-the-heap-or-passed-to-another-thread">
<h4><a name="Rf-value-capture"></a>F.53: Evitare l’acquisizione per riferimento nelle lambda che non si useranno localmente, compresi quelli restituiti, memorizzati nell’heap o passati da un altro thread<a class="headerlink" href="#f-53-avoid-capturing-by-reference-in-lambdas-that-will-be-used-non-locally-including-returned-stored-on-the-heap-or-passed-to-another-thread" title="Link to this heading">¶</a></h4>
<section id="id330">
<h5>Motivo<a class="headerlink" href="#id330" title="Link to this heading">¶</a></h5>
<p>Puntatori e riferimenti a locali non dovrebbero sopravvivere al loro scope. Le lambda che catturano per riferimento sono solo un altro posto in cui memorizzare un riferimento a un oggetto locale e non dovrebbero farlo se sopravvivono (o una loro copia) allo scope.</p>
</section>
<section id="id331">
<h5>Esempio, cattivo<a class="headerlink" href="#id331" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int local = 42;

// Want a reference to local.
// Note, that after program exits this scope,
// local no longer exists, therefore
// process() call will have undefined behavior!
thread_pool.queue_work([&amp;] { process(local); });
</pre></div>
</div>
</section>
<section id="id332">
<h5>Esempio, buono<a class="headerlink" href="#id332" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int local = 42;
// Want a copy of local.
// Since a copy of local is made, it will
// always be available for the call.
thread_pool.queue_work([=] { process(local); });
</pre></div>
</div>
</section>
<section id="id333">
<h5>Nota<a class="headerlink" href="#id333" title="Link to this heading">¶</a></h5>
<p>Se è necessario catturare un puntatore non locale, prendere in considerazione l’utilizzo di <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code>; questo gestisce sia il ciclo di vita che la sincronizzazione.</p>
<p>Se deve essere catturato il puntatore <code class="docutils literal notranslate"><span class="pre">this</span></code>, considerare l’utilizzo della cattura di <code class="docutils literal notranslate"><span class="pre">[*this]</span></code>, che crea una copia dell’intero oggetto.</p>
</section>
<section id="id334">
<h5>Imposizione<a class="headerlink" href="#id334" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Semplice) Emette un warning quando la “capture-list” [lista dei parametri] contiene un riferimento ad una variabile definita localmente</p></li>
<li><p>(Complesso) Emette un warning quando la “capture-list” contiene un riferimento ad una variabile dichiarata localmente e la lambda viene passata ad un contesto non-<code class="docutils literal notranslate"><span class="pre">const</span></code> e non-local</p></li>
</ul>
</section>
</section>
<section id="f-54-when-writing-a-lambda-that-captures-this-or-any-class-data-member-don-t-use-default-capture">
<h4><a name="Rf-this-capture"></a>F.54: Quando si scrive una lambda che cattura <code class="docutils literal notranslate"><span class="pre">this</span></code> o un qualsiasi dato membro della classe, non usare il «default capture» <code class="docutils literal notranslate"><span class="pre">[=]</span></code><a class="headerlink" href="#f-54-when-writing-a-lambda-that-captures-this-or-any-class-data-member-don-t-use-default-capture" title="Link to this heading">¶</a></h4>
<section id="id335">
<h5>Motivo<a class="headerlink" href="#id335" title="Link to this heading">¶</a></h5>
<p>È confusionario. Scrivere <code class="docutils literal notranslate"><span class="pre">[=]</span></code> in una funzione membro sembra catturare per valore, mentre in realtà cattura tutti i dati membri per riferimento perché in effetti cattura il puntatore invisibile <code class="docutils literal notranslate"><span class="pre">this</span></code> per valore. Se si intende fare questo, si scriva esplicitamente <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</section>
<section id="id336">
<h5>Esempio<a class="headerlink" href="#id336" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class My_class {
    int x = 0;
    // ...

    void f()
    {
        int i = 0;
        // ...

        auto lambda = [=] { use(i, x); };   // BAD: &quot;looks like&quot; copy/value capture

        x = 42;
        lambda(); // calls use(0, 42);
        x = 43;
        lambda(); // calls use(0, 43);

        // ...

        auto lambda2 = [i, this] { use(i, x); }; // ok, most explicit and least confusing

        // ...
    }
};
</pre></div>
</div>
</section>
<section id="id337">
<h5>Nota<a class="headerlink" href="#id337" title="Link to this heading">¶</a></h5>
<p>Se si intende catturare una copia di tutti i dati membri di classe, si consideri il C++17 <code class="docutils literal notranslate"><span class="pre">[*this]</span></code>.</p>
</section>
<section id="id338">
<h5>Imposizione<a class="headerlink" href="#id338" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare qualsiasi capture-list di lambda che specifica un’acquisizione di <code class="docutils literal notranslate"><span class="pre">[=]</span></code> e cattura anche <code class="docutils literal notranslate"><span class="pre">this</span></code> (esplicitamente o tramite acquisizione di default e un uso di <code class="docutils literal notranslate"><span class="pre">this</span></code> nel corpo) body)</p></li>
</ul>
</section>
</section>
<section id="f-55-don-t-use-va-arg-arguments">
<h4><a name="F-varargs"></a>F.55: Non usare gli argomenti  <code class="docutils literal notranslate"><span class="pre">va_arg</span></code><a class="headerlink" href="#f-55-don-t-use-va-arg-arguments" title="Link to this heading">¶</a></h4>
<section id="id339">
<h5>Motivo<a class="headerlink" href="#id339" title="Link to this heading">¶</a></h5>
<p>La lettura da un <code class="docutils literal notranslate"><span class="pre">va_arg</span></code> presuppone che sia stato passato effettivamente il tipo corretto. Il passaggio con varargs presuppone che sia letto il tipo corretto. Questo è alquanto fragile perché non può essere imposta la sicurezza nel linguaggio e quindi si affida alla disciplina del programmatore per la correttezza.</p>
</section>
<section id="id340">
<h5>Esempio<a class="headerlink" href="#id340" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int sum(...)
{
    // ...
    while (/*...*/)
        result += va_arg(list, int); // BAD, assumes it will be passed ints
    // ...
}

sum(3, 2); // ok
sum(3.14159, 2.71828); // BAD, undefined

template&lt;class ...Args&gt;
auto sum(Args... args) // GOOD, and much more flexible
{
    return (... + args); // note: C++17 &quot;fold expression&quot;
}

sum(3, 2); // ok: 5
sum(3.14159, 2.71828); // ok: ~5.85987
</pre></div>
</div>
</section>
<section id="alternatives">
<h5>Alternative<a class="headerlink" href="#alternatives" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>overloading</p></li>
<li><p>template variadici</p></li>
<li><p>argomenti <code class="docutils literal notranslate"><span class="pre">variant</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initializer_list</span></code> (omogenea)</p></li>
</ul>
</section>
<section id="id341">
<h5>Nota<a class="headerlink" href="#id341" title="Link to this heading">¶</a></h5>
<p>La dichiarazione di un parametro <code class="docutils literal notranslate"><span class="pre">...</span></code> talvolta è utile nelle tecniche che non implicano il passaggio dell’argomento corrente, in particolare per dichiarare le funzioni «acchiappa-tutto [take-anything]» i modo da disabilitare «tutto il resto» in un insieme di overload o per esprimere il caso “onnicomprensivo” [catchall] in un metaprogramma template.</p>
</section>
<section id="id342">
<h5>Imposizione<a class="headerlink" href="#id342" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Emettere una diagnostica per l’uso di <code class="docutils literal notranslate"><span class="pre">va_list</span></code>, <code class="docutils literal notranslate"><span class="pre">va_start</span></code>, o <code class="docutils literal notranslate"><span class="pre">va_arg</span></code>.</p></li>
<li><p>Emettere una diagnostica per il passaggio di un argomento ad un parametro vararg di una funzione che non offre un overload per un tipo più specifico nella posizione del vararg. Per risolvere: Usare una funzione diversa, o <code class="docutils literal notranslate"><span class="pre">[[suppress(&quot;type&quot;)]]</span></code>.</p></li>
</ul>
</section>
</section>
<section id="f-56-avoid-unnecessary-condition-nesting">
<h4><a name="F-nesting"></a>F.56: Evitare inutili condizioni di annidamento<a class="headerlink" href="#f-56-avoid-unnecessary-condition-nesting" title="Link to this heading">¶</a></h4>
<section id="id343">
<h5>Motivo<a class="headerlink" href="#id343" title="Link to this heading">¶</a></h5>
<p>Un limitato annidamento delle condizioni rende il codice più facile da seguire. Ne rende anche più chiaro o scopo. Sforzarsi nel porre il codice essenziale nello scope più esterno, a meno che questo non nasconda l’intento del codice).</p>
</section>
<section id="id344">
<h5>Esempio<a class="headerlink" href="#id344" title="Link to this heading">¶</a></h5>
<p>Utilizza una [guard-clause] per gestire casi eccezionali e tornare prima.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Bad: Deep nesting
void foo() {
    ...
    if (x) {
        computeImportantThings(x);
    }
}

// Bad: Still a redundant else.
void foo() {
    ...
    if (!x) {
        return;
    }
    else {
        computeImportantThings(x);
    }
}

// Good: Early return, no redundant else
void foo() {
    ...
    if (!x)
        return;

    computeImportantThings(x);
}
</pre></div>
</div>
</section>
<section id="id345">
<h5>Esempio<a class="headerlink" href="#id345" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Bad: Unnecessary nesting of conditions
void foo() {
    ...
    if (x) {
        if (y) {
            computeImportantThings(x);
        }
    }
}

// Good: Merge conditions + return early
void foo() {
    ...
    if (!(x &amp;&amp; y))
        return;

    computeImportantThings(x);
}
</pre></div>
</div>
</section>
<section id="id346">
<h5>Imposizione<a class="headerlink" href="#id346" title="Link to this heading">¶</a></h5>
<p>Segnalare un <code class="docutils literal notranslate"><span class="pre">else</span></code> ridondante. Segnalare una funzione il cui corpo è semplicemente un’istruzione condizionale che racchiude un blocco.</p>
</section>
</section>
</section>
</section>
<section id="c-classes-and-class-hierarchies">
<h2><a name="S-class"></a>C: Classi e gerarchie di classi<a class="headerlink" href="#c-classes-and-class-hierarchies" title="Link to this heading">¶</a></h2>
<p>Una classe è un tipo definito dall’utente, per il quale un programmatore può definire la rappresentazione, le operazioni e le interfacce. Le gerarchie di classi si usano per organizzare le classi correlate in strutture gerarchiche.</p>
<p>Riepilogo delle regole sulle classi:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rc-org"><span class="xref myst">C.1: Organizzare i dati correlati in strutture (<code class="docutils literal notranslate"><span class="pre">struct</span></code> o <code class="docutils literal notranslate"><span class="pre">class</span></code>)</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-struct"><span class="xref myst">C.2: Utilizzare <code class="docutils literal notranslate"><span class="pre">class</span></code> se la classe ha un invariante; usare <code class="docutils literal notranslate"><span class="pre">struct</span></code> se i dati membro possono variare indipendentemente</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-interface"><span class="xref myst">C.3: Rappresentare la distinzione tra un’interfaccia e un’implementazione utilizzando una classe</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-member"><span class="xref myst">C.4: Creare una funzione membro solo se è necessario l’accesso diretto alla rappresentazione di una classe</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-helper"><span class="xref myst">C.5: Inserire le funzioni helper nello stesso namespace della classe che supportano</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-standalone"><span class="xref myst">C.7: Non definire una classe o un enum e dichiarare una variabile dello stesso tipo nella stessa istruzione</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-class"><span class="xref myst">C.8: Usare <code class="docutils literal notranslate"><span class="pre">class</span></code> anziché <code class="docutils literal notranslate"><span class="pre">struct</span></code> se uno dei membri è non-public</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-private"><span class="xref myst">C.9: Ridurre al minimo l’esposizione dei membri</span></a></p></li>
</ul>
<p>Sottosezioni:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#SS-concrete"><span class="xref myst">C.concrete: Tipi concreti</span></a></p></li>
<li><p><a class="reference internal" href="#S-ctor"><span class="xref myst">C.ctor: Costruttori, assegnazioni e distruttori</span></a></p></li>
<li><p><a class="reference internal" href="#SS-containers"><span class="xref myst">C.con: Contenitori ed altri gestori di risorse</span></a></p></li>
<li><p><a class="reference internal" href="#SS-lambdas"><span class="xref myst">C.lambdas: Oggetti funzione e lambda</span></a></p></li>
<li><p><a class="reference internal" href="#SS-hier"><span class="xref myst">C.hier: Gerarchie di classi (OOP)</span></a></p></li>
<li><p><a class="reference internal" href="#SS-overload"><span class="xref myst">C.over: Overloading e operatori overloaded</span></a></p></li>
<li><p><a class="reference internal" href="#SS-union"><span class="xref myst">C.union: Unioni</span></a></p></li>
</ul>
<section id="c-1-organize-related-data-into-structures-structs-or-classes">
<h3><a name="Rc-org"></a>C.1: Organizzare i dati correlati in strutture (<code class="docutils literal notranslate"><span class="pre">struct</span></code> o <code class="docutils literal notranslate"><span class="pre">class</span></code>)<a class="headerlink" href="#c-1-organize-related-data-into-structures-structs-or-classes" title="Link to this heading">¶</a></h3>
<section id="id347">
<h4>Motivo<a class="headerlink" href="#id347" title="Link to this heading">¶</a></h4>
<p>Facilità di comprensione. Se i dati sono correlati (per motivi di fondo), tale fatto dovrebbe riflettersi nel codice.</p>
</section>
<section id="id348">
<h4>Esempio<a class="headerlink" href="#id348" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void draw(int x, int y, int x2, int y2);  // BAD: unnecessary implicit relationships
void draw(Point from, Point to);          // better
</pre></div>
</div>
</section>
<section id="id349">
<h4>Nota<a class="headerlink" href="#id349" title="Link to this heading">¶</a></h4>
<p>Una semplice classe, senza funzioni virtuali, non implica né un aumento di spazio né di tempo.</p>
</section>
<section id="id350">
<h4>Nota<a class="headerlink" href="#id350" title="Link to this heading">¶</a></h4>
<p>Dal punto di vista del linguaggio <code class="docutils literal notranslate"><span class="pre">class</span></code> e <code class="docutils literal notranslate"><span class="pre">struct</span></code> differiscono solo per la visibilità di default dei loro membri.</p>
</section>
<section id="id351">
<h4>Imposizione<a class="headerlink" href="#id351" title="Link to this heading">¶</a></h4>
<p>Probabilmente impossibile. Forse è possibile una ricerca euristica di elementi di dati utilizzati insieme.</p>
</section>
</section>
<section id="c-2-use-class-if-the-class-has-an-invariant-use-struct-if-the-data-members-can-vary-independently">
<h3><a name="Rc-struct"></a>C.2: Utilizzare <code class="docutils literal notranslate"><span class="pre">class</span></code> se la classe ha un invariante; usare <code class="docutils literal notranslate"><span class="pre">struct</span></code> se i dati membro possono variare indipendentemente<a class="headerlink" href="#c-2-use-class-if-the-class-has-an-invariant-use-struct-if-the-data-members-can-vary-independently" title="Link to this heading">¶</a></h3>
<section id="id352">
<h4>Motivo<a class="headerlink" href="#id352" title="Link to this heading">¶</a></h4>
<p>Leggibilità. Facilità di comprensione. L’uso di <code class="docutils literal notranslate"><span class="pre">class</span></code> avvisa il programmatore della necessità di un invariante. Questa è un’utile convenzione.</p>
</section>
<section id="id353">
<h4>Nota<a class="headerlink" href="#id353" title="Link to this heading">¶</a></h4>
<p>Un invariante, è una condizione logica per i membri di un oggetto che un costruttore deve stabilire, affinché le funzioni membro pubbliche la possano assumere. Dopo aver stabilito l’invariante (in genere in un costruttore), ogni funzione membro può essere chiamata per l’oggetto. Un invariante può essere dichiarato informalmente (p.es., in un commento) o più formalmente utilizzando <code class="docutils literal notranslate"><span class="pre">Expects</span></code>.</p>
<p>Se tutti i dati membro possono variare indipendentemente l’uno dall’altro, non è possibile alcun invariante.</p>
</section>
<section id="id354">
<h4>Esempio<a class="headerlink" href="#id354" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Pair {  // the members can vary independently
    string name;
    int volume;
};
</pre></div>
</div>
<p>ma:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Date {
public:
    // validate that {yy, mm, dd} is a valid date and initialize
    Date(int yy, Month mm, char dd);
    // ...
private:
    int y;
    Month m;
    char d;    // day
};
</pre></div>
</div>
</section>
<section id="id355">
<h4>Nota<a class="headerlink" href="#id355" title="Link to this heading">¶</a></h4>
<p>Se una classe ha dati <code class="docutils literal notranslate"><span class="pre">private</span></code>, un utente non può completamente inizializzare un oggetto senza l’uso di un costruttore. Quindi, chi definisce la classe fornirà un costruttore e deve specificarne il significato. Questo vuol dire effettivamente che chi definisce la classe deve definire un invariante.</p>
<p><strong>Si veda anche</strong>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rc-class"><span class="xref myst">definire una classe con dati privati con <code class="docutils literal notranslate"><span class="pre">class</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rl-order"><span class="xref myst">In una classe, è preferibile piazzare prima l’interfaccia</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-private"><span class="xref myst">minimizzare l’esposizione dei membri</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-protected"><span class="xref myst">Evitare dati <code class="docutils literal notranslate"><span class="pre">protected</span></code></span></a></p></li>
</ul>
</section>
<section id="id356">
<h4>Imposizione<a class="headerlink" href="#id356" title="Link to this heading">¶</a></h4>
<p>Cercare le <code class="docutils literal notranslate"><span class="pre">struct</span></code> con tutti i dati privati e le <code class="docutils literal notranslate"><span class="pre">class</span></code> con tutti i membri pubblici.</p>
</section>
</section>
<section id="c-3-represent-the-distinction-between-an-interface-and-an-implementation-using-a-class">
<h3><a name="Rc-interface"></a>C.3: Rappresentare la distinzione tra un’interfaccia e un’implementazione utilizzando una classe<a class="headerlink" href="#c-3-represent-the-distinction-between-an-interface-and-an-implementation-using-a-class" title="Link to this heading">¶</a></h3>
<section id="id357">
<h4>Motivo<a class="headerlink" href="#id357" title="Link to this heading">¶</a></h4>
<p>Una distinzione esplicita tra interfaccia e implementazione migliora la leggibilità e semplifica la manutenzione.</p>
</section>
<section id="id358">
<h4>Esempio<a class="headerlink" href="#id358" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Date {
public:
    Date();
    // validate that {yy, mm, dd} is a valid date and initialize
    Date(int yy, Month mm, char dd);

    int day() const;
    Month month() const;
    // ...
private:
    // ... some representation ...
};
</pre></div>
</div>
<p>Ad esempio, ora possiamo cambiare la rappresentazione di una <code class="docutils literal notranslate"><span class="pre">Date</span></code> senza influire sui suoi utenti (è tuttavia probabile che si debba ricompilare).
For example, we can now change the representation of a <code class="docutils literal notranslate"><span class="pre">Date</span></code> without affecting its users (recompilation is likely, though).</p>
</section>
<section id="id359">
<h4>Nota<a class="headerlink" href="#id359" title="Link to this heading">¶</a></h4>
<p>Ovviamente, usare una classe in questo modo per rappresentare la distinzione tra l’interfaccia e l’implementazione, non è l’unica maniera. Per esempio, possiamo usare un set di dichiarazioni di funzioni indipendenti in un namespace, una classe base astratta o una funzione template con i «concetti» per rappresentare un’interfaccia. Il problema più importante è distinguere esplicitamente tra un’interfaccia e i suoi «dettagli» di implementazione.
Idealmente, e solitamente, un’interfaccia è molto più stabile delle sue implementazioni.</p>
</section>
<section id="id360">
<h4>Imposizione<a class="headerlink" href="#id360" title="Link to this heading">¶</a></h4>
<p>???</p>
</section>
</section>
<section id="c-4-make-a-function-a-member-only-if-it-needs-direct-access-to-the-representation-of-a-class">
<h3><a name="Rc-member"></a>C.4: Creare una funzione membro solo se è necessario l’accesso diretto alla rappresentazione di una classe<a class="headerlink" href="#c-4-make-a-function-a-member-only-if-it-needs-direct-access-to-the-representation-of-a-class" title="Link to this heading">¶</a></h3>
<section id="id361">
<h4>Motivo<a class="headerlink" href="#id361" title="Link to this heading">¶</a></h4>
<p>Meno accoppiamento c’è con le funzioni membro, meno funzioni ci saranno che possono causare problemi modificando lo stato dell’oggetto, e si riduce il numero delle funzioni che si devono modificare dopo averne cambiato la rappresentazione.</p>
</section>
<section id="id362">
<h4>Esempio<a class="headerlink" href="#id362" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Date {
    // ... relatively small interface ...
};

// helper functions:
Date next_weekday(Date);
bool operator==(Date, Date);
</pre></div>
</div>
<p>Le «funzioni helper» non hanno bisogno dell’accesso diretto alla rappresentazione di una <code class="docutils literal notranslate"><span class="pre">Date</span></code>.</p>
</section>
<section id="id363">
<h4>Nota<a class="headerlink" href="#id363" title="Link to this heading">¶</a></h4>
<p>Questa regola diventa ancora migliore se il C++ adotta la <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0251r0.pdf">«uniform function call»</a>.</p>
</section>
<section id="id364">
<h4>Eccezione<a class="headerlink" href="#id364" title="Link to this heading">¶</a></h4>
<p>Il linguaggio richiede che delle funzioni <code class="docutils literal notranslate"><span class="pre">virtual</span></code> siano membri, e non tutte le funzioni <code class="docutils literal notranslate"><span class="pre">virtual</span></code> accedono direttamente ai dati. In particolare, i membri di una classe astratta raramente lo fanno.</p>
<p>Nota <a class="reference external" href="https://web.archive.org/web/20200605021759/https://parasol.tamu.edu/~yuriys/papers/OMM10.pdf">multi-methods</a>.</p>
</section>
<section id="id365">
<h4>Eccezione<a class="headerlink" href="#id365" title="Link to this heading">¶</a></h4>
<p>Il linguaggio richiede che gli operatori <code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">()</span></code>, <code class="docutils literal notranslate"><span class="pre">[]</span></code> e <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> siano membri.</p>
</section>
<section id="id366">
<h4>Eccezione<a class="headerlink" href="#id366" title="Link to this heading">¶</a></h4>
<p>Un set di overload potrebbe avere dei membri che non accedono direttamente ai dati <code class="docutils literal notranslate"><span class="pre">private</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Foobar {
public:
    void foo(long x) { /* manipulate private data */ }
    void foo(double x) { foo(std::lround(x)); }
    // ...
private:
    // ...
};
</pre></div>
</div>
</section>
<section id="id367">
<h4>Eccezione<a class="headerlink" href="#id367" title="Link to this heading">¶</a></h4>
<p>Allo stesso modo, un insieme di funzioni potrebbe essere progettato per essere utilizzato in sequenze concatenate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>x.scale(0.5).rotate(45).set_color(Color::red);
</pre></div>
</div>
<p>In genere, alcune di queste funzioni, ma non tutte, accedono direttamente ai dati <code class="docutils literal notranslate"><span class="pre">private</span></code>.</p>
</section>
<section id="id368">
<h4>Imposizione<a class="headerlink" href="#id368" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Cercare le funzioni membro non-<code class="docutils literal notranslate"><span class="pre">virtual</span></code> che non toccano direttamente i dati membro. L’intoppo è che molte funzioni membro che lo fanno non hanno bisogno di toccare direttamente i dati membro.</p></li>
<li><p>Ignorare le funzioni <code class="docutils literal notranslate"><span class="pre">virtual</span></code>.</p></li>
<li><p>Ignorare le funzioni che fanno parte di un set di overload di cui almeno una funzione accede ai membri <code class="docutils literal notranslate"><span class="pre">private</span></code>.</p></li>
<li><p>Ignorare le funzioni che restituiscono <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p></li>
</ul>
</section>
</section>
<section id="c-5-place-helper-functions-in-the-same-namespace-as-the-class-they-support">
<h3><a name="Rc-helper"></a>C.5: Inserire le funzioni helper nello stesso namespace della classe che supportano<a class="headerlink" href="#c-5-place-helper-functions-in-the-same-namespace-as-the-class-they-support" title="Link to this heading">¶</a></h3>
<section id="id369">
<h4>Motivo<a class="headerlink" href="#id369" title="Link to this heading">¶</a></h4>
<p>Una funzione helper è una funzione (solitamente fornita da chi scrive la classe) che non necessita di accedere direttamente alla rappresentazione della classe, ma viene vista come parte dell’interfaccia utile alla classe. Posizionandole nello stesso namespace della classe, si rende palese la loro relazione con la classe e consente loro di essere trovate cercando gli argomenti dipendenti.</p>
</section>
<section id="id370">
<h4>Esempio<a class="headerlink" href="#id370" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>namespace Chrono { // here we keep time-related services

    class Time { /* ... */ };
    class Date { /* ... */ };

    // helper functions:
    bool operator==(Date, Date);
    Date next_weekday(Date);
    // ...
}
</pre></div>
</div>
</section>
<section id="id371">
<h4>Nota<a class="headerlink" href="#id371" title="Link to this heading">¶</a></h4>
<p>Ciò è particolarmente importante per gli <a class="reference internal" href="#Ro-namespace"><span class="xref myst">operatori overloaded</span></a>.</p>
</section>
<section id="id372">
<h4>Imposizione<a class="headerlink" href="#id372" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnare le funzioni globali prendendo i tipi degli argomenti da un singolo namespace.</p></li>
</ul>
</section>
</section>
<section id="c-7-don-t-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement">
<h3><a name="Rc-standalone"></a>C.7: Non definire una classe o un enum e dichiarare una variabile dello stesso tipo nella stessa istruzione<a class="headerlink" href="#c-7-don-t-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement" title="Link to this heading">¶</a></h3>
<section id="id373">
<h4>Motivo<a class="headerlink" href="#id373" title="Link to this heading">¶</a></h4>
<p>Mescolare una definizione di tipo e la definizione di un’altra entità nella stessa dichiarazione è confuso e non necessario.</p>
</section>
<section id="id374">
<h4>Esempio, cattivo<a class="headerlink" href="#id374" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Data { /*...*/ } data{ /*...*/ };
</pre></div>
</div>
</section>
<section id="id375">
<h4>Esempio, buono<a class="headerlink" href="#id375" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Data { /*...*/ };
Data data{ /*...*/ };
</pre></div>
</div>
</section>
<section id="id376">
<h4>Imposizione<a class="headerlink" href="#id376" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare se la <code class="docutils literal notranslate"><span class="pre">}</span></code> di una definizione di una classe o di una enumerazione non è seguita da un <code class="docutils literal notranslate"><span class="pre">;</span></code>. Il <code class="docutils literal notranslate"><span class="pre">;</span></code> è mancante.</p></li>
</ul>
</section>
</section>
<section id="c-8-use-class-rather-than-struct-if-any-member-is-non-public">
<h3><a name="Rc-class"></a>C.8: Usare <code class="docutils literal notranslate"><span class="pre">class</span></code> anziché <code class="docutils literal notranslate"><span class="pre">struct</span></code> se uno dei membri è non-public<a class="headerlink" href="#c-8-use-class-rather-than-struct-if-any-member-is-non-public" title="Link to this heading">¶</a></h3>
<section id="id377">
<h4>Motivo<a class="headerlink" href="#id377" title="Link to this heading">¶</a></h4>
<p>Leggibilità. Per chiarire che qualcosa viene nascosto/astratto. Questa è un’utile convenzione.</p>
</section>
<section id="id378">
<h4>Esempio, cattivo<a class="headerlink" href="#id378" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Date {
    int d, m;

    Date(int i, Month m);
    // ... lots of functions ...
private:
    int y;  // year
};
</pre></div>
</div>
<p>Non c’è nulla di sbagliato in questo codice per quanto riguarda le regole del C++, ma è quasi tutto sbagliato dal punto di vista del design. I dati privati sono nascosti lontano da quelli pubblici. I dati sono sparpagliati in più parti nella dichiarazione della classe. Le diverse parti di dati hanno un diverso accesso. Tutto ciò riduce la leggibilità e complica la manutenzione.</p>
</section>
<section id="id379">
<h4>Nota<a class="headerlink" href="#id379" title="Link to this heading">¶</a></h4>
<p>In una classe è preferibile piazzare prima l’interfaccia, <a class="reference internal" href="#Rl-order"><span class="xref myst">cfr. NL.16</span></a>.</p>
</section>
<section id="id380">
<h4>Imposizione<a class="headerlink" href="#id380" title="Link to this heading">¶</a></h4>
<p>Si segnalano le classi dichiarate con <code class="docutils literal notranslate"><span class="pre">struct</span></code> se c’è un membro <code class="docutils literal notranslate"><span class="pre">private</span></code> o <code class="docutils literal notranslate"><span class="pre">protected</span></code>.</p>
</section>
</section>
<section id="c-9-minimize-exposure-of-members">
<h3><a name="Rc-private"></a>C.9: Ridurre al minimo l’esposizione dei membri<a class="headerlink" href="#c-9-minimize-exposure-of-members" title="Link to this heading">¶</a></h3>
<section id="id381">
<h4>Motivo<a class="headerlink" href="#id381" title="Link to this heading">¶</a></h4>
<p>Incapsulamento. Nascondere le informazioni. Ridurre al minimo la possibilità di accesso involontario. Questo semplifica la manutenzione.</p>
</section>
<section id="id382">
<h4>Esempio<a class="headerlink" href="#id382" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T, typename U&gt;
struct pair {
    T a;
    U b;
    // ...
};
</pre></div>
</div>
<p>Qualunque cosa si faccia nella parte <code class="docutils literal notranslate"><span class="pre">//</span></code>, un qualsiasi utente di una <code class="docutils literal notranslate"><span class="pre">pair</span></code> può arbitrariamente e indipendentemente cambiarne la <code class="docutils literal notranslate"><span class="pre">a</span></code> e la <code class="docutils literal notranslate"><span class="pre">b</span></code>. In una base di codice di grandi dimensioni, non si può facilmente trovare quale codice fa cosa ai membri della <code class="docutils literal notranslate"><span class="pre">pair</span></code>. Questo potrebbe essere esattamente voluto, ma volendo far rispettare una relazione tra i membri, bisogna renderli <code class="docutils literal notranslate"><span class="pre">private</span></code> e imporre tale relazione (invariante) tramite i costruttori e le funzioni membro. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Distance {
public:
    // ...
    double meters() const { return magnitude*unit; }
    void set_unit(double u)
    {
            // ... check that u is a factor of 10 ...
            // ... change magnitude appropriately ...
            unit = u;
    }
    // ...
private:
    double magnitude;
    double unit;    // 1 is meters, 1000 is kilometers, 0.001 is millimeters, etc.
};
</pre></div>
</div>
</section>
<section id="id383">
<h4>Nota<a class="headerlink" href="#id383" title="Link to this heading">¶</a></h4>
<p>Se non è possibile determinare facilmente l’insieme degli utenti diretti di un insieme di variabili, il tipo o l’utilizzo di tale insieme non può essere (facilmente) cambiato/migliorato. Questo è generalmente il caso dei i dati <code class="docutils literal notranslate"><span class="pre">public</span></code> e <code class="docutils literal notranslate"><span class="pre">protected</span></code>.</p>
</section>
<section id="id384">
<h4>Esempio<a class="headerlink" href="#id384" title="Link to this heading">¶</a></h4>
<p>Una classe può fornire due interfacce ai suoi utenti. Una per le classi derivate (<code class="docutils literal notranslate"><span class="pre">protected</span></code>) e  una per gli utenti generici (<code class="docutils literal notranslate"><span class="pre">public</span></code>). Ad esempio, ad una classe derivata potrebbe essere consentito di saltare un controllo a runtime perché ne è già garantita la correttezza:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Foo {
public:
    int bar(int x) { check(x); return do_bar(x); }
    // ...
protected:
    int do_bar(int x); // do some operation on the data
    // ...
private:
    // ... data ...
};

class Dir : public Foo {
    //...
    int mem(int x, int y)
    {
        /* ... do something ... */
        return do_bar(x + y); // OK: derived class can bypass check
    }
};

void user(Foo&amp; x)
{
    int r1 = x.bar(1);      // OK, will check
    int r2 = x.do_bar(2);   // error: would bypass check
    // ...
}
</pre></div>
</div>
</section>
<section id="id385">
<h4>Nota<a class="headerlink" href="#id385" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="#Rh-protected"><span class="xref myst">I dati <code class="docutils literal notranslate"><span class="pre">protected</span></code> sono una cattiva idea</span></a>.</p>
</section>
<section id="id386">
<h4>Nota<a class="headerlink" href="#id386" title="Link to this heading">¶</a></h4>
<p>Preferire l’ordine con i membri <code class="docutils literal notranslate"><span class="pre">public</span></code> prima dei membri <code class="docutils literal notranslate"><span class="pre">protected</span></code> prima dei membri <code class="docutils literal notranslate"><span class="pre">private</span></code>; vedere <a class="reference internal" href="#Rl-order"><span class="xref myst">NL.16</span></a>.</p>
</section>
<section id="id387">
<h4>Imposizione<a class="headerlink" href="#id387" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#Rh-protected"><span class="xref myst">Segnare i dati protected</span></a>.</p></li>
<li><p>Segnalare i mix di dati <code class="docutils literal notranslate"><span class="pre">public</span></code> e <code class="docutils literal notranslate"><span class="pre">private</span></code></p></li>
</ul>
</section>
</section>
<section id="c-concrete-concrete-types">
<h3><a name="SS-concrete"></a>C.concrete: Tipi concreti<a class="headerlink" href="#c-concrete-concrete-types" title="Link to this heading">¶</a></h3>
<p>Riepilogo delle regole sui tipi concreti:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rc-concrete"><span class="xref myst">C.10: Preferire i tipi concreti alle gerarchie di classi</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-regular"><span class="xref myst">C.11: Rendere concreti i tipi regolari</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-constref"><span class="xref myst">C.12: Non creare dati membro <code class="docutils literal notranslate"><span class="pre">const</span></code> o riferimenti in un tipo copiabile o spostabile [movable]</span></a></p></li>
</ul>
<section id="c-10-prefer-concrete-types-over-class-hierarchies">
<h4><a name="Rc-concrete"></a>C.10: Preferire i tipi concreti alle gerarchie di classi<a class="headerlink" href="#c-10-prefer-concrete-types-over-class-hierarchies" title="Link to this heading">¶</a></h4>
<section id="id388">
<h5>Motivo<a class="headerlink" href="#id388" title="Link to this heading">¶</a></h5>
<p>Un tipo concreto è fondamentalmente più semplice di un tipo in una classe: più facile da progettare, più facile da implementare, più facile da usare, più facile da ragionarci, più piccolo e più veloce. È necessario un motivo (caso d’uso) per usare una gerarchia.</p>
</section>
<section id="id389">
<h5>Esempio<a class="headerlink" href="#id389" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Point1 {
    int x, y;
    // ... operations ...
    // ... no virtual functions ...
};

class Point2 {
    int x, y;
    // ... operations, some virtual ...
    virtual ~Point2();
};

void use()
{
    Point1 p11 {1, 2};   // make an object on the stack
    Point1 p12 {p11};    // a copy

    auto p21 = make_unique&lt;Point2&gt;(1, 2);   // make an object on the free store
    auto p22 = p21-&gt;clone();                // make a copy
    // ...
}
</pre></div>
</div>
<p>Se una classe fa parte di una gerarchia, se ne devono modificare gli oggetti (nel codice reale se non necessariamente nei piccoli esempi) tramite i puntatori o i riferimenti. Ciò implica più uso della memoria, più allocazioni e deallocazioni e più lavoro a run-time per eseguire le indirezioni risultanti.</p>
</section>
<section id="id390">
<h5>Nota<a class="headerlink" href="#id390" title="Link to this heading">¶</a></h5>
<p>I tipi concreti si possono allocare sullo stack e possono essere membri di altre classi.</p>
</section>
<section id="id391">
<h5>Nota<a class="headerlink" href="#id391" title="Link to this heading">¶</a></h5>
<p>L’uso dell’indirezione è fondamentale per le interfacce polimorfiche a run-time. L’overhead non è l’allocazione/deallocazione (questo è solo il caso più comune). Possiamo usare una classe base come interfaccia di un oggetto nello scope di una classe derivata. Questo viene fatto laddove l’allocazione dinamica è proibita (p.es. hard-real-time) e per fornire un’interfaccia stabile a qualche tipo di plug-in.</p>
</section>
<section id="id392">
<h5>Imposizione<a class="headerlink" href="#id392" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="c-11-make-concrete-types-regular">
<h4><a name="Rc-regular"></a>C.11: Rendere concreti i tipi regolari<a class="headerlink" href="#c-11-make-concrete-types-regular" title="Link to this heading">¶</a></h4>
<section id="id393">
<h5>Motivo<a class="headerlink" href="#id393" title="Link to this heading">¶</a></h5>
<p>I tipi regolari sono più facili da capire e discutere dei tipi non regolari (l’irregolarità richiede uno sforzo aggiuntivo per capirli e usarli).</p>
<p>I tipi nativi del C++ sono regolari, così come lo sono le classi della libreria standard come <code class="docutils literal notranslate"><span class="pre">string</span></code>, <code class="docutils literal notranslate"><span class="pre">vector</span></code> e <code class="docutils literal notranslate"><span class="pre">map</span></code>. Le classi concrete senza assegnazione ed uguaglianza possono essere definite, ma sono (e dovrebbero essere) rare.</p>
</section>
<section id="id394">
<h5>Esempio<a class="headerlink" href="#id394" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Bundle {
    string name;
    vector&lt;Record&gt; vr;
};

bool operator==(const Bundle&amp; a, const Bundle&amp; b)
{
    return a.name == b.name &amp;&amp; a.vr == b.vr;
}

Bundle b1 { &quot;my bundle&quot;, {r1, r2, r3}};
Bundle b2 = b1;
if (!(b1 == b2)) error(&quot;impossible!&quot;);
b2.name = &quot;the other bundle&quot;;
if (b1 == b2) error(&quot;No!&quot;);
</pre></div>
</div>
<p>In particolare, se un tipo concreto è copiabile, è preferibile dargli anche un operatore di confronto per l’uguaglianza in modo da essere certi che <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code> implica <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code>.</p>
</section>
<section id="id395">
<h5>Nota<a class="headerlink" href="#id395" title="Link to this heading">¶</a></h5>
<p>Per le struct destinate ad essere condivise col codice C, la definizione di <code class="docutils literal notranslate"><span class="pre">operator==</span></code> potrebbe non essere fattibile.</p>
</section>
<section id="id396">
<h5>Nota<a class="headerlink" href="#id396" title="Link to this heading">¶</a></h5>
<p>Gli handle per le risorse che non si possono clonare, p.es., uno <code class="docutils literal notranslate"><span class="pre">scoped_lock</span></code> per un <code class="docutils literal notranslate"><span class="pre">mutex</span></code>, sono tipi concreti ma solitamente non possono essere copiati (mentre, di solito, possono essere spostati), quindi non possono essere regolari; tendono, invece, ad essere «move-only».</p>
</section>
<section id="id397">
<h5>Imposizione<a class="headerlink" href="#id397" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="c-12-don-t-make-data-members-const-or-references-in-a-copyable-or-movable-type">
<h4><a name="Rc-constref"></a>C.12: Non creare dati membro <code class="docutils literal notranslate"><span class="pre">const</span></code> o riferimenti in un tipo copiabile o spostabile [movable]<a class="headerlink" href="#c-12-don-t-make-data-members-const-or-references-in-a-copyable-or-movable-type" title="Link to this heading">¶</a></h4>
<section id="id398">
<h5>Motivo<a class="headerlink" href="#id398" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">const</span></code> e i membri dei dati di riferimento non sono utili in un tipo copiabile o spostabile e rendono tali tipi difficili da usare rendendoli almeno in parte non copiabili/non spostabili per ragioni subdole.</p>
</section>
<section id="id399">
<h5>Esempio; cattivo<a class="headerlink" href="#id399" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class bad {
    const int i;    // bad
    string&amp; s;      // bad
    // ...
};
</pre></div>
</div>
<p>I dati membro <code class="docutils literal notranslate"><span class="pre">const</span></code> e <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> rendono questa classe «only-sort-of-copyable» – costruibile per copia ma non assegnabile per copia.</p>
</section>
<section id="id400">
<h5>Nota<a class="headerlink" href="#id400" title="Link to this heading">¶</a></h5>
<p>Se è necessario che un membro punti a qualcosa, usare un puntatore (semplice o smart e <code class="docutils literal notranslate"><span class="pre">gsl::not_null</span></code> se non dev’essere null) anziché un riferimento.</p>
</section>
<section id="id401">
<h5>Imposizione<a class="headerlink" href="#id401" title="Link to this heading">¶</a></h5>
<p>Segnalare un dato membro che sia <code class="docutils literal notranslate"><span class="pre">const</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> o <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> in un tipo che ha un’operazione di copia o spostamento.</p>
</section>
</section>
</section>
<section id="c-ctor-constructors-assignments-and-destructors">
<h3><a name="S-ctor"></a>C.ctor: Costruttori, assegnazioni e distruttori<a class="headerlink" href="#c-ctor-constructors-assignments-and-destructors" title="Link to this heading">¶</a></h3>
<p>Queste funzioni controllano il ciclo di vita degli oggetti: creazione, copia, spostamento e distruzione. Definire i costruttori per garantire e semplificare l’inizializzazione delle classi.</p>
<p>Queste sono le <em>operazioni di default</em>:</p>
<ul class="simple">
<li><p>un costruttore di default: <code class="docutils literal notranslate"><span class="pre">X()</span></code></p></li>
<li><p>un costruttore copia: <code class="docutils literal notranslate"><span class="pre">X(const</span> <span class="pre">X&amp;)</span></code></p></li>
<li><p>un costruttore di assegnazione: <code class="docutils literal notranslate"><span class="pre">operator=(const</span> <span class="pre">X&amp;)</span></code></p></li>
<li><p>un costruttore di spostamento [move]: <code class="docutils literal notranslate"><span class="pre">X(X&amp;&amp;)</span></code></p></li>
<li><p>un’assegnazione di spostamento: <code class="docutils literal notranslate"><span class="pre">operator=(X&amp;&amp;)</span></code></p></li>
<li><p>un distruttore: <code class="docutils literal notranslate"><span class="pre">~X()</span></code></p></li>
</ul>
<p>Per default, il compilatore definisce ciascuna di queste operazioni se viene usato, ma è possibile sopprimere il default.</p>
<p>Le operazioni di default sono un insieme di operazioni che assieme implementano la semantica del ciclo di vita di un oggetto. Per default, il C++ tratta le classi come tipi simil-valore, ma non tutti i tipi sono come i valori.</p>
<p>Regole sull’insieme delle operazioni di default:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rc-zero"><span class="xref myst">C.20: Se si può evitare di definire operazioni di default, lo si faccia</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-five"><span class="xref myst">C.21: Se c’è la definizione o il <code class="docutils literal notranslate"><span class="pre">=delete</span></code> di qualsiasi funzione di copia, spostamento o distruzione, ci dev’essere la definizione o il <code class="docutils literal notranslate"><span class="pre">=delete</span></code> per tutte</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-matched"><span class="xref myst">C.22: Uniformare le operazioni di default</span></a></p></li>
</ul>
<p>Regole del distruttore:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rc-dtor"><span class="xref myst">C.30: Definire un distruttore se una classe necessita di un’azione esplicita alla distruzione di un oggetto</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-dtor-release"><span class="xref myst">C.31: Tutte le risorse acquisite da una classe devono essere rilasciate dal distruttore della classe</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-dtor-ptr"><span class="xref myst">C.32: Se una classe ha un puntatore [raw] (<code class="docutils literal notranslate"><span class="pre">T*</span></code>) o un riferimento (<code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>), si valuti se potrebbe essere proprietario</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-dtor-ptr2"><span class="xref myst">C.33: Se una classe ha un membro puntatore proprietario, definire un distruttore</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-dtor-virtual"><span class="xref myst">C.35: Il distruttore di una classe base dovrebbe essere sia public che virtual, oppure protected e non-virtual</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-dtor-fail"><span class="xref myst">C.36: Un distruttore non deve fallire</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-dtor-noexcept"><span class="xref myst">C.37: Creare i distruttori com <code class="docutils literal notranslate"><span class="pre">noexcept</span></code></span></a></p></li>
</ul>
<p>Regole del costruttore:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rc-ctor"><span class="xref myst">C.40: Definire un costruttore se una classe ha un invariante</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-complete"><span class="xref myst">C.41: Un costruttore dovrebbe creare un oggetto completamente inizializzato</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-throw"><span class="xref myst">C.42: Se un costruttore non è in grado di costruire un oggetto valido, generare un’eccezione</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-default0"><span class="xref myst">C.43: Accertarsi che una classe copiabile abbia un costruttore di default</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-default00"><span class="xref myst">C.44: È preferibile che i costruttori di default siano semplici e che non sollevino errori [non-throwing]</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-default"><span class="xref myst">C.45: Non definire un costruttore di default che inizializza solamente i dati membri; usare, invece, gli inizializzatori dei membri</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-explicit"><span class="xref myst">C.46: Per default, dichiarare costruttori ad argomento singolo con <code class="docutils literal notranslate"><span class="pre">explicit</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rc-order"><span class="xref myst">C.47: Definire e inizializzare i dati membro secondo l’ordine di dichiarazione dei membri</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-in-class-initializer"><span class="xref myst">C.48: Preferire gli inizializzatori membro di default agli inizializzatori membro nei costruttori per gli inizializzatori costanti</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-initialize"><span class="xref myst">C.49: Nei costruttori preferire l’inizializzazione alle assegnazioni</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-factory"><span class="xref myst">C.50: Usare una funzione factory se c’è bisogno di un «comportamento virtuale» durante l’inizializzazione</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-delegating"><span class="xref myst">C.51: Utilizzare i costruttori [delegating] per rappresentare azioni comuni a tutti i costruttori di una classe</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-inheriting"><span class="xref myst">C.52: Usare i costruttori ereditati per importare i costruttori in una classe derivata che non necessita di un ulteriore inizializzazione</span></a></p></li>
</ul>
<p>Regole di copia e spostamento [move]:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rc-copy-assignment"><span class="xref myst">C.60: Creare le assegnazioni di copia non-<code class="docutils literal notranslate"><span class="pre">virtual</span></code>, prendere il parametro con <code class="docutils literal notranslate"><span class="pre">const&amp;</span></code> e restituire con non-<code class="docutils literal notranslate"><span class="pre">const&amp;</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rc-copy-semantic"><span class="xref myst">C.61: Un’operazione di copia dovrebbe copiare</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-copy-self"><span class="xref myst">C.62: Rendere l’assegnazione di copia sicura in caso di auto-assegnazione</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-move-assignment"><span class="xref myst">C.63: Rendere l’assegnazione di spostamento [move] non-<code class="docutils literal notranslate"><span class="pre">virtual</span></code>, prendere il parametro con <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> e restituire con non-<code class="docutils literal notranslate"><span class="pre">const&amp;</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rc-move-semantic"><span class="xref myst">C.64: Un’operazione di [move] dovrebbe spostare e lasciare il sorgente in uno stato valido</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-move-self"><span class="xref myst">C.65: Rendere l’assegnazione con spostamento sicura per l’auto-assegnazione</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-move-noexcept"><span class="xref myst">C.66: Creare le operazioni di [move] come <code class="docutils literal notranslate"><span class="pre">noexcept</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rc-copy-virtual"><span class="xref myst">C.67: Una classe polimorfica dovrebbe sopprimere la copia/spostamento public</span></a></p></li>
</ul>
<p>Altre regole sulle operazioni di default:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rc-eqdefault"><span class="xref myst">C.80: Utilizzare <code class="docutils literal notranslate"><span class="pre">=default</span></code> se si deve essere espliciti sull’uso della semantica del default</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-delete"><span class="xref myst">C.81: Utilizzare <code class="docutils literal notranslate"><span class="pre">=delete</span></code> quando si vuol disabilitare il comportamento di default (senza volere un’alternativa)</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-ctor-virtual"><span class="xref myst">C.82: Non richiamare funzioni virtuali nei costruttori e nei distruttori</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-swap"><span class="xref myst">C.83: Per i tipi [value-like], si preveda di fornire una funzione di “swap” di tipo <code class="docutils literal notranslate"><span class="pre">noexcept</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rc-swap-fail"><span class="xref myst">C.84: Uno <code class="docutils literal notranslate"><span class="pre">swap</span></code> non deve fallire</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-swap-noexcept"><span class="xref myst">C.85: Rendere lo <code class="docutils literal notranslate"><span class="pre">swap</span></code> <code class="docutils literal notranslate"><span class="pre">noexcept</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rc-eq"><span class="xref myst">C.86: Creare lo <code class="docutils literal notranslate"><span class="pre">==</span></code> simmetrico rispetto ai tipi di operandi e <code class="docutils literal notranslate"><span class="pre">noexcept</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rc-eq-base"><span class="xref myst">C.87: Attenzione a <code class="docutils literal notranslate"><span class="pre">==</span></code> sulle classi base</span></a></p></li>
<li><p><a class="reference internal" href="#Rc-hash"><span class="xref myst">C.89: Rendere un <code class="docutils literal notranslate"><span class="pre">hash</span></code> <code class="docutils literal notranslate"><span class="pre">noexcept</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rc-memset"><span class="xref myst">C.90: Affidarsi ai costruttori e agli operatori di assegnazione, non a memset né a memcpy</span></a></p></li>
</ul>
</section>
<section id="c-defop-default-operations">
<h3><a name="SS-defop"></a>C.defop: Operazioni di Default<a class="headerlink" href="#c-defop-default-operations" title="Link to this heading">¶</a></h3>
<p>Per default, il linguaggio fornisce le operazioni di default con la loro semantica di default. Tuttavia, un programmatore può disabilitare o sostituire questi default.</p>
<section id="c-20-if-you-can-avoid-defining-default-operations-do">
<h4><a name="Rc-zero"></a>C.20: Se si può evitare di definire operazioni di default, lo si faccia<a class="headerlink" href="#c-20-if-you-can-avoid-defining-default-operations-do" title="Link to this heading">¶</a></h4>
<section id="id402">
<h5>Motivo<a class="headerlink" href="#id402" title="Link to this heading">¶</a></h5>
<p>È il più semplice e fornisce la semantica più pulita.</p>
</section>
<section id="id403">
<h5>Esempio<a class="headerlink" href="#id403" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Named_map {
public:
    // ... no default operations declared ...
private:
    string name;
    map&lt;int, int&gt; rep;
};

Named_map nm;        // default construct
Named_map nm2 {nm};  // copy construct
</pre></div>
</div>
<p>Dato che <code class="docutils literal notranslate"><span class="pre">std::map</span></code> e <code class="docutils literal notranslate"><span class="pre">string</span></code> hanno entrambe funzioni speciali, non c’è bisogno di altro.</p>
</section>
<section id="id404">
<h5>Nota<a class="headerlink" href="#id404" title="Link to this heading">¶</a></h5>
<p>Questa è conosciuta come «la regola dello zero».</p>
</section>
<section id="id405">
<h5>Imposizione<a class="headerlink" href="#id405" title="Link to this heading">¶</a></h5>
<p>(Non imponibile) Sebbene non imponibile, un buon analizzatore statico può rilevare schemi che segnalano un possibile miglioramento per soddisfare questa regola. Ad esempio, una classe con una coppia di membri (pointer, size) e un distruttore che esegue il <code class="docutils literal notranslate"><span class="pre">delete</span></code> del puntatore, probabilmente si potrebbe convertire in un <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</section>
</section>
<section id="c-21-if-you-define-or-delete-any-copy-move-or-destructor-function-define-or-delete-them-all">
<h4><a name="Rc-five"></a>C.21: Se c’è la definizione o il <code class="docutils literal notranslate"><span class="pre">=delete</span></code>  di qualsiasi funzione di copia, spostamento o distruzione, ci dev’essere la definizione o il <code class="docutils literal notranslate"><span class="pre">=delete</span></code> per tutte<a class="headerlink" href="#c-21-if-you-define-or-delete-any-copy-move-or-destructor-function-define-or-delete-them-all" title="Link to this heading">¶</a></h4>
<section id="id406">
<h5>Motivo<a class="headerlink" href="#id406" title="Link to this heading">¶</a></h5>
<p>Le semantiche per la copia, lo spostamento e la distruzione sono strettamente correlate, quindi se una dev’essere dichiarata, è probabile che anche le altre debbano essere considerate.</p>
<p>Dichiarando una qualsiasi funzione copia/spostamento/distruttore, anche se <code class="docutils literal notranslate"><span class="pre">=default</span></code> o <code class="docutils literal notranslate"><span class="pre">=delete</span></code>, sopprimerà la dichiarazione implicita di un costruttore di spostamento e di un operatore di assegnazione con spostamento. Dichiarando un costruttore [move] o un operatore di assegnazione [move], anche come <code class="docutils literal notranslate"><span class="pre">=default</span></code> o <code class="docutils literal notranslate"><span class="pre">=delete</span></code>, si farà in modo che la generazione implicita, di un costruttore copia o di un operatore di assegnazione, venga definita come cancellata. Quindi appena uno di questi viene dichiarato, dovrebbero essere dichiarati tutti gli altri per evitare effetti indesiderati come il trasformare tutti i potenziali spostamenti in più costose copie, o il rendere una classe [move-only].</p>
</section>
<section id="id407">
<h5>Esempio, cattivo<a class="headerlink" href="#id407" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct M2 {   // bad: incomplete set of copy/move/destructor operations
public:
    // ...
    // ... no copy or move operations ...
    ~M2() { delete[] rep; }
private:
    pair&lt;int, int&gt;* rep;  // zero-terminated set of pairs
};

void use()
{
    M2 x;
    M2 y;
    // ...
    x = y;   // the default assignment
    // ...
}
</pre></div>
</div>
<p>Dato che era necessaria una «attenzione speciale» per il distruttore (qui, per de-allocare), la probabilità che gli operatori di assegnazione di copia e spostamento, definiti entrambi implicitamente, siano corretti, è bassa (qui, ci sarebbe una doppia cancellazione).</p>
</section>
<section id="id408">
<h5>Nota<a class="headerlink" href="#id408" title="Link to this heading">¶</a></h5>
<p>Questa è nota come «la regola del cinque».</p>
</section>
<section id="id409">
<h5>Nota<a class="headerlink" href="#id409" title="Link to this heading">¶</a></h5>
<p>Se si vuole un’implementazione di default (mentre se ne definisce l’altra), si scriva <code class="docutils literal notranslate"><span class="pre">=default</span></code> per mostrare che lo si sta facendo intenzionalmente per questa funzione. Se non si vuole generare una funzione di default, la si sopprime con <code class="docutils literal notranslate"><span class="pre">=delete</span></code>.</p>
</section>
<section id="id410">
<h5>Esempio, buono<a class="headerlink" href="#id410" title="Link to this heading">¶</a></h5>
<p>Quando un distruttore dev’essere dichiarato solo per renderlo <code class="docutils literal notranslate"><span class="pre">virtual</span></code>, può essere definito come di default.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class AbstractBase {
public:
    virtual void foo() = 0;  // at least one abstract method to make the class abstract
    virtual ~AbstractBase() = default;
    // ...
};
</pre></div>
</div>
<p>Per evitare lo slicing come per la <a class="reference internal" href="#Rc-copy-virtual"><span class="xref myst">C.67</span></a>, rendere protect le operazioni di copia e spostamento oppure con <code class="docutils literal notranslate"><span class="pre">=delete</span></code>d e aggiungendo un <code class="docutils literal notranslate"><span class="pre">clone</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class CloneableBase {
public:
    virtual unique_ptr&lt;CloneableBase&gt; clone() const;
    virtual ~CloneableBase() = default;
    CloneableBase() = default;
    CloneableBase(const CloneableBase&amp;) = delete;
    CloneableBase&amp; operator=(const CloneableBase&amp;) = delete;
    CloneableBase(CloneableBase&amp;&amp;) = delete;
    CloneableBase&amp; operator=(CloneableBase&amp;&amp;) = delete;
    // ... other constructors and functions ...
};
</pre></div>
</div>
<p>Qui, definire solo le operazioni di [move] o solo quelle di copia, avrebbe lo stesso effetto, ma affermare esplicitamente l’intento per ciascun membro speciale, lo rende più palese al lettore.</p>
</section>
<section id="id411">
<h5>Nota<a class="headerlink" href="#id411" title="Link to this heading">¶</a></h5>
<p>I compilatori applicano gran parte di questa regola e, idealmente, avvertono di qualsiasi violazione.</p>
</section>
<section id="id412">
<h5>Nota<a class="headerlink" href="#id412" title="Link to this heading">¶</a></h5>
<p>Affidarsi ad un’operazione di copia, generata implicitamente, in una classe con un distruttore, è deprecato.</p>
</section>
<section id="id413">
<h5>Nota<a class="headerlink" href="#id413" title="Link to this heading">¶</a></h5>
<p>La scrittura di queste funzioni può essere esposta ad errori. Notare i tipi dei loro argomenti:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {
public:
    // ...
    virtual ~X() = default;               // destructor (virtual if X is meant to be a base class)
    X(const X&amp;) = default;                // copy constructor
    X&amp; operator=(const X&amp;) = default;     // copy assignment
    X(X&amp;&amp;) noexcept = default;            // move constructor
    X&amp; operator=(X&amp;&amp;) noexcept = default; // move assignment
};
</pre></div>
</div>
<p>Un errore minore (come uno di ortografia, tralasciando un <code class="docutils literal notranslate"><span class="pre">const</span></code>, usando <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> anziché <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> o tralasciando una funzione speciale ) può causare errori o warning. Per evitare il tedio e la possibilità di errori, provare a seguire la <a class="reference internal" href="#Rc-zero"><span class="xref myst">regola dello zero</span></a>.</p>
</section>
<section id="id414">
<h5>Imposizione<a class="headerlink" href="#id414" title="Link to this heading">¶</a></h5>
<p>(Semplice) Una classe dovrebbe avere una dichiarazione (anche un <code class="docutils literal notranslate"><span class="pre">=delete</span></code>) per tutte o per nessuna delle funzioni copia/spostamento/distruttore.</p>
</section>
</section>
<section id="c-22-make-default-operations-consistent">
<h4><a name="Rc-matched"></a>C.22: Uniformare le operazioni di default<a class="headerlink" href="#c-22-make-default-operations-consistent" title="Link to this heading">¶</a></h4>
<section id="id415">
<h5>Motivo<a class="headerlink" href="#id415" title="Link to this heading">¶</a></h5>
<p>Le operazioni di default sono concettualmente un insieme abbinato. La loro semantica è correlata. Gli utenti resteranno sorpresi se la costruzione copia/[move] e l’assegnazione copia/[move] fanno logicamente cose diverse. Gli utenti resteranno sorpresi se i costruttori e i distruttori non forniscono una vista coerente della gestione delle risorse. Gli utenti resteranno sorpresi se la copia e il [move] non riflettono il modo in cui funzionano i costruttori e i distruttori.</p>
</section>
<section id="id416">
<h5>Esempio, cattivo<a class="headerlink" href="#id416" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Silly {   // BAD: Inconsistent copy operations
    class Impl {
        // ...
    };
    shared_ptr&lt;Impl&gt; p;
public:
    Silly(const Silly&amp; a) : p(make_shared&lt;Impl&gt;()) { *p = *a.p; }   // deep copy
    Silly&amp; operator=(const Silly&amp; a) { p = a.p; return *this; }   // shallow copy
    // ...
};
</pre></div>
</div>
<p>Queste operazioni non concordano per la semantica della copia. Ciò porterà a confusione e bug.</p>
</section>
<section id="id417">
<h5>Imposizione<a class="headerlink" href="#id417" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Complesso) Un costruttore di copia/spostamento e il corrispondente operatore di assegnazione di copia/spostamento dovrebbero scrivere sugli stessi dati membri allo stesso livello di dereferenziazione.</p></li>
<li><p>(Complesso) Tutti i dati membri scritti in un costruttore di copia/spostamento devono essere inizializzati anche da tutti gli altri costruttori.</p></li>
<li><p>(Complesso) Se un costruttore di copia/spostamento esegue una copia «deep» [approfondita] di un dato membro, il distruttore dovrebbe modificare il dato membro.</p></li>
<li><p>(Complesso) Se un distruttore sta modificando un dato membro, tale dato membro deve essere scritto in qualsiasi costruttore di copia/spostamento e operatore di assegnazione.</p></li>
</ul>
</section>
</section>
</section>
<section id="c-dtor-destructors">
<h3><a name="SS-dtor"></a>C.dtor: Distruttori<a class="headerlink" href="#c-dtor-destructors" title="Link to this heading">¶</a></h3>
<p>«Questa classe necessita di un distruttore?» è una domanda sul design sorprendentemente perspicace. Per la maggior parte delle classi la risposta è «no» o perché la classe non ha risorse o perché la distruzione è gestita dal<a class="reference internal" href="#Rc-zero"><span class="xref myst">la regola dello zero</span></a>; cioè, i suoi membri possono prendersi cura di se stessi per quanto riguarda la distruzione. Se la risposta è «sì», ne consegue gran parte della progettazione della classe (cfr. <a class="reference internal" href="#Rc-five"><span class="xref myst">la regola del cinque</span></a>).</p>
<section id="c-30-define-a-destructor-if-a-class-needs-an-explicit-action-at-object-destruction">
<h4><a name="Rc-dtor"></a>C.30: Definire un distruttore se una classe necessita di un’azione esplicita alla distruzione di un oggetto<a class="headerlink" href="#c-30-define-a-destructor-if-a-class-needs-an-explicit-action-at-object-destruction" title="Link to this heading">¶</a></h4>
<section id="id418">
<h5>Motivo<a class="headerlink" href="#id418" title="Link to this heading">¶</a></h5>
<p>Un distruttore viene invocato implicitamente alla fine della vita di un oggetto. Se il distruttore di default è sufficiente, lo si utilizzi. Definire un distruttore non di default solo se una classe deve eseguire del codice che non fa già parte dei distruttori dei suoi membri.</p>
</section>
<section id="id419">
<h5>Esempio<a class="headerlink" href="#id419" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename A&gt;
struct final_action {   // slightly simplified
    A act;
    final_action(A a) : act{a} {}
    ~final_action() { act(); }
};

template&lt;typename A&gt;
final_action&lt;A&gt; finally(A act)   // deduce action type
{
    return final_action&lt;A&gt;{act};
}

void test()
{
    auto act = finally([] { cout &lt;&lt; &quot;Exit test\n&quot;; });  // establish exit action
    // ...
    if (something) return;   // act done here
    // ...
} // act done here
</pre></div>
</div>
<p>Lo scopo di <code class="docutils literal notranslate"><span class="pre">final_action</span></code> è quello di ottenere l’esecuzione di un pezzo di codice (solitamente una lambda) al momento della distruzione.</p>
</section>
<section id="id420">
<h5>Nota<a class="headerlink" href="#id420" title="Link to this heading">¶</a></h5>
<p>Ci sono due categorie generali di classi che richiedono un distruttore definito dall’utente:</p>
<ul class="simple">
<li><p>Una classe con una risorsa che non sia già rappresentata come una classe con un distruttore, p.es., un `vector o una classe di transazione.</p></li>
<li><p>Una classe che esiste principalmente per eseguire un’azione al momento della distruzione, come un tracer o un <code class="docutils literal notranslate"><span class="pre">final_action</span></code>.</p></li>
</ul>
</section>
<section id="id421">
<h5>Esempio, cattivo<a class="headerlink" href="#id421" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Foo {   // bad; use the default destructor
public:
    // ...
    ~Foo() { s = &quot;&quot;; i = 0; vi.clear(); }  // clean up
private:
    string s;
    int i;
    vector&lt;int&gt; vi;
};
</pre></div>
</div>
<p>Il distruttore di default lo fa meglio, più efficientemente e non può andare in errore.</p>
</section>
<section id="id422">
<h5>Imposizione<a class="headerlink" href="#id422" title="Link to this heading">¶</a></h5>
<p>Si cercano delle probabili «risorse implicite», come puntatori e riferimenti. Si cercano le classi con distruttori anche se tutti i loro dati membro hanno dei distruttori.</p>
</section>
</section>
<section id="c-31-all-resources-acquired-by-a-class-must-be-released-by-the-class-s-destructor">
<h4><a name="Rc-dtor-release"></a>C.31: Tutte le risorse acquisite da una classe devono essere rilasciate dal distruttore della classe<a class="headerlink" href="#c-31-all-resources-acquired-by-a-class-must-be-released-by-the-class-s-destructor" title="Link to this heading">¶</a></h4>
<section id="id423">
<h5>Motivo<a class="headerlink" href="#id423" title="Link to this heading">¶</a></h5>
<p>Prevenire i [leak] delle risorse, specialmente in caso di errore.</p>
</section>
<section id="id424">
<h5>Nota<a class="headerlink" href="#id424" title="Link to this heading">¶</a></h5>
<p>Per le risorse rappresentate come classi con un completo set di operazioni di default, ciò avviene automaticamente.</p>
</section>
<section id="id425">
<h5>Esempio<a class="headerlink" href="#id425" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {
    ifstream f;   // might own a file
    // ... no default operations defined or =deleted ...
};
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ifstream</span></code> di <code class="docutils literal notranslate"><span class="pre">X</span></code> chiude implicitamente qualsiasi file che potrebbe aver aperto alla distruzione del suo <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</section>
<section id="id426">
<h5>Esempio, cattivo<a class="headerlink" href="#id426" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X2 {     // bad
    FILE* f;   // might own a file
    // ... no default operations defined or =deleted ...
};
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">X2</span></code> potrebbe generare un [leak] da un handle del file.</p>
</section>
<section id="id427">
<h5>Nota<a class="headerlink" href="#id427" title="Link to this heading">¶</a></h5>
<p>Che dire di un socket che non viene chiuso? Un distruttore o un’operazione di chiusura o pulizia <a class="reference internal" href="#Rc-dtor-fail"><span class="xref myst">non dovrebbe mai fallire</span></a>. Se tuttavia capita, c’è un problema che non ha una soluzione completamente valida. Per cominciare, chi scrive un distruttore non sa perché il distruttore viene chiamato e non può «rifiutarsi di agire» lanciando un’eccezione. Si veda  la <a class="reference internal" href="#Sd-never-fail"><span class="xref myst">discussione</span></a>. A peggiorare il problema, molte operazioni di «chiusura/rilascio» non si possono rieseguire. In molti hanno cercato di risolvere questo problema, ma non è nota alcuna soluzione generale. Se possibile, considerare la mancata chiusura/pulizia un errore progettuale fondamentale e terminare.</p>
</section>
<section id="id428">
<h5>Nota<a class="headerlink" href="#id428" title="Link to this heading">¶</a></h5>
<p>Una classe può contenere puntatori e riferimenti a oggetti che non possiede. Ovviamente, tali oggetti non dovrebbero subire un <code class="docutils literal notranslate"><span class="pre">delete</span></code> da parte del distruttore della classe. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Preprocessor pp { /* ... */ };
Parser p { pp, /* ... */ };
Type_checker tc { p, /* ... */ };
</pre></div>
</div>
<p>Qui <code class="docutils literal notranslate"><span class="pre">p</span></code> fa riferimento a <code class="docutils literal notranslate"><span class="pre">pp</span></code> ma non lo possiede.</p>
</section>
<section id="id429">
<h5>Imposizione<a class="headerlink" href="#id429" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Semplice) Se una classe ha puntatori o membri di riferimento che sono proprietari (ad esempio, considerati proprietari utilizzando <code class="docutils literal notranslate"><span class="pre">gsl::owner</span></code>), allora è necessario fare riferimento ad essi nel suo distruttore.</p></li>
<li><p>(Difficile) Determinare se il puntatore o i membri di riferimento sono proprietari quando non esiste una dichiarazione esplicita di proprietà
(ad esempio, esaminando i costruttori).</p></li>
</ul>
</section>
</section>
<section id="c-32-if-a-class-has-a-raw-pointer-t-or-reference-t-consider-whether-it-might-be-owning">
<h4><a name="Rc-dtor-ptr"></a>C.32: Se una classe ha un puntatore [raw] (<code class="docutils literal notranslate"><span class="pre">T*</span></code>) o un riferimento (<code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>), si valuti se potrebbe essere proprietario<a class="headerlink" href="#c-32-if-a-class-has-a-raw-pointer-t-or-reference-t-consider-whether-it-might-be-owning" title="Link to this heading">¶</a></h4>
<section id="id430">
<h5>Motivo<a class="headerlink" href="#id430" title="Link to this heading">¶</a></h5>
<p>C’è tantissimo codice che non è specifico sulla proprietà [ownership].</p>
</section>
<section id="id431">
<h5>Esempio<a class="headerlink" href="#id431" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class legacy_class
{
    foo* m_owning;   // Bad: change to unique_ptr&lt;T&gt; or owner&lt;T*&gt;
    bar* m_observer; // OK: keep
}
</pre></div>
</div>
<p>L’unico modo per determinare la proprietà potrebbe essere l’analisi del codice.</p>
</section>
<section id="id432">
<h5>Nota<a class="headerlink" href="#id432" title="Link to this heading">¶</a></h5>
<p>La proprietà dovrebbe essere chiara nel nuovo codice (e nel codice legacy revisionato) secondo <a class="reference internal" href="#Rr-owner"><span class="xref myst">R.20</span></a> per puntatori proprietari e <a class="reference internal" href="#Rr-ptr"><span class="xref myst">R.3</span></a> per puntatori non proprietari.  I riferimenti non dovrebbero mai possedere <a class="reference internal" href="#Rr-ref"><span class="xref myst">R.4</span></a>.</p>
</section>
<section id="id433">
<h5>Imposizione<a class="headerlink" href="#id433" title="Link to this heading">¶</a></h5>
<p>Osservare l’inizializzazione dei puntatori membro e dei riferimenti ai membri e vedere se viene utilizzata un’allocazione.</p>
</section>
</section>
<section id="c-33-if-a-class-has-an-owning-pointer-member-define-a-destructor">
<h4><a name="Rc-dtor-ptr2"></a>C.33: Se una classe ha un membro puntatore proprietario, definire un distruttore<a class="headerlink" href="#c-33-if-a-class-has-an-owning-pointer-member-define-a-destructor" title="Link to this heading">¶</a></h4>
<section id="id434">
<h5>Motivo<a class="headerlink" href="#id434" title="Link to this heading">¶</a></h5>
<p>Un oggetto posseduto deve subire un <code class="docutils literal notranslate"><span class="pre">deleted</span></code> quando avviene la distruzione dell’oggetto che lo possiede.</p>
</section>
<section id="id435">
<h5>Esempio<a class="headerlink" href="#id435" title="Link to this heading">¶</a></h5>
<p>Un membro puntatore potrebbe rappresentare una risorsa. <a class="reference internal" href="#Rr-ptr"><span class="xref myst">Un <code class="docutils literal notranslate"><span class="pre">T*</span></code> non dovrebbe farlo</span></a>, ma nel vecchio codice, era una cosa comune. Si consideri un <code class="docutils literal notranslate"><span class="pre">T*</span></code> un possibile proprietario e quindi sospetto.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
class Smart_ptr {
    T* p;   // BAD: vague about ownership of *p
    // ...
public:
    // ... no user-defined default operations ...
};

void use(Smart_ptr&lt;int&gt; p1)
{
    // error: p2.p leaked (if not nullptr and not owned by some other code)
    auto p2 = p1;
}
</pre></div>
</div>
<p>Da notare che se si definisce un distruttore, si devono definire o cancellare [delete] <a class="reference internal" href="#Rc-five"><span class="xref myst">tutte le operazioni di default</span></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
class Smart_ptr2 {
    T* p;   // BAD: vague about ownership of *p
    // ...
public:
    // ... no user-defined copy operations ...
    ~Smart_ptr2() { delete p; }  // p is an owner!
};

void use(Smart_ptr2&lt;int&gt; p1)
{
    auto p2 = p1;   // error: double deletion
}
</pre></div>
</div>
<p>L’operazione copia di default eseguirà soltanto la copia di <code class="docutils literal notranslate"><span class="pre">p1.p</span></code> in <code class="docutils literal notranslate"><span class="pre">p2.p</span></code> portando ad una doppia distruzione di <code class="docutils literal notranslate"><span class="pre">p1.p</span></code>. Si deve essere espliciti sulla proprietà:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
class Smart_ptr3 {
    owner&lt;T*&gt; p;   // OK: explicit about ownership of *p
    // ...
public:
    // ...
    // ... copy and move operations ...
    ~Smart_ptr3() { delete p; }
};

void use(Smart_ptr3&lt;int&gt; p1)
{
    auto p2 = p1;   // OK: no double deletion
}
</pre></div>
</div>
</section>
<section id="id436">
<h5>Nota<a class="headerlink" href="#id436" title="Link to this heading">¶</a></h5>
<p>Spesso il modo più semplice per avere un distruttore è quello di sostituire il puntatore con uno smart pointer (p.es., <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code>) e lasciare che il compilatore ne organizzi opportunamente la distruzione implicita.</p>
</section>
<section id="id437">
<h5>Nota<a class="headerlink" href="#id437" title="Link to this heading">¶</a></h5>
<p>Perché non richiedere semplicemente che tutti i puntatori proprietari siano «smart pointer»? Ciò a volte richiederebbe modifiche non banali al codice e potrebbe influire sulle ABI.</p>
</section>
<section id="id438">
<h5>Imposizione<a class="headerlink" href="#id438" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Una classe con un dato membro puntatore è sospetta.</p></li>
<li><p>Una classe con un <code class="docutils literal notranslate"><span class="pre">owner&lt;T&gt;</span></code> dovrebbe definire le proprie operazioni di default.</p></li>
</ul>
</section>
</section>
<section id="c-35-a-base-class-destructor-should-be-either-public-and-virtual-or-protected-and-non-virtual">
<h4><a name="Rc-dtor-virtual"></a>C.35: Il distruttore di una classe base dovrebbe essere sia public che virtual, oppure protected e non-virtual<a class="headerlink" href="#c-35-a-base-class-destructor-should-be-either-public-and-virtual-or-protected-and-non-virtual" title="Link to this heading">¶</a></h4>
<section id="id439">
<h5>Motivo<a class="headerlink" href="#id439" title="Link to this heading">¶</a></h5>
<p>Per prevenire comportamenti indefiniti. Se il distruttore è pubblico, il codice chiamante può tentare di distruggere un oggetto derivato della classe tramite un puntatore alla classe base e il risultato è indefinito se il distruttore della classe base è non-virtual. Se il distruttore è protected, allora il codice chiamante non può distruggere tramite un puntatore alla classe base e il distruttore non deve necessariamente essere virtual; deve essere protected, non private, in modo che i distruttori derivati lo possano invocare. In generale, chi scrive una classe base non conosce l’azione appropriata da farsi al momento della distruzione.</p>
</section>
<section id="id440">
<h5>Discussione<a class="headerlink" href="#id440" title="Link to this heading">¶</a></h5>
<p>Cfr. <a class="reference internal" href="#Sd-dtor"><span class="xref myst">questo nella sezione Discussione</span></a>.</p>
</section>
<section id="id441">
<h5>Esempio, cattivo<a class="headerlink" href="#id441" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Base {  // BAD: implicitly has a public non-virtual destructor
    virtual void f();
};

struct D : Base {
    string s {&quot;a resource needing cleanup&quot;};
    ~D() { /* ... do some cleanup ... */ }
    // ...
};

void use()
{
    unique_ptr&lt;Base&gt; p = make_unique&lt;D&gt;();
    // ...
} // p&#39;s destruction calls ~Base(), not ~D(), which leaks D::s and possibly more
</pre></div>
</div>
</section>
<section id="id442">
<h5>Nota<a class="headerlink" href="#id442" title="Link to this heading">¶</a></h5>
<p>Una funzione virtuale definisce un’interfaccia per le classi derivate che possono essere utilizzate senza guardare le classi derivate. Se l’interfaccia consente la distruzione, dovrebbe essere sicuro farlo.</p>
</section>
<section id="id443">
<h5>Nota<a class="headerlink" href="#id443" title="Link to this heading">¶</a></h5>
<p>Un distruttore deve essere non-private altrimenti se ne impedirà l’uso, per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {
    ~X();   // private destructor
    // ...
};

void use()
{
    X a;                        // error: cannot destroy
    auto p = make_unique&lt;X&gt;();  // error: cannot destroy
}
</pre></div>
</div>
</section>
<section id="id444">
<h5>Eccezione<a class="headerlink" href="#id444" title="Link to this heading">¶</a></h5>
<p>Possiamo immaginare un caso in cui si potrebbe volere un distruttore virtuale protetto: Quando un oggetto di un tipo derivato (e solo di questo tipo) dovrebbe poter distruggere <em>un altro</em> oggetto (non se stesso) tramite un puntatore alla base. Tuttavia, non si è mai visto un caso del genere in pratica.</p>
</section>
<section id="id445">
<h5>Imposizione<a class="headerlink" href="#id445" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Una classe con una qualsiasi funzione virtuale dovrebbe avere un distruttore o pubblico e virtuale oppure protetto e non-virtuale.</p></li>
<li><p>Se una classe discende pubblicamente da una classe base, la classe base dovrebbe avere un distruttore pubblico e virtuale oppure protetto e non virtuale.</p></li>
</ul>
</section>
</section>
<section id="c-36-a-destructor-must-not-fail">
<h4><a name="Rc-dtor-fail"></a>C.36: Un distruttore non deve fallire<a class="headerlink" href="#c-36-a-destructor-must-not-fail" title="Link to this heading">¶</a></h4>
<section id="id446">
<h5>Motivo<a class="headerlink" href="#id446" title="Link to this heading">¶</a></h5>
<p>In generale non sappiamo come scrivere un codice privo di errori se un distruttore dovesse fallire. La libreria standard richiede che tutte le classi con cui ha a che fare abbiano distruttori che sollevino eccezioni [throw].</p>
</section>
<section id="id447">
<h5>Esempio<a class="headerlink" href="#id447" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {
public:
    ~X() noexcept;
    // ...
};

X::~X() noexcept
{
    // ...
    if (cannot_release_a_resource) terminate();
    // ...
}
</pre></div>
</div>
</section>
<section id="id448">
<h5>Nota<a class="headerlink" href="#id448" title="Link to this heading">¶</a></h5>
<p>In molti hanno cercato di escogitare uno schema infallibile per affrontare i fallimenti nei distruttori. Nessuno è riuscito a elaborare uno schema generale. Questo può essere un vero problema nella pratica: Ad esempio, che dire di un socket che non si chiude? Chi scrive un distruttore non sa perché viene chiamato e non può fa sì che si «rifiuti di agire» lanciando un’eccezione. Si veda  la <a class="reference internal" href="#Sd-never-fail"><span class="xref myst">discussione</span></a>. A peggiorare il problema, molte operazioni di «chiusura/rilascio» non si possono rieseguire. Se possibile, considerare la mancata chiusura/pulizia un errore progettuale fondamentale e terminare.</p>
</section>
<section id="id449">
<h5>Nota<a class="headerlink" href="#id449" title="Link to this heading">¶</a></h5>
<p>Dichiarare un distruttore <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>. Ciò garantirà il normale completamento o la terminazione del programma.</p>
</section>
<section id="id450">
<h5>Nota<a class="headerlink" href="#id450" title="Link to this heading">¶</a></h5>
<p>Se una risorsa non può essere rilasciata e il programma non deve fallire, si provi a segnalare l’errore al resto del sistema in qualche modo (forse anche modificando qualche stato globale e sperando che qualcosa si accorga e sia in grado di provvedere). Bisogna essere pienamente consapevoli del fatto che questa tecnica è particolare e soggetta a errori. Si consideri l’esempio: «la mia connessione non si chiuderà». Probabilmente c’è un problema all’altra estremità della connessione e solo un pezzo di codice responsabile di entrambe le estremità della connessione può gestire correttamente il problema. Il distruttore potrebbe inviare un messaggio (in qualche modo) alla parte responsabile del sistema, assumere di aver chiuso la connessione e tornare normalmente.</p>
</section>
<section id="id451">
<h5>Nota<a class="headerlink" href="#id451" title="Link to this heading">¶</a></h5>
<p>Se un distruttore usa operazioni che potrebbero non riuscire, può rilevare le eccezioni e, in qualche caso, completare comunque correttamente (p.es., utilizzando un meccanismo diverso da quello che è andato in errore).</p>
</section>
<section id="id452">
<h5>Imposizione<a class="headerlink" href="#id452" title="Link to this heading">¶</a></h5>
<p>(Semplice) Un distruttore dovrebbe essere dichiarato <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> se può andare in errore.</p>
</section>
</section>
<section id="c-37-make-destructors-noexcept">
<h4><a name="Rc-dtor-noexcept"></a>C.37: Creare i distruttori come <code class="docutils literal notranslate"><span class="pre">noexcept</span></code><a class="headerlink" href="#c-37-make-destructors-noexcept" title="Link to this heading">¶</a></h4>
<section id="id453">
<h5>Motivo<a class="headerlink" href="#id453" title="Link to this heading">¶</a></h5>
<p><a class="reference internal" href="#Rc-dtor-fail"><span class="xref myst">Un distruttore non deve fallire</span></a>. Se un distruttore tenta di uscire con un’eccezione, si tratta di un errore di progettazione e sarebbe meglio che il programma terminasse.</p>
</section>
<section id="id454">
<h5>Nota<a class="headerlink" href="#id454" title="Link to this heading">¶</a></h5>
<p>Un distruttore (sia «user-defined» che generato dal compilatore) è implicitamente dichiarato <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> (indipendentemente dal codice) se tutti i membri della sua classe hanno distruttori <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>. Segnando esplicitamente i distruttori con <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>, un autore si tutela dal fatto che il distruttore possa diventare implicitamente <code class="docutils literal notranslate"><span class="pre">noexcept(false)</span></code> aggiungendo o modificando un membro della classe.</p>
</section>
<section id="id455">
<h5>Esempio<a class="headerlink" href="#id455" title="Link to this heading">¶</a></h5>
<p>Non tutti i distruttori sono noexcept per default; un membro che possa lanciare un’eccezione [throwing] avvelena tutta la gerarchia della classe</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct X {
    Details x;  // happens to have a throwing destructor
    // ...
    ~X() { }    // implicitly noexcept(false); aka can throw
};
</pre></div>
</div>
<p>Quindi, in caso di dubbio, dichiarare un distruttore noexcept.</p>
</section>
<section id="id456">
<h5>Nota<a class="headerlink" href="#id456" title="Link to this heading">¶</a></h5>
<p>Perché non dichiarare quindi tutti i distruttori noexcept? Perché in molti casi questo – specialmente nei casi semplici – potrebbe generare disordine.</p>
</section>
<section id="id457">
<h5>Imposizione<a class="headerlink" href="#id457" title="Link to this heading">¶</a></h5>
<p>(Semplice) Un distruttore dovrebbe essere dichiarato <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> se può andare in errore.</p>
</section>
</section>
</section>
<section id="c-ctor-constructors">
<h3><a name="SS-ctor"></a>C.ctor: Costruttori<a class="headerlink" href="#c-ctor-constructors" title="Link to this heading">¶</a></h3>
<p>Un costruttore definisce come un oggetto viene inizializzato (costruito).</p>
<section id="c-40-define-a-constructor-if-a-class-has-an-invariant">
<h4><a name="Rc-ctor"></a>C.40: Definire un costruttore se una classe ha un invariante<a class="headerlink" href="#c-40-define-a-constructor-if-a-class-has-an-invariant" title="Link to this heading">¶</a></h4>
<section id="id458">
<h5>Motivo<a class="headerlink" href="#id458" title="Link to this heading">¶</a></h5>
<p>Ecco a cosa servono i costruttori.</p>
</section>
<section id="id459">
<h5>Esempio<a class="headerlink" href="#id459" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Date {  // a Date represents a valid date
              // in the January 1, 1900 to December 31, 2100 range
    Date(int dd, int mm, int yy)
        :d{dd}, m{mm}, y{yy}
    {
        if (!is_valid(d, m, y)) throw Bad_date{};  // enforce invariant
    }
    // ...
private:
    int d, m, y;
};
</pre></div>
</div>
<p>Spesso è una buona idea esprimere l’invariante come una <code class="docutils literal notranslate"><span class="pre">Ensures</span></code> sul costruttore.</p>
</section>
<section id="id460">
<h5>Nota<a class="headerlink" href="#id460" title="Link to this heading">¶</a></h5>
<p>Un costruttore può essere utilizzato per comodità anche se una classe non ha un invariante. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Rec {
    string s;
    int i {0};
    Rec(const string&amp; ss) : s{ss} {}
    Rec(int ii) :i{ii} {}
};

Rec r1 {7};
Rec r2 {&quot;Foo bar&quot;};
</pre></div>
</div>
</section>
<section id="id461">
<h5>Nota<a class="headerlink" href="#id461" title="Link to this heading">¶</a></h5>
<p>La regola della lista di inizializzatori del C++11 elimina la necessità di molti costruttori. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Rec2{
    string s;
    int i;
    Rec2(const string&amp; ss, int ii = 0) :s{ss}, i{ii} {}   // redundant
};

Rec2 r1 {&quot;Foo&quot;, 7};
Rec2 r2 {&quot;Bar&quot;};
</pre></div>
</div>
<p>Il costruttore di <code class="docutils literal notranslate"><span class="pre">Rec2</span></code> è ridondante. Inoltre, il valore di default per <code class="docutils literal notranslate"><span class="pre">int</span></code> sarebbe meglio se fosse un <a class="reference internal" href="#Rc-in-class-initializer"><span class="xref myst">inizializzatore di membro di default</span></a>.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Rc-complete"><span class="xref myst">costruire oggetti validi</span></a> e <a class="reference internal" href="#Rc-throw"><span class="xref myst">eccezioni nei costruttori</span></a>.</p>
</section>
<section id="id462">
<h5>Imposizione<a class="headerlink" href="#id462" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Contrassegnare le classi con operazioni di copia user-defined ma senza costruttore (una copia user-defined è un buon indicatore del fatto che la classe ha un invariante)</p></li>
</ul>
</section>
</section>
<section id="c-41-a-constructor-should-create-a-fully-initialized-object">
<h4><a name="Rc-complete"></a>C.41: Un costruttore dovrebbe creare un oggetto completamente inizializzato<a class="headerlink" href="#c-41-a-constructor-should-create-a-fully-initialized-object" title="Link to this heading">¶</a></h4>
<section id="id463">
<h5>Motivo<a class="headerlink" href="#id463" title="Link to this heading">¶</a></h5>
<p>Un costruttore stabilisce l’invariante per una classe. L’utilizzatore di una classe dovrebbe poter supporre che un oggetto costruito è utilizzabile.</p>
</section>
<section id="id464">
<h5>Esempio, cattivo<a class="headerlink" href="#id464" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X1 {
    FILE* f;   // call init() before any other function
    // ...
public:
    X1() {}
    void init();   // initialize f
    void read();   // read from f
    // ...
};

void f()
{
    X1 file;
    file.read();   // crash or bad read!
    // ...
    file.init();   // too late
    // ...
}
</pre></div>
</div>
<p>I compilatori non leggono i commenti.</p>
</section>
<section id="id465">
<h5>Eccezione<a class="headerlink" href="#id465" title="Link to this heading">¶</a></h5>
<p>Se una classe non può convenientemente costruire un oggetto valido, <a class="reference internal" href="#Rc-factory"><span class="xref myst">si usa una funzione factory</span></a>.</p>
</section>
<section id="id466">
<h5>Imposizione<a class="headerlink" href="#id466" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Semplice) Ogni costruttore dovrebbe inizializzare ogni dato membro (esplicitamente, tramite una chiamata ctor delegante o tramite costruttore di default).</p></li>
<li><p>(Ignoto) Se un costruttore ha un contratto <code class="docutils literal notranslate"><span class="pre">Ensures</span></code>, provare a vedere se vale come post-condizione.</p></li>
</ul>
</section>
<section id="id467">
<h5>Nota<a class="headerlink" href="#id467" title="Link to this heading">¶</a></h5>
<p>Se un costruttore acquisisce una risorsa (per creare un oggetto valido), tale risorsa deve essere <a class="reference internal" href="#Rc-dtor-release"><span class="xref myst">rilasciata dal distruttore</span></a>. L’idioma dell’avere dei costruttori che acquisiscono risorse e distruttori che le rilasciano è detto <a class="reference internal" href="#Rr-raii"><span class="xref myst">RAII</span></a> («Resource Acquisition Is Initialization»).</p>
</section>
</section>
<section id="c-42-if-a-constructor-cannot-construct-a-valid-object-throw-an-exception">
<h4><a name="Rc-throw"></a>C.42: Se un costruttore non è in grado di costruire un oggetto valido, generare un’eccezione<a class="headerlink" href="#c-42-if-a-constructor-cannot-construct-a-valid-object-throw-an-exception" title="Link to this heading">¶</a></h4>
<section id="id468">
<h5>Motivo<a class="headerlink" href="#id468" title="Link to this heading">¶</a></h5>
<p>Lasciare un oggetto invalido vuol dire andarsi a cercare i problemi.</p>
</section>
<section id="id469">
<h5>Esempio<a class="headerlink" href="#id469" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X2 {
    FILE* f;
    // ...
public:
    X2(const string&amp; name)
        :f{fopen(name.c_str(), &quot;r&quot;)}
    {
        if (!f) throw runtime_error{&quot;could not open&quot; + name};
        // ...
    }

    void read();      // read from f
    // ...
};

void f()
{
    X2 file {&quot;Zeno&quot;}; // throws if file isn&#39;t open
    file.read();      // fine
    // ...
}
</pre></div>
</div>
</section>
<section id="id470">
<h5>Esempio, cattivo<a class="headerlink" href="#id470" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X3 {     // bad: the constructor leaves a non-valid object behind
    FILE* f;   // call is_valid() before any other function
    bool valid;
    // ...
public:
    X3(const string&amp; name)
        :f{fopen(name.c_str(), &quot;r&quot;)}, valid{false}
    {
        if (f) valid = true;
        // ...
    }

    bool is_valid() { return valid; }
    void read();   // read from f
    // ...
};

void f()
{
    X3 file {&quot;Heraclides&quot;};
    file.read();   // crash or bad read!
    // ...
    if (file.is_valid()) {
        file.read();
        // ...
    }
    else {
        // ... handle error ...
    }
    // ...
}
</pre></div>
</div>
</section>
<section id="id471">
<h5>Nota<a class="headerlink" href="#id471" title="Link to this heading">¶</a></h5>
<p>Per una definizione di una variabile (p-es., sullo stack o come membro di un altro oggetto) non esiste alcuna esplicita chiamata a funzione da cui si possa restituire un codice d’errore. Lasciarsi dietro un oggetto invalido e affidarsi agli utilizzatori che verifichino costantemente la funzione <code class="docutils literal notranslate"><span class="pre">is_valid()</span></code> prima di usarlo è noioso, soggetto a errori ed inefficiente.</p>
</section>
<section id="id472">
<h5>Eccezione<a class="headerlink" href="#id472" title="Link to this heading">¶</a></h5>
<p>Esistono domini, come alcuni sistemi in stretto real-time (si pensi ai controlli di un aereo) in cui (senza il supporto di strumenti aggiuntivi) la gestione delle eccezioni non è sufficientemente prevedibile da un punto di vista temporale. Lì deve essere utilizzata la tecnica <code class="docutils literal notranslate"><span class="pre">is_valid()</span></code>. In tali casi, controllare <code class="docutils literal notranslate"><span class="pre">is_valid()</span></code> spesso e simulare immediatamente il <a class="reference internal" href="#Rr-raii"><span class="xref myst">RAII</span></a>.</p>
</section>
<section id="id473">
<h5>Alternativa<a class="headerlink" href="#id473" title="Link to this heading">¶</a></h5>
<p>Se si è tentati di usare qualche semantica [idiom] di «inizializzazione post-costruttore» o «inizializzazione a due fasi», si desista. Se proprio si deve fare, si cerchi tra le <a class="reference internal" href="#Rc-factory"><span class="xref myst">funzioni factory</span></a>.</p>
</section>
<section id="id474">
<h5>Nota<a class="headerlink" href="#id474" title="Link to this heading">¶</a></h5>
<p>Uno dei motivi per cui le persone hanno usato le funzioni <code class="docutils literal notranslate"><span class="pre">init()</span></code> anziché inizializzare direttamente nel costruttore è stato quello di evitare la replicazione del codice. <a class="reference internal" href="#Rc-delegating"><span class="xref myst">I costruttori delegating</span></a> e <a class="reference internal" href="#Rc-in-class-initializer"><span class="xref myst">l’inizializzazione di default dei membri</span></a> lo fanno meglio. Un’altra ragione è stata quella di ritardare l’inizializzazione finché non fosse stato necessario avere un oggetto; spesso la soluzione a ciò è <a class="reference internal" href="#Res-init"><span class="xref myst">non dichiarare una variabile finché non possa essere adeguatamente inizializzata</span></a></p>
</section>
<section id="id475">
<h5>Imposizione<a class="headerlink" href="#id475" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="c-43-ensure-that-a-copyable-class-has-a-default-constructor">
<h4><a name="Rc-default0"></a>C.43: Accertarsi che una classe copiabile abbia un costruttore di default<a class="headerlink" href="#c-43-ensure-that-a-copyable-class-has-a-default-constructor" title="Link to this heading">¶</a></h4>
<section id="id476">
<h5>Motivo<a class="headerlink" href="#id476" title="Link to this heading">¶</a></h5>
<p>Ovvero, assicurarsi che se una classe concreta è copiabile, soddisfi anche il resto di «semi-regolare».</p>
<p>Molti linguaggi e strutture di librerie si affidano ai costruttori di default per inizializzare i propri elementi, p.es. <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">a[10]</span></code> e <code class="docutils literal notranslate"><span class="pre">std::vector&lt;T&gt;</span> <span class="pre">v(10)</span></code>. Un costruttore di default spesso semplifica il compito di definire uno <a class="reference internal" href="#???"><span class="xref myst">stato di spostato</span></a> adatto per un tipo che sia anche copiabile.</p>
</section>
<section id="id477">
<h5>Esempio<a class="headerlink" href="#id477" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Date { // BAD: no default constructor
public:
    Date(int dd, int mm, int yyyy);
    // ...
};

vector&lt;Date&gt; vd1(1000);   // default Date needed here
vector&lt;Date&gt; vd2(1000, Date{7, Month::October, 1885});   // alternative
</pre></div>
</div>
<p>Il costruttore di default viene auto-generato solo se non c’è un costruttore dichiarato dall’utente, quindi è impossibile inizializzare il vettore <code class="docutils literal notranslate"><span class="pre">vd1</span></code> nell’esempio precedente. L’assenza di un valore di default può riservare delle sorprese agli utenti e complicarne l’uso, quindi se lo si può ragionevolmente definire, lo si faccia.</p>
<p>Si è scelto <code class="docutils literal notranslate"><span class="pre">Date</span></code> per incoraggiare il pensiero: Non c’è alcuna data di default «naturale» (il big bang è troppo lontano nel tempo per essere utile per la maggior parte delle persone), quindi questo esempio non è banale. <code class="docutils literal notranslate"><span class="pre">{0,</span> <span class="pre">0,</span> <span class="pre">0}</span></code> non è una data valida nella maggior parte dei sistemi di calendari, quindi si sceglie quello che potrebbe assomigliare al <code class="docutils literal notranslate"><span class="pre">NaN</span></code> dei numeri a virgola mobile. Tuttavia, la maggior parte delle classi <code class="docutils literal notranslate"><span class="pre">Date</span></code> realistiche hanno una «data iniziale» (p.es. è famoso il 1 gennaio 1970), quindi averla come default è solitamente ovvio.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Date {
public:
    Date(int dd, int mm, int yyyy);
    Date() = default; // [See also](#Rc-default)
    // ...
private:
    int dd {1};
    int mm {1};
    int yyyy {1970};
    // ...
};

vector&lt;Date&gt; vd1(1000);
</pre></div>
</div>
</section>
<section id="id478">
<h5>Nota<a class="headerlink" href="#id478" title="Link to this heading">¶</a></h5>
<p>Una classe con membri che abbiano tutti costruttori di default, ottiene implicitamente un costruttore di default:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct X {
    string s;
    vector&lt;int&gt; v;
};

X x; // means X{ { }, { } }; that is the empty string and the empty vector
</pre></div>
</div>
<p>Attenzione che i tipi [built-in] non vengono correttamente costruiti di default:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct X {
    string s;
    int i;
};

void f()
{
    X x;    // x.s is initialized to the empty string; x.i is uninitialized

    cout &lt;&lt; x.s &lt;&lt; &#39; &#39; &lt;&lt; x.i &lt;&lt; &#39;\n&#39;;
    ++x.i;
}
</pre></div>
</div>
<p>Gli oggetti allocati staticamente di tipo [built-in] vengono per default inizializzati a <code class="docutils literal notranslate"><span class="pre">0</span></code>, ma non le variabili locali di tipo [built-in]. Attenzione che il compilatore potrebbe inizializzare per default le variabili locali di tipo [built-in], mentre una compilazione ottimizzata non lo farà. Pertanto, codice simile a quello dell’esempio precedente potrebbe sembrare funzionante, ma si basa su un comportamento indefinito. Assumendo che si voglia un’inizializzazione, un’inizializzazione esplicita di default può essere d’aiuto:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct X {
    string s;
    int i {};   // default initialize (to 0)
};
</pre></div>
</div>
</section>
<section id="id479">
<h5>Note<a class="headerlink" href="#id479" title="Link to this heading">¶</a></h5>
<p>Le classi che non hanno una ragionevole costruzione di default sono solitamente anche non copiabili, quindi non rientrano in questa linea-guida.</p>
<p>Per esempio, una classe base non dovrebbe essere copiabile e quindi non necessita obbligatoriamente di un costruttore di default:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Shape is an abstract base class, not a copyable type.
// It might or might not need a default constructor.
struct Shape {
    virtual void draw() = 0;
    virtual void rotate(int) = 0;
    // =delete copy/move functions
    // ...
};
</pre></div>
</div>
<p>Una classe che deve acquisire una risorsa fornita dal chiamante durante la costruzione spesso non può avere un costruttore di default, ma non rientra in questa linea-guida poiché tale classe di solito non è comunque copiabile:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// std::lock_guard is not a copyable type.
// It does not have a default constructor.
lock_guard g {mx};  // guard the mutex mx
lock_guard g2;      // error: guarding nothing
</pre></div>
</div>
<p>Una classe che ha uno «stato speciale» che deve essere gestito separatamente dagli altri stati dalle funzioni membro o dagli utenti provoca un lavoro extra (e molto probabilmente più errori). Tale tipo può naturalmente usare lo stato speciale come valore costruito di default, indipendentemente dal fatto che sia o meno copiabile:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// std::ofstream is not a copyable type.
// It does happen to have a default constructor
// that goes along with a special &quot;not open&quot; state.
ofstream out {&quot;Foobar&quot;};
// ...
out &lt;&lt; log(time, transaction);
</pre></div>
</div>
<p>I tipi similari di stati speciali che sono copiabili, ad esempio i puntatori smart copiabili che hanno lo stato speciale «==nullptr», devono utilizzare lo stato speciale come il valore di default nel costruttore.</p>
<p>Tuttavia, è preferibile avere un default per un costruttore di default anziché uno stato significativo come per le <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> delle <code class="docutils literal notranslate"><span class="pre">std::string</span></code> e per i <code class="docutils literal notranslate"><span class="pre">{}</span></code> dei <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>.</p>
</section>
<section id="id480">
<h5>Imposizione<a class="headerlink" href="#id480" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare le classi che siano copiabili con <code class="docutils literal notranslate"><span class="pre">=</span></code> senza un costruttore di default</p></li>
<li><p>Segnalare le classi che sono confrontabili con <code class="docutils literal notranslate"><span class="pre">==</span></code> ma non copiabili</p></li>
</ul>
</section>
</section>
<section id="c-44-prefer-default-constructors-to-be-simple-and-non-throwing">
<h4><a name="Rc-default00"></a>C.44: È preferibile che i costruttori di default siano semplici e che non sollevino errori [non-throwing]<a class="headerlink" href="#c-44-prefer-default-constructors-to-be-simple-and-non-throwing" title="Link to this heading">¶</a></h4>
<section id="id481">
<h5>Motivo<a class="headerlink" href="#id481" title="Link to this heading">¶</a></h5>
<p>Essere in grado di impostare un valore ad «un default» senza le operazioni che possono fallire semplifica la gestione degli errori e il ragionamento sulle operazioni di [move].</p>
</section>
<section id="example-problematic">
<h5>Esempio, problematico<a class="headerlink" href="#example-problematic" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
// elem points to space-elem element allocated using new
class Vector0 {
public:
    Vector0() :Vector0{0} {}
    Vector0(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}
    // ...
private:
    own&lt;T*&gt; elem;
    T* space;
    T* last;
};
</pre></div>
</div>
<p>Questo va bene ed è generale, ma impostare un <code class="docutils literal notranslate"><span class="pre">Vector0</span></code> a vuoto dopo un errore implica un’allocazione, che potrebbe non riuscire. Inoltre, avere un <code class="docutils literal notranslate"><span class="pre">Vector</span></code> di default rappresentato come <code class="docutils literal notranslate"><span class="pre">{new</span> <span class="pre">T[0],</span> <span class="pre">0,</span> <span class="pre">0}</span></code> sembra dispendioso. Per esempio, <code class="docutils literal notranslate"><span class="pre">Vector0&lt;int&gt;</span> <span class="pre">v[100]</span></code> costa 100 allocazioni.</p>
</section>
<section id="id482">
<h5>Esempio<a class="headerlink" href="#id482" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
// elem is nullptr or elem points to space-elem element allocated using new
class Vector1 {
public:
    // sets the representation to {nullptr, nullptr, nullptr}; doesn&#39;t throw
    Vector1() noexcept {}
    Vector1(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}
    // ...
private:
    own&lt;T*&gt; elem {};
    T* space {};
    T* last {};
};
</pre></div>
</div>
<p>L’uso di <code class="docutils literal notranslate"><span class="pre">{nullptr,</span> <span class="pre">nullptr,</span> <span class="pre">nullptr}</span></code> rende <code class="docutils literal notranslate"><span class="pre">Vector1{}</span></code> economico, ma è un caso speciale ed implica dei controlli a run-time. Impostare un <code class="docutils literal notranslate"><span class="pre">Vector1</span></code> a vuoto dopo aver rilevato un errore è banale.</p>
</section>
<section id="id483">
<h5>Imposizione<a class="headerlink" href="#id483" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare i costruttori di default che possono sollevare errori</p></li>
</ul>
</section>
</section>
<section id="c-45-don-t-define-a-default-constructor-that-only-initializes-data-members-use-default-member-initializers-instead">
<h4><a name="Rc-default"></a>C.45: Non definire un costruttore di default che inizializza solamente i dati membri; usare, invece, gli inizializzatori dei membri<a class="headerlink" href="#c-45-don-t-define-a-default-constructor-that-only-initializes-data-members-use-default-member-initializers-instead" title="Link to this heading">¶</a></h4>
<section id="id484">
<h5>Motivo<a class="headerlink" href="#id484" title="Link to this heading">¶</a></h5>
<p>L’uso degli inizializzatori dei membri di default consente al compilatore di generare la funzione. La funzione generata dal compilatore può essere più efficiente.</p>
</section>
<section id="id485">
<h5>Esempio, cattivo<a class="headerlink" href="#id485" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X1 { // BAD: doesn&#39;t use member initializers
    string s;
    int i;
public:
    X1() :s{&quot;default&quot;}, i{1} { }
    // ...
};
</pre></div>
</div>
</section>
<section id="id486">
<h5>Esempio<a class="headerlink" href="#id486" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X2 {
    string s {&quot;default&quot;};
    int i {1};
public:
    // use compiler-generated default constructor
    // ...
};
</pre></div>
</div>
</section>
<section id="id487">
<h5>Imposizione<a class="headerlink" href="#id487" title="Link to this heading">¶</a></h5>
<p>(Semplice) Un costruttore di default dovrebbe fare di più che inizializzare semplicemente i dati membri con costanti.</p>
</section>
</section>
<section id="c-46-by-default-declare-single-argument-constructors-explicit">
<h4><a name="Rc-explicit"></a>C.46: Per default, dichiarare costruttori ad argomento singolo con explicit<a class="headerlink" href="#c-46-by-default-declare-single-argument-constructors-explicit" title="Link to this heading">¶</a></h4>
<section id="id488">
<h5>Motivo<a class="headerlink" href="#id488" title="Link to this heading">¶</a></h5>
<p>Per evitare conversioni indesiderate.</p>
</section>
<section id="id489">
<h5>Esempio, cattivo<a class="headerlink" href="#id489" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class String {
public:
    String(int);   // BAD
    // ...
};

String s = 10;   // surprise: string of size 10
</pre></div>
</div>
</section>
<section id="id490">
<h5>Eccezione<a class="headerlink" href="#id490" title="Link to this heading">¶</a></h5>
<p>Se si vuole veramente una conversione implicita da parte dell’argomento del costruttore al tipo della classe, non usare <code class="docutils literal notranslate"><span class="pre">explicit</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Complex {
public:
    Complex(double d);   // OK: we want a conversion from d to {d, 0}
    // ...
};

Complex z = 10.7;   // unsurprising conversion
</pre></div>
</div>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Ro-conversion"><span class="xref myst">Discussione sulle conversioni implicite</span></a></p>
</section>
<section id="id491">
<h5>Nota<a class="headerlink" href="#id491" title="Link to this heading">¶</a></h5>
<p>I costruttori copia e [move] non devono essere creati con <code class="docutils literal notranslate"><span class="pre">explicit</span></code> perché non eseguono conversioni. I costruttori “explicit” di copia/[move] rendono difficile il passaggio e la restituzione per valore.</p>
</section>
<section id="id492">
<h5>Imposizione<a class="headerlink" href="#id492" title="Link to this heading">¶</a></h5>
<p>(Semplice) I costruttori con singolo argomento devono essere dichiarati <code class="docutils literal notranslate"><span class="pre">explicit</span></code>. Dei buoni costruttori con argomento singolo non-<code class="docutils literal notranslate"><span class="pre">explicit</span></code> sono rari nella maggior parte dei codici. Avvertire per quelli che non sono in una «lista positiva».</p>
</section>
</section>
<section id="c-47-define-and-initialize-data-members-in-the-order-of-member-declaration">
<h4><a name="Rc-order"></a>C.47: Definire e inizializzare i dati membro secondo l’ordine di dichiarazione dei membri<a class="headerlink" href="#c-47-define-and-initialize-data-members-in-the-order-of-member-declaration" title="Link to this heading">¶</a></h4>
<section id="id493">
<h5>Motivo<a class="headerlink" href="#id493" title="Link to this heading">¶</a></h5>
<p>Per ridurre al minimo la confusione e gli errori. Questo è l’ordine con cui avviene l’inizializzazione (indipendentemente dall’ordine degli inizializzatori dei membri).</p>
</section>
<section id="id494">
<h5>Esempio, cattivo<a class="headerlink" href="#id494" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Foo {
    int m1;
    int m2;
public:
    Foo(int x) :m2{x}, m1{++x} { }   // BAD: misleading initializer order
    // ...
};

Foo x(1); // surprise: x.m1 == x.m2 == 2
</pre></div>
</div>
</section>
<section id="id495">
<h5>Imposizione<a class="headerlink" href="#id495" title="Link to this heading">¶</a></h5>
<p>(Semplice) Una lista di inizializzatori dei membri deve indicare i membri nello stesso ordine con cui sono dichiarati.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Sd-order"><span class="xref myst">Discussione</span></a></p>
</section>
</section>
<section id="c-48-prefer-default-member-initializers-to-member-initializers-in-constructors-for-constant-initializers">
<h4><a name="Rc-in-class-initializer"></a>C.48: Preferire gli inizializzatori membro di default agli inizializzatori membro nei costruttori per gli inizializzatori costanti<a class="headerlink" href="#c-48-prefer-default-member-initializers-to-member-initializers-in-constructors-for-constant-initializers" title="Link to this heading">¶</a></h4>
<section id="id496">
<h5>Motivo<a class="headerlink" href="#id496" title="Link to this heading">¶</a></h5>
<p>Rende esplicito che ci si aspetta di usare lo stesso valore in tutti i costruttori. Evitare le ripetizioni. Evitare i problemi di manutenzione. Porta ad un codice più breve e più efficiente.</p>
</section>
<section id="id497">
<h5>Esempio, cattivo<a class="headerlink" href="#id497" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {   // BAD
    int i;
    string s;
    int j;
public:
    X() :i{666}, s{&quot;qqq&quot;} { }   // j is uninitialized
    X(int ii) :i{ii} {}         // s is &quot;&quot; and j is uninitialized
    // ...
};
</pre></div>
</div>
<p>Come può un manutentore sapere se <code class="docutils literal notranslate"><span class="pre">j</span></code> sia stato deliberatamente lasciato non inizializzato (probabilmente è comunque una cattiva idea) e se sia stato intenzionale dare a <code class="docutils literal notranslate"><span class="pre">s</span></code> il valore di default <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> in un caso e <code class="docutils literal notranslate"><span class="pre">qqq</span></code> in un altro (quasi certamente un bug)? Il problema con <code class="docutils literal notranslate"><span class="pre">j</span></code> (dimenticando di inizializzare un membro) si verifica spesso quando si aggiunge un nuovo membro a una classe esistente.</p>
</section>
<section id="id498">
<h5>Esempio<a class="headerlink" href="#id498" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X2 {
    int i {666};
    string s {&quot;qqq&quot;};
    int j {0};
public:
    X2() = default;        // all members are initialized to their defaults
    X2(int ii) :i{ii} {}   // s and j initialized to their defaults
    // ...
};
</pre></div>
</div>
<p><strong>Alternativa</strong>: Possiamo parzialmente avvantaggiarci dei benefici degli argomenti di default nei costruttori, e che non è raro nel codice più vecchio. Tuttavia, questo è meno esplicito, causa l’esistenza di più argomenti da passare, ed è ripetitivo quando ci sono più di un costruttore:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X3 {   // BAD: inexplicit, argument passing overhead
    int i;
    string s;
    int j;
public:
    X3(int ii = 666, const string&amp; ss = &quot;qqq&quot;, int jj = 0)
        :i{ii}, s{ss}, j{jj} { }   // all members are initialized to their defaults
    // ...
};
</pre></div>
</div>
</section>
<section id="id499">
<h5>Imposizione<a class="headerlink" href="#id499" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Semplice) Ogni costruttore dovrebbe inizializzare ogni dato membro (esplicitamente, tramite una chiamata ctor delegante o tramite costruttore di default).</p></li>
<li><p>(Semplice) Gli argomenti di default per i costruttori suggeriscono che un inizializzatore di membro di default potrebbe essere più appropriato.</p></li>
</ul>
</section>
</section>
<section id="c-49-prefer-initialization-to-assignment-in-constructors">
<h4><a name="Rc-initialize"></a>C.49: Nei costruttori preferire l’inizializzazione alle assegnazioni<a class="headerlink" href="#c-49-prefer-initialization-to-assignment-in-constructors" title="Link to this heading">¶</a></h4>
<section id="id500">
<h5>Motivo<a class="headerlink" href="#id500" title="Link to this heading">¶</a></h5>
<p>Una inizializzazione dichiara esplicitamente che viene eseguita l’inizializzazione, anziché l’assegnazione, e può essere più elegante ed efficiente. Previene gli errori «utilizzo prima della valorizzazione».</p>
</section>
<section id="id501">
<h5>Esempio, buono<a class="headerlink" href="#id501" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class A {   // Good
    string s1;
public:
    A(czstring p) : s1{p} { }    // GOOD: directly construct (and the C-string is explicitly named)
    // ...
};
</pre></div>
</div>
</section>
<section id="id502">
<h5>Esempio, cattivo<a class="headerlink" href="#id502" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class B {   // BAD
    string s1;
public:
    B(const char* p) { s1 = p; }   // BAD: default constructor followed by assignment
    // ...
};

class C {   // UGLY, aka very bad
    int* p;
public:
    C() { cout &lt;&lt; *p; p = new int{10}; }   // accidental use before initialized
    // ...
};
</pre></div>
</div>
</section>
<section id="example-better-still">
<h5>Esempio, ancora migliore<a class="headerlink" href="#example-better-still" title="Link to this heading">¶</a></h5>
<p>Invece di quei <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code> si potrebbe usare <code class="docutils literal notranslate"><span class="pre">std::string_view</span></code> o <code class="docutils literal notranslate"><span class="pre">gsl::span&lt;char&gt;</span></code> del C++17 come ù<a class="reference internal" href="#Rstr-view"><span class="xref myst">un modo più generale di presentare gli argomenti ad una funzione</span></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class D {   // Good
    string s1;
public:
    D(string_view v) : s1{v} { }    // GOOD: directly construct
    // ...
};
</pre></div>
</div>
</section>
</section>
<section id="c-50-use-a-factory-function-if-you-need-virtual-behavior-during-initialization">
<h4><a name="Rc-factory"></a>C.50: Usare una funzione factory se c’è bisogno di un «comportamento virtuale» durante l’inizializzazione<a class="headerlink" href="#c-50-use-a-factory-function-if-you-need-virtual-behavior-during-initialization" title="Link to this heading">¶</a></h4>
<section id="id503">
<h5>Motivo<a class="headerlink" href="#id503" title="Link to this heading">¶</a></h5>
<p>Se lo stato di un oggetto di una classe base deve dipendere dallo stato di una parte derivata dell’oggetto, bisogna usare una funzione virtuale (o equivalente) minimizzando la finestra di opportunità per abusare di un oggetto costruito male.</p>
</section>
<section id="id504">
<h5>Nota<a class="headerlink" href="#id504" title="Link to this heading">¶</a></h5>
<p>Il tipo restituito dalla factory dovrebbe normalmente essere <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> per default; se si condividono alcuni utilizzi, il chiamante può <code class="docutils literal notranslate"><span class="pre">move</span></code> lo <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> in uno <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>. Tuttavia, se l’autore della factory sa che tutti gli usi dell’oggetto restituito saranno condivisi, restituisce <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> ed usa <code class="docutils literal notranslate"><span class="pre">make_shared</span></code> nel body per risparmiare un’allocazione.</p>
</section>
<section id="id505">
<h5>Esempio, cattivo<a class="headerlink" href="#id505" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class B {
public:
    B()
    {
        /* ... */
        f(); // BAD: C.82: Don&#39;t call virtual functions in constructors and destructors
        /* ... */
    }

    virtual void f() = 0;
};
</pre></div>
</div>
</section>
<section id="id506">
<h5>Esempio<a class="headerlink" href="#id506" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class B {
protected:
    class Token {};

public:
    explicit B(Token) { /* ... */ }  // create an imperfectly initialized object
    virtual void f() = 0;

    template&lt;class T&gt;
    static shared_ptr&lt;T&gt; create()    // interface for creating shared objects
    {
        auto p = make_shared&lt;T&gt;(typename T::Token{});
        p-&gt;post_initialize();
        return p;
    }

protected:
    virtual void post_initialize()   // called right after construction
        { /* ... */ f(); /* ... */ } // GOOD: virtual dispatch is safe
};

class D : public B {                 // some derived class
protected:
    class Token {};

public:
    explicit D(Token) : B{ B::Token{} } {}
    void f() override { /* ...  */ };

protected:
    template&lt;class T&gt;
    friend shared_ptr&lt;T&gt; B::create();
};

shared_ptr&lt;D&gt; p = D::create&lt;D&gt;();  // creating a D object
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">make_shared</span></code> richiede che il costruttore sia pubblico. Richiedendo un <code class="docutils literal notranslate"><span class="pre">Token</span></code> protetto, il costruttore non può più essere chiamato pubblicamente, quindi si evita che un oggetto non completamente costruito se ne vada libero. Fornendo la funzione factory <code class="docutils literal notranslate"><span class="pre">create()</span></code>, si rende conveniente la costruzione (nel [free store]).</p>
</section>
<section id="id507">
<h5>Nota<a class="headerlink" href="#id507" title="Link to this heading">¶</a></h5>
<p>Le funzioni factory convenzionali vengono allocate nel [free store], anziché sullo stack o in un oggetto che lo racchiude.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Sd-factory"><span class="xref myst">Discussione</span></a></p>
</section>
</section>
<section id="c-51-use-delegating-constructors-to-represent-common-actions-for-all-constructors-of-a-class">
<h4><a name="Rc-delegating"></a>C.51: Utilizzare i costruttori [delegating] per rappresentare azioni comuni a tutti i costruttori di una classe<a class="headerlink" href="#c-51-use-delegating-constructors-to-represent-common-actions-for-all-constructors-of-a-class" title="Link to this heading">¶</a></h4>
<section id="id508">
<h5>Motivo<a class="headerlink" href="#id508" title="Link to this heading">¶</a></h5>
<p>Per evitare ripetizioni e accidentali differenze.</p>
</section>
<section id="id509">
<h5>Esempio, cattivo<a class="headerlink" href="#id509" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Date {   // BAD: repetitive
    int d;
    Month m;
    int y;
public:
    Date(int dd, Month mm, year yy)
        :d{dd}, m{mm}, y{yy}
        { if (!valid(d, m, y)) throw Bad_date{}; }

    Date(int dd, Month mm)
        :d{dd}, m{mm} y{current_year()}
        { if (!valid(d, m, y)) throw Bad_date{}; }
    // ...
};
</pre></div>
</div>
<p>L’azione comune diventa noiosa da scrivere e potrebbe accidentalmente non essere comune.</p>
</section>
<section id="id510">
<h5>Esempio<a class="headerlink" href="#id510" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Date2 {
    int d;
    Month m;
    int y;
public:
    Date2(int dd, Month mm, year yy)
        :d{dd}, m{mm}, y{yy}
        { if (!valid(d, m, y)) throw Bad_date{}; }

    Date2(int dd, Month mm)
        :Date2{dd, mm, current_year()} {}
    // ...
};
</pre></div>
</div>
<p><strong>Si veda anche</strong>: Se l“«azione ripetuta» è una semplice inizializzazione, considerare <a class="reference internal" href="#Rc-in-class-initializer"><span class="xref myst">un inizializzatore membro di default</span></a>.</p>
</section>
<section id="id511">
<h5>Imposizione<a class="headerlink" href="#id511" title="Link to this heading">¶</a></h5>
<p>(Moderato) Cercare parti di costruttori simili</p>
</section>
</section>
<section id="c-52-use-inheriting-constructors-to-import-constructors-into-a-derived-class-that-does-not-need-further-explicit-initialization">
<h4><a name="Rc-inheriting"></a>C.52: Usare i costruttori ereditati per importare i costruttori in una classe derivata che non necessita di un ulteriore inizializzazione<a class="headerlink" href="#c-52-use-inheriting-constructors-to-import-constructors-into-a-derived-class-that-does-not-need-further-explicit-initialization" title="Link to this heading">¶</a></h4>
<section id="id512">
<h5>Motivo<a class="headerlink" href="#id512" title="Link to this heading">¶</a></h5>
<p>Se sono necessari quei costruttori per una classe derivata, la loro re-implementazione è noiosa e soggetta ad errori.</p>
</section>
<section id="id513">
<h5>Esempio<a class="headerlink" href="#id513" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">std::vector</span></code> ha molti costruttori complicati, quindi se si vuole il proprio <code class="docutils literal notranslate"><span class="pre">vector</span></code>, non lo si deve re-implementare:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Rec {
    // ... data and lots of nice constructors ...
};

class Oper : public Rec {
    using Rec::Rec;
    // ... no data members ...
    // ... lots of nice utility functions ...
};
</pre></div>
</div>
</section>
<section id="id514">
<h5>Esempio, cattivo<a class="headerlink" href="#id514" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Rec2 : public Rec {
    int x;
    using Rec::Rec;
};

Rec2 r {&quot;foo&quot;, 7};
int val = r.x;   // uninitialized
</pre></div>
</div>
</section>
<section id="id515">
<h5>Imposizione<a class="headerlink" href="#id515" title="Link to this heading">¶</a></h5>
<p>Assicurarsi che ogni membro della classe derivata venga inizializzato.</p>
</section>
</section>
</section>
<section id="c-copy-copy-and-move">
<h3><a name="SS-copy"></a>C.copy: Copia e spostamento<a class="headerlink" href="#c-copy-copy-and-move" title="Link to this heading">¶</a></h3>
<p>I tipi concreti dovrebbero generalmente essere copiabili, ma non le interfacce in una gerarchia di classi. Gli handle delle risorse potrebbero o meno essere copiabili. I tipi possono essere definiti per lo spostamento per motivi logici o prestazionali.</p>
<section id="c-60-make-copy-assignment-non-virtual-take-the-parameter-by-const-and-return-by-non-const">
<h4><a name="Rc-copy-assignment"></a>C.60: Creare le assegnazioni di copia non-<code class="docutils literal notranslate"><span class="pre">virtual</span></code>, prendere il parametro con <code class="docutils literal notranslate"><span class="pre">const&amp;</span></code> e restituire con non-<code class="docutils literal notranslate"><span class="pre">const&amp;</span></code><a class="headerlink" href="#c-60-make-copy-assignment-non-virtual-take-the-parameter-by-const-and-return-by-non-const" title="Link to this heading">¶</a></h4>
<section id="id516">
<h5>Motivo<a class="headerlink" href="#id516" title="Link to this heading">¶</a></h5>
<p>È semplice ed efficiente. Se si vuole ottimizzare per gli rvalue, si fornisce un overload che prende un <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> (cfr. <a class="reference internal" href="#Rf-consume"><span class="xref myst">F.18</span></a>).</p>
</section>
<section id="id517">
<h5>Esempio<a class="headerlink" href="#id517" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Foo {
public:
    Foo&amp; operator=(const Foo&amp; x)
    {
        // GOOD: no need to check for self-assignment (other than performance)
        auto tmp = x;
        swap(tmp); // see C.83
        return *this;
    }
    // ...
};

Foo a;
Foo b;
Foo f();

a = b;    // assign lvalue: copy
a = f();  // assign rvalue: potentially move
</pre></div>
</div>
</section>
<section id="id518">
<h5>Nota<a class="headerlink" href="#id518" title="Link to this heading">¶</a></h5>
<p>La tecnica di implementazione dello <code class="docutils literal notranslate"><span class="pre">swap</span></code> offre la <a class="reference internal" href="#Abrahams01"><span class="xref myst">garanzia forte</span></a>.</p>
</section>
<section id="id519">
<h5>Esempio<a class="headerlink" href="#id519" title="Link to this heading">¶</a></h5>
<p>Cosa succede se si possono avere prestazioni superiori non creando una copia temporanea? Si consideri un semplice <code class="docutils literal notranslate"><span class="pre">Vector</span></code> destinato ad un dominio dove è comune l’assegnazione di grandi <code class="docutils literal notranslate"><span class="pre">Vector</span></code> delle stesse dimensioni. In questo caso, la copia degli elementi implicita nella tecnica dell’implementazione dello <code class="docutils literal notranslate"><span class="pre">swap</span></code> potrebbe aumentare il costo di un ordine di grandezza:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
class Vector {
public:
    Vector&amp; operator=(const Vector&amp;);
    // ...
private:
    T* elem;
    int sz;
};

Vector&amp; Vector::operator=(const Vector&amp; a)
{
    if (a.sz &gt; sz) {
        // ... use the swap technique, it can&#39;t be bettered ...
        return *this;
    }
    // ... copy sz elements from *a.elem to elem ...
    if (a.sz &lt; sz) {
        // ... destroy the surplus elements in *this and adjust size ...
    }
    return *this;
}
</pre></div>
</div>
<p>Scrivendo direttamente negli elementi di destinazione, si otterrà solo <a class="reference internal" href="#Abrahams01"><span class="xref myst">la garanzia di base</span></a> anziché la garanzia forte offerta dalla tecnica dello <code class="docutils literal notranslate"><span class="pre">swap</span></code>. Attenzione alle <a class="reference internal" href="#Rc-copy-self"><span class="xref myst">auto-assegnazioni</span></a>.</p>
<p><strong>Alternative</strong>: Se si ritiene di aver bisogno di un operatore di assegnazione <code class="docutils literal notranslate"><span class="pre">virtual</span></code>, e si capisce perché è profondamente problematico, non lo si chiami <code class="docutils literal notranslate"><span class="pre">operator=</span></code>. Chiamare la funzione come <code class="docutils literal notranslate"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">assign(const</span> <span class="pre">Foo&amp;)</span></code>. Cfr.  <a class="reference internal" href="#Rc-copy-virtual"><span class="xref myst">costruttore copia contro <code class="docutils literal notranslate"><span class="pre">clone()</span></code></span></a>.</p>
</section>
<section id="id520">
<h5>Imposizione<a class="headerlink" href="#id520" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Semplice) Un operatore di assegnazione non dovrebbe essere virtuale. Questo è un punto oscuro!</p></li>
<li><p>(Semplice) Un operatore di assegnazione dovrebbe restituire <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> per abilitare il concatenamento, non alternative come <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T&amp;</span></code> che interferiscono con la componibilità e l’inseribilità degli oggetti nei contenitori.</p></li>
<li><p>(Moderato) Un operatore di assegnazione dovrebbe (implicitamente o esplicitamente) invocare tutti gli operatori di assegnazione base e membri. Si osservi il distruttore per determinare se il tipo ha la semantica del puntatore o quella del valore.</p></li>
</ul>
</section>
</section>
<section id="c-61-a-copy-operation-should-copy">
<h4><a name="Rc-copy-semantic"></a>C.61: Un’operazione di copia dovrebbe copiare<a class="headerlink" href="#c-61-a-copy-operation-should-copy" title="Link to this heading">¶</a></h4>
<section id="id521">
<h5>Motivo<a class="headerlink" href="#id521" title="Link to this heading">¶</a></h5>
<p>Questa è la semantica generalmente assunta. Dopo <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></code>, si dovrebbe avere <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code>. Dopo una copia <code class="docutils literal notranslate"><span class="pre">x</span></code> e <code class="docutils literal notranslate"><span class="pre">y</span></code> possono essere oggetti indipendenti (semantica del valore, come funzionano i tipi nativi non-puntatori e i tipi della libreria standard) o riferirsi a oggetti condivisi (semantica dei puntatori, come funzionano i puntatori).</p>
</section>
<section id="id522">
<h5>Esempio<a class="headerlink" href="#id522" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {   // OK: value semantics
public:
    X();
    X(const X&amp;);     // copy X
    void modify();   // change the value of X
    // ...
    ~X() { delete[] p; }
private:
    T* p;
    int sz;
};

bool operator==(const X&amp; a, const X&amp; b)
{
    return a.sz == b.sz &amp;&amp; equal(a.p, a.p + a.sz, b.p, b.p + b.sz);
}

X::X(const X&amp; a)
    :p{new T[a.sz]}, sz{a.sz}
{
    copy(a.p, a.p + sz, p);
}

X x;
X y = x;
if (x != y) throw Bad{};
x.modify();
if (x == y) throw Bad{};   // assume value semantics
</pre></div>
</div>
</section>
<section id="id523">
<h5>Esempio<a class="headerlink" href="#id523" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X2 {  // OK: pointer semantics
public:
    X2();
    X2(const X2&amp;) = default; // shallow copy
    ~X2() = default;
    void modify();          // change the pointed-to value
    // ...
private:
    T* p;
    int sz;
};

bool operator==(const X2&amp; a, const X2&amp; b)
{
    return a.sz == b.sz &amp;&amp; a.p == b.p;
}

X2 x;
X2 y = x;
if (x != y) throw Bad{};
x.modify();
if (x != y) throw Bad{};  // assume pointer semantics
</pre></div>
</div>
</section>
<section id="id524">
<h5>Nota<a class="headerlink" href="#id524" title="Link to this heading">¶</a></h5>
<p>Preferire la semantica del valore a meno che non si stia costruendo uno «smart pointer». La semantica del valore è la più semplice su cui ragionare ed è quella che si aspettano le strutture della libreria standard.</p>
</section>
<section id="id525">
<h5>Imposizione<a class="headerlink" href="#id525" title="Link to this heading">¶</a></h5>
<p>(Non imponibile)</p>
</section>
</section>
<section id="c-62-make-copy-assignment-safe-for-self-assignment">
<h4><a name="Rc-copy-self"></a>C.62: Rendere l’assegnazione di copia sicura in caso di auto-assegnazione<a class="headerlink" href="#c-62-make-copy-assignment-safe-for-self-assignment" title="Link to this heading">¶</a></h4>
<section id="id526">
<h5>Motivo<a class="headerlink" href="#id526" title="Link to this heading">¶</a></h5>
<p>Se <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span></code> modifica il valore di <code class="docutils literal notranslate"><span class="pre">x</span></code>, si resterà sorpresi ed avverranno brutti errori (spesso anche dei leak).</p>
</section>
<section id="id527">
<h5>Esempio<a class="headerlink" href="#id527" title="Link to this heading">¶</a></h5>
<p>I contenitori della libreria standard gestiscono l’auto-assegnazione con eleganza ed efficienza:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>std::vector&lt;int&gt; v = {3, 1, 4, 1, 5, 9};
v = v;
// the value of v is still {3, 1, 4, 1, 5, 9}
</pre></div>
</div>
</section>
<section id="id528">
<h5>Nota<a class="headerlink" href="#id528" title="Link to this heading">¶</a></h5>
<p>L’assegnazione di default generata dai membri che gestiscono correttamente l’auto-assegnazione gestisce correttamente l’auto-assegnazione.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Bar {
    vector&lt;pair&lt;int, int&gt;&gt; v;
    map&lt;string, int&gt; m;
    string s;
};

Bar b;
// ...
b = b;   // correct and efficient
</pre></div>
</div>
</section>
<section id="id529">
<h5>Nota<a class="headerlink" href="#id529" title="Link to this heading">¶</a></h5>
<p>È possibile gestire l’auto-assegnazione testandola esplicitamente, ma spesso è più rapido e più elegante farlo senza un test (p.es., <a class="reference internal" href="#Rc-swap"><span class="xref myst">utilizzando <code class="docutils literal notranslate"><span class="pre">swap</span></code></span></a>).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Foo {
    string s;
    int i;
public:
    Foo&amp; operator=(const Foo&amp; a);
    // ...
};

Foo&amp; Foo::operator=(const Foo&amp; a)   // OK, but there is a cost
{
    if (this == &amp;a) return *this;
    s = a.s;
    i = a.i;
    return *this;
}
</pre></div>
</div>
<p>Questo è ovviamente sicuro e apparentemente efficiente. Tuttavia, cosa succede se si esegue un auto-assegnazione per un milione di assegnazioni? Questo ha a che fare con un milione di test ridondanti (ma dato che la risposta è essenzialmente la stessa, il predittore del branch [branch predictor] del computer indovinerà quasi sempre). Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Foo&amp; Foo::operator=(const Foo&amp; a)   // simpler, and probably much better
{
    s = a.s;
    i = a.i;
    return *this;
}
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">std::string</span></code>  è sicuro per l’auto-assegnazione così come lo sono gli <code class="docutils literal notranslate"><span class="pre">int</span></code>. Tutto il costo è sostenuto dal (raro) caso dell’auto-assegnazione.</p>
</section>
<section id="id530">
<h5>Imposizione<a class="headerlink" href="#id530" title="Link to this heading">¶</a></h5>
<p>(Semplice) Gli operatori di assegnazione non devono avere lo schema <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(this</span> <span class="pre">==</span> <span class="pre">&amp;a)</span> <span class="pre">return</span> <span class="pre">*this;</span></code> ???</p>
</section>
</section>
<section id="c-63-make-move-assignment-non-virtual-take-the-parameter-by-and-return-by-non-const">
<h4><a name="Rc-move-assignment"></a>C.63: Rendere l’assegnazione di spostamento [move] non-<code class="docutils literal notranslate"><span class="pre">virtual</span></code>, prendere il parametro con <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> e restituire con non-<code class="docutils literal notranslate"><span class="pre">const&amp;</span></code><a class="headerlink" href="#c-63-make-move-assignment-non-virtual-take-the-parameter-by-and-return-by-non-const" title="Link to this heading">¶</a></h4>
<section id="id531">
<h5>Motivo<a class="headerlink" href="#id531" title="Link to this heading">¶</a></h5>
<p>È semplice ed efficiente.</p>
<p><strong>Cfr.</strong>: <a class="reference internal" href="#Rc-copy-assignment"><span class="xref myst">La regola per l’assegnazione-copia</span></a>.</p>
</section>
<section id="id532">
<h5>Imposizione<a class="headerlink" href="#id532" title="Link to this heading">¶</a></h5>
<p>Equivalente a quanto fatto per l”<a class="reference internal" href="#Rc-copy-assignment"><span class="xref myst">assegnazione-copia</span></a>.</p>
<ul class="simple">
<li><p>(Semplice) Un operatore di assegnazione non dovrebbe essere virtuale. Questo è un punto oscuro!</p></li>
<li><p>(Semplice) Un operatore di assegnazione dovrebbe restituire <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> per abilitare il concatenamento, non alternative come <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T&amp;</span></code> che interferiscono con la componibilità e l’inseribilità degli oggetti nei contenitori.</p></li>
<li><p>(Moderato) Un operatore di assegnazione di spostamento dovrebbe (implicitamente o esplicitamente) invocare tutti gli operatori di assegnazione di spostamento base e membri.</p></li>
</ul>
</section>
</section>
<section id="c-64-a-move-operation-should-move-and-leave-its-source-in-a-valid-state">
<h4><a name="Rc-move-semantic"></a>C.64: Un’operazione di [move] dovrebbe spostare e lasciare il sorgente in uno stato valido<a class="headerlink" href="#c-64-a-move-operation-should-move-and-leave-its-source-in-a-valid-state" title="Link to this heading">¶</a></h4>
<section id="id533">
<h5>Motivo<a class="headerlink" href="#id533" title="Link to this heading">¶</a></h5>
<p>Questa è la semantica generalmente assunta. Dopo <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">std::move(x)</span></code> il valore di <code class="docutils literal notranslate"><span class="pre">y</span></code> dovrebbe essere il valore che aveva <code class="docutils literal notranslate"><span class="pre">x</span></code> e <code class="docutils literal notranslate"><span class="pre">x</span></code> dovrebbe essere in uno stato valido.</p>
</section>
<section id="id534">
<h5>Esempio<a class="headerlink" href="#id534" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {   // OK: value semantics
public:
    X();
    X(X&amp;&amp; a) noexcept;  // move X
    X&amp; operator=(X&amp;&amp; a) noexcept; // move-assign X
    void modify();     // change the value of X
    // ...
    ~X() { delete[] p; }
private:
    T* p;
    int sz;
};

X::X(X&amp;&amp; a) noexcept
    :p{a.p}, sz{a.sz}  // steal representation
{
    a.p = nullptr;     // set to &quot;empty&quot;
    a.sz = 0;
}

void use()
{
    X x{};
    // ...
    X y = std::move(x);
    x = X{};   // OK
} // OK: x can be destroyed
</pre></div>
</div>
</section>
<section id="id535">
<h5>Nota<a class="headerlink" href="#id535" title="Link to this heading">¶</a></h5>
<p>Idealmente, quello rimosso dovrebbe avere il valore di default del tipo. Accertarsene, a meno che non ci sia una ragione eccezionalmente buona per non farlo. Tuttavia, non tutti i tipi hanno un valore di default e per alcuni tipi stabilire il valore di default può risultare costoso. Lo standard richiede solo che l’oggetto da cui si è rimosso il valore possa essere distrutto. Spesso è possibile fare facilmente ed economicamente meglio: La libreria standard presuppone che sia possibile assegnare ad un oggetto da cui si è rimosso il valore. Lasciare sempre l’oggetto da cui si è rimosso il valore in uno stato valido (necessariamente specificato).</p>
</section>
<section id="id536">
<h5>Nota<a class="headerlink" href="#id536" title="Link to this heading">¶</a></h5>
<p>A meno che non ci sia una ragione eccezionalmente forte per non farlo, fare in modo che <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">std::move(y);</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">z;</span></code> funzioni con la semantica convenzionale.</p>
</section>
<section id="id537">
<h5>Imposizione<a class="headerlink" href="#id537" title="Link to this heading">¶</a></h5>
<p>(Non imponibile) Cercare le assegnazioni ai membri nell’operazione di spostamento. Se c’è un costruttore di default, confrontare quelle assegnazioni con le inizializzazioni nel costruttore di default.</p>
</section>
</section>
<section id="c-65-make-move-assignment-safe-for-self-assignment">
<h4><a name="Rc-move-self"></a>C.65: Rendere l’assegnazione con spostamento sicura per l’auto-assegnazione<a class="headerlink" href="#c-65-make-move-assignment-safe-for-self-assignment" title="Link to this heading">¶</a></h4>
<section id="id538">
<h5>Motivo<a class="headerlink" href="#id538" title="Link to this heading">¶</a></h5>
<p>Se <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span></code> cambia il valore di <code class="docutils literal notranslate"><span class="pre">x</span></code>, si resterà sorpresi e capiteranno brutti errori. Tuttavia, solitamente la gente non scrive un’auto-assegnazione che si trasforma in uno spostamento, ma può accadere. Tuttavia, <code class="docutils literal notranslate"><span class="pre">std::swap</span></code> è implementato usando le operazioni di spostamento quindi se accidentalmente si fa uno <code class="docutils literal notranslate"><span class="pre">swap(a,</span> <span class="pre">b)</span></code> dove <code class="docutils literal notranslate"><span class="pre">a</span></code> e <code class="docutils literal notranslate"><span class="pre">b</span></code> si riferiscono allo stesso oggetto, il non riuscire a gestire l’auto-assegnazione potrebbe essere un serio e subdolo errore.</p>
</section>
<section id="id539">
<h5>Esempio<a class="headerlink" href="#id539" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Foo {
    string s;
    int i;
public:
    Foo&amp; operator=(Foo&amp;&amp; a) noexcept;
    // ...
};

Foo&amp; Foo::operator=(Foo&amp;&amp; a) noexcept  // OK, but there is a cost
{
    if (this == &amp;a) return *this;  // this line is redundant
    s = std::move(a.s);
    i = a.i;
    return *this;
}
</pre></div>
</div>
<p>L’obiezione dell’uno-su-un-milione rispetto al test <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(this</span> <span class="pre">==</span> <span class="pre">&amp;a)</span> <span class="pre">return</span> <span class="pre">*this;</span></code> della discussione sull”<a class="reference internal" href="#Rc-copy-self"><span class="xref myst">auto-assegnazione</span></a> è ancor più rilevante per l’auto-spostamento.</p>
</section>
<section id="id540">
<h5>Nota<a class="headerlink" href="#id540" title="Link to this heading">¶</a></h5>
<p>Non è noto un modo generale per evitare che dopo un test <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(this</span> <span class="pre">==</span> <span class="pre">&amp;a)</span> <span class="pre">return</span> <span class="pre">*this;</span></code> per un assegnazione con spostamento si abbia ancora una risposta corretta (ovvero, dopo <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span></code> il valore di <code class="docutils literal notranslate"><span class="pre">x</span></code> resta invariato).</p>
</section>
<section id="id541">
<h5>Nota<a class="headerlink" href="#id541" title="Link to this heading">¶</a></h5>
<p>Lo standard ISO garantisce solo uno stato «valido ma non specificato» per i contenitori della standard-library. Sembra che questo non sia stato un problema nei 10 anni di utilizzo sperimentale ed in produzione. Si prega di contattare gli editori se si trova un contro esempio. La regola qui è più cautelativa ed insiste sulla completa sicurezza.</p>
</section>
<section id="id542">
<h5>Esempio<a class="headerlink" href="#id542" title="Link to this heading">¶</a></h5>
<p>Ecco un modo per spostare un puntatore senza un test (lo si immagini come codice nell’implementazione di un assegnazione con spostamento):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// move from other.ptr to this-&gt;ptr
T* temp = other.ptr;
other.ptr = nullptr;
delete ptr; // in self-move, this-&gt;ptr is also null; delete is a no-op
ptr = temp; // in self-move, the original ptr is restored
</pre></div>
</div>
</section>
<section id="id543">
<h5>Imposizione<a class="headerlink" href="#id543" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Moderato) Nel caso dell’auto-assegnazione, un operatore di assegnazione con spostamento non deve lasciare l’oggetto con i membri puntatori cancellati con <code class="docutils literal notranslate"><span class="pre">delete</span></code> o settati a <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</p></li>
<li><p>(Non applicabile) Si veda l’uso dei tipi di contenitori nella standard-library (compreso  <code class="docutils literal notranslate"><span class="pre">string</span></code>) e si considerino sicuri per gli usi ordinari (non life-critical).</p></li>
</ul>
</section>
</section>
<section id="c-66-make-move-operations-noexcept">
<h4><a name="Rc-move-noexcept"></a>C.66: Creare le operazioni di [move] come <code class="docutils literal notranslate"><span class="pre">noexcept</span></code><a class="headerlink" href="#c-66-make-move-operations-noexcept" title="Link to this heading">¶</a></h4>
<section id="id544">
<h5>Motivo<a class="headerlink" href="#id544" title="Link to this heading">¶</a></h5>
<p>Uno spostamento che va in errore [throwing] va contro le ragionevoli assunzioni della maggior parte delle persone. Uno spostamento [non-throwing] verrà usato in modo più efficiente dalla standard-library e dalle strutture del linguaggio.</p>
</section>
<section id="id545">
<h5>Esempio<a class="headerlink" href="#id545" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
class Vector {
public:
    Vector(Vector&amp;&amp; a) noexcept :elem{a.elem}, sz{a.sz} { a.elem = nullptr; a.sz = 0; }
    Vector&amp; operator=(Vector&amp;&amp; a) noexcept {
        if (&amp;a != this) {
            delete elem;
            elem = a.elem; a.elem = nullptr;
            sz   = a.sz;   a.sz   = 0;
        }
        return *this;
    }
    // ...
private:
    T* elem;
    int sz;
};
</pre></div>
</div>
<p>Queste operazioni non generano errori [throw].</p>
</section>
<section id="id546">
<h5>Esempio, cattivo<a class="headerlink" href="#id546" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
class Vector2 {
public:
    Vector2(Vector2&amp;&amp; a) noexcept { *this = a; }             // just use the copy
    Vector2&amp; operator=(Vector2&amp;&amp; a) noexcept { *this = a; }  // just use the copy
    // ...
private:
    T* elem;
    int sz;
};
</pre></div>
</div>
<p>Questo <code class="docutils literal notranslate"><span class="pre">Vector2</span></code> non è solo inefficiente, ma dato che la copia di un vettore richiede un’allocazione, può andare in errore [throw].</p>
</section>
<section id="id547">
<h5>Imposizione<a class="headerlink" href="#id547" title="Link to this heading">¶</a></h5>
<p>(Semplice) Un’operazione di spostamento deve essere contrassegnata con <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>.</p>
</section>
</section>
<section id="c-67-a-polymorphic-class-should-suppress-public-copy-move">
<h4><a name="Rc-copy-virtual"></a>C.67: Una classe polimorfica dovrebbe sopprimere la copia/spostamento public<a class="headerlink" href="#c-67-a-polymorphic-class-should-suppress-public-copy-move" title="Link to this heading">¶</a></h4>
<section id="id548">
<h5>Motivo<a class="headerlink" href="#id548" title="Link to this heading">¶</a></h5>
<p>Una <em>classe polimorfica</em> è una classe che definisce o eredita almeno una funzione virtuale. È probabile che verrà usata come classe base per altre classi derivate con un comportamento polimorfico. Se viene accidentalmente passata per valore, col costruttore copia e le assegnazioni generate implicitamente, si rischia di “spaccare”: verrà copiata solo la porzione base dell’oggetto derivato, e il comportamento polimorfico risulterà corrotto.</p>
<p>Se la classe non ha dati, imporre <code class="docutils literal notranslate"><span class="pre">=delete</span></code> alle funzioni di copia e spostamento. Altrimenti renderli protected.</p>
</section>
<section id="id549">
<h5>Esempio, cattivo<a class="headerlink" href="#id549" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class B { // BAD: polymorphic base class doesn&#39;t suppress copying
public:
    virtual char m() { return &#39;B&#39;; }
    // ... nothing about copy operations, so uses default ...
};

class D : public B {
public:
    char m() override { return &#39;D&#39;; }
    // ...
};

void f(B&amp; b)
{
    auto b2 = b; // oops, slices the object; b2.m() will return &#39;B&#39;
}

D d;
f(d);
</pre></div>
</div>
</section>
<section id="id550">
<h5>Esempio<a class="headerlink" href="#id550" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class B { // GOOD: polymorphic class suppresses copying
public:
    B() = default;
    B(const B&amp;) = delete;
    B&amp; operator=(const B&amp;) = delete;
    virtual char m() { return &#39;B&#39;; }
    // ...
};

class D : public B {
public:
    char m() override { return &#39;D&#39;; }
    // ...
};

void f(B&amp; b)
{
    auto b2 = b; // ok, compiler will detect inadvertent copying, and protest
}

D d;
f(d);
</pre></div>
</div>
</section>
<section id="id551">
<h5>Nota<a class="headerlink" href="#id551" title="Link to this heading">¶</a></h5>
<p>Se è necessario creare copie complete [deep] di oggetti polimorfici, si usano le funzioni <code class="docutils literal notranslate"><span class="pre">clone()</span></code>: cfr. <a class="reference internal" href="#Rh-copy"><span class="xref myst">C.130</span></a>.</p>
</section>
<section id="id552">
<h5>Eccezione<a class="headerlink" href="#id552" title="Link to this heading">¶</a></h5>
<p>Le classi che rappresentano oggetti eccezioni devono sia essere polimorfiche che costruibili-per-copia.</p>
</section>
<section id="id553">
<h5>Imposizione<a class="headerlink" href="#id553" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare una classe polimorfica con un’operazione di copia public.</p></li>
<li><p>Segnalare un’assegnazione di oggetti di classi polimorfiche.</p></li>
</ul>
</section>
</section>
</section>
<section id="c-other-other-default-operation-rules">
<h3>C.other: Altre regole sulle operazioni di default<a class="headerlink" href="#c-other-other-default-operation-rules" title="Link to this heading">¶</a></h3>
<p>Oltre alle operazioni per le quali il linguaggio offre implementazioni di default, ci sono alcune operazioni talmente fondamentali che necessitano di regole specifiche per la loro definizione: confronti, <code class="docutils literal notranslate"><span class="pre">swap</span></code> e <code class="docutils literal notranslate"><span class="pre">hash</span></code>.</p>
<section id="c-80-use-default-if-you-have-to-be-explicit-about-using-the-default-semantics">
<h4><a name="Rc-eqdefault"></a>C.80: Utilizzare <code class="docutils literal notranslate"><span class="pre">=default</span></code> se si deve essere espliciti sull’uso della semantica del default<a class="headerlink" href="#c-80-use-default-if-you-have-to-be-explicit-about-using-the-default-semantics" title="Link to this heading">¶</a></h4>
<section id="id554">
<h5>Motivo<a class="headerlink" href="#id554" title="Link to this heading">¶</a></h5>
<p>È più probabile che il compilatore ottenga la giusta semantica di default e non è possibile implementare queste funzioni meglio del compilatore.</p>
</section>
<section id="id555">
<h5>Esempio<a class="headerlink" href="#id555" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Tracer {
    string message;
public:
    Tracer(const string&amp; m) : message{m} { cerr &lt;&lt; &quot;entering &quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; }
    ~Tracer() { cerr &lt;&lt; &quot;exiting &quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; }

    Tracer(const Tracer&amp;) = default;
    Tracer&amp; operator=(const Tracer&amp;) = default;
    Tracer(Tracer&amp;&amp;) noexcept = default;
    Tracer&amp; operator=(Tracer&amp;&amp;) noexcept = default;
};
</pre></div>
</div>
<p>Dato che si è definito il distruttore, si devono definire le operazioni di copia e spostamento. Il <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">default</span></code> è il modo migliore e più semplice per farlo.</p>
</section>
<section id="id556">
<h5>Esempio, cattivo<a class="headerlink" href="#id556" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Tracer2 {
    string message;
public:
    Tracer2(const string&amp; m) : message{m} { cerr &lt;&lt; &quot;entering &quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; }
    ~Tracer2() { cerr &lt;&lt; &quot;exiting &quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; }

    Tracer2(const Tracer2&amp; a) : message{a.message} {}
    Tracer2&amp; operator=(const Tracer2&amp; a) { message = a.message; return *this; }
    Tracer2(Tracer2&amp;&amp; a) noexcept :message{a.message} {}
    Tracer2&amp; operator=(Tracer2&amp;&amp; a) noexcept { message = a.message; return *this; }
};
</pre></div>
</div>
<p>Scrivere il codice per le operazioni di copia e spostamento è prolisso, noioso e soggetto ad errori. Un compilatore lo fa meglio.</p>
</section>
<section id="id557">
<h5>Imposizione<a class="headerlink" href="#id557" title="Link to this heading">¶</a></h5>
<p>(Moderato) Il codice di un’operazione speciale non dovrebbe avere la stessa accessibilità e semantica della versione generata dal compilatore, perché sarebbe ridondante</p>
</section>
</section>
<section id="c-81-use-delete-when-you-want-to-disable-default-behavior-without-wanting-an-alternative">
<h4><a name="Rc-delete"></a>C.81: Utilizzare <code class="docutils literal notranslate"><span class="pre">=delete</span></code> quando si vuol disabilitare il comportamento di default (senza volere un’alternativa)<a class="headerlink" href="#c-81-use-delete-when-you-want-to-disable-default-behavior-without-wanting-an-alternative" title="Link to this heading">¶</a></h4>
<section id="id558">
<h5>Motivo<a class="headerlink" href="#id558" title="Link to this heading">¶</a></h5>
<p>In alcuni casi, un’operazione di default non è desiderabile.</p>
</section>
<section id="id559">
<h5>Esempio<a class="headerlink" href="#id559" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Immortal {
public:
    ~Immortal() = delete;   // do not allow destruction
    // ...
};

void use()
{
    Immortal ugh;   // error: ugh cannot be destroyed
    Immortal* p = new Immortal{};
    delete p;       // error: cannot destroy *p
}
</pre></div>
</div>
</section>
<section id="id560">
<h5>Esempio<a class="headerlink" href="#id560" title="Link to this heading">¶</a></h5>
<p>Un <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> può essere spostato, ma non copiato. Per farlo, ne vengono cancellate le operazioni di copia. Per evitare la copia è necessario il <code class="docutils literal notranslate"><span class="pre">=delete</span></code> accanto alle sue operazioni di copia dagli lvalue:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr {
public:
    // ...
    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    // ...
    unique_ptr(unique_ptr&amp;&amp; u) noexcept;   // move constructor
    // ...
    unique_ptr(const unique_ptr&amp;) = delete; // disable copy from lvalue
    // ...
};

unique_ptr&lt;int&gt; make();   // make &quot;something&quot; and return it by moving

void f()
{
    unique_ptr&lt;int&gt; pi {};
    auto pi2 {pi};      // error: no move constructor from lvalue
    auto pi3 {make()};  // OK, move: the result of make() is an rvalue
}
</pre></div>
</div>
<p>Si noti che le funzioni eliminate devono essere pubbliche.</p>
</section>
<section id="id561">
<h5>Imposizione<a class="headerlink" href="#id561" title="Link to this heading">¶</a></h5>
<p>L’eliminazione di un’operazione di default è (dovrebbe essere) basata sulla semantica desiderata della classe. Considerare tali classi sospette, ma mantenere un «elenco positivo» di classi dove un umano ha affermato che la semantica è corretta.</p>
</section>
</section>
<section id="c-82-don-t-call-virtual-functions-in-constructors-and-destructors">
<h4><a name="Rc-ctor-virtual"></a>C.82: Non richiamare funzioni virtuali nei costruttori e nei distruttori<a class="headerlink" href="#c-82-don-t-call-virtual-functions-in-constructors-and-destructors" title="Link to this heading">¶</a></h4>
<section id="id562">
<h5>Motivo<a class="headerlink" href="#id562" title="Link to this heading">¶</a></h5>
<p>La funzione chiamata sarà quella dell’oggetto appena costruito, anziché una funzione eventualmente sovrapposta [overriding] in una classe derivata. Ciò può risultare molto confuso. Peggio ancora, una chiamata diretta o indiretta ad una funzione virtuale pura non implementata da un costruttore o da un distruttore provoca un comportamento indefinito.</p>
</section>
<section id="id563">
<h5>Esempio, cattivo<a class="headerlink" href="#id563" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Base {
public:
    virtual void f() = 0;   // not implemented
    virtual void g();       // implemented with Base version
    virtual void h();       // implemented with Base version
    virtual ~Base();        // implemented with Base version
};

class Derived : public Base {
public:
    void g() override;   // provide Derived implementation
    void h() final;      // provide Derived implementation

    Derived()
    {
        // BAD: attempt to call an unimplemented virtual function
        f();

        // BAD: will call Derived::g, not dispatch further virtually
        g();

        // GOOD: explicitly state intent to call only the visible version
        Derived::g();

        // ok, no qualification needed, h is final
        h();
    }
};
</pre></div>
</div>
<p>Si noti che chiamare una specifica funzione qualificata esplicitamente non è una chiamata virtuale anche se la funzione è <code class="docutils literal notranslate"><span class="pre">virtual</span></code>.</p>
<p><strong>Si veda anche</strong> <a class="reference internal" href="#Rc-factory"><span class="xref myst">funzioni factory</span></a> per come ottenere l’effetto di una chiamata a una funzione di una classe derivata senza rischiare il comportamento indefinito.</p>
</section>
<section id="id564">
<h5>Nota<a class="headerlink" href="#id564" title="Link to this heading">¶</a></h5>
<p>Non c’è nulla di intrinsecamente sbagliato nel chiamare funzioni virtuali da costruttori o distruttori. La semantica di tali chiamate è «type safe». Tuttavia, l’esperienza dimostra che tali chiamate sono raramente necessarie, confondono facilmente i manutentori e diventano una fonte di errori quando vengono utilizzate dai principianti.</p>
</section>
<section id="id565">
<h5>Imposizione<a class="headerlink" href="#id565" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare le chiamate a funzioni virtuali dai costruttori e dai distruttori.</p></li>
</ul>
</section>
</section>
<section id="c-83-for-value-like-types-consider-providing-a-noexcept-swap-function">
<h4><a name="Rc-swap"></a>C.83: Per i tipi [value-like], si preveda di fornire una funzione di “swap” di tipo <code class="docutils literal notranslate"><span class="pre">noexcept</span></code><a class="headerlink" href="#c-83-for-value-like-types-consider-providing-a-noexcept-swap-function" title="Link to this heading">¶</a></h4>
<section id="id566">
<h5>Motivo<a class="headerlink" href="#id566" title="Link to this heading">¶</a></h5>
<p>Uno <code class="docutils literal notranslate"><span class="pre">swap</span></code> può essere utile per implementare una serie di idiomi, da un sicuro spostamento di oggetti alla semplice implementazione di un’assegnazione, al fornire una funzione di “commit” garantita che consenta di avere un codice chiamante fortemente esente da errori. Si consideri l’uso di swap per implementare l’assegnazione per copia in termini di costruzione-copia. Si veda anche <a class="reference internal" href="#Re-never-fail"><span class="xref myst">distruttori, de-allocazione e swap non devono mai fallire</span></a>.</p>
</section>
<section id="id567">
<h5>Esempio, buono<a class="headerlink" href="#id567" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Foo {
public:
    void swap(Foo&amp; rhs) noexcept
    {
        m1.swap(rhs.m1);
        std::swap(m2, rhs.m2);
    }
private:
    Bar m1;
    int m2;
};
</pre></div>
</div>
<p>Fornire una funzione <code class="docutils literal notranslate"><span class="pre">swap</span></code> non-membro nello stesso namespace per il proprio tipo, per la comodità dei chiamanti.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void swap(Foo&amp; a, Foo&amp; b)
{
    a.swap(b);
}
</pre></div>
</div>
</section>
<section id="id568">
<h5>Imposizione<a class="headerlink" href="#id568" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>I tipi non-banalmente-copiabili dovrebbero fornire una funzione membro swap o un overload per lo swap generico.</p></li>
<li><p>(Semplice) Quando una classe ha una funzione membro <code class="docutils literal notranslate"><span class="pre">swap</span></code>, dovrebbe essere dichiarata <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>.</p></li>
</ul>
</section>
</section>
<section id="c-84-a-swap-function-must-not-fail">
<h4><a name="Rc-swap-fail"></a>C.84: Una funzione <code class="docutils literal notranslate"><span class="pre">swap</span></code> non può fallire<a class="headerlink" href="#c-84-a-swap-function-must-not-fail" title="Link to this heading">¶</a></h4>
<section id="id569">
<h5>Motivo<a class="headerlink" href="#id569" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">swap</span></code> è largamente usata nei modi che si presumono non falliscano mai e i programmi non possono essere facilmente scritti per funzionare correttamente in presenza di una <code class="docutils literal notranslate"><span class="pre">swap</span></code> non riuscita. I contenitori e gli algoritmi della standard-library non funzioneranno correttamente se uno [swap] di un tipo di elemento fallisce.</p>
</section>
<section id="id570">
<h5>Esempio, cattivo<a class="headerlink" href="#id570" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void swap(My_vector&amp; x, My_vector&amp; y)
{
    auto tmp = x;   // copy elements
    x = y;
    y = tmp;
}
</pre></div>
</div>
<p>Questo non è soltanto lento, ma se per gli elementi avviene un’allocazione di memoria in <code class="docutils literal notranslate"><span class="pre">tmp</span></code>, questo <code class="docutils literal notranslate"><span class="pre">swap</span></code> potrebbe fallire e farebbe fallire gli algoritmi STL se venissero usati.</p>
</section>
<section id="id571">
<h5>Imposizione<a class="headerlink" href="#id571" title="Link to this heading">¶</a></h5>
<p>(Semplice) Quando una classe ha una funzione membro <code class="docutils literal notranslate"><span class="pre">swap</span></code>, dovrebbe essere dichiarata <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>.</p>
</section>
</section>
<section id="c-85-make-swap-noexcept">
<h4><a name="Rc-swap-noexcept"></a>C.85: Rendere lo <code class="docutils literal notranslate"><span class="pre">swap</span></code> <code class="docutils literal notranslate"><span class="pre">noexcept</span></code><a class="headerlink" href="#c-85-make-swap-noexcept" title="Link to this heading">¶</a></h4>
<section id="id572">
<h5>Motivo<a class="headerlink" href="#id572" title="Link to this heading">¶</a></h5>
<p><a class="reference internal" href="#Rc-swap-fail"><span class="xref myst">Uno <code class="docutils literal notranslate"><span class="pre">swap</span></code> non deve fallire</span></a>. Se uno <code class="docutils literal notranslate"><span class="pre">swap</span></code> tenta di uscire con un’eccezione, si tratta di un errore di progettazione ed è meglio che il programma termini.</p>
</section>
<section id="id573">
<h5>Imposizione<a class="headerlink" href="#id573" title="Link to this heading">¶</a></h5>
<p>(Semplice) Quando una classe ha una funzione membro <code class="docutils literal notranslate"><span class="pre">swap</span></code>, dovrebbe essere dichiarata <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>.</p>
</section>
</section>
<section id="c-86-make-symmetric-with-respect-to-operand-types-and-noexcept">
<h4><a name="Rc-eq"></a>C.86: Creare lo <code class="docutils literal notranslate"><span class="pre">==</span></code> simmetrico rispetto ai tipi di operandi e <code class="docutils literal notranslate"><span class="pre">noexcept</span></code><a class="headerlink" href="#c-86-make-symmetric-with-respect-to-operand-types-and-noexcept" title="Link to this heading">¶</a></h4>
<section id="id574">
<h5>Motivo<a class="headerlink" href="#id574" title="Link to this heading">¶</a></h5>
<p>Il trattamento asimmetrico degli operandi è inatteso e fonte di errori dove sono possibili delle conversioni. <code class="docutils literal notranslate"><span class="pre">==</span></code> è un’operazione fondamentale e i programmatori dovrebbero essere in grado di usarla senza paura di sbagliare.</p>
</section>
<section id="id575">
<h5>Esempio<a class="headerlink" href="#id575" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct X {
    string name;
    int number;
};

bool operator==(const X&amp; a, const X&amp; b) noexcept {
    return a.name == b.name &amp;&amp; a.number == b.number;
}
</pre></div>
</div>
</section>
<section id="id576">
<h5>Esempio, cattivo<a class="headerlink" href="#id576" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class B {
    string name;
    int number;
    bool operator==(const B&amp; a) const {
        return name == a.name &amp;&amp; number == a.number;
    }
    // ...
};
</pre></div>
</div>
<p>Il confronto di <code class="docutils literal notranslate"><span class="pre">B</span></code> accetta le conversioni per il secondo operando, ma non per il primo.</p>
</section>
<section id="id577">
<h5>Nota<a class="headerlink" href="#id577" title="Link to this heading">¶</a></h5>
<p>Se una classe è in uno stato di errore, come il <code class="docutils literal notranslate"><span class="pre">NaN</span></code> per <code class="docutils literal notranslate"><span class="pre">double</span></code>, c’è la tentazione di fare un confronto con lo stato dell’errore. L’alternativa consiste nel fare in modo che due stati erronei risultino uguali, mentre il confronto tra uno stato valido ed uno erroneo risulti falso.</p>
</section>
<section id="id578">
<h5>Nota<a class="headerlink" href="#id578" title="Link to this heading">¶</a></h5>
<p>Questa regola si applica a tutti i soliti operatori di confronto: <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> e <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>.</p>
</section>
<section id="id579">
<h5>Imposizione<a class="headerlink" href="#id579" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare un <code class="docutils literal notranslate"><span class="pre">operator==()</span></code> per cui i tipi degli argomenti differiscano; lo stesso per gli altri operatori di confronto: <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> e <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>.</p></li>
<li><p>Segnalare i membri <code class="docutils literal notranslate"><span class="pre">operator==()</span></code>; lo stesso per gli altri operatori di confronto: <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> e <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>.</p></li>
</ul>
</section>
</section>
<section id="c-87-beware-of-on-base-classes">
<h4><a name="Rc-eq-base"></a>C.87: Attenzione a <code class="docutils literal notranslate"><span class="pre">==</span></code> sulle classi base<a class="headerlink" href="#c-87-beware-of-on-base-classes" title="Link to this heading">¶</a></h4>
<section id="id580">
<h5>Motivo<a class="headerlink" href="#id580" title="Link to this heading">¶</a></h5>
<p>È davvero difficile scrivere un infallibile e utile <code class="docutils literal notranslate"><span class="pre">==</span></code> per una gerarchia.</p>
</section>
<section id="id581">
<h5>Esempio, cattivo<a class="headerlink" href="#id581" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class B {
    string name;
    int number;
public:
    virtual bool operator==(const B&amp; a) const
    {
         return name == a.name &amp;&amp; number == a.number;
    }
    // ...
};
</pre></div>
</div>
<p>Il confronto di <code class="docutils literal notranslate"><span class="pre">B</span></code> accetta le conversioni per il secondo operando, ma non per il primo.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class D : public B {
    char character;
public:
    virtual bool operator==(const D&amp; a) const
    {
        return B::operator==(a) &amp;&amp; character == a.character;
    }
    // ...
};

B b = ...
D d = ...
b == d;    // compares name and number, ignores d&#39;s character
d == b;    // compares name and number, ignores d&#39;s character
D d2;
d == d2;   // compares name, number, and character
B&amp; b2 = d2;
b2 == d;   // compares name and number, ignores d2&#39;s and d&#39;s character
</pre></div>
</div>
<p>Naturalmente ci sono modi per far funzionare <code class="docutils literal notranslate"><span class="pre">==</span></code> in una gerarchia, ma gli approcci improvvisati non sono scalabili</p>
</section>
<section id="id582">
<h5>Nota<a class="headerlink" href="#id582" title="Link to this heading">¶</a></h5>
<p>Questa regola si applica a tutti i soliti operatori di confronto: <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> e <code class="docutils literal notranslate"><span class="pre">&lt;=&gt;</span></code>.</p>
</section>
<section id="id583">
<h5>Imposizione<a class="headerlink" href="#id583" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare un <code class="docutils literal notranslate"><span class="pre">operator==()</span></code> virtuale; lo stesso per altri operatori di confronto: <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> e <code class="docutils literal notranslate"><span class="pre">&lt;=&gt;</span></code>.</p></li>
</ul>
</section>
</section>
<section id="c-89-make-a-hash-noexcept">
<h4><a name="Rc-hash"></a>C.89: Rendere un <code class="docutils literal notranslate"><span class="pre">hash</span></code> <code class="docutils literal notranslate"><span class="pre">noexcept</span></code><a class="headerlink" href="#c-89-make-a-hash-noexcept" title="Link to this heading">¶</a></h4>
<section id="id584">
<h5>Motivo<a class="headerlink" href="#id584" title="Link to this heading">¶</a></h5>
<p>Gli utenti dei contenitori che usano l’hash lo fanno indirettamente e non si aspettano una eccezione. È un requisito della standard-library.</p>
</section>
<section id="id585">
<h5>Esempio, cattivo<a class="headerlink" href="#id585" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;&gt;
struct hash&lt;My_type&gt; {  // thoroughly bad hash specialization
    using result_type = size_t;
    using argument_type = My_type;

    size_t operator()(const My_type &amp; x) const
    {
        size_t xs = x.s.size();
        if (xs &lt; 4) throw Bad_My_type{};    // &quot;Nobody expects the Spanish inquisition!&quot;
        return hash&lt;size_t&gt;()(x.s.size()) ^ trim(x.s);
    }
};

int main()
{
    unordered_map&lt;My_type, int&gt; m;
    My_type mt{ &quot;asdfg&quot; };
    m[mt] = 7;
    cout &lt;&lt; m[My_type{ &quot;asdfg&quot; }] &lt;&lt; &#39;\n&#39;;
}
</pre></div>
</div>
<p>Se bisogna definire una specializzazione di <code class="docutils literal notranslate"><span class="pre">hash</span></code>, provare semplicemente a combinare le specializzazioni di <code class="docutils literal notranslate"><span class="pre">hash</span></code> della libreria standard con <code class="docutils literal notranslate"><span class="pre">^</span></code> (xor). Ciò tende a funzionare meglio della «intelligenza» per i non-specialisti.</p>
</section>
<section id="id586">
<h5>Imposizione<a class="headerlink" href="#id586" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare gli <code class="docutils literal notranslate"><span class="pre">hash</span></code> con eccezioni.</p></li>
</ul>
</section>
</section>
<section id="c-90-rely-on-constructors-and-assignment-operators-not-memset-and-memcpy">
<h4><a name="Rc-memset"></a>C.90: Affidarsi ai costruttori e agli operatori di assegnazione, non a <code class="docutils literal notranslate"><span class="pre">memset</span></code> né a <code class="docutils literal notranslate"><span class="pre">memcpy</span></code><a class="headerlink" href="#c-90-rely-on-constructors-and-assignment-operators-not-memset-and-memcpy" title="Link to this heading">¶</a></h4>
<section id="id587">
<h5>Motivo<a class="headerlink" href="#id587" title="Link to this heading">¶</a></h5>
<p>Il meccanismo standard del C++ per costruire un’istanza di un tipo consiste nel richiamare il suo costruttore. Come specificato nella linea-guida <a class="reference internal" href="#Rc-complete"><span class="xref myst">C.41</span></a>: un costruttore dovrebbe creare un oggetto completamente inizializzato. Non dovrebbe essere necessaria alcuna ulteriore inizializzazione, come per <code class="docutils literal notranslate"><span class="pre">memcpy</span></code>. Un tipo fornirà un costruttore copia e/o un operatore di assegnazione per creare adeguatamente una copia della classe, preservando le invarianti del tipo.  Utilizzando memcpy per copiare un tipo non banalmente copiabile si ottiene un comportamento indefinito.  Spesso ciò provoca lo slicing, e la corruzione dei dati.</p>
</section>
<section id="id588">
<h5>Esempio, buono<a class="headerlink" href="#id588" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct base {
    virtual void update() = 0;
    std::shared_ptr&lt;int&gt; sp;
};

struct derived : public base {
    void update() override {}
};
</pre></div>
</div>
</section>
<section id="id589">
<h5>Esempio, cattivo<a class="headerlink" href="#id589" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void init(derived&amp; a)
{
    memset(&amp;a, 0, sizeof(derived));
}
</pre></div>
</div>
<p>Questo è [type-unsafe] e sovrascrive la vtable.</p>
</section>
<section id="id590">
<h5>Esempio, cattivo<a class="headerlink" href="#id590" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void copy(derived&amp; a, derived&amp; b)
{
    memcpy(&amp;a, &amp;b, sizeof(derived));
}
</pre></div>
</div>
<p>Anche questo è type-unsafe e sovrascrive la vtable.</p>
</section>
<section id="id591">
<h5>Imposizione<a class="headerlink" href="#id591" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare il passaggio a <code class="docutils literal notranslate"><span class="pre">memset</span></code> o a <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> di un tipo non-banalmente-copiabile.</p></li>
</ul>
</section>
</section>
</section>
<section id="c-con-containers-and-other-resource-handles">
<h3><a name="SS-containers"></a>C.con: Contenitori ed altri handle di risorse<a class="headerlink" href="#c-con-containers-and-other-resource-handles" title="Link to this heading">¶</a></h3>
<p>Un contenitore è un oggetto che contiene una sequenza di oggetti di qualche tipo; <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> è un archetipo di contenitore. Un handle [gestore] di una risorsa è una classe che possiede una risorsa; <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> è il tipico handle di una risorsa; la sua risorsa è la sua sequenza degli elementi.</p>
<p>Riepilogo delle regole sui contenitori:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rcon-stl"><span class="xref myst">C.100: Seguire la STL quando si definisce un contenitore</span></a></p></li>
<li><p><a class="reference internal" href="#Rcon-val"><span class="xref myst">C.101: Fornire una semantica del valore ad un contenitore</span></a></p></li>
<li><p><a class="reference internal" href="#Rcon-move"><span class="xref myst">C.102: Fornire ad un contenitore le operazioni di spostamento</span></a></p></li>
<li><p><a class="reference internal" href="#Rcon-init"><span class="xref myst">C.103: Fornire ad un contenitore un costruttore con una lista inizializzatrice</span></a></p></li>
<li><p><a class="reference internal" href="#Rcon-empty"><span class="xref myst">C.104: Fornire ad un contenitore un costruttore di default che lo imposti a vuoto</span></a></p></li>
<li><p>???</p></li>
<li><p><a class="reference internal" href="#Rcon-ptr"><span class="xref myst">C.109: Se un handle di risorsa ha una semantica di puntatore, fornire <code class="docutils literal notranslate"><span class="pre">*</span></code> e <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code></span></a></p></li>
</ul>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#S-resource"><span class="xref myst">Risorse</span></a></p>
<section id="c-100-follow-the-stl-when-defining-a-container">
<h4><a name="Rcon-stl"></a>C.100: Seguire la STL quando si definisce un contenitore<a class="headerlink" href="#c-100-follow-the-stl-when-defining-a-container" title="Link to this heading">¶</a></h4>
<section id="id592">
<h5>Motivo<a class="headerlink" href="#id592" title="Link to this heading">¶</a></h5>
<p>I contenitori della STL sono familiari alla maggior parte dei programmatori C++ e hanno un design fondamentalmente solido.</p>
</section>
<section id="id593">
<h5>Nota<a class="headerlink" href="#id593" title="Link to this heading">¶</a></h5>
<p>Esistono, ovviamente, altri stili di progettazione e talvolta si discostano dallo stile della libreria standard, ma in assenza di un solido motivo per differenziarsi, è più semplice e più facile sia per gli implementatori che per gli utenti seguire lo standard.</p>
<p>In particolare, <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> e <code class="docutils literal notranslate"><span class="pre">std::map</span></code> costituiscono dei modelli utili relativamente semplici.</p>
</section>
<section id="id594">
<h5>Esempio<a class="headerlink" href="#id594" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// simplified (e.g., no allocators):

template&lt;typename T&gt;
class Sorted_vector {
    using value_type = T;
    // ... iterator types ...

    Sorted_vector() = default;
    Sorted_vector(initializer_list&lt;T&gt;);    // initializer-list constructor: sort and store
    Sorted_vector(const Sorted_vector&amp;) = default;
    Sorted_vector(Sorted_vector&amp;&amp;) noexcept = default;
    Sorted_vector&amp; operator=(const Sorted_vector&amp;) = default;     // copy assignment
    Sorted_vector&amp; operator=(Sorted_vector&amp;&amp;) noexcept = default; // move assignment
    ~Sorted_vector() = default;

    Sorted_vector(const std::vector&lt;T&gt;&amp; v);   // store and sort
    Sorted_vector(std::vector&lt;T&gt;&amp;&amp; v);        // sort and &quot;steal representation&quot;

    const T&amp; operator[](int i) const { return rep[i]; }
    // no non-const direct access to preserve order

    void push_back(const T&amp;);   // insert in the right place (not necessarily at back)
    void push_back(T&amp;&amp;);        // insert in the right place (not necessarily at back)

    // ... cbegin(), cend() ...
private:
    std::vector&lt;T&gt; rep;  // use a std::vector to hold elements
};

template&lt;typename T&gt; bool operator==(const Sorted_vector&lt;T&gt;&amp;, const Sorted_vector&lt;T&gt;&amp;);
template&lt;typename T&gt; bool operator!=(const Sorted_vector&lt;T&gt;&amp;, const Sorted_vector&lt;T&gt;&amp;);
// ...
</pre></div>
</div>
<p>Qui viene seguito lo stile STL, ma in modo incompleto. Non è raro. Fornire solo le funzionalità che hanno senso per uno specifico contenitore. La chiave consiste nel definire i costruttori convenzionali, le assegnazioni, i distruttori e gli iteratori (come significativi per lo specifico contenitore) con la loro convenzionale semantica. Partendo da questa base, il contenitore può essere espanso secondo le necessità. Qui sono stati aggiunti degli speciali costruttori per <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>.</p>
</section>
<section id="id595">
<h5>Imposizione<a class="headerlink" href="#id595" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="c-101-give-a-container-value-semantics">
<h4><a name="Rcon-val"></a>C.101: Fornire una semantica del valore ad un contenitore<a class="headerlink" href="#c-101-give-a-container-value-semantics" title="Link to this heading">¶</a></h4>
<section id="id596">
<h5>Motivo<a class="headerlink" href="#id596" title="Link to this heading">¶</a></h5>
<p>Gli oggetti regolari sono più semplici da immaginare e gestire di quelli irregolari. Familiarità.</p>
</section>
<section id="id597">
<h5>Nota<a class="headerlink" href="#id597" title="Link to this heading">¶</a></h5>
<p>Se ha senso, si crea un contenitore <code class="docutils literal notranslate"><span class="pre">Regular</span></code> (il concetto). In particolare, ci si assicuri che un oggetto risulti uguale a se stesso da un’operazione di confronto.</p>
</section>
<section id="id598">
<h5>Esempio<a class="headerlink" href="#id598" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(const Sorted_vector&lt;string&gt;&amp; v)
{
    Sorted_vector&lt;string&gt; v2 {v};
    if (v != v2)
        cout &lt;&lt; &quot;Behavior against reason and logic.\n&quot;;
    // ...
}
</pre></div>
</div>
</section>
<section id="id599">
<h5>Imposizione<a class="headerlink" href="#id599" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="c-102-give-a-container-move-operations">
<h4><a name="Rcon-move"></a>C.102: Fornire ad un contenitore le operazioni di spostamento<a class="headerlink" href="#c-102-give-a-container-move-operations" title="Link to this heading">¶</a></h4>
<section id="id600">
<h5>Motivo<a class="headerlink" href="#id600" title="Link to this heading">¶</a></h5>
<p>I contenitori tendono a diventare grandi; senza un costruttore di spostamento ed uno di copia un oggetto può risultare costoso da spostare, inducendo così le persone a passare i puntatori per poi affrontare i problemi di gestione delle risorse.</p>
</section>
<section id="id601">
<h5>Esempio<a class="headerlink" href="#id601" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Sorted_vector&lt;int&gt; read_sorted(istream&amp; is)
{
    vector&lt;int&gt; v;
    cin &gt;&gt; v;   // assume we have a read operation for vectors
    Sorted_vector&lt;int&gt; sv = v;  // sorts
    return sv;
}
</pre></div>
</div>
<p>Un utente può ragionevolmente presumere che il ritorno da un contenitore di tipo standard sia economico.</p>
</section>
<section id="id602">
<h5>Imposizione<a class="headerlink" href="#id602" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="c-103-give-a-container-an-initializer-list-constructor">
<h4><a name="Rcon-init"></a>C.103: Fornire ad un contenitore un costruttore con una lista inizializzatrice<a class="headerlink" href="#c-103-give-a-container-an-initializer-list-constructor" title="Link to this heading">¶</a></h4>
<section id="id603">
<h5>Motivo<a class="headerlink" href="#id603" title="Link to this heading">¶</a></h5>
<p>Le persone si aspettano di essere in grado di inizializzare un contenitore con un set di valori. Familiarità.</p>
</section>
<section id="id604">
<h5>Esempio<a class="headerlink" href="#id604" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Sorted_vector&lt;int&gt; sv {1, 3, -1, 7, 0, 0}; // Sorted_vector sorts elements as needed
</pre></div>
</div>
</section>
<section id="id605">
<h5>Imposizione<a class="headerlink" href="#id605" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="c-104-give-a-container-a-default-constructor-that-sets-it-to-empty">
<h4><a name="Rcon-empty"></a>C.104: Fornire ad un contenitore un costruttore di default che lo imposti a vuoto<a class="headerlink" href="#c-104-give-a-container-a-default-constructor-that-sets-it-to-empty" title="Link to this heading">¶</a></h4>
<section id="id606">
<h5>Motivo<a class="headerlink" href="#id606" title="Link to this heading">¶</a></h5>
<p>Renderlo <code class="docutils literal notranslate"><span class="pre">Regular</span></code>.</p>
</section>
<section id="id607">
<h5>Esempio<a class="headerlink" href="#id607" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;Sorted_sequence&lt;string&gt;&gt; vs(100);    // 100 Sorted_sequences each with the value &quot;&quot;
</pre></div>
</div>
</section>
<section id="id608">
<h5>Imposizione<a class="headerlink" href="#id608" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="c-109-if-a-resource-handle-has-pointer-semantics-provide-and">
<h4><a name="Rcon-ptr"></a>C.109: Se un handle di risorsa ha una semantica di puntatore, fornire <code class="docutils literal notranslate"><span class="pre">*</span></code> e <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code><a class="headerlink" href="#c-109-if-a-resource-handle-has-pointer-semantics-provide-and" title="Link to this heading">¶</a></h4>
<section id="id609">
<h5>Motivo<a class="headerlink" href="#id609" title="Link to this heading">¶</a></h5>
<p>Questo è quello che ci si aspetta dai puntatori. Familiarità.</p>
</section>
<section id="id610">
<h5>Esempio<a class="headerlink" href="#id610" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id611">
<h5>Imposizione<a class="headerlink" href="#id611" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
</section>
<section id="c-lambdas-function-objects-and-lambdas">
<h3><a name="SS-lambdas"></a>C.lambdas: Oggetti funzione e lambda<a class="headerlink" href="#c-lambdas-function-objects-and-lambdas" title="Link to this heading">¶</a></h3>
<p>Un oggetto funzione è un oggetto che fornisce un  <code class="docutils literal notranslate"><span class="pre">()</span></code> [overloaded] in modo che lo si possa chiamare. Un’espressione lambda (colloquialmente spesso abbreviata in «una lambda») è una notazione per generare un oggetto funzione. Gli oggetti funzione dovrebbero essere economici da copiare (e quindi <a class="reference internal" href="#Rf-in"><span class="xref myst">passati per valore</span></a>).</p>
<p>Sommario:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rf-name"><span class="xref myst">F.10: Se un’operazione può essere riutilizzata, le si assegna un nome</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-lambda"><span class="xref myst">F.11: Usare una lambda anonima se c’è bisogno di un semplice oggetto funzione in un posto soltanto</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-capture-vs-overload"><span class="xref myst">F.50: Usare una lambda quando non è possibile una funzione (per acquisire le variabili locali o scrivere una funzione locale))</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-reference-capture"><span class="xref myst">F.52: Preferire l’acquisizione per riferimento nelle lambda da usare localmente, compresi quelli passati  agli algoritmi</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-value-capture"><span class="xref myst">F.53: Evitare l’acquisizione per riferimento nelle lambda che non si useranno localmente, compresi quelli restituiti, memorizzati nell’heap o passati da un altro thread</span></a></p></li>
<li><p><a class="reference internal" href="#Res-lambda-init"><span class="xref myst">ES.28: Usare le lambda per delle inizializzazioni complesse, specialmente di variabili <code class="docutils literal notranslate"><span class="pre">const</span></code></span></a></p></li>
</ul>
</section>
<section id="c-hier-class-hierarchies-oop">
<h3><a name="SS-hier"></a>C.hier: Gerarchia di classi (OOP)<a class="headerlink" href="#c-hier-class-hierarchies-oop" title="Link to this heading">¶</a></h3>
<p>Una gerarchia di classi viene costruita per rappresentare (solo) un insieme concetti organizzati gerarchicamente. In genere le classi base fungono da interfacce. Esistono due usi principali delle gerarchie, spesso chiamati ereditarietà dell’implementazione e ereditarietà dell’interfaccia.</p>
<p>Sommario delle regole per le gerarchie di classi:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rh-domain"><span class="xref myst">C.120: Usare le gerarchie di classi per rappresentare (solo) i concetti con una intrinseca struttura gerarchica</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-abstract"><span class="xref myst">C.121: Se una classe base viene usata come interfaccia, crearla come classe astratta pura</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-separation"><span class="xref myst">C.122: Usare le classi astratte come interfacce quando è necessaria una completa separazione tra l’interfaccia e l’implementazione</span></a></p></li>
</ul>
<p>Sommario delle regole di progettazione per le classi di una gerarchia:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rh-abstract-ctor"><span class="xref myst">C.126: Una classe astratta, solitamente, non necessita di un costruttore scritto a mano</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-dtor"><span class="xref myst">C.127: Una classe con una funzione virtuale dovrebbe avere un distruttore virtuale o protected</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-override"><span class="xref myst">C.128: Le funzioni virtuali devono specificare esattamente un attributo tra <code class="docutils literal notranslate"><span class="pre">virtual</span></code>, <code class="docutils literal notranslate"><span class="pre">override</span></code> e <code class="docutils literal notranslate"><span class="pre">final</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rh-kind"><span class="xref myst">C.129: Quando si progetta una gerarchia di classi, distinguere tra ereditarietà dell’implementazione e ereditarietà dell’interfaccia</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-copy"><span class="xref myst">C.130: Per eseguire copie complete [deep] di classi polimorfiche preferire una funzione virtuale <code class="docutils literal notranslate"><span class="pre">clone</span></code> anziché un costruttore di copia/assegnazione public</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-get"><span class="xref myst">C.131: Evitare getter e setter banali</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-virtual"><span class="xref myst">C.132: Non creare una funzione <code class="docutils literal notranslate"><span class="pre">virtual</span></code> senza motivo</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-protected"><span class="xref myst">C.133: Evitare dati <code class="docutils literal notranslate"><span class="pre">protected</span></code> data</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-public"><span class="xref myst">C.134: Assicurarsi che tutti i dati membro non-<code class="docutils literal notranslate"><span class="pre">const</span></code> abbiano lo stesso livello di accesso</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-mi-interface"><span class="xref myst">C.135: Utilizzare l’ereditarietà multipla per rappresentare più interfacce distinte</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-mi-implementation"><span class="xref myst">C.136: Utilizzare l’ereditarietà multipla per rappresentare l’unione degli attributi di un’implementazione</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-vbase"><span class="xref myst">C.137: Usare basi <code class="docutils literal notranslate"><span class="pre">virtual</span></code> per evitare troppe classi base generali</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-using"><span class="xref myst">C.138: Creare un set di overload per una classe derivata e le sue basi con <code class="docutils literal notranslate"><span class="pre">using</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rh-final"><span class="xref myst">C.139: Usare <code class="docutils literal notranslate"><span class="pre">final</span></code> sulle classi con parsimonia</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-virtual-default-arg"><span class="xref myst">C.140: Non fornire argomenti di default diversi a una funzione virtuale e a una sovrapposta [overrider]</span></a></p></li>
</ul>
<p>Sommario delle regole per l’accesso a oggetti in una gerarchia:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rh-poly"><span class="xref myst">C.145: Accedere agli oggetti polimorfici tramite puntatori e riferimenti</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-dynamic_cast"><span class="xref myst">C.146: Usare il <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> dove è inevitabile la navigazione della gerarchia della classe</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-ref-cast"><span class="xref myst">C.147: Usare il <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> per un tipo di riferimento quando la non riuscita della ricerca della classe richiesta è considerata un errore</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-ptr-cast"><span class="xref myst">C.148: Usare <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> per un tipo di puntatore quando la non riuscita della ricerca della classe richiesta è considerata una alternativa valida</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-smart"><span class="xref myst">C.149: Usare <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> o <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> per evitare di dimenticarsi il <code class="docutils literal notranslate"><span class="pre">delete</span></code> degli oggetti creati con <code class="docutils literal notranslate"><span class="pre">new</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rh-make_unique"><span class="xref myst">C.150: Usare <code class="docutils literal notranslate"><span class="pre">make_unique()</span></code> per costruire oggetti posseduti dagli <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code>s</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-make_shared"><span class="xref myst">C.151: Usare <code class="docutils literal notranslate"><span class="pre">make_shared()</span></code> per costruire oggetti posseduti dagli <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>s</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-array"><span class="xref myst">C.152: Mai assegnare un puntatore ad un array di oggetti di classi derivate a un puntatore alla sua classe base</span></a></p></li>
<li><p><a class="reference internal" href="#Rh-use-virtual"><span class="xref myst">C.153: Preferire la funzione virtual al casting</span></a></p></li>
</ul>
<section id="c-120-use-class-hierarchies-to-represent-concepts-with-inherent-hierarchical-structure-only">
<h4><a name="Rh-domain"></a>C.120: Usare le gerarchie di classi per rappresentare (solo) i concetti con una intrinseca struttura gerarchica<a class="headerlink" href="#c-120-use-class-hierarchies-to-represent-concepts-with-inherent-hierarchical-structure-only" title="Link to this heading">¶</a></h4>
<section id="id612">
<h5>Motivo<a class="headerlink" href="#id612" title="Link to this heading">¶</a></h5>
<p>La diretta rappresentazione delle idee nel codice facilita la comprensione e la manutenzione. Assicurarsi che l’idea rappresentata nella classe base coincida esattamente con tutti i tipi derivati e che non esista un modo migliore per rappresentarla che usare l’accoppiamento stretto [tight coupling] dell’ereditarietà.</p>
<p><em>Non</em> usare l’ereditarietà quando basterà semplicemente avere un dato membro. In genere ciò significa che il tipo derivato deve sovrascrivere [override] una funzione base virtuale o deve accedere ad un membro protected.</p>
</section>
<section id="id613">
<h5>Esempio<a class="headerlink" href="#id613" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class DrawableUIElement {
public:
    virtual void render() const = 0;
    // ...
};

class AbstractButton : public DrawableUIElement {
public:
    virtual void onClick() = 0;
    // ...
};

class PushButton : public AbstractButton {
    void render() const override;
    void onClick() override;
    // ...
};

class Checkbox : public AbstractButton {
// ...
};
</pre></div>
</div>
</section>
<section id="id614">
<h5>Esempio, cattivo<a class="headerlink" href="#id614" title="Link to this heading">¶</a></h5>
<p><em>Non</em> rappresentare concetti in domini non-gerarchici con gerarchie di classi.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
class Container {
public:
    // list operations:
    virtual T&amp; get() = 0;
    virtual void put(T&amp;) = 0;
    virtual void insert(Position) = 0;
    // ...
    // vector operations:
    virtual T&amp; operator[](int) = 0;
    virtual void sort() = 0;
    // ...
    // tree operations:
    virtual void balance() = 0;
    // ...
};
</pre></div>
</div>
<p>Qui la maggior parte delle classi che si sovrascrivono [overriding] non possono implementare bene la maggior parte delle funzioni richieste nell’interfaccia. Pertanto la classe base diventa un onere di implementazione. Inoltre, l’utente di <code class="docutils literal notranslate"><span class="pre">Container</span></code> non può fare affidamento sulle funzioni membro che effettivamente eseguono operazioni significative in modo ragionevolmente efficiente; potrebbe sollevare, invece, un’eccezione. Pertanto gli utenti devono ricorrere ad un controllo a run-time e/o a non usare questa interfaccia (super)generale a favore di un’interfaccia particolare trovata a run-time interrogando il tipo (p.es., un <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code>).</p>
</section>
<section id="id615">
<h5>Imposizione<a class="headerlink" href="#id615" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Cercare le classi con molti membri che non fanno altro che sollevare errori [throw].</p></li>
<li><p>Segnalare ogni utilizzo di una classe base non pubblica <code class="docutils literal notranslate"><span class="pre">B</span></code> dove la classe derivata <code class="docutils literal notranslate"><span class="pre">D</span></code> non sovrascrive [override] una funzione virtuale né accede a membri protetti in <code class="docutils literal notranslate"><span class="pre">B</span></code>, e <code class="docutils literal notranslate"><span class="pre">B</span></code> non è nessuna delle seguenti: vuota, un parametro template o un pacchetto di parametri di <code class="docutils literal notranslate"><span class="pre">D</span></code>, una classe template specializzata con <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p></li>
</ul>
</section>
</section>
<section id="c-121-if-a-base-class-is-used-as-an-interface-make-it-a-pure-abstract-class">
<h4><a name="Rh-abstract"></a>C.121: Se una classe base viene usata come interfaccia, crearla come classe astratta pura<a class="headerlink" href="#c-121-if-a-base-class-is-used-as-an-interface-make-it-a-pure-abstract-class" title="Link to this heading">¶</a></h4>
<section id="id616">
<h5>Motivo<a class="headerlink" href="#id616" title="Link to this heading">¶</a></h5>
<p>Una classe è più stabile (meno fragile) se non contiene dati. Le interfacce dovrebbero normalmente essere composte interamente da funzioni virtuali pure pubbliche e un distruttore virtuale di default/vuoto.</p>
</section>
<section id="id617">
<h5>Esempio<a class="headerlink" href="#id617" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class My_interface {
public:
    // ...only pure virtual functions here ...
    virtual ~My_interface() {}   // or =default
};
</pre></div>
</div>
</section>
<section id="id618">
<h5>Esempio, cattivo<a class="headerlink" href="#id618" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Goof {
public:
    // ...only pure virtual functions here ...
    // no virtual destructor
};

class Derived : public Goof {
    string s;
    // ...
};

void use()
{
    unique_ptr&lt;Goof&gt; p {new Derived{&quot;here we go&quot;}};
    f(p.get()); // use Derived through the Goof interface
    g(p.get()); // use Derived through the Goof interface
} // leak
</pre></div>
</div>
<p>La <code class="docutils literal notranslate"><span class="pre">Derived</span></code> viene distrutta con <code class="docutils literal notranslate"><span class="pre">delete</span></code> tramite la sua interfaccia <code class="docutils literal notranslate"><span class="pre">Goof</span></code>, quindi la sua <code class="docutils literal notranslate"><span class="pre">string</span></code> si perde [leak]. Dando a <code class="docutils literal notranslate"><span class="pre">Goof</span></code> un distruttore virtuale tutto va bene.</p>
</section>
<section id="id619">
<h5>Imposizione<a class="headerlink" href="#id619" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Avvisare su qualsiasi classe che contiene dati membro e che abbia anche una funzione virtuale sovrascrivibile [overridable] (non-<code class="docutils literal notranslate"><span class="pre">final</span></code>) che non sia stata ereditata da una classe base.</p></li>
</ul>
</section>
</section>
<section id="c-122-use-abstract-classes-as-interfaces-when-complete-separation-of-interface-and-implementation-is-needed">
<h4><a name="Rh-separation"></a>C.122: Usare le classi astratte come interfacce quando è necessaria una completa separazione tra l’interfaccia e l’implementazione<a class="headerlink" href="#c-122-use-abstract-classes-as-interfaces-when-complete-separation-of-interface-and-implementation-is-needed" title="Link to this heading">¶</a></h4>
<section id="id620">
<h5>Motivo<a class="headerlink" href="#id620" title="Link to this heading">¶</a></h5>
<p>Come all’interno del confine di un ABI [Application Binary Interface] (link).</p>
</section>
<section id="id621">
<h5>Esempio<a class="headerlink" href="#id621" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Device {
    virtual ~Device() = default;
    virtual void write(span&lt;const char&gt; outbuf) = 0;
    virtual void read(span&lt;char&gt; inbuf) = 0;
};

class D1 : public Device {
    // ... data ...

    void write(span&lt;const char&gt; outbuf) override;
    void read(span&lt;char&gt; inbuf) override;
};

class D2 : public Device {
    // ... different data ...

    void write(span&lt;const char&gt; outbuf) override;
    void read(span&lt;char&gt; inbuf) override;
};
</pre></div>
</div>
<p>Un utente ora può utilizzare l’interfaccia di <code class="docutils literal notranslate"><span class="pre">D1</span></code> e di <code class="docutils literal notranslate"><span class="pre">D2</span></code> in modo intercambiabile attraverso l’interfaccia fornita da <code class="docutils literal notranslate"><span class="pre">Device</span></code>. Inoltre, si possono aggiornare <code class="docutils literal notranslate"><span class="pre">D1</span></code> e <code class="docutils literal notranslate"><span class="pre">D2</span></code> in modo che i file binari non siano compatibili con le versioni precedenti finché tutti gli accessi passano tramite <code class="docutils literal notranslate"><span class="pre">Device</span></code>.</p>
</section>
<section id="id622">
<h5>Imposizione<a class="headerlink" href="#id622" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
</section>
</section>
<section id="c-hierclass-designing-classes-in-a-hierarchy">
<h3>C.hierclass: Progettazioni di classi in una gerarchia:<a class="headerlink" href="#c-hierclass-designing-classes-in-a-hierarchy" title="Link to this heading">¶</a></h3>
<section id="c-126-an-abstract-class-typically-doesn-t-need-a-user-written-constructor">
<h4><a name="Rh-abstract-ctor"></a>C.126: Una classe astratta, solitamente, non necessita di un costruttore scritto a mano<a class="headerlink" href="#c-126-an-abstract-class-typically-doesn-t-need-a-user-written-constructor" title="Link to this heading">¶</a></h4>
<section id="id623">
<h5>Motivo<a class="headerlink" href="#id623" title="Link to this heading">¶</a></h5>
<p>Una classe astratta in genere non ha dati da inizializzare in un costruttore.</p>
</section>
<section id="id624">
<h5>Esempio<a class="headerlink" href="#id624" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Shape {
public:
    // no user-written constructor needed in abstract base class
    virtual Point center() const = 0;    // pure virtual
    virtual void move(Point to) = 0;
    // ... more pure virtual functions...
    virtual ~Shape() {}                 // destructor
};

class Circle : public Shape {
public:
    Circle(Point p, int rad);           // constructor in derived class
    Point center() const override { return x; }
};
</pre></div>
</div>
</section>
<section id="id625">
<h5>Eccezione<a class="headerlink" href="#id625" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Un costruttore di una classe base che, per esempio, registra un oggetto da qualche parte, potrebbe aver bisogno di un costruttore.</p></li>
<li><p>In casi estremamente rari, potrebbe essere ragionevole che una classe astratta abbia un po” di dati condivisi da tutte le classi derivate (p.es., dati ad uso statistico, informazioni di debug, ecc.); tali classi tendono ad avere dei costruttori. Ma attenzione: Tali classi tendono anche ad essere propense a richiedere l’ereditarietà virtuale.</p></li>
</ul>
</section>
<section id="id626">
<h5>Imposizione<a class="headerlink" href="#id626" title="Link to this heading">¶</a></h5>
<p>Segnalare le classi astratte con costruttori.</p>
</section>
</section>
<section id="c-127-a-class-with-a-virtual-function-should-have-a-virtual-or-protected-destructor">
<h4><a name="Rh-dtor"></a>C.127: Una classe con una funzione virtuale dovrebbe avere un distruttore virtuale o protected<a class="headerlink" href="#c-127-a-class-with-a-virtual-function-should-have-a-virtual-or-protected-destructor" title="Link to this heading">¶</a></h4>
<section id="id627">
<h5>Motivo<a class="headerlink" href="#id627" title="Link to this heading">¶</a></h5>
<p>Una classe con una funzione virtuale è solitamente (e in generale) utilizzata tramite un puntatore ad una classe base. Di solito, l’ultimo utente deve chiamare il delete su un puntatore alla base, spesso tramite uno smart pointer alla base, quindi il distruttore dovrebbe essere pubblico e virtuale. Meno spesso, se non si intende supportare la cancellazione tramite un puntatore a una base, il distruttore dovrebbe essere protected e non-virtuale; cfr. <a class="reference internal" href="#Rc-dtor-virtual"><span class="xref myst">C.35</span></a>.</p>
</section>
<section id="id628">
<h5>Esempio, cattivo<a class="headerlink" href="#id628" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct B {
    virtual int f() = 0;
    // ... no user-written destructor, defaults to public non-virtual ...
};

// bad: derived from a class without a virtual destructor
struct D : B {
    string s {&quot;default&quot;};
    // ...
};

void use()
{
    unique_ptr&lt;B&gt; p = make_unique&lt;D&gt;();
    // ...
} // undefined behavior, might call B::~B only and leak the string
</pre></div>
</div>
</section>
<section id="id629">
<h5>Nota<a class="headerlink" href="#id629" title="Link to this heading">¶</a></h5>
<p>Ci sono persone che non seguono questa regola perché intendono usare una classe solo attraverso un <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>: <code class="docutils literal notranslate"><span class="pre">std::shared_ptr&lt;B&gt;</span> <span class="pre">p</span> <span class="pre">=</span> <span class="pre">std::make_shared&lt;D&gt;(args);</span></code> Qui, lo shared pointer si occuperà della cancellazione e quindi non avverrà alcun [leak] derivante da un inappropriato <code class="docutils literal notranslate"><span class="pre">delete</span></code> della base. Le persone che lo fanno in modo coerente possono ottenere un falso positivo, ma la regola è importante – cosa succede se ne viene allocato uno utilizzando <code class="docutils literal notranslate"><span class="pre">make_unique</span></code>? Non è sicuro a meno che l’autore di <code class="docutils literal notranslate"><span class="pre">B</span></code> assicuri che non possa mai essere utilizzato in modo improprio, ad esempio rendendo privati tutti i costruttori e fornendo una funzione factory per imporre l’allocazione con <code class="docutils literal notranslate"><span class="pre">make_shared</span></code>.</p>
</section>
<section id="id630">
<h5>Imposizione<a class="headerlink" href="#id630" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Una classe con una qualsiasi funzione virtuale dovrebbe avere un distruttore o pubblico e virtuale oppure protetto e non-virtuale.</p></li>
<li><p>Segnalare il <code class="docutils literal notranslate"><span class="pre">delete</span></code> di una classe con una funzione virtuale ma senza un distruttore virtuale.</p></li>
</ul>
</section>
</section>
<section id="c-128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final">
<h4><a name="Rh-override"></a>C.128: Le funzioni virtuali devono specificare esattamente un attributo tra <code class="docutils literal notranslate"><span class="pre">virtual</span></code>, <code class="docutils literal notranslate"><span class="pre">override</span></code> e <code class="docutils literal notranslate"><span class="pre">final</span></code><a class="headerlink" href="#c-128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final" title="Link to this heading">¶</a></h4>
<section id="id631">
<h5>Motivo<a class="headerlink" href="#id631" title="Link to this heading">¶</a></h5>
<p>Leggibilità. Rilevamento di errori. Scrivere un esplicito <code class="docutils literal notranslate"><span class="pre">virtual</span></code>, <code class="docutils literal notranslate"><span class="pre">override</span></code>, o <code class="docutils literal notranslate"><span class="pre">final</span></code> è auto-documentante e consente al compilatore di intercettare gli errori di tipi e/o di nomi tra le classi base e quelle derivate. Tuttavia, scrivere più di uno di questi tre è sia ridondante che una potenziale fonte di errori.</p>
<p>È semplice e chiaro:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">virtual</span></code> significa esattamente e solo «questa è una nuova funzione virtuale».</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">override</span></code> significa esattamente e solo «questa è una funzione overrider e non-final».</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">final</span></code> significa esattamente e solo «questa è una funzione overrider e finale».</p></li>
</ul>
</section>
<section id="id632">
<h5>Esempio, cattivo<a class="headerlink" href="#id632" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct B {
    void f1(int);
    virtual void f2(int) const;
    virtual void f3(int);
    // ...
};

struct D : B {
    void f1(int);        // bad (hope for a warning): D::f1() hides B::f1()
    void f2(int) const;  // bad (but conventional and valid): no explicit override
    void f3(double);     // bad (hope for a warning): D::f3() hides B::f3()
    // ...
};
</pre></div>
</div>
</section>
<section id="id633">
<h5>Esempio, buono<a class="headerlink" href="#id633" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Better : B {
    void f1(int) override;        // error (caught): Better::f1() hides B::f1()
    void f2(int) const override;
    void f3(double) override;     // error (caught): Better::f3() hides B::f3()
    // ...
};
</pre></div>
</div>
</section>
<section id="id634">
<h5>Discussione<a class="headerlink" href="#id634" title="Link to this heading">¶</a></h5>
<p>Vogliamo eliminare due particolari classi di errori:</p>
<ul class="simple">
<li><p><strong>virtual implicito</strong>: il programmatore voleva che la funzione fosse implicitamente virtuale ed è così (ma chi legge il codice non può saperlo); o il programmatore voleva che la funzione fosse implicitamente virtuale ma non lo è (p.es., a causa di una subdola discrepanza nell’elenco dei parametri); o il programmatore non voleva che la funzione fosse virtuale ma lo è (perché capita che abbia la stessa firma della funzione virtuale nella classe base)</p></li>
<li><p><strong>override implicito</strong>: il programmatore voleva che la funzione fosse implicitamente una sovrascrittura [overrider] e lo è (ma i lettori del codice non possono saperlo); o il programmatore voleva che la funzione fosse implicitamente una sovrascrittura [overrider] ma non lo è (p.es., a causa di una subdola discrepanza nell’elenco dei parametri); oppure il programmatore non voleva che la funzione fosse una sovrascrittura [overrider] ma lo è (perché capita che abbia la stessa firma di una funzione virtuale nella classe base – da notare che questo problema sorge indipendentemente dal fatto che la funzione sia esplicitamente o meno dichiarata virtuale, perché il programmatore  potrebbe aver voluto creare o una nuova funzione virtuale o una nuova funzione non-virtuale)</p></li>
</ul>
<p>Nota: Su una classe definita come <code class="docutils literal notranslate"><span class="pre">final</span></code>, non importa se si inserisce <code class="docutils literal notranslate"><span class="pre">override</span></code> o <code class="docutils literal notranslate"><span class="pre">final</span></code> su una singola funzione virtuale.</p>
<p>Note: Usare <code class="docutils literal notranslate"><span class="pre">final</span></code> sulle funzioni con parsimonia. Non riguarda necessariamente l’ottimizzazione e preclude un’ulteriore overriding.</p>
<section id="id635">
<h6>Imposizione<a class="headerlink" href="#id635" title="Link to this heading">¶</a></h6>
<ul class="simple">
<li><p>Confrontare i nomi delle funzioni nelle classi base e derivare e segnalare l’uso dello stesso nome che non sovrascrive [override].</p></li>
<li><p>Segnalare gli [override] senza né <code class="docutils literal notranslate"><span class="pre">override</span></code> né <code class="docutils literal notranslate"><span class="pre">final</span></code>.</p></li>
<li><p>Segnalare le dichiarazioni di funzioni che usano più di uno tra <code class="docutils literal notranslate"><span class="pre">virtual</span></code>, <code class="docutils literal notranslate"><span class="pre">override</span></code> e <code class="docutils literal notranslate"><span class="pre">final</span></code>.</p></li>
</ul>
</section>
</section>
</section>
<section id="c-129-when-designing-a-class-hierarchy-distinguish-between-implementation-inheritance-and-interface-inheritance">
<h4><a name="Rh-kind"></a>C.129: Quando si progetta una gerarchia di classi, distinguere tra ereditarietà dell’implementazione e ereditarietà dell’interfaccia<a class="headerlink" href="#c-129-when-designing-a-class-hierarchy-distinguish-between-implementation-inheritance-and-interface-inheritance" title="Link to this heading">¶</a></h4>
<section id="id636">
<h5>Motivo<a class="headerlink" href="#id636" title="Link to this heading">¶</a></h5>
<p>L’implementazione dei dettagli in un’interfaccia la rendono fragile; vale a dire, obbliga i suoi utenti a dover ricompilare dopo aver modificato l’implementazione. I dati in una classe base aumentano la complessità dell’implementazione della base e possono portare alla replicazione del codice.</p>
</section>
<section id="id637">
<h5>Nota<a class="headerlink" href="#id637" title="Link to this heading">¶</a></h5>
<p>Definizione:</p>
<ul class="simple">
<li><p>l’ereditarietà dell’interfaccia è l’utilizzo dell’ereditarietà per separare gli utenti dalle implementazioni, in particolare consente alle classi derivate di poter essere aggiunte e modificate senza influire sugli utenti delle classi base.</p></li>
<li><p>l’ereditarietà dell’implementazione è l’utilizzo dell’ereditarietà per semplificare l’implementazione di nuove strutture mettendo a disposizione nuove operazioni utili agli implementatori di nuove operazioni correlate (talvolta detto «programmazione per differenza»).</p></li>
</ul>
<p>Una classe interfaccia pura è semplicemente un insieme di funzioni virtuali pure; cfr. <a class="reference internal" href="#Ri-abstract"><span class="xref myst">I.25</span></a>.</p>
<p>All’inizio dell’OOP (p.es., negli anni “80 e “90), l’ereditarietà dell’implementazione e l’ereditarietà dell’interfaccia venivano spesso confuse e le cattive abitudini sono dure a morire. Anche adesso, la confusione non è rara nel vecchio codice e nel materiale didattico di vecchio stampo.</p>
<p>L’importanza di separare i due tipi di ereditarietà aumenta</p>
<ul class="simple">
<li><p>con la dimensione della gerarchia (p.es., decine di classi derivate),</p></li>
<li><p>col periodo di tempo in cui viene usata la gerarchia (p.es., decenni), e</p></li>
<li><p>col numero di organizzazioni diverse in cui viene usata una gerarchia (p.es., può essere difficile distribuire un aggiornamento di una classe base)</p></li>
</ul>
</section>
<section id="id638">
<h5>Esempio, cattivo<a class="headerlink" href="#id638" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Shape {   // BAD, mixed interface and implementation
public:
    Shape();
    Shape(Point ce = {0, 0}, Color co = none): cent{ce}, col {co} { /* ... */}

    Point center() const { return cent; }
    Color color() const { return col; }

    virtual void rotate(int) = 0;
    virtual void move(Point p) { cent = p; redraw(); }

    virtual void redraw();

    // ...
private:
    Point cent;
    Color col;
};

class Circle : public Shape {
public:
    Circle(Point c, int r) : Shape{c}, rad{r} { /* ... */ }

    // ...
private:
    int rad;
};

class Triangle : public Shape {
public:
    Triangle(Point p1, Point p2, Point p3); // calculate center
    // ...
};
</pre></div>
</div>
<p>Problemi:</p>
<ul class="simple">
<li><p>Col crescere della gerarchia e con l’aggiunta di più dati a <code class="docutils literal notranslate"><span class="pre">Shape</span></code>, i costruttori diventano sempre più difficili da scrivere e manutenere.</p></li>
<li><p>Perché calcolare il centro di un <code class="docutils literal notranslate"><span class="pre">Triangle</span></code>? potrebbe non essere mai usato.</p></li>
<li><p>Aggiungendo un dato membro a <code class="docutils literal notranslate"><span class="pre">Shape</span></code> (p.es., lo stile del disegno o la lavagna) tutte le classi derivate da <code class="docutils literal notranslate"><span class="pre">Shape</span></code> e tutto il codice che usa <code class="docutils literal notranslate"><span class="pre">Shape</span></code> dovranno essere rivisti, forse cambiati e probabilmente ricompilati.</p></li>
</ul>
<p>L’implementazione di <code class="docutils literal notranslate"><span class="pre">Shape::move()</span></code> è un esempio di ereditarietà di implementazione: si è definito <code class="docutils literal notranslate"><span class="pre">move()</span></code> una volta e per tutte le classi derivate. Maggiore è il codice presente in queste implementazioni delle funzioni membro della classe base e più i dati vengono condivisi mettendoli nella base, più benefici si ottengono - e meno è stabile la gerarchia.</p>
</section>
<section id="id639">
<h5>Esempio<a class="headerlink" href="#id639" title="Link to this heading">¶</a></h5>
<p>Questa gerarchia di Shape può essere riscritta usando l’ereditarietà dell’interfaccia:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Shape {  // pure interface
public:
    virtual Point center() const = 0;
    virtual Color color() const = 0;

    virtual void rotate(int) = 0;
    virtual void move(Point p) = 0;

    virtual void redraw() = 0;

    // ...
};
</pre></div>
</div>
<p>Si noti che un’interfaccia pura ha raramente costruttori: non c’è niente da costruire.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Circle : public Shape {
public:
    Circle(Point c, int r, Color c) : cent{c}, rad{r}, col{c} { /* ... */ }

    Point center() const override { return cent; }
    Color color() const override { return col; }

    // ...
private:
    Point cent;
    int rad;
    Color col;
};
</pre></div>
</div>
<p>L’interfaccia ora è meno fragile, ma c’è più lavoro nell’implementazione delle funzioni membro. Per esempio, <code class="docutils literal notranslate"><span class="pre">center</span></code> deve essere implementato per ogni classe derivata da <code class="docutils literal notranslate"><span class="pre">Shape</span></code>.</p>
</section>
<section id="example-dual-hierarchy">
<h5>Esempio, doppia gerarchia<a class="headerlink" href="#example-dual-hierarchy" title="Link to this heading">¶</a></h5>
<p>Come possiamo avere i vantaggi di gerarchie stabili dalle gerarchie delle interfacce e i benefici del riutilizzo delle implementazioni con l’ereditarietà dell’implementazione? Una tecnica popolare è la doppia gerarchia. Ci sono molti modi per implementare l’idea delle doppie gerarchie; qui, useremo la variante dell’ereditarietà multipla.</p>
<p>Per prima cosa progettiamo una gerarchia di classi di interfacce:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Shape {   // pure interface
public:
    virtual Point center() const = 0;
    virtual Color color() const = 0;

    virtual void rotate(int) = 0;
    virtual void move(Point p) = 0;

    virtual void redraw() = 0;

    // ...
};

class Circle : public virtual Shape {   // pure interface
public:
    virtual int radius() = 0;
    // ...
};
</pre></div>
</div>
<p>Per rendere utile questa interfaccia, si deve fornire l’implementazione delle classi (qui, chiamate equivalentemente, ma nel namespace <code class="docutils literal notranslate"><span class="pre">Impl</span></code>):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Impl::Shape : public virtual ::Shape { // implementation
public:
    // constructors, destructor
    // ...
    Point center() const override { /* ... */ }
    Color color() const override { /* ... */ }

    void rotate(int) override { /* ... */ }
    void move(Point p) override { /* ... */ }

    void redraw() override { /* ... */ }

    // ...
};
</pre></div>
</div>
<p>Ora <code class="docutils literal notranslate"><span class="pre">Shape</span></code> è un mediocre esempio di classe con un’implementazione, ma soprassediamo perché è solo un semplice esempio di una tecnica destinata a gerarchie più complesse.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Impl::Circle : public virtual ::Circle, public Impl::Shape {   // implementation
public:
    // constructors, destructor

    int radius() override { /* ... */ }
    // ...
};
</pre></div>
</div>
<p>E si potrebbero estendere le gerarchie aggiungendo una classe Smiley (:-)):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Smiley : public virtual Circle { // pure interface
public:
    // ...
};

class Impl::Smiley : public virtual ::Smiley, public Impl::Circle {   // implementation
public:
    // constructors, destructor
    // ...
}
</pre></div>
</div>
<p>Ora ci sono due gerarchie:</p>
<ul class="simple">
<li><p>interfaccia: Smiley -&gt; Circle -&gt; Shape</p></li>
<li><p>implementazione: Impl::Smiley -&gt; Impl::Circle -&gt; Impl::Shape</p></li>
</ul>
<p>Dato che ciascuna implementazione è derivata dalla sua interfaccia e dalla sua implementazione della classe base si ottiene un Reticolo (Digrafo aciclico [Directed Acyclic Graph, DAG]):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Smiley     -&gt;         Circle     -&gt;  Shape
  ^                     ^               ^
  |                     |               |
Impl::Smiley -&gt; Impl::Circle -&gt; Impl::Shape
</pre></div>
</div>
<p>Come accennato, questo è solo uno dei modi per costruire una doppia gerarchia.</p>
<p>La gerarchia di implementazione può essere utilizzata direttamente, piuttosto che attraverso l’interfaccia astratta.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void work_with_shape(Shape&amp;);

int user()
{
    Impl::Smiley my_smiley{ /* args */ };   // create concrete shape
    // ...
    my_smiley.some_member();        // use implementation class directly
    // ...
    work_with_shape(my_smiley);     // use implementation through abstract interface
    // ...
}
</pre></div>
</div>
<p>Ciò può essere utile quando la classe di implementazione non ha membri nell’interfaccia astratta o se l’uso diretto di un membro offre un’opportunità di ottimizzazione (p.es., se una funzione membro dell’implementazione è <code class="docutils literal notranslate"><span class="pre">final</span></code>)</p>
</section>
<section id="id640">
<h5>Nota<a class="headerlink" href="#id640" title="Link to this heading">¶</a></h5>
<p>Un’altra tecnica (correlata) per separare l’interfaccia e l’implementazione è la <a class="reference internal" href="#Ri-pimpl"><span class="xref myst">Pimpl [Pointer to implementation]</span></a>.</p>
</section>
<section id="id641">
<h5>Nota<a class="headerlink" href="#id641" title="Link to this heading">¶</a></h5>
<p>Spesso c’è da scegliere tra l’offrire funzionalità comuni come funzioni della classe base (implementate) e funzioni a sé stanti (in un namespace di implementazione). Le classi base forniscono una notazione più breve ed un più facile accesso ai dati condivisi (nella classe base) al costo di avere le funzionalità disponibili solo agli utenti della gerarchia.</p>
</section>
<section id="id642">
<h5>Imposizione<a class="headerlink" href="#id642" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare una conversione derivata da una base verso una base con sia i dati che le funzioni virtuali (ad eccezione delle chiamate da un membro della classe derivata ad un membro della classe base)</p></li>
<li><p>???</p></li>
</ul>
</section>
</section>
<section id="c-130-for-making-deep-copies-of-polymorphic-classes-prefer-a-virtual-clone-function-instead-of-public-copy-construction-assignment">
<h4><a name="Rh-copy"></a>C.130: Per eseguire copie complete [deep] di classi polimorfiche preferire una funzione virtuale <code class="docutils literal notranslate"><span class="pre">clone</span></code> anziché un costruttore di copia/assegnazione public<a class="headerlink" href="#c-130-for-making-deep-copies-of-polymorphic-classes-prefer-a-virtual-clone-function-instead-of-public-copy-construction-assignment" title="Link to this heading">¶</a></h4>
<section id="id643">
<h5>Motivo<a class="headerlink" href="#id643" title="Link to this heading">¶</a></h5>
<p>La copia di una classe polimorfica è sconsigliata a causa dei problemi di spaccatura [slicing], cfr <a class="reference internal" href="#Rc-copy-virtual"><span class="xref myst">C.67</span></a>. Se c’è davvero bisogno della semantica della copia, si fa una copia completa [deeply]: Si fornisce una funzione <code class="docutils literal notranslate"><span class="pre">clone</span></code> virtuale che copierà l’effettivo tipo più-derivato e restituisce un puntatore che possiede il nuovo oggetto, poi, in una classe derivata  restituisce il tipo derivato (si usa un tipo di ritorno covariante).</p>
</section>
<section id="id644">
<h5>Esempio<a class="headerlink" href="#id644" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class B {
public:
    B() = default;
    virtual ~B() = default;
    virtual gsl::owner&lt;B*&gt; clone() const = 0;
protected:
     B(const B&amp;) = default;
     B&amp; operator=(const B&amp;) = default;
     B(B&amp;&amp;) noexcept = default;
     B&amp; operator=(B&amp;&amp;) noexcept = default;
    // ...
};

class D : public B {
public:
    gsl::owner&lt;D*&gt; clone() const override
    {
        return new D{*this};
    };
};
</pre></div>
</div>
<p>In generale, si raccomanda di usare gli smart pointer per rappresentare il possesso (cfr. <a class="reference internal" href="#Rr-owner"><span class="xref myst">R.20</span></a>). Tuttavia, a causa delle regole del linguaggio, il tipo di ritorno covariante non può essere uno smart pointer: <code class="docutils literal notranslate"><span class="pre">D::clone</span></code> non può restituire un <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;D&gt;</span></code> mentre <code class="docutils literal notranslate"><span class="pre">B::clone</span></code> restituisce  <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;B&gt;</span></code>. Pertanto, è necessario restituire in modo coerente <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;B&gt;</span></code> in tutti gli [override] o usare l’utility <code class="docutils literal notranslate"><span class="pre">owner&lt;&gt;</span></code> dalle <a class="reference internal" href="#SS-views"><span class="xref myst">Guidelines Support Library</span></a>.</p>
</section>
</section>
<section id="c-131-avoid-trivial-getters-and-setters">
<h4><a name="Rh-get"></a>C.131: Evitare getter e setter banali<a class="headerlink" href="#c-131-avoid-trivial-getters-and-setters" title="Link to this heading">¶</a></h4>
<section id="id645">
<h5>Motivo<a class="headerlink" href="#id645" title="Link to this heading">¶</a></h5>
<p>Un getter o un setter banale non aggiunge alcuna semantica del valore; l’elemento del dato potrebbe semplicemente anche essere <code class="docutils literal notranslate"><span class="pre">public</span></code>.</p>
</section>
<section id="id646">
<h5>Esempio<a class="headerlink" href="#id646" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Point {   // Bad: verbose
    int x;
    int y;
public:
    Point(int xx, int yy) : x{xx}, y{yy} { }
    int get_x() const { return x; }
    void set_x(int xx) { x = xx; }
    int get_y() const { return y; }
    void set_y(int yy) { y = yy; }
    // no behavioral member functions
};
</pre></div>
</div>
<p>Si consideri di trasformare tale classe in una <code class="docutils literal notranslate"><span class="pre">struct</span></code> – ovvero, un gruppo di variabili senza comportamento, tutti dati pubblici e nessuna funzione membro.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Point {
    int x {0};
    int y {0};
};
</pre></div>
</div>
<p>Notare che possiamo inserire inizializzatori di default sui dati membri: <a class="reference internal" href="#Rc-initialize"><span class="xref myst">C.49: Nei costruttori preferire l’inizializzazione alle assegnazioni</span></a>.</p>
</section>
<section id="id647">
<h5>Nota<a class="headerlink" href="#id647" title="Link to this heading">¶</a></h5>
<p>La chiave di questa regola è se la semantica del getter/setter è banale. Anche se non è una definizione completa di «banale», si consideri se ci potrebbero essere delle differenze, oltre alla sintassi, se il getter/setter fosse invece un dato membro pubblico. Esempi di semantiche non-banali sarebbero: mantenere una classe invariante o convertire tra un tipo interno e un tipo dell’interfaccia.</p>
</section>
<section id="id648">
<h5>Imposizione<a class="headerlink" href="#id648" title="Link to this heading">¶</a></h5>
<p>Segnalare funzioni membro <code class="docutils literal notranslate"><span class="pre">get</span></code> e <code class="docutils literal notranslate"><span class="pre">set</span></code> multiple che accedono semplicemente ad un membro senza una ulteriore semantica.</p>
</section>
</section>
<section id="c-132-don-t-make-a-function-virtual-without-reason">
<h4><a name="Rh-virtual"></a>C.132: Non creare una funzione <code class="docutils literal notranslate"><span class="pre">virtual</span></code> senza motivo<a class="headerlink" href="#c-132-don-t-make-a-function-virtual-without-reason" title="Link to this heading">¶</a></h4>
<section id="id649">
<h5>Motivo<a class="headerlink" href="#id649" title="Link to this heading">¶</a></h5>
<p>Un ridondante <code class="docutils literal notranslate"><span class="pre">virtual</span></code> aumenta il run-time e la dimensione del codice oggetto. Una funzione virtuale può essere sovrascritta [overridden] ed è quindi aperta ad errori in una classe derivata. Una funzione virtuale garantisce la replica del codice in una gerarchia basata sui template.</p>
</section>
<section id="id650">
<h5>Esempio, cattivo<a class="headerlink" href="#id650" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class T&gt;
class Vector {
public:
    // ...
    virtual int size() const { return sz; }   // bad: what good could a derived class do?
private:
    T* elem;   // the elements
    int sz;    // number of elements
};
</pre></div>
</div>
<p>Questo tipo di «vector» non è pensato per essere usato come classe base.</p>
</section>
<section id="id651">
<h5>Imposizione<a class="headerlink" href="#id651" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare una classe con funzioni virtuali ma senza classi derivate.</p></li>
<li><p>Segnalare una classe dove tutte le funzioni membro sono virtuali ed hanno delle implementazioni.</p></li>
</ul>
</section>
</section>
<section id="c-133-avoid-protected-data">
<h4><a name="Rh-protected"></a>C.133: Evitare dati <code class="docutils literal notranslate"><span class="pre">protected</span></code><a class="headerlink" href="#c-133-avoid-protected-data" title="Link to this heading">¶</a></h4>
<section id="id652">
<h5>Motivo<a class="headerlink" href="#id652" title="Link to this heading">¶</a></h5>
<p>I dati <code class="docutils literal notranslate"><span class="pre">protected</span></code> sono fonte di errori e complessità. I dati <code class="docutils literal notranslate"><span class="pre">protected</span></code> complicano le istruzioni degli invarianti. I dati <code class="docutils literal notranslate"><span class="pre">protected</span></code> violano intrinsecamente la direttiva contraria a mettere i dati nelle classi base, che solitamente porta a dover gestire anche l’ereditarietà virtuale.</p>
</section>
<section id="id653">
<h5>Esempio, cattivo<a class="headerlink" href="#id653" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Shape {
public:
    // ... interface functions ...
protected:
    // data for use in derived classes:
    Color fill_color;
    Color edge_color;
    Style st;
};
</pre></div>
</div>
<p>Ora tocca ad ogni <code class="docutils literal notranslate"><span class="pre">Shape</span></code> derivata gestire correttamente i dati protected. Questo è molto diffuso, ma è stato anche una grande fonte di problemi di manutenzione . In una grande gerarchia di classi, l’uso coerente di dati protetti è difficile da manutenere perché potrebbe esserci molto codice, sparpagliato tra molte classi. L’insieme delle classi che possono toccare quei dati è aperto: chiunque può derivare una nuova classe e cominciare a cambiare i dati protected. Capita spesso, che non sia possibile esaminare l’insieme completo delle classi, quindi qualsiasi modifica alla rappresentazione della classe diventa proibitiva. Non c’è alcuna invariante imposta per i dati protected; è molto simile ad un insieme di variabili globali. I dati protected sono di fatto diventati globali in moltissimi sorgenti.</p>
</section>
<section id="id654">
<h5>Nota<a class="headerlink" href="#id654" title="Link to this heading">¶</a></h5>
<p>Spesso i dati protected sembrano allettanti per consentire innumerevoli miglioramenti tramite la derivazione. Spesso, quello che si ottiene sono modifiche ed errori inaspettati. <a class="reference internal" href="#Rc-private"><span class="xref myst">Preferire dati <code class="docutils literal notranslate"><span class="pre">private</span></code> data</span></a> con un’invariante ben specificato e ben rispettato. In alternativa, e spesso è meglio, <a class="reference internal" href="#Rh-abstract"><span class="xref myst">tenere i dati all’esterno di qualsiasi classe usata come interfaccia</span></a>.</p>
</section>
<section id="id655">
<h5>Nota<a class="headerlink" href="#id655" title="Link to this heading">¶</a></h5>
<p>La funzione membro protected può andar bene.</p>
</section>
<section id="id656">
<h5>Imposizione<a class="headerlink" href="#id656" title="Link to this heading">¶</a></h5>
<p>Segnalare le classi con dati <code class="docutils literal notranslate"><span class="pre">protected</span></code>.</p>
</section>
</section>
<section id="c-134-ensure-all-non-const-data-members-have-the-same-access-level">
<h4><a name="Rh-public"></a>C.134: Assicurarsi che tutti i dati membro non-<code class="docutils literal notranslate"><span class="pre">const</span></code> abbiano lo stesso livello di accesso<a class="headerlink" href="#c-134-ensure-all-non-const-data-members-have-the-same-access-level" title="Link to this heading">¶</a></h4>
<section id="id657">
<h5>Motivo<a class="headerlink" href="#id657" title="Link to this heading">¶</a></h5>
<p>Prevenire la confusione logica che porta ad errori. Se i dati membri non-`const non hanno lo stesso livello di accesso, il tipo è confuso su ciò che si cerca di fare. È un tipo che mantiene un invariante o è semplicemente una raccolta di valori?</p>
</section>
<section id="id658">
<h5>Discussione<a class="headerlink" href="#id658" title="Link to this heading">¶</a></h5>
<p>La domanda principale è: Quale codice è responsabile della manutenzione di un valore significativo/corretto per quella variabile?</p>
<p>Esistono esattamente due tipi di dati membro:</p>
<ul class="simple">
<li><p>A: Quelli che non partecipano all’invariante dell’oggetto. Qualsiasi combinazione di valori per questi membri è valida.</p></li>
<li><p>B: Quelli che partecipano all’invariante dell’oggetto. Non tutte le combinazioni di valori sono significative (altrimenti non ci sarebbero invarianti). Pertanto, tutto il codice che ha l’accesso in scrittura su queste variabili deve conoscere l’invariante, conoscere la semantica e conoscere (e attivamente implementare e imporre) le regole per mantenere i valori corretti.</p></li>
</ul>
<p>I dati membro della categoria A devono essere <code class="docutils literal notranslate"><span class="pre">public</span></code> (o, più raramente, <code class="docutils literal notranslate"><span class="pre">protected</span></code> se si vuole solo che siano visibili dalle classi derivate). Non hanno bisogno di incapsulamento. Tutto il codice nel sistema potrebbe anche vederli e modificarli.</p>
<p>I dati membro della categoria B devono essere <code class="docutils literal notranslate"><span class="pre">private</span></code> o <code class="docutils literal notranslate"><span class="pre">const</span></code>. Questo perché l’incapsulamento è importante. Renderli non-<code class="docutils literal notranslate"><span class="pre">private</span></code> e non-<code class="docutils literal notranslate"><span class="pre">const</span></code> significherebbe che l’oggetto non può controllare il proprio stato: Una quantità illimitata di codice al di fuori della classe dovrebbe sapere dell’invariante e contribuire accuratamente alla sua manutenzione – se questi dati membro fossero <code class="docutils literal notranslate"><span class="pre">public</span></code>, sarebbe tutto il codice chiamante che utilizza l’oggetto; se fossero <code class="docutils literal notranslate"><span class="pre">protected</span></code>, sarebbe tutto il codice nelle classi derivate attuali e future. Questo porta a un codice fragile e strettamente accoppiato che diventa rapidamente un incubo da mantenere. Qualsiasi codice che imposta inavvertitamente i dati membro a una combinazione di valori invalida o inaspettata corromperà l’oggetto e tutti i suoi successivi usi.</p>
<p>La maggior parte delle classi sono tutte A o tutte B:</p>
<ul class="simple">
<li><p><em>Tutte public</em>: Se si sta scrivendo un blocco-di-variabili aggregate senza un invariante tra tali variabili, allora tutte le variabili dovrebbero essere <code class="docutils literal notranslate"><span class="pre">public</span></code>. <a class="reference internal" href="#Rc-struct"><span class="xref myst">Per convenzione, tali classi si dichiarano <code class="docutils literal notranslate"><span class="pre">struct</span></code> anziché <code class="docutils literal notranslate"><span class="pre">class</span></code></span></a></p></li>
<li><p><em>Tutte private</em>: Se si sta scrivendo un tipo che mantiene un invariante, allora tutte le variabili non-<code class="docutils literal notranslate"><span class="pre">const</span></code> dovrebbero essere private – esse dovrebbero essere incapsulate.</p></li>
</ul>
</section>
<section id="id659">
<h5>Eccezione<a class="headerlink" href="#id659" title="Link to this heading">¶</a></h5>
<p>Occasionalmente le classi si mischiano tra A e B, solitamente per debug. Un oggetto incapsulato potrebbe contenere qualcosa di simile a una strumentazione di debug non-<code class="docutils literal notranslate"><span class="pre">const</span></code> che non fa parte dell’invariante e quindi rientra nella categoria A – in realtà non fa parte del valore dell’oggetto né dello stato osservabile significativo. In tal caso, le parti A devono essere trattate come A (rese <code class="docutils literal notranslate"><span class="pre">public</span></code>, o in rari casi <code class="docutils literal notranslate"><span class="pre">protected</span></code> se devono essere visibili solo alle classi derivate) e le parti B devono comunque essere trattate come B (<code class="docutils literal notranslate"><span class="pre">private</span></code> o <code class="docutils literal notranslate"><span class="pre">const</span></code>).</p>
</section>
<section id="id660">
<h5>Imposizione<a class="headerlink" href="#id660" title="Link to this heading">¶</a></h5>
<p>Segnalare qualsiasi classe che abbia dati membro non-<code class="docutils literal notranslate"><span class="pre">const</span></code> con diversi livelli di accesso.</p>
</section>
</section>
<section id="c-135-use-multiple-inheritance-to-represent-multiple-distinct-interfaces">
<h4><a name="Rh-mi-interface"></a>C.135: Utilizzare l’ereditarietà multipla per rappresentare più interfacce distinte<a class="headerlink" href="#c-135-use-multiple-inheritance-to-represent-multiple-distinct-interfaces" title="Link to this heading">¶</a></h4>
<section id="id661">
<h5>Motivo<a class="headerlink" href="#id661" title="Link to this heading">¶</a></h5>
<p>Non tutte le classi supporteranno necessariamente tutte le interfacce, e non tutti i chiamanti vorranno necessariamente gestire tutte le operazioni. Specialmente per suddividere le interfacce monolitiche in «aspetti» del comportamento supportati da una determinata classe derivata.</p>
</section>
<section id="id662">
<h5>Esempio<a class="headerlink" href="#id662" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class iostream : public istream, public ostream {   // very simplified
    // ...
};
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">istream</span></code> fornisce l’interfaccia per le operazioni di input; <code class="docutils literal notranslate"><span class="pre">ostream</span></code> fornisce l’interfaccia per le operazioni di output. <code class="docutils literal notranslate"><span class="pre">iostream</span></code> fornisce l’unione delle interfacce di <code class="docutils literal notranslate"><span class="pre">istream</span></code> e <code class="docutils literal notranslate"><span class="pre">ostream</span></code> e la sincronizzazione necessaria affinché ci siano entrambe su un unico flusso.</p>
</section>
<section id="id663">
<h5>Nota<a class="headerlink" href="#id663" title="Link to this heading">¶</a></h5>
<p>Questo è un uso molto comune dell’eredità perché è comune la necessità di avere più interfacce diverse per un’implementazione e tali interfacce risultano spesso non facilmente o naturalmente organizzate in una gerarchia con un’unica radice.</p>
</section>
<section id="id664">
<h5>Nota<a class="headerlink" href="#id664" title="Link to this heading">¶</a></h5>
<p>Tali interfacce sono tipicamente classi astratte.</p>
</section>
<section id="id665">
<h5>Imposizione<a class="headerlink" href="#id665" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="c-136-use-multiple-inheritance-to-represent-the-union-of-implementation-attributes">
<h4><a name="Rh-mi-implementation"></a>C.136: Utilizzare l’ereditarietà multipla per rappresentare l’unione degli attributi di un’implementazione<a class="headerlink" href="#c-136-use-multiple-inheritance-to-represent-the-union-of-implementation-attributes" title="Link to this heading">¶</a></h4>
<section id="id666">
<h5>Motivo<a class="headerlink" href="#id666" title="Link to this heading">¶</a></h5>
<p>Alcune forme di [mixin] (classi parziali) hanno uno stato e spesso operazioni su tale stato. Se le operazioni sono virtuali, l’uso dell’ereditarietà è necessario, se non si usa l’ereditarietà si può evitare la ripetizione del codice e il [forwarding].</p>
</section>
<section id="id667">
<h5>Esempio<a class="headerlink" href="#id667" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class iostream : public istream, public ostream {   // very simplified
    // ...
};
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">istream</span></code> fornisce l’interfaccia per le operazioni di input (ed alcuni dati); <code class="docutils literal notranslate"><span class="pre">ostream</span></code> fornisce l’interfaccia per le operazioni di output (ed alcuni dati). <code class="docutils literal notranslate"><span class="pre">iostream</span></code> fornisce l’unione delle interfacce di <code class="docutils literal notranslate"><span class="pre">istream</span></code> e <code class="docutils literal notranslate"><span class="pre">ostream</span></code> e la sincronizzazione necessaria affinché ci siano entrambe su un unico flusso.</p>
</section>
<section id="id668">
<h5>Nota<a class="headerlink" href="#id668" title="Link to this heading">¶</a></h5>
<p>Questo è un uso relativamente raro perché l’implementazione può spesso essere organizzata in una gerarchia con un’unica radice.</p>
</section>
<section id="id669">
<h5>Esempio<a class="headerlink" href="#id669" title="Link to this heading">¶</a></h5>
<p>A volte, un «attributo di implementazione» è più simile ad un «mixin» che determina il comportamento di un’implementazione e inietta [inject] i membri per abilitare l’implementazione dei requisiti. Per esempio, si veda <code class="docutils literal notranslate"><span class="pre">std::enable_shared_from_this</span></code> o i vari pezzi di codice da boost.intrusive (p.es. <code class="docutils literal notranslate"><span class="pre">list_base_hook</span></code> or <code class="docutils literal notranslate"><span class="pre">intrusive_ref_counter</span></code>).</p>
</section>
<section id="id670">
<h5>Imposizione<a class="headerlink" href="#id670" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="c-137-use-virtual-bases-to-avoid-overly-general-base-classes">
<h4><a name="Rh-vbase"></a>C.137: Usare basi <code class="docutils literal notranslate"><span class="pre">virtual</span></code> per evitare troppe classi base generali<a class="headerlink" href="#c-137-use-virtual-bases-to-avoid-overly-general-base-classes" title="Link to this heading">¶</a></h4>
<section id="id671">
<h5>Motivo<a class="headerlink" href="#id671" title="Link to this heading">¶</a></h5>
<p>Consentire la separazione di dati condivisi e l’interfaccia.  Per evitare che tutti i dati condivisi vengano inseriti in un’unica classe base.</p>
</section>
<section id="id672">
<h5>Esempio<a class="headerlink" href="#id672" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Interface {
    virtual void f();
    virtual int g();
    // ... no data here ...
};

class Utility {  // with data
    void utility1();
    virtual void utility2();    // customization point
public:
    int x;
    int y;
};

class Derive1 : public Interface, virtual protected Utility {
    // override Interface functions
    // Maybe override Utility virtual functions
    // ...
};

class Derive2 : public Interface, virtual protected Utility {
    // override Interface functions
    // Maybe override Utility virtual functions
    // ...
};
</pre></div>
</div>
<p>Avere <code class="docutils literal notranslate"><span class="pre">Utility</span></code> a fattor comune ha senso se molte classi derivate condividono significativi «dettagli implementativi».</p>
</section>
<section id="id673">
<h5>Nota<a class="headerlink" href="#id673" title="Link to this heading">¶</a></h5>
<p>Ovviamente, l’esempio è troppo «teorico», ma è difficile trovare un <em>piccolo</em> esempio realistico. <code class="docutils literal notranslate"><span class="pre">Interface</span></code> è la radice di una <a class="reference internal" href="#Rh-abstract"><span class="xref myst">gerarchia di interfaccia</span></a> e <code class="docutils literal notranslate"><span class="pre">Utility</span></code>  è la radice di una <a class="reference internal" href="#Rh-kind"><span class="xref myst">gerarchia di implementazione</span></a>. Questo è un <a class="reference external" href="https://www.quora.com/What-are-the-uses-and-advantages-of-virtual-base-class-in-C%2B%2B/answer/Lance-Diduck">esempio leggermente più realistico</a> con una spiegazione.</p>
</section>
<section id="id674">
<h5>Nota<a class="headerlink" href="#id674" title="Link to this heading">¶</a></h5>
<p>Spesso, la linearizzazione di una gerarchia costituisce una soluzione migliore.</p>
</section>
<section id="id675">
<h5>Imposizione<a class="headerlink" href="#id675" title="Link to this heading">¶</a></h5>
<p>Segnalare gerarchie di interfacce mischiate a quelle di implementazioni.</p>
</section>
</section>
<section id="c-138-create-an-overload-set-for-a-derived-class-and-its-bases-with-using">
<h4><a name="Rh-using"></a>C.138: Creare un set di overload per una classe derivata e le sue basi con <code class="docutils literal notranslate"><span class="pre">using</span></code><a class="headerlink" href="#c-138-create-an-overload-set-for-a-derived-class-and-its-bases-with-using" title="Link to this heading">¶</a></h4>
<section id="id676">
<h5>Motivo<a class="headerlink" href="#id676" title="Link to this heading">¶</a></h5>
<p>Senza una dichiarazione “using”, le funzioni membro nella classe derivata nascondono tutto l’insieme di overload ereditato.</p>
</section>
<section id="id677">
<h5>Esempio, cattivo<a class="headerlink" href="#id677" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;iostream&gt;
class B {
public:
    virtual int f(int i) { std::cout &lt;&lt; &quot;f(int): &quot;; return i; }
    virtual double f(double d) { std::cout &lt;&lt; &quot;f(double): &quot;; return d; }
    virtual ~B() = default;
};
class D: public B {
public:
    int f(int i) override { std::cout &lt;&lt; &quot;f(int): &quot;; return i + 1; }
};
int main()
{
    D d;
    std::cout &lt;&lt; d.f(2) &lt;&lt; &#39;\n&#39;;   // prints &quot;f(int): 3&quot;
    std::cout &lt;&lt; d.f(2.3) &lt;&lt; &#39;\n&#39;; // prints &quot;f(int): 3&quot;
}
</pre></div>
</div>
</section>
<section id="id678">
<h5>Esempio, buono<a class="headerlink" href="#id678" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class D: public B {
public:
    int f(int i) override { std::cout &lt;&lt; &quot;f(int): &quot;; return i + 1; }
    using B::f; // exposes f(double)
};
</pre></div>
</div>
</section>
<section id="id679">
<h5>Nota<a class="headerlink" href="#id679" title="Link to this heading">¶</a></h5>
<p>Questo problema riguarda sia le funzioni membro virtuali che quelle non virtuali</p>
<p>Per le basi variadiche, il C++17 ha introdotto una forma variadica della dichiarazione “using”,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class... Ts&gt;
struct Overloader : Ts... {
    using Ts::operator()...; // exposes operator() from every base
};
</pre></div>
</div>
</section>
<section id="id680">
<h5>Imposizione<a class="headerlink" href="#id680" title="Link to this heading">¶</a></h5>
<p>Diagnosticare l’hiding dei nomi</p>
</section>
</section>
<section id="c-139-use-final-on-classes-sparingly">
<h4><a name="Rh-final"></a>C.139: Usare <code class="docutils literal notranslate"><span class="pre">final</span></code> sulle classi con parsimonia<a class="headerlink" href="#c-139-use-final-on-classes-sparingly" title="Link to this heading">¶</a></h4>
<section id="id681">
<h5>Motivo<a class="headerlink" href="#id681" title="Link to this heading">¶</a></h5>
<p>“Tappare” una gerarchia con classi <code class="docutils literal notranslate"><span class="pre">final</span></code> è raramente necessario per motivi logici e può risultare dannoso per l’estensibilità della gerarchia.</p>
</section>
<section id="id682">
<h5>Esempio, cattivo<a class="headerlink" href="#id682" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Widget { /* ... */ };

// nobody will ever want to improve My_widget (or so you thought)
class My_widget final : public Widget { /* ... */ };

class My_improved_widget : public My_widget { /* ... */ };  // error: can&#39;t do that
</pre></div>
</div>
</section>
<section id="id683">
<h5>Nota<a class="headerlink" href="#id683" title="Link to this heading">¶</a></h5>
<p>Non tutte le classi sono pensate per essere classi base. La maggior parte delle classi della standard-library ne sono esempi (p.es., <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> e <code class="docutils literal notranslate"><span class="pre">std::string</span></code> non sono progettate per derivarle). Questa regola riguarda l’utilizzo di <code class="docutils literal notranslate"><span class="pre">final</span></code> sulle classi con funzioni virtuali pensate per essere interfacce per una gerarchia di classi.</p>
</section>
<section id="id684">
<h5>Nota<a class="headerlink" href="#id684" title="Link to this heading">¶</a></h5>
<p>Fermare una singola funzione virtuale con <code class="docutils literal notranslate"><span class="pre">final</span></code> va incontro ad errori in quanto <code class="docutils literal notranslate"><span class="pre">final</span></code> può facilmente essere bypassato quando si definisce/sovrascrive un insieme di funzioni. Fortunatamente, il compilatore rileva questi errori: Non è possibile ri-dichiarare/ri-aprire un membro <code class="docutils literal notranslate"><span class="pre">final</span></code> in una classe derivata.</p>
</section>
<section id="id685">
<h5>Nota<a class="headerlink" href="#id685" title="Link to this heading">¶</a></h5>
<p>Le richieste di miglioramenti delle prestazioni da <code class="docutils literal notranslate"><span class="pre">final</span></code> devono essere motivate. Troppo spesso, tali affermazioni si basano su congetture o esperienze con altri linguaggi.</p>
<p>Ci sono esempi in cui <code class="docutils literal notranslate"><span class="pre">final</span></code> può essere importante sia per motivi logici che prestazionali. Un esempio è la gerarchia performance-critical AST ([Abstract syntax tree] albero sintattico astratto) in un compilatore o uno strumento di analisi del linguaggio. Non tutti gli anni vengono aggiunte nuove classi derivate e solo dagli implementatori della libreria. Tuttavia, gli abusi sono (o almeno sono stati) molto più comuni.</p>
</section>
<section id="id686">
<h5>Imposizione<a class="headerlink" href="#id686" title="Link to this heading">¶</a></h5>
<p>Segnalare l’uso di <code class="docutils literal notranslate"><span class="pre">final</span></code> sulle classi.</p>
</section>
</section>
<section id="c-140-do-not-provide-different-default-arguments-for-a-virtual-function-and-an-overrider">
<h4><a name="Rh-virtual-default-arg"></a>C.140: Non fornire argomenti di default diversi per una funzione virtuale e un [overrider]<a class="headerlink" href="#c-140-do-not-provide-different-default-arguments-for-a-virtual-function-and-an-overrider" title="Link to this heading">¶</a></h4>
<section id="id687">
<h5>Motivo<a class="headerlink" href="#id687" title="Link to this heading">¶</a></h5>
<p>Questo può confondere: Un [overrider] non eredita gli argomenti di default.</p>
</section>
<section id="id688">
<h5>Esempio, cattivo<a class="headerlink" href="#id688" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Base {
public:
    virtual int multiply(int value, int factor = 2) = 0;
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    int multiply(int value, int factor = 10) override;
};

Derived d;
Base&amp; b = d;

b.multiply(10);  // these two calls will call the same function but
d.multiply(10);  // with different arguments and so different results
</pre></div>
</div>
</section>
<section id="id689">
<h5>Imposizione<a class="headerlink" href="#id689" title="Link to this heading">¶</a></h5>
<p>Segnalare gli argomenti di default delle funzioni virtuali se le dichiarazioni differiscono tra quelli della base e quelli della derivata.</p>
</section>
</section>
</section>
<section id="c-hier-access-accessing-objects-in-a-hierarchy">
<h3>C.hier-access: Accesso agli oggetti di una gerarchia<a class="headerlink" href="#c-hier-access-accessing-objects-in-a-hierarchy" title="Link to this heading">¶</a></h3>
<section id="c-145-access-polymorphic-objects-through-pointers-and-references">
<h4><a name="Rh-poly"></a>C.145: Accedere agli oggetti polimorfici tramite puntatori e riferimenti<a class="headerlink" href="#c-145-access-polymorphic-objects-through-pointers-and-references" title="Link to this heading">¶</a></h4>
<section id="id690">
<h5>Motivo<a class="headerlink" href="#id690" title="Link to this heading">¶</a></h5>
<p>Se si ha una classe con una funzione virtuale, non si sa (in generale) da quale classe proviene la funzione da utilizzare.</p>
</section>
<section id="id691">
<h5>Esempio<a class="headerlink" href="#id691" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct B { int a; virtual int f(); virtual ~B() = default };
struct D : B { int b; int f() override; };

void use(B b)
{
    D d;
    B b2 = d;   // slice
    B b3 = b;
}

void use2()
{
    D d;
    use(d);   // slice
}
</pre></div>
</div>
<p>Entrambe le <code class="docutils literal notranslate"><span class="pre">d</span></code> vengono spaccate [sliced].</p>
</section>
<section id="id692">
<h5>Eccezione<a class="headerlink" href="#id692" title="Link to this heading">¶</a></h5>
<p>Si può accedere con sicurezza ad un oggetto polimorfico nello scope della sua definizione, ma senza spaccarlo [slice].</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use3()
{
    D d;
    d.f();   // OK
}
</pre></div>
</div>
</section>
<section id="id693">
<h5>Si veda anche<a class="headerlink" href="#id693" title="Link to this heading">¶</a></h5>
<p><a class="reference internal" href="#Rc-copy-virtual"><span class="xref myst">Una classe polimorfica dovrebbe sopprimere la copia</span></a></p>
</section>
<section id="id694">
<h5>Imposizione<a class="headerlink" href="#id694" title="Link to this heading">¶</a></h5>
<p>Segnalare tutte le spaccature [slicing].</p>
</section>
</section>
<section id="c-146-use-dynamic-cast-where-class-hierarchy-navigation-is-unavoidable">
<h4><a name="Rh-dynamic_cast"></a>C.146: Usare il <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> dove è inevitabile la navigazione della gerarchia della classe<a class="headerlink" href="#c-146-use-dynamic-cast-where-class-hierarchy-navigation-is-unavoidable" title="Link to this heading">¶</a></h4>
<section id="id695">
<h5>Motivo<a class="headerlink" href="#id695" title="Link to this heading">¶</a></h5>
<p>Il <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> viene controllato a run time.</p>
</section>
<section id="id696">
<h5>Esempio<a class="headerlink" href="#id696" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct B {   // an interface
    virtual void f();
    virtual void g();
    virtual ~B();
};

struct D : B {   // a wider interface
    void f() override;
    virtual void h();
};

void user(B* pb)
{
    if (D* pd = dynamic_cast&lt;D*&gt;(pb)) {
        // ... use D&#39;s interface ...
    }
    else {
        // ... make do with B&#39;s interface ...
    }
}
</pre></div>
</div>
<p>L’uso degli altri cast può violare la sicurezza sul tipo e causare l’accesso del programma ad una variabile che in effetti è di tipo <code class="docutils literal notranslate"><span class="pre">X</span></code> come se fosse un tipo <code class="docutils literal notranslate"><span class="pre">Z</span></code> non correlato: <code class="docutils literal notranslate"><span class="pre">Z</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void user2(B* pb)   // bad
{
    D* pd = static_cast&lt;D*&gt;(pb);    // I know that pb really points to a D; trust me
    // ... use D&#39;s interface ...
}

void user3(B* pb)    // unsafe
{
    if (some_condition) {
        D* pd = static_cast&lt;D*&gt;(pb);   // I know that pb really points to a D; trust me
        // ... use D&#39;s interface ...
    }
    else {
        // ... make do with B&#39;s interface ...
    }
}

void f()
{
    B b;
    user(&amp;b);   // OK
    user2(&amp;b);  // bad error
    user3(&amp;b);  // OK *if* the programmer got the some_condition check right
}
</pre></div>
</div>
</section>
<section id="id697">
<h5>Nota<a class="headerlink" href="#id697" title="Link to this heading">¶</a></h5>
<p>Come per altri cast, di <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> se ne è abusato. <a class="reference internal" href="#Rh-use-virtual"><span class="xref myst">Preferire le funzioni virtuali al casting</span></a>. Preferire il <a class="reference internal" href="#???"><span class="xref myst">polimorfismo statico</span></a> alla navigazione nella gerarchia dove possibile (non è necessaria alcuna risoluzione a run-time) ed è ragionevolmente conveniente.</p>
</section>
<section id="id698">
<h5>Nota<a class="headerlink" href="#id698" title="Link to this heading">¶</a></h5>
<p>Alcune persone usano <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> dove sarebbe più appropriato un <code class="docutils literal notranslate"><span class="pre">typeid</span></code>; il <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> è un «tipo di operazione» generale per scoprire l’interfaccia migliore per un oggetto, mentre il <code class="docutils literal notranslate"><span class="pre">typeid</span></code> è un’operazione «dammi il tipo esatto di questo oggetto» operazione per scoprire l’effettivo tipo di un oggetto. Quest’ultima è un’operazione intrinsecamente più semplice che dovrebbe essere più veloce. Quest’ultima (<code class="docutils literal notranslate"><span class="pre">typeid</span></code>) è facilmente realizzabile a mano se necessario (p.es., se si lavora su un sistema in cui l’RTTI (Run-Time Type Information) è - per qualche motivo – proibito -), la prima (<code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code>) è molto più difficile da implementare correttamente in generale.</p>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct B {
    const char* name {&quot;B&quot;};
    // if pb1-&gt;id() == pb2-&gt;id() *pb1 is the same type as *pb2
    virtual const char* id() const { return name; }
    // ...
};

struct D : B {
    const char* name {&quot;D&quot;};
    const char* id() const override { return name; }
    // ...
};

void use()
{
    B* pb1 = new B;
    B* pb2 = new D;

    cout &lt;&lt; pb1-&gt;id(); // &quot;B&quot;
    cout &lt;&lt; pb2-&gt;id(); // &quot;D&quot;


    if (pb2-&gt;id() == &quot;D&quot;) {         // looks innocent
        D* pd = static_cast&lt;D*&gt;(pb2);
        // ...
    }
    // ...
}
</pre></div>
</div>
<p>Il risultato di <code class="docutils literal notranslate"><span class="pre">pb2-&gt;id()</span> <span class="pre">==</span> <span class="pre">&quot;D&quot;</span></code> è in effetti definito dall’implementazione. È stato aggiunto per porre l’accento sui pericoli dell’RTTI (Run-Time Type Information) fatto in casa. Questo codice potrebbe funzionare come previsto per anni, fallisce solo su una nuova macchina, un nuovo compilatore o un nuovo linker che non unifica i caratteri letterali.</p>
<p>Se si implementa la propria RTTI, si faccia attenzione.</p>
</section>
<section id="id699">
<h5>Eccezione<a class="headerlink" href="#id699" title="Link to this heading">¶</a></h5>
<p>Se la propria implementazione ha un <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> particolarmente lento, si potrebbe dover usare una soluzione alternativa. Tuttavia, tutte le soluzioni alternative che non possono essere risolte staticamente comportano il cast esplicito (solitamente <code class="docutils literal notranslate"><span class="pre">static_cast</span></code>) e sono soggette a errori. Fondamentalmente si realizzerà il proprio <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> speciale. Quindi, per prima cosa ci si assicura che il proprio <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> sia davvero lento come si suppone (ci sono un discreto numero di commenti non supportati a proposito) e che il proprio uso del <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> richieda realmente delle prestazioni elevate.</p>
<p>Si ritiene che le attuali implementazioni di <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> siano inutilmente lente. Ad esempio, in condizioni adeguate, è possibile eseguire un <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> in un <a class="reference external" href="http://www.stroustrup.com/fast_dynamic_casting.pdf">rapido tempo costante</a>. Tuttavia, la compatibilità rende difficili le modifiche anche se tutti concordano sul fatto che sarebbe utile uno sforzo per ottimizzare.</p>
<p>In rarissimi casi, se si è constatato un sensibile overhead del <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code>, si hanno altri mezzi per garantire staticamente che un downcast abbia successo (p.es., usando attentamente il CRTP [Curiously Recurring Template Pattern]), e che non vi sia implicata nessuna ereditarietà virtuale, si consideri di ricorrere tatticamente ad uno <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> con un evidente commento e disclaimer che riassuma questo paragrafo e che è necessaria una notevole attenzione umana per la manutenzione perché il sistema dei tipi non può verificare la correttezza. Anche così, nella nostra esperienza, queste situazioni tipo «Io so quello che faccio» restano fonti di errori.</p>
</section>
<section id="id700">
<h5>Eccezione<a class="headerlink" href="#id700" title="Link to this heading">¶</a></h5>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename B&gt;
class Dx : B {
    // ...
};
</pre></div>
</div>
</section>
<section id="id701">
<h5>Imposizione<a class="headerlink" href="#id701" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare tutti gli usi di <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> per i downcast, compresi i cast C-style che eseguono uno <code class="docutils literal notranslate"><span class="pre">static_cast</span></code>.</p></li>
<li><p>Questa regola fa parte del <a class="reference internal" href="#Pro-type-downcast"><span class="xref myst">profilo di sicurezza del tipo</span></a>.</p></li>
</ul>
</section>
</section>
<section id="c-147-use-dynamic-cast-to-a-reference-type-when-failure-to-find-the-required-class-is-considered-an-error">
<h4><a name="Rh-ref-cast"></a>C.147: Usare <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> per un tipo di riferimento quando la non riuscita della ricerca della classe richiesta è considerata un errore<a class="headerlink" href="#c-147-use-dynamic-cast-to-a-reference-type-when-failure-to-find-the-required-class-is-considered-an-error" title="Link to this heading">¶</a></h4>
<section id="id702">
<h5>Motivo<a class="headerlink" href="#id702" title="Link to this heading">¶</a></h5>
<p>Il cast su un riferimento esprime l’intenzione di finire con un oggetto valido, quindi il cast deve avere successo. Il <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> solleverà un errore se fallisce.</p>
</section>
<section id="id703">
<h5>Esempio<a class="headerlink" href="#id703" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>std::string f(Base&amp; b)
{
    return dynamic_cast&lt;Derived&amp;&gt;(b).to_string();
}
</pre></div>
</div>
</section>
<section id="id704">
<h5>Imposizione<a class="headerlink" href="#id704" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="c-148-use-dynamic-cast-to-a-pointer-type-when-failure-to-find-the-required-class-is-considered-a-valid-alternative">
<h4><a name="Rh-ptr-cast"></a>C.148: Usare <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> per un tipo di puntatore quando la non riuscita della ricerca della classe richiesta è considerata una alternativa valida<a class="headerlink" href="#c-148-use-dynamic-cast-to-a-pointer-type-when-failure-to-find-the-required-class-is-considered-a-valid-alternative" title="Link to this heading">¶</a></h4>
<section id="id705">
<h5>Motivo<a class="headerlink" href="#id705" title="Link to this heading">¶</a></h5>
<p>La conversione <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> consente di verificare se un puntatore punta ad un oggetto polimorfico che ha una determinata classe nella sua gerarchia. Dato che quando fallisce nel trovare la classe restituisce semplicemente un valore nullo, lo si può testare a run time. Questo consente di scrivere codice in grado di scegliere percorsi alternativi a seconda dei risultati.</p>
<p>In contrapposizione con la <a class="reference internal" href="#Rh-ref-cast"><span class="xref myst">C.147</span></a>, dove il fallimento è un errore e non si deve usare per l’esecuzione condizionale.</p>
</section>
<section id="id706">
<h5>Esempio<a class="headerlink" href="#id706" title="Link to this heading">¶</a></h5>
<p>L’esempio seguente descrive la funzione <code class="docutils literal notranslate"><span class="pre">add</span></code> di uno <code class="docutils literal notranslate"><span class="pre">Shape_owner</span></code> che diventa proprietario degli oggetti <code class="docutils literal notranslate"><span class="pre">Shape</span></code> costruiti. Gli oggetti vengono anche ordinati in viste, a seconda dei loro attributi geometrici. In questo esempio, <code class="docutils literal notranslate"><span class="pre">Shape</span></code> non eredita da <code class="docutils literal notranslate"><span class="pre">Geometric_attributes</span></code>. Lo fanno solo le sue sottoclassi.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void add(Shape* const item)
{
  // Ownership is always taken
  owned_shapes.emplace_back(item);

  // Check the Geometric_attributes and add the shape to none/one/some/all of the views

  if (auto even = dynamic_cast&lt;Even_sided*&gt;(item))
  {
    view_of_evens.emplace_back(even);
  }

  if (auto trisym = dynamic_cast&lt;Trilaterally_symmetrical*&gt;(item))
  {
    view_of_trisyms.emplace_back(trisym);
  }
}
</pre></div>
</div>
</section>
<section id="id707">
<h5>Note<a class="headerlink" href="#id707" title="Link to this heading">¶</a></h5>
<p>Un fallimento nella ricerca della classe richiesta farà sì che <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> restituisca un valore nullo e la de-referenziazione di un puntatore null porterà ad un comportamento indefinito. Quindi, il risultato della <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> deve sempre essere trattato come se potesse contenere un valore nullo e testato.</p>
</section>
<section id="id708">
<h5>Imposizione<a class="headerlink" href="#id708" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Complicato) A meno che non esista un test per il valore nullo del risultato di un <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> di un tipo di puntatore, avvisare in caso di de-referenziazione del puntatore.</p></li>
</ul>
</section>
</section>
<section id="c-149-use-unique-ptr-or-shared-ptr-to-avoid-forgetting-to-delete-objects-created-using-new">
<h4><a name="Rh-smart"></a>C.149: Usare <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> o <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> per evitare di dimenticarsi il <code class="docutils literal notranslate"><span class="pre">delete</span></code> degli oggetti creati con <code class="docutils literal notranslate"><span class="pre">new</span></code><a class="headerlink" href="#c-149-use-unique-ptr-or-shared-ptr-to-avoid-forgetting-to-delete-objects-created-using-new" title="Link to this heading">¶</a></h4>
<section id="id709">
<h5>Motivo<a class="headerlink" href="#id709" title="Link to this heading">¶</a></h5>
<p>Evitare perdite [leak] di risorse.</p>
</section>
<section id="id710">
<h5>Esempio<a class="headerlink" href="#id710" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use(int i)
{
    auto p = new int {7};           // bad: initialize local pointers with new
    auto q = make_unique&lt;int&gt;(9);   // ok: guarantee the release of the memory-allocated for 9
    if (0 &lt; i) return;              // maybe return and leak
    delete p;                       // too late
}
</pre></div>
</div>
</section>
<section id="id711">
<h5>Imposizione<a class="headerlink" href="#id711" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare l’inizializzazione di un puntatore “nudo” [naked] col risultato di un <code class="docutils literal notranslate"><span class="pre">new</span></code></p></li>
<li><p>Segnalare il <code class="docutils literal notranslate"><span class="pre">delete</span></code> di variabili locali</p></li>
</ul>
</section>
</section>
<section id="c-150-use-make-unique-to-construct-objects-owned-by-unique-ptrs">
<h4><a name="Rh-make_unique"></a>C.150: Usare <code class="docutils literal notranslate"><span class="pre">make_unique()</span></code> per costruire oggetti posseduti dagli <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code><a class="headerlink" href="#c-150-use-make-unique-to-construct-objects-owned-by-unique-ptrs" title="Link to this heading">¶</a></h4>
<p>Cfr. <a class="reference internal" href="#Rr-make_unique"><span class="xref myst">R.23</span></a></p>
</section>
<section id="c-151-use-make-shared-to-construct-objects-owned-by-shared-ptrs">
<h4><a name="Rh-make_shared"></a>C.151: Usare <code class="docutils literal notranslate"><span class="pre">make_shared()</span></code> per costruire oggetti posseduti dagli <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code><a class="headerlink" href="#c-151-use-make-shared-to-construct-objects-owned-by-shared-ptrs" title="Link to this heading">¶</a></h4>
<p>Cfr. <a class="reference internal" href="#Rr-make_shared"><span class="xref myst">R.22</span></a></p>
</section>
<section id="c-152-never-assign-a-pointer-to-an-array-of-derived-class-objects-to-a-pointer-to-its-base">
<h4><a name="Rh-array"></a>C.152: Mai assegnare un puntatore ad un array di oggetti di classi derivate a un puntatore alla sua classe base<a class="headerlink" href="#c-152-never-assign-a-pointer-to-an-array-of-derived-class-objects-to-a-pointer-to-its-base" title="Link to this heading">¶</a></h4>
<section id="id712">
<h5>Motivo<a class="headerlink" href="#id712" title="Link to this heading">¶</a></h5>
<p>Indicizzando [Subscripting] il puntatore base risultante porterà ad accedere ad un oggetto invalido e probabilmente alla corruzione della memoria.</p>
</section>
<section id="id713">
<h5>Esempio<a class="headerlink" href="#id713" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct B { int x; };
struct D : B { int y; };

void use(B*);

D a[] = { {1, 2}, {3, 4}, {5, 6} };
B* p = a;     // bad: a decays to &amp;a[0] which is converted to a B*
p[1].x = 7;   // overwrite a[0].y

use(a);       // bad: a decays to &amp;a[0] which is converted to a B*
</pre></div>
</div>
</section>
<section id="id714">
<h5>Imposizione<a class="headerlink" href="#id714" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare tutte le combinazioni di decadimenti e basi di array in conversioni derivate.</p></li>
<li><p>Si passa un array come uno <code class="docutils literal notranslate"><span class="pre">span</span></code> anziché un puntatore e non si lascia che il nome dell’array subisca una conversione derivata-dalla-base prima di accedere allo <code class="docutils literal notranslate"><span class="pre">span</span></code></p></li>
</ul>
</section>
</section>
<section id="c-153-prefer-virtual-function-to-casting">
<h4><a name="Rh-use-virtual"></a>C.153: Preferire la funzione virtual al casting<a class="headerlink" href="#c-153-prefer-virtual-function-to-casting" title="Link to this heading">¶</a></h4>
<section id="id715">
<h5>Motivo<a class="headerlink" href="#id715" title="Link to this heading">¶</a></h5>
<p>Una chiamata a una funzione virtuale è sicura, mentre il casting è soggetto a errori. Una chiamata a una funzione virtuale raggiunge le funzioni più derivate, mentre un cast potrebbe raggiungere una classe intermedia dando, quindi, un risultato sbagliato (specialmente durante la modifica per manutenzione di una gerarchia).</p>
</section>
<section id="id716">
<h5>Esempio<a class="headerlink" href="#id716" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id717">
<h5>Imposizione<a class="headerlink" href="#id717" title="Link to this heading">¶</a></h5>
<p>Cfr. <a class="reference internal" href="#Rh-dynamic_cast"><span class="xref myst">C.146</span></a> and ???</p>
</section>
</section>
</section>
<section id="c-over-overloading-and-overloaded-operators">
<h3><a name="SS-overload"></a>C.over: Operatori di sovraccarico [overloading] e sovraccaricati<a class="headerlink" href="#c-over-overloading-and-overloaded-operators" title="Link to this heading">¶</a></h3>
<p>Si possono sovraccaricare le normali funzioni, le funzioni template e gli operatori. Non si possono sovraccaricare gli oggetti funzione.</p>
<p>Riepilogo delle regole sull’overloading:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Ro-conventional"><span class="xref myst">C.160: Definire gli operatori soprattutto per imitare l’uso convenzionale</span></a></p></li>
<li><p><a class="reference internal" href="#Ro-symmetric"><span class="xref myst">C.161: Utilizzare le funzioni non-membro per gli operatori simmetrici</span></a></p></li>
<li><p><a class="reference internal" href="#Ro-equivalent"><span class="xref myst">C.162: Eseguire l’overload delle operazioni che sono approssimativamente equivalenti</span></a></p></li>
<li><p><a class="reference internal" href="#Ro-equivalent-2"><span class="xref myst">C.163: Eseguire l’overload solo delle operazioni che sono approssimativamente equivalenti</span></a></p></li>
<li><p><a class="reference internal" href="#Ro-conversion"><span class="xref myst">C.164: Evitare la conversione implicita degli operatori</span></a></p></li>
<li><p><a class="reference internal" href="#Ro-custom"><span class="xref myst">C.165: Utilizzare <code class="docutils literal notranslate"><span class="pre">using</span></code> per i punti di personalizzazione</span></a></p></li>
<li><p><a class="reference internal" href="#Ro-address-of"><span class="xref myst">C.166: Eseguire l’overloading del <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> unario solo come parte di un sistema di smart pointer e riferimenti</span></a></p></li>
<li><p><a class="reference internal" href="#Ro-overload"><span class="xref myst">C.167: Utilizzare un operatore per un’operazione col suo significato convenzionale</span></a></p></li>
<li><p><a class="reference internal" href="#Ro-namespace"><span class="xref myst">C.168: Definire gli operatori sovraccaricati [overloaded] nel namespace dei loro operandi</span></a></p></li>
<li><p><a class="reference internal" href="#Ro-lambda"><span class="xref myst">C.170: Se si vuole eseguire l’overloading di una lambda, si usi una lambda generica</span></a></p></li>
</ul>
<section id="c-160-define-operators-primarily-to-mimic-conventional-usage">
<h4><a name="Ro-conventional"></a>C.160: Definire gli operatori principalmente per imitare l’uso convenzionale<a class="headerlink" href="#c-160-define-operators-primarily-to-mimic-conventional-usage" title="Link to this heading">¶</a></h4>
<section id="id718">
<h5>Motivo<a class="headerlink" href="#id718" title="Link to this heading">¶</a></h5>
<p>Ridurre le sorprese.</p>
</section>
<section id="id719">
<h5>Esempio<a class="headerlink" href="#id719" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {
public:
    // ...
    X&amp; operator=(const X&amp;); // member function defining assignment
    friend bool operator==(const X&amp;, const X&amp;); // == needs access to representation
                                                // after a = b we have a == b
    // ...
};
</pre></div>
</div>
<p>Qui viene mantenuta la semantica convenzionale: <a class="reference internal" href="#SS-copy"><span class="xref myst">Le copie sono uguali</span></a>.</p>
</section>
<section id="id720">
<h5>Esempio, cattivo<a class="headerlink" href="#id720" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X operator+(X a, X b) { return a.v - b.v; }   // bad: makes + subtract
</pre></div>
</div>
</section>
<section id="id721">
<h5>Nota<a class="headerlink" href="#id721" title="Link to this heading">¶</a></h5>
<p>Gli operatori non-membri devono essere definiti friend o definiti nello <a class="reference internal" href="#Ro-namespace"><span class="xref myst">stesso namespace dei loro operandi</span></a>. <a class="reference internal" href="#Ro-symmetric"><span class="xref myst">Gli operatori binari dovrebbero trattare i loro operandi in modo equivalente</span></a>.</p>
</section>
<section id="id722">
<h5>Imposizione<a class="headerlink" href="#id722" title="Link to this heading">¶</a></h5>
<p>Forse impossibile.</p>
</section>
</section>
<section id="c-161-use-non-member-functions-for-symmetric-operators">
<h4><a name="Ro-symmetric"></a>C.161: Utilizzare le funzioni non-membro per gli operatori simmetrici<a class="headerlink" href="#c-161-use-non-member-functions-for-symmetric-operators" title="Link to this heading">¶</a></h4>
<section id="id723">
<h5>Motivo<a class="headerlink" href="#id723" title="Link to this heading">¶</a></h5>
<p>Se si usano le funzioni membro, ne servono due. A meno che non si usi una funzione non membro per (diciamo) <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code> e <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">==</span> <span class="pre">a</span></code> sarà leggermente diverso.</p>
</section>
<section id="id724">
<h5>Esempio<a class="headerlink" href="#id724" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool operator==(Point a, Point b) { return a.x == b.x &amp;&amp; a.y == b.y; }
</pre></div>
</div>
</section>
<section id="id725">
<h5>Imposizione<a class="headerlink" href="#id725" title="Link to this heading">¶</a></h5>
<p>Segnalare le funzioni operatore membro.</p>
</section>
</section>
<section id="c-162-overload-operations-that-are-roughly-equivalent">
<h4><a name="Ro-equivalent"></a>C.162: Eseguire l’overload delle operazioni che sono approssimativamente equivalenti<a class="headerlink" href="#c-162-overload-operations-that-are-roughly-equivalent" title="Link to this heading">¶</a></h4>
<section id="id726">
<h5>Motivo<a class="headerlink" href="#id726" title="Link to this heading">¶</a></h5>
<p>Avere dei nomi diversi per operazioni logicamente equivalenti su diversi tipi di argomenti confonde, induce alla codifica del tipo delle informazioni nei nomi delle funzioni e impedisce la programmazione generica.</p>
</section>
<section id="id727">
<h5>Esempio<a class="headerlink" href="#id727" title="Link to this heading">¶</a></h5>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void print(int a);
void print(int a, int base);
void print(const string&amp;);
</pre></div>
</div>
<p>Queste tre funzioni stampano (correttamente) i rispettivi argomenti. Di contro:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void print_int(int a);
void print_based(int a, int base);
void print_string(const string&amp;);
</pre></div>
</div>
<p>Queste tre funzioni stampano (correttamente) i rispettivi argomenti. Le aggiunte ai nomi aggiungono verbosità ed impediscono un codice generico.</p>
</section>
<section id="id728">
<h5>Imposizione<a class="headerlink" href="#id728" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="c-163-overload-only-for-operations-that-are-roughly-equivalent">
<h4><a name="Ro-equivalent-2"></a>C.163: Eseguire l’overload solo delle operazioni che sono approssimativamente equivalenti<a class="headerlink" href="#c-163-overload-only-for-operations-that-are-roughly-equivalent" title="Link to this heading">¶</a></h4>
<section id="id729">
<h5>Motivo<a class="headerlink" href="#id729" title="Link to this heading">¶</a></h5>
<p>Avere lo stesso nome per funzioni logicamente diverse è fonte di confusione e causa errori durante l’uso della programmazione generica.</p>
</section>
<section id="id730">
<h5>Esempio<a class="headerlink" href="#id730" title="Link to this heading">¶</a></h5>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void open_gate(Gate&amp; g);   // remove obstacle from garage exit lane
void fopen(const char* name, const char* mode);   // open file
</pre></div>
</div>
<p>Le due operazioni sono fondamentalmente diverse (e non correlate), quindi è bene che i loro nomi differiscano. Di contro:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void open(Gate&amp; g);   // remove obstacle from garage exit lane
void open(const char* name, const char* mode =&quot;r&quot;);   // open file
</pre></div>
</div>
<p>Le due operazioni continuano ad essere diverse (e non correlate) ma i nomi sono stati ridotti al minimo (comune), aprendo la strada alla confusione. Fortunatamente, il sistema dei tipi rileverà molti di questi errori.</p>
</section>
<section id="id731">
<h5>Nota<a class="headerlink" href="#id731" title="Link to this heading">¶</a></h5>
<p>Porre particolare attenzione ai nomi comuni e popolari, come <code class="docutils literal notranslate"><span class="pre">open</span></code>, <code class="docutils literal notranslate"><span class="pre">move</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code> e <code class="docutils literal notranslate"><span class="pre">==</span></code>.</p>
</section>
<section id="id732">
<h5>Imposizione<a class="headerlink" href="#id732" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="c-164-avoid-implicit-conversion-operators">
<h4><a name="Ro-conversion"></a>C.164: Evitare la conversione implicita degli operatori<a class="headerlink" href="#c-164-avoid-implicit-conversion-operators" title="Link to this heading">¶</a></h4>
<section id="id733">
<h5>Motivo<a class="headerlink" href="#id733" title="Link to this heading">¶</a></h5>
<p>Le conversioni implicite possono essere essenziali (p.es., da <code class="docutils literal notranslate"><span class="pre">double</span></code> a <code class="docutils literal notranslate"><span class="pre">int</span></code>) ma spesso causano sorprese (p.es., da <code class="docutils literal notranslate"><span class="pre">String</span></code> a stringhe C-style).</p>
</section>
<section id="id734">
<h5>Nota<a class="headerlink" href="#id734" title="Link to this heading">¶</a></h5>
<p>Preferire le conversioni con un nome esplicito finché non appare una seria esigenza. Per «seria esigenza» si intende un motivo fondamentale e frequente nel dominio dell’applicazione (come una conversione di numeri interi in numeri complessi). Non introdurre conversioni implicite (tramite operatori di conversione o costruttori non-<code class="docutils literal notranslate"><span class="pre">explicit</span></code>) solo per una minima comodità.</p>
</section>
<section id="id735">
<h5>Esempio<a class="headerlink" href="#id735" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct S1 {
    string s;
    // ...
    operator char*() { return s.data(); }  // BAD, likely to cause surprises
};

struct S2 {
    string s;
    // ...
    explicit operator char*() { return s.data(); }
};

void f(S1 s1, S2 s2)
{
    char* x1 = s1;     // OK, but can cause surprises in many contexts
    char* x2 = s2;     // error (and that&#39;s usually a good thing)
    char* x3 = static_cast&lt;char*&gt;(s2); // we can be explicit (on your head be it)
}
</pre></div>
</div>
<p>Una conversione implicita inaspettata e potenzialmente dannosa può capitare in contesti arbitrariamente difficili da individuare, p.es.,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>S1 ff();

char* g()
{
    return ff();
}
</pre></div>
</div>
<p>La stringa restituita da <code class="docutils literal notranslate"><span class="pre">ff()</span></code> viene distrutta prima che si possa utilizzare il puntatore restituito.</p>
</section>
<section id="id736">
<h5>Imposizione<a class="headerlink" href="#id736" title="Link to this heading">¶</a></h5>
<p>Segnalare tutti gli operatori di conversione non espliciti.</p>
</section>
</section>
<section id="c-165-use-using-for-customization-points">
<h4><a name="Ro-custom"></a>C.165: Utilizzare <code class="docutils literal notranslate"><span class="pre">using</span></code> per i punti di personalizzazione<a class="headerlink" href="#c-165-use-using-for-customization-points" title="Link to this heading">¶</a></h4>
<section id="id737">
<h5>Motivo<a class="headerlink" href="#id737" title="Link to this heading">¶</a></h5>
<p>Per trovare oggetti funzione e funzioni definite in un diverso namespace per «personalizzare» una funzione in comune.</p>
</section>
<section id="id738">
<h5>Esempio<a class="headerlink" href="#id738" title="Link to this heading">¶</a></h5>
<p>Si consideri <code class="docutils literal notranslate"><span class="pre">swap</span></code>. È una funzione generica (libreria standard) con una definizione che funzionerà praticamente per qualsiasi tipo. Tuttavia, è preferibile definire degli <code class="docutils literal notranslate"><span class="pre">swap()</span></code> specifici per dei particolari tipi. Per esempio, la <code class="docutils literal notranslate"><span class="pre">swap()</span></code> generica, copierà gli elementi di due <code class="docutils literal notranslate"><span class="pre">vector</span></code> da scambiare, mentre una buona e specifica implementazione non copierà affatto gli elementi.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>namespace N {
    My_type X { /* ... */ };
    void swap(X&amp;, X&amp;);   // optimized swap for N::X
    // ...
}

void f1(N::X&amp; a, N::X&amp; b)
{
    std::swap(a, b);   // probably not what we wanted: calls std::swap()
}
</pre></div>
</div>
<p>La <code class="docutils literal notranslate"><span class="pre">std::swap()</span></code> in <code class="docutils literal notranslate"><span class="pre">f1()</span></code> fa esattamente quello che le si chiede di fare: chiama la <code class="docutils literal notranslate"><span class="pre">swap()</span></code> nel namespace <code class="docutils literal notranslate"><span class="pre">std</span></code>. Sfortunatamente, è probabile che non sia ciò che si vuole. Come si può prendere in considerazione <code class="docutils literal notranslate"><span class="pre">N::X</span></code>?</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f2(N::X&amp; a, N::X&amp; b)
{
    swap(a, b);   // calls N::swap
}
</pre></div>
</div>
<p>Ma potrebbe non essere la cosa desiderata per il codice generico. Lì, in genere si vuole la funzione specifica, se esiste, altrimenti la funzione generica. Questo si ottiene includendo la funzione generale nella ricerca per la funzione:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f3(N::X&amp; a, N::X&amp; b)
{
    using std::swap;  // make std::swap available
    swap(a, b);        // calls N::swap if it exists, otherwise std::swap
}
</pre></div>
</div>
</section>
<section id="id739">
<h5>Imposizione<a class="headerlink" href="#id739" title="Link to this heading">¶</a></h5>
<p>Improbabile, ad eccezione dei punti di personalizzazione noti, come in <code class="docutils literal notranslate"><span class="pre">swap</span></code>. Il problema è che sono plausibili entrambe le versioni.</p>
</section>
</section>
<section id="c-166-overload-unary-only-as-part-of-a-system-of-smart-pointers-and-references">
<h4><a name="Ro-address-of"></a>C.166: Eseguire l’overloading del <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> unario solo come parte di un sistema di smart pointer e riferimenti<a class="headerlink" href="#c-166-overload-unary-only-as-part-of-a-system-of-smart-pointers-and-references" title="Link to this heading">¶</a></h4>
<section id="id740">
<h5>Motivo<a class="headerlink" href="#id740" title="Link to this heading">¶</a></h5>
<p>L’operatore <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> è fondamentale in C++. Molte parti della semantica del C++ ne presuppongono il significato di default.</p>
</section>
<section id="id741">
<h5>Esempio<a class="headerlink" href="#id741" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Ptr { // a somewhat smart pointer
    Ptr(X* pp) : p(pp) { /* check */ }
    X* operator-&gt;() { /* check */ return p; }
    X operator[](int i);
    X operator*();
private:
    T* p;
};

class X {
    Ptr operator&amp;() { return Ptr{this}; }
    // ...
};
</pre></div>
</div>
</section>
<section id="id742">
<h5>Nota<a class="headerlink" href="#id742" title="Link to this heading">¶</a></h5>
<p>Se si «pasticcia» con l’operatore <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> ci si assicuri che la sua definizione abbia dei significati corrispondenti per <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">[]</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code> e <code class="docutils literal notranslate"><span class="pre">.</span></code> sul tipo di risultato. Si noti che l’operatore <code class="docutils literal notranslate"><span class="pre">.</span></code> al momento non può essere sovraccaricato, quindi un sistema perfetto è impossibile. Ci auguriamo di rimediare: <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf">Operator Dot (R2)</a>. Si noti che <code class="docutils literal notranslate"><span class="pre">std::addressof()</span></code> produce sempre un puntatore [built-in].</p>
</section>
<section id="id743">
<h5>Imposizione<a class="headerlink" href="#id743" title="Link to this heading">¶</a></h5>
<p>Difficile. Avvertire se <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> è definito dall’utente senza definire anche <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> per il tipo di risultato.</p>
</section>
</section>
<section id="c-167-use-an-operator-for-an-operation-with-its-conventional-meaning">
<h4><a name="Ro-overload"></a>C.167: Utilizzare un operatore per un’operazione col suo significato convenzionale<a class="headerlink" href="#c-167-use-an-operator-for-an-operation-with-its-conventional-meaning" title="Link to this heading">¶</a></h4>
<section id="id744">
<h5>Motivo<a class="headerlink" href="#id744" title="Link to this heading">¶</a></h5>
<p>Leggibilità. Convenzione. Riusabilità. Supporto per la programmazione generica</p>
</section>
<section id="id745">
<h5>Esempio<a class="headerlink" href="#id745" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void cout_my_class(const My_class&amp; c) // confusing, not conventional,not generic
{
    std::cout &lt;&lt; /* class members here */;
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const my_class&amp; c) // OK
{
    return os &lt;&lt; /* class members here */;
}
</pre></div>
</div>
<p>Di per sé, <code class="docutils literal notranslate"><span class="pre">cout_my_class</span></code> sarebbe OK, ma non è utilizzabile/componibile col codice basato sulla convenzione di <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> per l’output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>My_class var { /* ... */ };
// ...
cout &lt;&lt; &quot;var = &quot; &lt;&lt; var &lt;&lt; &#39;\n&#39;;
</pre></div>
</div>
</section>
<section id="id746">
<h5>Nota<a class="headerlink" href="#id746" title="Link to this heading">¶</a></h5>
<p>Ci sono convenzioni forti e resistenti per il significato della maggior parte degli operatori, come ad esempio</p>
<ul class="simple">
<li><p>confronti (<code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> e <code class="docutils literal notranslate"><span class="pre">&lt;=&gt;</span></code>),</p></li>
<li><p>operazioni aritmetiche (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code> e <code class="docutils literal notranslate"><span class="pre">%</span></code>)</p></li>
<li><p>operazioni di accesso (<code class="docutils literal notranslate"><span class="pre">.</span></code>, <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code> unario e <code class="docutils literal notranslate"><span class="pre">[]</span></code>)</p></li>
<li><p>assegnazione (<code class="docutils literal notranslate"><span class="pre">=</span></code>)</p></li>
</ul>
<p>Non definire questi in modo non convenzionale e non inventarsi altri nomi per loro.</p>
</section>
<section id="id747">
<h5>Imposizione<a class="headerlink" href="#id747" title="Link to this heading">¶</a></h5>
<p>Difficile. Richiede un’analisi semantica.</p>
</section>
</section>
<section id="c-168-define-overloaded-operators-in-the-namespace-of-their-operands">
<h4><a name="Ro-namespace"></a>C.168: Definire gli operatori sovraccaricati [overloaded] nel namespace dei loro operandi<a class="headerlink" href="#c-168-define-overloaded-operators-in-the-namespace-of-their-operands" title="Link to this heading">¶</a></h4>
<section id="id748">
<h5>Motivo<a class="headerlink" href="#id748" title="Link to this heading">¶</a></h5>
<p>Leggibilità. Capacità di trovare gli operatori con l’ADL (Argument-dependent lookup). Evitare definizioni incoerenti nei diversi namespace</p>
</section>
<section id="id749">
<h5>Esempio<a class="headerlink" href="#id749" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct S { };
S operator+(S, S);   // OK: in the same namespace as S, and even next to S
S s;

S r = s + s;
</pre></div>
</div>
</section>
<section id="id750">
<h5>Esempio<a class="headerlink" href="#id750" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>namespace N {
    struct S { };
    S operator+(S, S);   // OK: in the same namespace as S, and even next to S
}

N::S s;

S r = s + s;  // finds N::operator+() by ADL
</pre></div>
</div>
</section>
<section id="id751">
<h5>Esempio, cattivo<a class="headerlink" href="#id751" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct S { };
S s;

namespace N {
    bool operator!(S a) { return true; }
    bool not_s = !s;
}

namespace M {
    bool operator!(S a) { return false; }
    bool not_s = !s;
}
</pre></div>
</div>
<p>Qui , il significato di <code class="docutils literal notranslate"><span class="pre">!s</span></code> differisce tra <code class="docutils literal notranslate"><span class="pre">N</span></code> e <code class="docutils literal notranslate"><span class="pre">M</span></code>. Ciò può risultare molto confuso. Eliminando la definizione di <code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">M</span></code> la confusione si trasforma nella possibilità di commettere un errore.</p>
</section>
<section id="id752">
<h5>Nota<a class="headerlink" href="#id752" title="Link to this heading">¶</a></h5>
<p>Se un operatore binario è definito per due tipi definiti diversamente in diversi namespace, non si può seguire questa regola. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Vec::Vector operator*(const Vec::Vector&amp;, const Mat::Matrix&amp;);
</pre></div>
</div>
<p>Potrebbe essere qualcosa da evitare.</p>
</section>
<section id="id753">
<h5>Si veda anche<a class="headerlink" href="#id753" title="Link to this heading">¶</a></h5>
<p>Questo è un caso speciale della regola secondo cui <a class="reference internal" href="#Rc-helper"><span class="xref myst">le funzioni helper dovrebbero essere definite nello stesso namespace delle loro classi</span></a>.</p>
</section>
<section id="id754">
<h5>Imposizione<a class="headerlink" href="#id754" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare le definizioni degli operatori che non stanno nel namespace dei loro operandi</p></li>
</ul>
</section>
</section>
<section id="c-170-if-you-feel-like-overloading-a-lambda-use-a-generic-lambda">
<h4><a name="Ro-lambda"></a>C.170: Se si vuole eseguire l’overloading di una lambda, si usi una lambda generica<a class="headerlink" href="#c-170-if-you-feel-like-overloading-a-lambda-use-a-generic-lambda" title="Link to this heading">¶</a></h4>
<section id="id755">
<h5>Motivo<a class="headerlink" href="#id755" title="Link to this heading">¶</a></h5>
<p>Non si può eseguire l’overload definendo due lambda con lo stesso nome.</p>
</section>
<section id="id756">
<h5>Esempio<a class="headerlink" href="#id756" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int);
void f(double);
auto f = [](char);   // error: cannot overload variable and function

auto g = [](int) { /* ... */ };
auto g = [](double) { /* ... */ };   // error: cannot overload variables

auto h = [](auto) { /* ... */ };   // OK
</pre></div>
</div>
</section>
<section id="id757">
<h5>Imposizione<a class="headerlink" href="#id757" title="Link to this heading">¶</a></h5>
<p>Il compilatore intercetta i tentativi di overload di una lambda.</p>
</section>
</section>
</section>
<section id="c-union-unions">
<h3><a name="SS-union"></a>C.union: Unioni<a class="headerlink" href="#c-union-unions" title="Link to this heading">¶</a></h3>
<p>Una <code class="docutils literal notranslate"><span class="pre">union</span></code> è una <code class="docutils literal notranslate"><span class="pre">struct</span></code> dove tutti i membri iniziano nello stesso indirizzo e quindi potrà contenere un solo membro per volta. Una <code class="docutils literal notranslate"><span class="pre">union</span></code> non tiene traccia di quale sia il membro che contiene quindi dev’essere il programmatore a prelevare quello giusto; ciò è intrinsecamente soggetto ad errori, ma ci sono dei modi per compensare.</p>
<p>Un tipo che è una <code class="docutils literal notranslate"><span class="pre">union</span></code> più un qualcosa che segnali il membro attualmente contenuto è chiamato <em>tagged union</em>, <em>discriminated union</em>, o un <em>variant</em>.</p>
<p>Riepilogo delle regole sulle union:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Ru-union"><span class="xref myst">C.180: Usare le <code class="docutils literal notranslate"><span class="pre">union</span></code> per risparmiare Memoria</span></a></p></li>
<li><p><a class="reference internal" href="#Ru-naked"><span class="xref myst">C.181: Evitare <code class="docutils literal notranslate"><span class="pre">union</span></code> «nude»</span></a></p></li>
<li><p><a class="reference internal" href="#Ru-anonymous"><span class="xref myst">C.182: Usare <code class="docutils literal notranslate"><span class="pre">union</span></code> anonime per implementare le tagged union</span></a></p></li>
<li><p><a class="reference internal" href="#Ru-pun"><span class="xref myst">C.183: Non usare una <code class="docutils literal notranslate"><span class="pre">union</span></code> per il «type punning»</span></a></p></li>
<li><p>???</p></li>
</ul>
<section id="c-180-use-unions-to-save-memory">
<h4><a name="Ru-union"></a>C.180: Usare le <code class="docutils literal notranslate"><span class="pre">union</span></code> per risparmiare memoria<a class="headerlink" href="#c-180-use-unions-to-save-memory" title="Link to this heading">¶</a></h4>
<section id="id758">
<h5>Motivo<a class="headerlink" href="#id758" title="Link to this heading">¶</a></h5>
<p>Una <code class="docutils literal notranslate"><span class="pre">union</span></code> consente di utilizzare un singolo pezzo di memoria per diversi tipi di oggetti in tempi diversi. Di conseguenza, può essere utilizzato per risparmiare memoria quando si hanno diversi oggetti che non vengono mai utilizzati contemporaneamente.</p>
</section>
<section id="id759">
<h5>Esempio<a class="headerlink" href="#id759" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>union Value {
    int x;
    double d;
};

Value v = { 123 };  // now v holds an int
cout &lt;&lt; v.x &lt;&lt; &#39;\n&#39;;    // write 123
v.d = 987.654;  // now v holds a double
cout &lt;&lt; v.d &lt;&lt; &#39;\n&#39;;    // write 987.654
</pre></div>
</div>
<p>Ma fare attenzione alla regola: <a class="reference internal" href="#Ru-naked"><span class="xref myst">Evitare <code class="docutils literal notranslate"><span class="pre">union</span></code> «nude»</span></a></p>
</section>
<section id="id760">
<h5>Esempio<a class="headerlink" href="#id760" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Short-string optimization

constexpr size_t buffer_size = 16; // Slightly larger than the size of a pointer

class Immutable_string {
public:
    Immutable_string(const char* str) :
        size(strlen(str))
    {
        if (size &lt; buffer_size)
            strcpy_s(string_buffer, buffer_size, str);
        else {
            string_ptr = new char[size + 1];
            strcpy_s(string_ptr, size + 1, str);
        }
    }

    ~Immutable_string()
    {
        if (size &gt;= buffer_size)
            delete[] string_ptr;
    }

    const char* get_str() const
    {
        return (size &lt; buffer_size) ? string_buffer : string_ptr;
    }

private:
    // If the string is short enough, we store the string itself
    // instead of a pointer to the string.
    union {
        char* string_ptr;
        char string_buffer[buffer_size];
    };

    const size_t size;
};
</pre></div>
</div>
</section>
<section id="id761">
<h5>Imposizione<a class="headerlink" href="#id761" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="c-181-avoid-naked-unions">
<h4><a name="Ru-naked"></a>C.181: Evitare <code class="docutils literal notranslate"><span class="pre">union</span></code> «nude»<a class="headerlink" href="#c-181-avoid-naked-unions" title="Link to this heading">¶</a></h4>
<section id="id762">
<h5>Motivo<a class="headerlink" href="#id762" title="Link to this heading">¶</a></h5>
<p>Una <em>union nuda</em> è una union senza un indicatore associato che indichi quale membro (se c’è) è contenuto,
quindi dev’essere il programmatore a tenerne traccia. Le unioni nude sono fonti di errori sui tipi.</p>
</section>
<section id="id763">
<h5>Esempio, cattivo<a class="headerlink" href="#id763" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>union Value {
    int x;
    double d;
};

Value v;
v.d = 987.654;  // v holds a double
</pre></div>
</div>
<p>Fin qui tutto bene, ma si può facilmente usare male la <code class="docutils literal notranslate"><span class="pre">union</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cout &lt;&lt; v.x &lt;&lt; &#39;\n&#39;;    // BAD, undefined behavior: v holds a double, but we read it as an int
</pre></div>
</div>
<p>Si noti che l’errore sul tipo avviene senza alcun cast esplicito. Quando fu testato il programma l’ultimo valore che si ottenne fu <code class="docutils literal notranslate"><span class="pre">1683627180</span></code> che era il valore intero per la disposizione dei bit per <code class="docutils literal notranslate"><span class="pre">987.654</span></code>. Ciò che si ha qui è un «invisibile» errore sul tipo che sembra dare un risultato che potrebbe facilmente sembrare innocuo.</p>
<p>E, a proposito di «invisibile», questo codice non produce niente in output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>v.x = 123;
cout &lt;&lt; v.d &lt;&lt; &#39;\n&#39;;    // BAD: undefined behavior
</pre></div>
</div>
</section>
<section id="id764">
<h5>Alternativa<a class="headerlink" href="#id764" title="Link to this heading">¶</a></h5>
<p>Racchiudere una <code class="docutils literal notranslate"><span class="pre">union</span></code> in una classe assieme ad un campo sul tipo.</p>
<p>Il tipo <code class="docutils literal notranslate"><span class="pre">variant</span></code> del C++17 (presente in <code class="docutils literal notranslate"><span class="pre">&lt;variant&gt;</span></code> fa al caso nostro:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>variant&lt;int, double&gt; v;
v = 123;        // v holds an int
int x = get&lt;int&gt;(v);
v = 123.456;    // v holds a double
double w = get&lt;double&gt;(v);
</pre></div>
</div>
</section>
<section id="id765">
<h5>Imposizione<a class="headerlink" href="#id765" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="c-182-use-anonymous-unions-to-implement-tagged-unions">
<h4><a name="Ru-anonymous"></a>C.182: Usare <code class="docutils literal notranslate"><span class="pre">union</span></code> anonime per implementare le tagged union<a class="headerlink" href="#c-182-use-anonymous-unions-to-implement-tagged-unions" title="Link to this heading">¶</a></h4>
<section id="id766">
<h5>Motivo<a class="headerlink" href="#id766" title="Link to this heading">¶</a></h5>
<p>Una «tagged union» ben progettata è «type safe». Una union <em>anonima</em> semplifica la definizione di una classe con una coppia (tag, union).</p>
</section>
<section id="id767">
<h5>Esempio<a class="headerlink" href="#id767" title="Link to this heading">¶</a></h5>
<p>Questo esempio è preso in prestito da TC++PL4 pp216-218. Se ne può cercare lì una spiegazione.</p>
<p>Il codice è piuttosto elaborato. Gestire un tipo con assegnazione e distruttore definiti dall’utente è complicato. Far risparmiare ai programmatori il dover scrivere questo codice è la ragione per includere il <code class="docutils literal notranslate"><span class="pre">variant</span></code> nello standard.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Value { // two alternative representations represented as a union
private:
    enum class Tag { number, text };
    Tag type; // discriminant

    union { // representation (note: anonymous union)
        int i;
        string s; // string has default constructor, copy operations, and destructor
    };
public:
    struct Bad_entry { }; // used for exceptions

    ~Value();
    Value&amp; operator=(const Value&amp;);   // necessary because of the string variant
    Value(const Value&amp;);
    // ...
    int number() const;
    string text() const;

    void set_number(int n);
    void set_text(const string&amp;);
    // ...
};

int Value::number() const
{
    if (type != Tag::number) throw Bad_entry{};
    return i;
}

string Value::text() const
{
    if (type != Tag::text) throw Bad_entry{};
    return s;
}

void Value::set_number(int n)
{
    if (type == Tag::text) {
        s.~string();      // explicitly destroy string
        type = Tag::number;
    }
    i = n;
}

void Value::set_text(const string&amp; ss)
{
    if (type == Tag::text)
        s = ss;
    else {
        new(&amp;s) string{ss};   // placement new: explicitly construct string
        type = Tag::text;
    }
}

Value&amp; Value::operator=(const Value&amp; e)   // necessary because of the string variant
{
    if (type == Tag::text &amp;&amp; e.type == Tag::text) {
        s = e.s;    // usual string assignment
        return *this;
    }

    if (type == Tag::text) s.~string(); // explicit destroy

    switch (e.type) {
    case Tag::number:
        i = e.i;
        break;
    case Tag::text:
        new(&amp;s) string(e.s);   // placement new: explicit construct
    }

    type = e.type;
    return *this;
}

Value::~Value()
{
    if (type == Tag::text) s.~string(); // explicit destroy
}
</pre></div>
</div>
</section>
<section id="id768">
<h5>Imposizione<a class="headerlink" href="#id768" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="c-183-don-t-use-a-union-for-type-punning">
<h4><a name="Ru-pun"></a>C.183: Non usare una <code class="docutils literal notranslate"><span class="pre">union</span></code> per il «type punning»<a class="headerlink" href="#c-183-don-t-use-a-union-for-type-punning" title="Link to this heading">¶</a></h4>
<section id="id769">
<h5>Motivo<a class="headerlink" href="#id769" title="Link to this heading">¶</a></h5>
<p>Si ha un comportamento indefinito nel leggere il membro di una <code class="docutils literal notranslate"><span class="pre">union</span></code> con un tipo diverso da quello con cui è stato scritto. Questo trucchetto è invisibile, o quanto meno più difficile da evidenziare rispetto al cast. Il «type punning» con una <code class="docutils literal notranslate"><span class="pre">union</span></code> è fonte di errori.</p>
</section>
<section id="id770">
<h5>Esempio, cattivo<a class="headerlink" href="#id770" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>union Pun {
    int x;
    unsigned char c[sizeof(int)];
};
</pre></div>
</div>
<p>L’idea di <code class="docutils literal notranslate"><span class="pre">Pun</span></code> è quella di essere in grado di vedere la rappresentazione in caratteri di un <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void bad(Pun&amp; u)
{
    u.x = &#39;x&#39;;
    cout &lt;&lt; u.c[0] &lt;&lt; &#39;\n&#39;;     // undefined behavior
}
</pre></div>
</div>
<p>Se si vogliono vedere i byte di un <code class="docutils literal notranslate"><span class="pre">int</span></code>, si usa un (named) cast:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void if_you_must_pun(int&amp; x)
{
    auto p = reinterpret_cast&lt;std::byte*&gt;(&amp;x);
    cout &lt;&lt; p[0] &lt;&lt; &#39;\n&#39;;     // OK; better
    // ...
}
</pre></div>
</div>
<p>L’accesso al risultato di un <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> dal tipo dichiarato <code class="docutils literal notranslate"><span class="pre">char*</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char*</span></code>, o <code class="docutils literal notranslate"><span class="pre">std::byte*</span></code> dell’oggetto, è un comportamento definito. (L’uso di <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> è sconsigliato, ma almeno si può vedere che succede qualcosa di strano.</p>
</section>
<section id="id771">
<h5>Nota<a class="headerlink" href="#id771" title="Link to this heading">¶</a></h5>
<p>Sfortunatamente, le <code class="docutils literal notranslate"><span class="pre">union</span></code> vengono comunemente usate per il «type punning». Non si considera «a volte funziona come previsto» un argomento conclusivo.</p>
<p>Il C++17 ha introdotto un tipo diverso <code class="docutils literal notranslate"><span class="pre">std::byte</span></code> per facilitare le operazioni sulla rappresentazione grezza degli oggetti.  Per queste operazioni si usi questo tipo invece di <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code> o di <code class="docutils literal notranslate"><span class="pre">char</span></code>.</p>
</section>
<section id="id772">
<h5>Imposizione<a class="headerlink" href="#id772" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
</section>
</section>
<section id="enum-enumerations">
<h2><a name="S-enum"></a>Enum: Enumerazioni<a class="headerlink" href="#enum-enumerations" title="Link to this heading">¶</a></h2>
<p>Le enumerazioni si usano per definire insiemi di valori interi e per definire tipi di questi insiemi di valori. Ci sono due tipi di enumerazioni, «semplici» <code class="docutils literal notranslate"><span class="pre">enum</span></code> e <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">enum</span></code>.</p>
<p>Riepilogo delle regole sulle enumerazioni:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Renum-macro"><span class="xref myst">Enum.1: Preferire le enumerazioni alle macro</span></a></p></li>
<li><p><a class="reference internal" href="#Renum-set"><span class="xref myst">Enum.2: Usare le enumerazioni per rappresentare insiemi di nomi di costanti correlate</span></a></p></li>
<li><p><a class="reference internal" href="#Renum-class"><span class="xref myst">Enum.3: Preferire le <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> alle «semplici» <code class="docutils literal notranslate"><span class="pre">enum</span></code>s</span></a></p></li>
<li><p><a class="reference internal" href="#Renum-oper"><span class="xref myst">Enum.4: Definire le operazioni sulle enumerazioni per un uso sicuro e semplice</span></a></p></li>
<li><p><a class="reference internal" href="#Renum-caps"><span class="xref myst">Enum.5: Non usare <code class="docutils literal notranslate"><span class="pre">TUTTO_IN_MAIUSCOLO</span></code> per gli enumeratori</span></a></p></li>
<li><p><a class="reference internal" href="#Renum-unnamed"><span class="xref myst">Enum.6: Evitare enumerazioni senza nome</span></a></p></li>
<li><p><a class="reference internal" href="#Renum-underlying"><span class="xref myst">Enum.7: Specificare il [tipo sottostante] di una enumerazione solo quando è necessario</span></a></p></li>
<li><p><a class="reference internal" href="#Renum-value"><span class="xref myst">Enum.8: Specificare i valori dell’enumeratore solo quando è necessario</span></a></p></li>
</ul>
<section id="enum-1-prefer-enumerations-over-macros">
<h3><a name="Renum-macro"></a>Enum.1: Preferire le enumerazioni alle macro<a class="headerlink" href="#enum-1-prefer-enumerations-over-macros" title="Link to this heading">¶</a></h3>
<section id="id773">
<h4>Motivo<a class="headerlink" href="#id773" title="Link to this heading">¶</a></h4>
<p>Le macro non obbediscono alle regole dello scope e del tipo. Inoltre, i nomi delle macro vengono rimossi durante il preprocessing e quindi solitamente non appaiono in tool come i debugger.</p>
</section>
<section id="id774">
<h4>Esempio<a class="headerlink" href="#id774" title="Link to this heading">¶</a></h4>
<p>Un primo esempio di vecchio codice non buono:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// webcolors.h (third party header)
#define RED   0xFF0000
#define GREEN 0x00FF00
#define BLUE  0x0000FF

// productinfo.h
// The following define product subtypes based on color
#define RED    0
#define PURPLE 1
#define BLUE   2

int webby = BLUE;   // webby == 2; probably not what was desired
</pre></div>
</div>
<p>Si usi invece un <code class="docutils literal notranslate"><span class="pre">enum</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
enum class Product_info { red = 0, purple = 1, blue = 2 };

int webby = blue;   // error: be specific
Web_color webby = Web_color::blue;
</pre></div>
</div>
<p>Abbiamo usato un <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> per evitare il conflitto fra i nomi.</p>
</section>
<section id="id775">
<h4>Nota<a class="headerlink" href="#id775" title="Link to this heading">¶</a></h4>
<p>Considerare anche le variabili <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> e <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">inline</span></code>.</p>
</section>
<section id="id776">
<h4>Imposizione<a class="headerlink" href="#id776" title="Link to this heading">¶</a></h4>
<p>Segnalare le macro che definiscono valori interi. Usare <code class="docutils literal notranslate"><span class="pre">enum</span></code> o <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">inline</span></code> o un’altra alternativa non-macro.</p>
</section>
</section>
<section id="enum-2-use-enumerations-to-represent-sets-of-related-named-constants">
<h3><a name="Renum-set"></a>Enum.2: Usare le enumerazioni per rappresentare insiemi di nomi di costanti correlate<a class="headerlink" href="#enum-2-use-enumerations-to-represent-sets-of-related-named-constants" title="Link to this heading">¶</a></h3>
<section id="id777">
<h4>Motivo<a class="headerlink" href="#id777" title="Link to this heading">¶</a></h4>
<p>Un’enumerazione mostra la correlazione degli enumeratori e può essere un tipo con un nome.</p>
</section>
<section id="id778">
<h4>Esempio<a class="headerlink" href="#id778" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
</pre></div>
</div>
</section>
<section id="id779">
<h4>Nota<a class="headerlink" href="#id779" title="Link to this heading">¶</a></h4>
<p>Lo switch con una enumerazione è una cosa comune ed il compilatore può mettere in guardia da insoliti valori delle label di un case. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum class Product_info { red = 0, purple = 1, blue = 2 };

void print(Product_info inf)
{
    switch (inf) {
    case Product_info::red: cout &lt;&lt; &quot;red&quot;; break;
    case Product_info::purple: cout &lt;&lt; &quot;purple&quot;; break;
    }
}
</pre></div>
</div>
<p>Questi <code class="docutils literal notranslate"><span class="pre">switch</span></code> con case mancanti sono spesso il risultato di un enumeratore aggiunto in seguito o un test incompleto.</p>
</section>
<section id="id780">
<h4>Imposizione<a class="headerlink" href="#id780" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare le istruzioni <code class="docutils literal notranslate"><span class="pre">switch</span></code> dove i <code class="docutils literal notranslate"><span class="pre">case</span></code> non gestiscono tutti gli enumeratori di una enumerazione.</p></li>
<li><p>Segnalare le istruzioni <code class="docutils literal notranslate"><span class="pre">switch</span></code> dove i <code class="docutils literal notranslate"><span class="pre">case</span></code> gestiscono alcuni enumeratori di una enumerazione ma non c’è alcun caso di <code class="docutils literal notranslate"><span class="pre">default</span></code>.</p></li>
</ul>
</section>
</section>
<section id="enum-3-prefer-class-enums-over-plain-enums">
<h3><a name="Renum-class"></a>Enum.3: Preferire la class enum alle «semplici» enum<a class="headerlink" href="#enum-3-prefer-class-enums-over-plain-enums" title="Link to this heading">¶</a></h3>
<section id="id781">
<h4>Motivo<a class="headerlink" href="#id781" title="Link to this heading">¶</a></h4>
<p>Per ridurre al minimo le sorprese: gli enum tradizionali vengono convertiti in int troppo rapidamente.</p>
</section>
<section id="id782">
<h4>Esempio<a class="headerlink" href="#id782" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void Print_color(int color);

enum Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
enum Product_info { red = 0, purple = 1, blue = 2 };

Web_color webby = Web_color::blue;

// Clearly at least one of these calls is buggy.
Print_color(webby);
Print_color(Product_info::blue);
</pre></div>
</div>
<p>Mentre usando una <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void Print_color(int color);

enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
enum class Product_info { red = 0, purple = 1, blue = 2 };

Web_color webby = Web_color::blue;
Print_color(webby);  // Error: cannot convert Web_color to int.
Print_color(Product_info::red);  // Error: cannot convert Product_info to int.
</pre></div>
</div>
</section>
<section id="id783">
<h4>Imposizione<a class="headerlink" href="#id783" title="Link to this heading">¶</a></h4>
<p>(Semplice) Avvisare di qualsiasi definizione non-class <code class="docutils literal notranslate"><span class="pre">enum</span></code>.</p>
</section>
</section>
<section id="enum-4-define-operations-on-enumerations-for-safe-and-simple-use">
<h3><a name="Renum-oper"></a>Enum.4: Definire le operazioni sulle enumerazioni per un uso sicuro e semplice<a class="headerlink" href="#enum-4-define-operations-on-enumerations-for-safe-and-simple-use" title="Link to this heading">¶</a></h3>
<section id="id784">
<h4>Motivo<a class="headerlink" href="#id784" title="Link to this heading">¶</a></h4>
<p>Comodità d’uso e per evitare errori.</p>
</section>
<section id="id785">
<h4>Esempio<a class="headerlink" href="#id785" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum class Day { mon, tue, wed, thu, fri, sat, sun };

Day&amp; operator++(Day&amp; d)
{
    return d = (d == Day::sun) ? Day::mon : static_cast&lt;Day&gt;(static_cast&lt;int&gt;(d)+1);
}

Day today = Day::sat;
Day tomorrow = ++today;
</pre></div>
</div>
<p>L’uso di uno <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> non è il massimo, ma</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Day&amp; operator++(Day&amp; d)
{
    return d = (d == Day::sun) ? Day::mon : Day{++d};    // error
}
</pre></div>
</div>
<p>è una ricorsione infinita e scrivendola senza un cast, con uno <code class="docutils literal notranslate"><span class="pre">switch</span></code> su tutti i casi è prolisso.</p>
</section>
<section id="id786">
<h4>Imposizione<a class="headerlink" href="#id786" title="Link to this heading">¶</a></h4>
<p>Segnalare le espressioni ripetute di conversioni ad una enumerazione.</p>
</section>
</section>
<section id="enum-5-don-t-use-all-caps-for-enumerators">
<h3><a name="Renum-caps"></a>Enum.5: Non usare <code class="docutils literal notranslate"><span class="pre">TUTTO_IN_MAIUSCOLO</span></code> per gli enumeratori<a class="headerlink" href="#enum-5-don-t-use-all-caps-for-enumerators" title="Link to this heading">¶</a></h3>
<section id="id787">
<h4>Motivo<a class="headerlink" href="#id787" title="Link to this heading">¶</a></h4>
<p>Evitare conflitti con le macro.</p>
</section>
<section id="id788">
<h4>Esempio, cattivo<a class="headerlink" href="#id788" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> // webcolors.h (third party header)
#define RED   0xFF0000
#define GREEN 0x00FF00
#define BLUE  0x0000FF

// productinfo.h
// The following define product subtypes based on color

enum class Product_info { RED, PURPLE, BLUE };   // syntax error
</pre></div>
</div>
</section>
<section id="id789">
<h4>Imposizione<a class="headerlink" href="#id789" title="Link to this heading">¶</a></h4>
<p>Segnalare gli enumeratori TUTTO_IN_MAIUSCOLO.</p>
</section>
</section>
<section id="enum-6-avoid-unnamed-enumerations">
<h3><a name="Renum-unnamed"></a>Enum.6: Evitare enumerazioni senza nome<a class="headerlink" href="#enum-6-avoid-unnamed-enumerations" title="Link to this heading">¶</a></h3>
<section id="id790">
<h4>Motivo<a class="headerlink" href="#id790" title="Link to this heading">¶</a></h4>
<p>Se non si dà un nome ad un’enumerazione, i valori non vengono correlati</p>
</section>
<section id="id791">
<h4>Esempio, cattivo<a class="headerlink" href="#id791" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum { red = 0xFF0000, scale = 4, is_signed = 1 };
</pre></div>
</div>
<p>Questo codice non è raro in quello scritto prima che esistessero alternative convenienti per indicare delle costanti intere.</p>
</section>
<section id="id792">
<h4>Alternativa<a class="headerlink" href="#id792" title="Link to this heading">¶</a></h4>
<p>Usare invece i valori <code class="docutils literal notranslate"><span class="pre">constexpr</span></code>. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>constexpr int red = 0xFF0000;
constexpr short scale = 4;
constexpr bool is_signed = true;
</pre></div>
</div>
</section>
<section id="id793">
<h4>Imposizione<a class="headerlink" href="#id793" title="Link to this heading">¶</a></h4>
<p>Segnalare le enumerazioni senza nome.</p>
</section>
</section>
<section id="enum-7-specify-the-underlying-type-of-an-enumeration-only-when-necessary">
<h3><a name="Renum-underlying"></a>Enum.7: Specificare il [tipo sottostante] di una enumerazione solo quando è necessario<a class="headerlink" href="#enum-7-specify-the-underlying-type-of-an-enumeration-only-when-necessary" title="Link to this heading">¶</a></h3>
<section id="id794">
<h4>Motivo<a class="headerlink" href="#id794" title="Link to this heading">¶</a></h4>
<p>Il default è più facile da leggere e da scrivere. <code class="docutils literal notranslate"><span class="pre">int</span></code> è il tipo intero di default. <code class="docutils literal notranslate"><span class="pre">int</span></code> è compatibile con gli <code class="docutils literal notranslate"><span class="pre">enum</span></code> del C.</p>
</section>
<section id="id795">
<h4>Esempio<a class="headerlink" href="#id795" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum class Direction : char { n, s, e, w,
                              ne, nw, se, sw };  // underlying type saves space

enum class Web_color : int32_t { red   = 0xFF0000,
                                 green = 0x00FF00,
                                 blue  = 0x0000FF };  // underlying type is redundant
</pre></div>
</div>
</section>
<section id="id796">
<h4>Nota<a class="headerlink" href="#id796" title="Link to this heading">¶</a></h4>
<p>Specificare il tipo in esame è necessario per il «forward-declare» di un enum o una classe enum:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum Flags : char;

void f(Flags);

// ....

enum Flags : char { /* ... */ };
</pre></div>
</div>
<p>o per garantire che i valori di quel tipo abbiano una specifica bit-precision:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum Bitboard : uint64_t { /* ... */ };
</pre></div>
</div>
</section>
<section id="id797">
<h4>Imposizione<a class="headerlink" href="#id797" title="Link to this heading">¶</a></h4>
<p>????</p>
</section>
</section>
<section id="enum-8-specify-enumerator-values-only-when-necessary">
<h3><a name="Renum-value"></a>Enum.8: Specificare i valori dell’enumeratore solo quando è necessario<a class="headerlink" href="#enum-8-specify-enumerator-values-only-when-necessary" title="Link to this heading">¶</a></h3>
<section id="id798">
<h4>Motivo<a class="headerlink" href="#id798" title="Link to this heading">¶</a></h4>
<p>È la cosa più semplice. Evitare i valori duplicati dell’enumeratore. Col default si ha un insieme consecutivo dei valori ed è un bene per l’implementazione delle istruzioni <code class="docutils literal notranslate"><span class="pre">switch</span></code>.</p>
</section>
<section id="id799">
<h4>Esempio<a class="headerlink" href="#id799" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum class Col1 { red, yellow, blue };
enum class Col2 { red = 1, yellow = 2, blue = 2 }; // typo
enum class Month { jan = 1, feb, mar, apr, may, jun,
                   jul, august, sep, oct, nov, dec }; // starting with 1 is conventional
enum class Base_flag { dec = 1, oct = dec &lt;&lt; 1, hex = dec &lt;&lt; 2 }; // set of bits
</pre></div>
</div>
<p>È necessario specificare i valori per far corrispondere i valori convenzionali (p.es., <code class="docutils literal notranslate"><span class="pre">Month</span></code>) e dove non si desiderano valori consecutivi (p.es., per avere bit separati come in <code class="docutils literal notranslate"><span class="pre">Base_flag</span></code>).</p>
</section>
<section id="id800">
<h4>Imposizione<a class="headerlink" href="#id800" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare i valori duplicati degli enumeratori</p></li>
<li><p>Segnalare valori consecutivi esplicitamente indicati degli enumeratori</p></li>
</ul>
</section>
</section>
</section>
<section id="r-resource-management">
<h2><a name="S-resource"></a>R: Gestione delle risorse<a class="headerlink" href="#r-resource-management" title="Link to this heading">¶</a></h2>
<p>Questa sezione contiene regole relative alle risorse. Una risorsa è tutto ciò che deve essere acquisito e (esplicitamente o implicitamente) rilasciato, come la memoria, gli handle dei file, i socket e i lock. Il motivo per cui deve essere rilasciata è generalmente perché può scarseggiare, quindi anche un rilascio ritardato potrebbe provocare danni. L’obiettivo fondamentale è garantire che non ci siano perdite di risorse [leak] e che non si trattenga una risorsa più a lungo del necessario. Un’entità responsabile del rilascio di una risorsa è detta proprietaria [owner].</p>
<p>Ci sono alcuni casi in cui le perdite [leak] possono essere accettabili o addirittura ottimali: Se si sta scrivendo un programma che produce semplicemente un output basato su un input e la quantità di memoria necessaria è proporzionale alla dimensione dell’input, la strategia ottimale (per le prestazioni e la facilità di programmazione) è talvolta quella di semplicemente mai cancellare niente. Se si ha memoria sufficiente per gestire il proprio input più grande, si ha una perdita [leak], ma ci si assicuri di dare un buon messaggio di errore se si sbaglia. Qui, non teniamo conto di questi casi.</p>
<ul class="simple">
<li><p>Riepilogo delle regole sulla gestione delle risorse:</p>
<ul>
<li><p><a class="reference internal" href="#Rr-raii"><span class="xref myst">R.1: Gestire automaticamente le risorse utilizzando gli handle e il RAII (Resource Acquisition Is Initialization)</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-use-ptr"><span class="xref myst">R.2: Nelle interfacce, usare puntatori semplici [raw] per denotare (solo) i singoli oggetti</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-ptr"><span class="xref myst">R.3: Un puntatore semplice [raw] (un <code class="docutils literal notranslate"><span class="pre">T*</span></code>) non è proprietario</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-ref"><span class="xref myst">R.4: Un riferimento [raw] (un <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>) non è proprietario</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-scoped"><span class="xref myst">R.5: Preferire oggetti con scope, non allocare sull’heap se non necessario</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-global"><span class="xref myst">R.6: Evitare le variabili globali non-<code class="docutils literal notranslate"><span class="pre">const</span></code></span></a></p></li>
</ul>
</li>
<li><p>Riepilogo delle regole sull’allocazione e la de-allocazione:</p>
<ul>
<li><p><a class="reference internal" href="#Rr-mallocfree"><span class="xref myst">R.10: Evitare <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> e <code class="docutils literal notranslate"><span class="pre">free()</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rr-newdelete"><span class="xref myst">R.11: Evitare di chiamare esplicitamente <code class="docutils literal notranslate"><span class="pre">new</span></code> e <code class="docutils literal notranslate"><span class="pre">delete</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rr-immediate-alloc"><span class="xref myst">R.12: Fornire immediatamente il risultato dell’allocazione di una risorsa ad un oggetto gestore</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-single-alloc"><span class="xref myst">R.13: Eseguire al massimo una allocazione di risorsa esplicita in una singola istruzione</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-ap"><span class="xref myst">R.14: Evitare parametri <code class="docutils literal notranslate"><span class="pre">[]</span></code>, preferire <code class="docutils literal notranslate"><span class="pre">span</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rr-pair"><span class="xref myst">R.15: Eseguire sempre l’overload dell’accoppiata allocazione/de-allocazione</span></a></p></li>
</ul>
</li>
<li><p><a name="Rr-summary-smartptrs"></a>Riepilogo delle regole sugli smart pointer:</p>
<ul>
<li><p><a class="reference internal" href="#Rr-owner"><span class="xref myst">R.20: Utilizzare <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> e <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> per rappresentare il possesso</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-unique"><span class="xref myst">R.21: Preferire <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> a <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> a meno che non sia necessario condividere il possesso</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-make_shared"><span class="xref myst">R.22: Usare <code class="docutils literal notranslate"><span class="pre">make_shared()</span></code> per creare gli <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>s</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-make_unique"><span class="xref myst">R.23: Usare <code class="docutils literal notranslate"><span class="pre">make_unique()</span></code> per creare gli <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code>s</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-weak_ptr"><span class="xref myst">R.24: Usare <code class="docutils literal notranslate"><span class="pre">std::weak_ptr</span></code> per interrompere i cicli di <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>s</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-smartptrparam"><span class="xref myst">R.30: Prendere gli smart pointer come parametri solo per esprimere esplicitamente la semantica della durata [lifetime]</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-smart"><span class="xref myst">R.31: Se si hanno smart pointer non-<code class="docutils literal notranslate"><span class="pre">std</span></code>, seguire il pattern base di <code class="docutils literal notranslate"><span class="pre">std</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rr-uniqueptrparam"><span class="xref myst">R.32: Prendere un parametro <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;widget&gt;</span></code> per esprimere che una funzione assume la proprietà di un <code class="docutils literal notranslate"><span class="pre">widget</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rr-reseat"><span class="xref myst">R.33: Prendere un parametro <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;widget&gt;&amp;</span></code> per esprimere che una funzione ricolloca/restituisce [reseat] il <code class="docutils literal notranslate"><span class="pre">widget</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rr-sharedptrparam-owner"><span class="xref myst">R.34: Prendere un parametro <code class="docutils literal notranslate"><span class="pre">shared_ptr&lt;widget&gt;</span></code> per esprimere la proprietà condivisa</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-sharedptrparam"><span class="xref myst">R.35: Prendere un parametro <code class="docutils literal notranslate"><span class="pre">shared_ptr&lt;widget&gt;&amp;</span></code> per esprimere che una funzione può ricollocare [reseat] lo shared pointer</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-sharedptrparam-const"><span class="xref myst">R.36: Prendere un parametro <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">shared_ptr&lt;widget&gt;&amp;</span></code> per esprimere che potrebbe conservare un conteggio dei riferimenti all’oggetto ???</span></a></p></li>
<li><p><a class="reference internal" href="#Rr-smartptrget"><span class="xref myst">R.37: Non passare un puntatore o un riferimento ottenuti da un alias di uno smart pointer</span></a></p></li>
</ul>
</li>
</ul>
<section id="r-1-manage-resources-automatically-using-resource-handles-and-raii-resource-acquisition-is-initialization">
<h3><a name="Rr-raii"></a>R.1: Gestire automaticamente le risorse utilizzando gli handle e il RAII (Resource Acquisition Is Initialization)<a class="headerlink" href="#r-1-manage-resources-automatically-using-resource-handles-and-raii-resource-acquisition-is-initialization" title="Link to this heading">¶</a></h3>
<section id="id801">
<h4>Motivo<a class="headerlink" href="#id801" title="Link to this heading">¶</a></h4>
<p>Per evitare leak [perdite] e la complessità di una gestione manuale delle risorse. La simmetria obbligata del costruttore/distruttore del linguaggio C++ rispecchia quella derivante dalle coppie di funzioni per acquisire/rilasciare le risorse come <code class="docutils literal notranslate"><span class="pre">fopen</span></code>/<code class="docutils literal notranslate"><span class="pre">fclose</span></code>, <code class="docutils literal notranslate"><span class="pre">lock</span></code>/<code class="docutils literal notranslate"><span class="pre">unlock</span></code> e <code class="docutils literal notranslate"><span class="pre">new</span></code>/<code class="docutils literal notranslate"><span class="pre">delete</span></code>. Quando si ha a che fare con una risorsa che necessita la chiamata alla coppia di funzioni acquisisci/rilascia, si incapsuli tale risorsa in un oggetto che gestisca autonomamente tale accoppiata – acquisisce la risorsa nel costruttore e la rilascia nel suo distruttore.</p>
</section>
<section id="id802">
<h4>Esempio, cattivo<a class="headerlink" href="#id802" title="Link to this heading">¶</a></h4>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void send(X* x, string_view destination)
{
    auto port = open_port(destination);
    my_mutex.lock();
    // ...
    send(port, x);
    // ...
    my_mutex.unlock();
    close_port(port);
    delete x;
}
</pre></div>
</div>
<p>In questo codice ci si deve ricordare di <code class="docutils literal notranslate"><span class="pre">unlock</span></code>, <code class="docutils literal notranslate"><span class="pre">close_port</span></code> e <code class="docutils literal notranslate"><span class="pre">delete</span></code> in ogni diramazione del flusso di codice, e farlo esattamente una sola volta. Inoltre, se una qualsiasi parte del codice segnalato con <code class="docutils literal notranslate"><span class="pre">...</span></code> genera un’eccezione, allora <code class="docutils literal notranslate"><span class="pre">x</span></code> viene perso e <code class="docutils literal notranslate"><span class="pre">my_mutex</span></code> resta bloccato [locked].</p>
</section>
<section id="id803">
<h4>Esempio<a class="headerlink" href="#id803" title="Link to this heading">¶</a></h4>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void send(unique_ptr&lt;X&gt; x, string_view destination)  // x owns the X
{
    Port port{destination};            // port owns the PortHandle
    lock_guard&lt;mutex&gt; guard{my_mutex}; // guard owns the lock
    // ...
    send(port, x);
    // ...
} // automatically unlocks my_mutex and deletes the pointer in x
</pre></div>
</div>
<p>Ora la pulizia di tutte le risorse è automatica, eseguita una sola volta su tutte le diramazioni che vadano o meno in errore. Come bonus, ora la funzione dichiara che assume la proprietà del puntatore.</p>
<p>Che cos’è <code class="docutils literal notranslate"><span class="pre">Port</span></code>? Un comodo involucro [wrapper] che incapsula la risorsa:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Port {
    PortHandle port;
public:
    Port(string_view destination) : port{open_port(destination)} { }
    ~Port() { close_port(port); }
    operator PortHandle() { return port; }

    // port handles can&#39;t usually be cloned, so disable copying and assignment if necessary
    Port(const Port&amp;) = delete;
    Port&amp; operator=(const Port&amp;) = delete;
};
</pre></div>
</div>
</section>
<section id="id804">
<h4>Nota<a class="headerlink" href="#id804" title="Link to this heading">¶</a></h4>
<p>Laddove una risorsa abbia «strani comportamenti» perché non è rappresentata come una classe con un distruttore, la si racchiude in una classe o si usa <a class="reference internal" href="#Re-finally"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">finally</span></code></span></a></p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Re-raii"><span class="xref myst">RAII</span></a></p>
</section>
</section>
<section id="r-2-in-interfaces-use-raw-pointers-to-denote-individual-objects-only">
<h3><a name="Rr-use-ptr"></a>R.2: Nelle interfacce, usare puntatori semplici [raw] per denotare (solo) i singoli oggetti<a class="headerlink" href="#r-2-in-interfaces-use-raw-pointers-to-denote-individual-objects-only" title="Link to this heading">¶</a></h3>
<section id="id805">
<h4>Motivo<a class="headerlink" href="#id805" title="Link to this heading">¶</a></h4>
<p>Gli array si rappresentano meglio con un tipo di contenitore (p.es., <code class="docutils literal notranslate"><span class="pre">vector</span></code> (proprietario)) o uno <code class="docutils literal notranslate"><span class="pre">span</span></code> (non-proprietario). Questi contenitori e viste contengono sufficienti informazioni per poter eseguire un controllo sul range.</p>
</section>
<section id="id806">
<h4>Esempio, cattivo<a class="headerlink" href="#id806" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int* p, int n)   // n is the number of elements in p[]
{
    // ...
    p[2] = 7;   // bad: subscript raw pointer
    // ...
}
</pre></div>
</div>
<p>Il compilatore non legge i commenti e senza leggere altro codice non si sa se <code class="docutils literal notranslate"><span class="pre">p</span></code> punta effettivamente a <code class="docutils literal notranslate"><span class="pre">n</span></code> elementi. Si usi invece <code class="docutils literal notranslate"><span class="pre">span</span></code>.</p>
</section>
<section id="id807">
<h4>Esempio<a class="headerlink" href="#id807" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void g(int* p, int fmt)   // print *p using format #fmt
{
    // ... uses *p and p[0] only ...
}
</pre></div>
</div>
</section>
<section id="id808">
<h4>Eccezione<a class="headerlink" href="#id808" title="Link to this heading">¶</a></h4>
<p>Le stringhe C-style vengono passate come singoli puntatori a sequenze di caratteri terminanti con zero. Si usi <code class="docutils literal notranslate"><span class="pre">zstring</span></code> invece di <code class="docutils literal notranslate"><span class="pre">char*</span></code> per indicare che ci si affida a questa convenzione.</p>
</section>
<section id="id809">
<h4>Nota<a class="headerlink" href="#id809" title="Link to this heading">¶</a></h4>
<p>Attualmente molte delle volte che si usa un puntatore ad un singolo elemento si potrebbe usare un riferimento. Tuttavia, dove <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> è un valore possibile, un riferimento potrebbe non essere un’alternativa ragionevole.</p>
</section>
<section id="id810">
<h4>Imposizione<a class="headerlink" href="#id810" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare l’aritmetica di un puntatore (compreso <code class="docutils literal notranslate"><span class="pre">++</span></code>) su un puntatore che non faccia parte di un contenitore, una vista o un iteratore. Questa regola genererebbe un numero enorme di falsi positivi se applicata a un codice più vecchio.</p></li>
<li><p>Segnalare i nomi di array passati come puntatori semplici</p></li>
</ul>
</section>
</section>
<section id="r-3-a-raw-pointer-a-t-is-non-owning">
<h3><a name="Rr-ptr"></a>R.3: Un puntatore semplice [raw] (un <code class="docutils literal notranslate"><span class="pre">T*</span></code>) non è proprietario<a class="headerlink" href="#r-3-a-raw-pointer-a-t-is-non-owning" title="Link to this heading">¶</a></h3>
<section id="id811">
<h4>Motivo<a class="headerlink" href="#id811" title="Link to this heading">¶</a></h4>
<p>Non c’è nulla (nello standard del C++ e nella maggior parte del codice) per dire il contrario e la maggior parte dei puntatori semplici non sono proprietari. Si vogliono identificare i puntatori proprietari in modo da gestire efficientemente il delete degli oggetti puntati dai puntatori proprietari.</p>
</section>
<section id="id812">
<h4>Esempio<a class="headerlink" href="#id812" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    int* p1 = new int{7};           // bad: raw owning pointer
    auto p2 = make_unique&lt;int&gt;(7);  // OK: the int is owned by a unique pointer
    // ...
}
</pre></div>
</div>
<p>Lo <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> protegge dai leak garantendo la cancellazione del suo oggetto (anche in presenza di eccezioni). Il <code class="docutils literal notranslate"><span class="pre">T*</span></code> non lo fa.</p>
</section>
<section id="id813">
<h4>Esempio<a class="headerlink" href="#id813" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
class X {
public:
    T* p;   // bad: it is unclear whether p is owning or not
    T* q;   // bad: it is unclear whether q is owning or not
    // ...
};
</pre></div>
</div>
<p>Si può risolvere il problema esplicitando il possesso:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
class X2 {
public:
    owner&lt;T*&gt; p;  // OK: p is owning
    T* q;         // OK: q is not owning
    // ...
};
</pre></div>
</div>
</section>
<section id="id814">
<h4>Eccezione<a class="headerlink" href="#id814" title="Link to this heading">¶</a></h4>
<p>Una delle maggiori tipologie di eccezione è il codice legacy, specialmente il codice che deve restare compilabile come C o interfacciarsi col C o il C++ C-style tramite le ABI. Il fatto che ci siano miliardi di righe di codice che violano questa regola contro il possesso dei <code class="docutils literal notranslate"><span class="pre">T*</span></code> non può essere ignorato. Ci piacerebbe vedere dei tool che trasformino i programmi con vecchio codice «legacy» di 20 anni fa in un chiaro codice moderno, incoraggiamo lo sviluppo, la distribuzione e l’uso di questi strumenti, speriamo che le linee-guida aiutino lo sviluppo di questi tool e che abbiano anche contribuito (e contribuiscano) alla ricerca e allo sviluppo in questo settore. Tuttavia, ci vorrà del tempo: il «codice legacy» viene generato più velocemente di quanto si possa rinnovare il vecchio codice, e così sarà per qualche anno.</p>
<p>Questo codice non può essere riscritto (anche assumendo un buon software di trasformazione del codice), comunque non presto. Questo problema non può essere risolto (su vasta scala) trasformando tutti i puntatori proprietari in <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> e <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>, in parte perché abbiamo bisogno di usare anche dei «puntatori raw» proprietari così come i semplici puntatori nell’implementazione degli handle delle risorse fondamentali. Per esempio, le comuni implementazioni di <code class="docutils literal notranslate"><span class="pre">vector</span></code> hanno un puntatore proprietario e due puntatori non-proprietari. Molte ABI (ed essenzialmente tutte le interfacce al codice C) usano i <code class="docutils literal notranslate"><span class="pre">T*</span></code>, alcuni di questi sono proprietari. Alcune interfacce non possono essere semplicemente annotate con <code class="docutils literal notranslate"><span class="pre">owner</span></code> perché devono restare compilabili come C (anche se questo sarebbe un raro buon uso per una macro, che si espanderebbe in <code class="docutils literal notranslate"><span class="pre">owner</span></code> solo in C++).</p>
</section>
<section id="id815">
<h4>Nota<a class="headerlink" href="#id815" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">owner&lt;T*&gt;</span></code> non ha una semantica di default oltre a <code class="docutils literal notranslate"><span class="pre">T*</span></code>. Esso può essere utilizzato senza modificare alcun codice utilizzandolo e senza influire sulle ABI. È semplicemente un indicatore per programmatori e strumenti di analisi. Per esempio, se un <code class="docutils literal notranslate"><span class="pre">owner&lt;T*&gt;</span></code> è un membro di una classe, è opportuno che quella classe abbia un distruttore che ne esegua un <code class="docutils literal notranslate"><span class="pre">delete</span></code>.</p>
</section>
<section id="id816">
<h4>Esempio, cattivo<a class="headerlink" href="#id816" title="Link to this heading">¶</a></h4>
<p>La restituzione di un puntatore (semplice [raw]), genera nel chiamante un’incertezza sulla gestione del suo ciclo di vita; ovvero, chi cancella l’oggetto a cui si punta?</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Gadget* make_gadget(int n)
{
    auto p = new Gadget{n};
    // ...
    return p;
}

void caller(int n)
{
    auto p = make_gadget(n);   // remember to delete p
    // ...
    delete p;
}
</pre></div>
</div>
<p>Oltre a soffrire del problema del <a class="reference internal" href="#Rp-leak"><span class="xref myst">leak</span></a>, questo aggiunge un’allocazione e una de-allocazione spurie, ed è inutilmente prolissa. Se Gadget è economico da spostare al di fuori di una funzione (ovvero, è piccolo o ha un’efficiente operazione di spostamento), basta restituirlo «per valore» (si veda <a class="reference internal" href="#Rf-out"><span class="xref myst">«out» dei valori di ritorno</span></a>):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Gadget make_gadget(int n)
{
    Gadget g{n};
    // ...
    return g;
}
</pre></div>
</div>
</section>
<section id="id817">
<h4>Nota<a class="headerlink" href="#id817" title="Link to this heading">¶</a></h4>
<p>Questa regola si applica alle funzioni factory.</p>
</section>
<section id="id818">
<h4>Nota<a class="headerlink" href="#id818" title="Link to this heading">¶</a></h4>
<p>Se è richiesta la semantica dei puntatori (p. es., perché il tipo restituito deve far riferimento ad una classe base della gerarchia (un’interfaccia)), restituire uno «smart pointer.»</p>
</section>
<section id="id819">
<h4>Imposizione<a class="headerlink" href="#id819" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>(Semplice) Un warning su un <code class="docutils literal notranslate"><span class="pre">delete</span></code> di un puntatore semplice che non sia un <code class="docutils literal notranslate"><span class="pre">owner&lt;T&gt;</span></code>.</p></li>
<li><p>(Moderato) Un warning sia sul fallimento di un <code class="docutils literal notranslate"><span class="pre">reset</span></code> che su un esplicito <code class="docutils literal notranslate"><span class="pre">delete</span></code> di un puntatore a <code class="docutils literal notranslate"><span class="pre">owner&lt;T&gt;</span></code> su ogni percorso del codice.</p></li>
<li><p>(Semplice) Avvisare se il valore di ritorno di <code class="docutils literal notranslate"><span class="pre">new</span></code> è assegnato ad un puntatore semplice.</p></li>
<li><p>(Semplice) Avvisare se una funzione restituisce un oggetto che sia stato allocato nella funzione ma che abbia un costruttore di spostamento. Suggerire, invece, di restituirlo per valore.</p></li>
</ul>
</section>
</section>
<section id="r-4-a-raw-reference-a-t-is-non-owning">
<h3><a name="Rr-ref"></a>R.4: Un riferimento [raw] (un <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>) non è proprietario<a class="headerlink" href="#r-4-a-raw-reference-a-t-is-non-owning" title="Link to this heading">¶</a></h3>
<section id="id820">
<h4>Motivo<a class="headerlink" href="#id820" title="Link to this heading">¶</a></h4>
<p>Non c’è nulla (nello standard del C++ e nella maggior parte del codice) che dica diversamente e la maggior parte dei riferimenti sono non-proprietari. Si vuole che i proprietari siano identificati in modo da poter affidabilmente ed efficientemente eseguire il delete degli oggetti puntati dai puntatori proprietari.</p>
</section>
<section id="id821">
<h4>Esempio<a class="headerlink" href="#id821" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    int&amp; r = *new int{7};  // bad: raw owning reference
    // ...
    delete &amp;r;             // bad: violated the rule against deleting raw pointers
}
</pre></div>
</div>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Rr-ptr"><span class="xref myst">La regola del puntatore semplice</span></a></p>
</section>
<section id="id822">
<h4>Imposizione<a class="headerlink" href="#id822" title="Link to this heading">¶</a></h4>
<p>Si veda <a class="reference internal" href="#Rr-ptr"><span class="xref myst">La regola del puntatore semplice</span></a></p>
</section>
</section>
<section id="r-5-prefer-scoped-objects-don-t-heap-allocate-unnecessarily">
<h3><a name="Rr-scoped"></a>R.5: Preferire oggetti con scope, non allocare sull’heap se non necessario<a class="headerlink" href="#r-5-prefer-scoped-objects-don-t-heap-allocate-unnecessarily" title="Link to this heading">¶</a></h3>
<section id="id823">
<h4>Motivo<a class="headerlink" href="#id823" title="Link to this heading">¶</a></h4>
<p>Un oggetto con scope è un oggetto locale, un oggetto globale o un membro. Ciò implica che non vi sono costi aggiuntivi diversi per l’allocazione e la de-allocazione oltre a quello già usato per lo scope contenitore o l’oggetto. I membri di un oggetto con scope sono essi stessi con scope e il costruttore e il distruttore dell’oggetto gestiscono il ciclo di vita dei membri.</p>
</section>
<section id="id824">
<h4>Esempio<a class="headerlink" href="#id824" title="Link to this heading">¶</a></h4>
<p>L’esempio seguente è inefficiente (perché presenta un’allocazione e una de-allocazione non necessarie), vulnerabile al ritorno da eccezioni generate nella parte <code class="docutils literal notranslate"><span class="pre">...</span></code> (che porta a leak), ed è prolisso:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int n)
{
    auto p = new Gadget{n};
    // ...
    delete p;
}
</pre></div>
</div>
<p>Utilizzare invece una variabile locale:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int n)
{
    Gadget g{n};
    // ...
}
</pre></div>
</div>
</section>
<section id="id825">
<h4>Imposizione<a class="headerlink" href="#id825" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>(Moderato) Avvisare se un oggetto è allocato e poi de-allocato su tutte le diramazioni all’interno di una funzione. Suggerire invece che dovrebbe essere un oggetto stack locale.</p></li>
<li><p>(Semplice) Avverte se un <code class="docutils literal notranslate"><span class="pre">Unique_pointer</span></code> o <code class="docutils literal notranslate"><span class="pre">Shared_pointer</span></code> locale, che non viene spostato, copiato, riassegnato o <code class="docutils literal notranslate"><span class="pre">reset</span></code> prima della fine del suo ciclo di vita, non viene dichiarato <code class="docutils literal notranslate"><span class="pre">const</span></code>. Eccezione: non produrre tale avviso su un <code class="docutils literal notranslate"><span class="pre">Unique_pointer</span></code> locale a un array «unbounded». (Vedere di seguito.)</p></li>
</ul>
</section>
<section id="id826">
<h4>Eccezione<a class="headerlink" href="#id826" title="Link to this heading">¶</a></h4>
<p>È corretto creare un <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unique_ptr&lt;T[]&gt;</span></code> locale in un buffer allocato nell’heap, poiché questo è un modo valido per rappresentare un array dinamico con uno scope.</p>
</section>
<section id="id827">
<h4>Esempio<a class="headerlink" href="#id827" title="Link to this heading">¶</a></h4>
<p>Un caso d’uso valido per una variabile <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unique_ptr&lt;T[]&gt;</span></code> locale:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int get_median_value(const std::list&lt;int&gt;&amp; integers)
{
  const auto size = integers.size();

  // OK: declaring a local unique_ptr&lt;T[]&gt;.
  const auto local_buffer = std::make_unique_for_overwrite&lt;int[]&gt;(size);

  std::copy_n(begin(integers), size, local_buffer.get());
  std::nth_element(local_buffer.get(), local_buffer.get() + size/2, local_buffer.get() + size);

  return local_buffer[size/2];
}
</pre></div>
</div>
</section>
</section>
<section id="r-6-avoid-non-const-global-variables">
<h3><a name="Rr-global"></a>R.6: Evitare le variabili globali non-<code class="docutils literal notranslate"><span class="pre">const</span></code><a class="headerlink" href="#r-6-avoid-non-const-global-variables" title="Link to this heading">¶</a></h3>
<p>Cfr.  <a class="reference internal" href="#Ri-global"><span class="xref myst">I.2</span></a></p>
</section>
<section id="r-alloc-allocation-and-deallocation">
<h3><a name="SS-alloc"></a>R.alloc: Allocazione e de-allocazione<a class="headerlink" href="#r-alloc-allocation-and-deallocation" title="Link to this heading">¶</a></h3>
<section id="r-10-avoid-malloc-and-free">
<h4><a name="Rr-mallocfree"></a>R.10: Evitare <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> e <code class="docutils literal notranslate"><span class="pre">free()</span></code><a class="headerlink" href="#r-10-avoid-malloc-and-free" title="Link to this heading">¶</a></h4>
<section id="id828">
<h5>Motivo<a class="headerlink" href="#id828" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">malloc()</span></code> e <code class="docutils literal notranslate"><span class="pre">free()</span></code> non supportano la costruzione e la distruzione e non si collegano bene con <code class="docutils literal notranslate"><span class="pre">new</span></code> e <code class="docutils literal notranslate"><span class="pre">delete</span></code>.</p>
</section>
<section id="id829">
<h5>Esempio<a class="headerlink" href="#id829" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Record {
    int id;
    string name;
    // ...
};

void use()
{
    // p1 might be nullptr
    // *p1 is not initialized; in particular,
    // that string isn&#39;t a string, but a string-sized bag of bits
    Record* p1 = static_cast&lt;Record*&gt;(malloc(sizeof(Record)));

    auto p2 = new Record;

    // unless an exception is thrown, *p2 is default initialized
    auto p3 = new(nothrow) Record;
    // p3 might be nullptr; if not, *p3 is default initialized

    // ...

    delete p1;    // error: cannot delete object allocated by malloc()
    free(p2);    // error: cannot free() object allocated by new
}
</pre></div>
</div>
<p>In alcune implementazioni quel <code class="docutils literal notranslate"><span class="pre">delete</span></code> e quel <code class="docutils literal notranslate"><span class="pre">free()</span></code> potrebbero funzionare, o potrebbero causare errori a run-time.</p>
</section>
<section id="id830">
<h5>Eccezione<a class="headerlink" href="#id830" title="Link to this heading">¶</a></h5>
<p>Esistono applicazioni e sezioni di codice in cui le eccezioni non sono accettabili. Alcuni dei migliori esempi di questo tipo sono nel codice “life-critical” e hard-real-time. Attenzione che molti divieti sull’uso delle eccezioni si basano sulla superstizione (che è un male) o hanno a che fare con codice più vecchio con una gestione delle risorse non sistematica (sfortunatamente, ma a volte necessaria). In questi casi si considerino le versioni <code class="docutils literal notranslate"><span class="pre">nothrow</span></code> di <code class="docutils literal notranslate"><span class="pre">new</span></code>.</p>
</section>
<section id="id831">
<h5>Imposizione<a class="headerlink" href="#id831" title="Link to this heading">¶</a></h5>
<p>Segnalare l’uso esplicito di <code class="docutils literal notranslate"><span class="pre">malloc</span></code> o <code class="docutils literal notranslate"><span class="pre">free</span></code>.</p>
</section>
</section>
<section id="r-11-avoid-calling-new-and-delete-explicitly">
<h4><a name="Rr-newdelete"></a>R.11: Evitare di chiamare esplicitamente <code class="docutils literal notranslate"><span class="pre">new</span></code> e <code class="docutils literal notranslate"><span class="pre">delete</span></code><a class="headerlink" href="#r-11-avoid-calling-new-and-delete-explicitly" title="Link to this heading">¶</a></h4>
<section id="id832">
<h5>Motivo<a class="headerlink" href="#id832" title="Link to this heading">¶</a></h5>
<p>Il puntatore restituito da <code class="docutils literal notranslate"><span class="pre">new</span></code> dovrebbe appartenere ad un gestore di risorse (che potrebbe chiamare <code class="docutils literal notranslate"><span class="pre">delete</span></code>). Se il puntatore restituito da <code class="docutils literal notranslate"><span class="pre">new</span></code> viene assegnato ad un semplice puntatore, l’oggetto può generare un leak.</p>
</section>
<section id="id833">
<h5>Nota<a class="headerlink" href="#id833" title="Link to this heading">¶</a></h5>
<p>In un programma di grandi dimensioni, un semplice <code class="docutils literal notranslate"><span class="pre">delete</span></code> (ovvero un <code class="docutils literal notranslate"><span class="pre">delete</span></code> nel codice dell’applicazione, anziché nella parte di codice dedicata alla gestione delle risorse) è un probabile bug: se si hanno N <code class="docutils literal notranslate"><span class="pre">delete</span></code>, come si può essere sicuri che non ne servano N+1 o N-1? Il bug potrebbe essere latente: potrebbe emergere solo durante la manutenzione. Se si ha un semplice <code class="docutils literal notranslate"><span class="pre">new</span></code>, probabilmente ci vorrà un semplice <code class="docutils literal notranslate"><span class="pre">delete</span></code> da qualche parte, quindi probabilmente si avrà un bug.</p>
</section>
<section id="id834">
<h5>Imposizione<a class="headerlink" href="#id834" title="Link to this heading">¶</a></h5>
<p>(Semplice) Avvisare di qualsiasi uso esplicito di <code class="docutils literal notranslate"><span class="pre">new</span></code> e <code class="docutils literal notranslate"><span class="pre">delete</span></code>. Suggerire, invece, l’uso di <code class="docutils literal notranslate"><span class="pre">make_unique</span></code>.</p>
</section>
</section>
<section id="r-12-immediately-give-the-result-of-an-explicit-resource-allocation-to-a-manager-object">
<h4><a name="Rr-immediate-alloc"></a>R.12: Fornire immediatamente il risultato dell’allocazione di una risorsa ad un oggetto gestore<a class="headerlink" href="#r-12-immediately-give-the-result-of-an-explicit-resource-allocation-to-a-manager-object" title="Link to this heading">¶</a></h4>
<section id="id835">
<h5>Motivo<a class="headerlink" href="#id835" title="Link to this heading">¶</a></h5>
<p>In caso contrario, un’eccezione o un return potrebbero causare un leak.</p>
</section>
<section id="id836">
<h5>Esempio, cattivo<a class="headerlink" href="#id836" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void func(const string&amp; name)
{
    FILE* f = fopen(name, &quot;r&quot;);            // open the file
    vector&lt;char&gt; buf(1024);
    auto _ = finally([f] { fclose(f); });  // remember to close the file
    // ...
}
</pre></div>
</div>
<p>L’allocazione di <code class="docutils literal notranslate"><span class="pre">buf</span></code> potrebbe fallire e produrre un leak dell’handle del file.</p>
</section>
<section id="id837">
<h5>Esempio<a class="headerlink" href="#id837" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void func(const string&amp; name)
{
    ifstream f{name};   // open the file
    vector&lt;char&gt; buf(1024);
    // ...
}
</pre></div>
</div>
<p>L’utilizzo dell’handle del file (in <code class="docutils literal notranslate"><span class="pre">ifstream</span></code>) è semplice, efficiente e sicuro.</p>
</section>
<section id="id838">
<h5>Imposizione<a class="headerlink" href="#id838" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare le allocazioni esplicite usate per inizializzare i puntatori (problema: quante allocazioni di risorse dirette si possono riconoscere?)</p></li>
</ul>
</section>
</section>
<section id="r-13-perform-at-most-one-explicit-resource-allocation-in-a-single-expression-statement">
<h4><a name="Rr-single-alloc"></a>R.13: Eseguire al massimo una allocazione di risorsa esplicita in una singola istruzione<a class="headerlink" href="#r-13-perform-at-most-one-explicit-resource-allocation-in-a-single-expression-statement" title="Link to this heading">¶</a></h4>
<section id="id839">
<h5>Motivo<a class="headerlink" href="#id839" title="Link to this heading">¶</a></h5>
<p>Se si eseguono due allocazioni di risorse esplicite in un’unica istruzione, si può avere un leak delle risorse perché l’ordine di valutazione di molte sotto-espressioni, compresi gli argomenti delle funzioni, non è specificato.</p>
</section>
<section id="id840">
<h5>Esempio<a class="headerlink" href="#id840" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fun(shared_ptr&lt;Widget&gt; sp1, shared_ptr&lt;Widget&gt; sp2);
</pre></div>
</div>
<p>Questa <code class="docutils literal notranslate"><span class="pre">fun</span></code> si può chiamare così:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// BAD: potential leak
fun(shared_ptr&lt;Widget&gt;(new Widget(a, b)), shared_ptr&lt;Widget&gt;(new Widget(c, d)));
</pre></div>
</div>
<p>Questo non è exception-safe perché il compilatore potrebbe riordinare le due espressioni nel costruire i due argomenti della funzione. In particolare, il compilatore può intercalare l’esecuzione delle due espressioni: L’allocazione della memoria (chiamando <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new</span></code>) può essere fatta, per entrambi gli oggetti, prima, seguita poi dai tentativi di richiamare i due costruttori <code class="docutils literal notranslate"><span class="pre">Widget</span></code>. Se uno dei costruttori genera un’eccezione, allora la memoria dell’altro oggetto non verrà mai rilasciata!</p>
<p>Questo subdolo problema ha una semplice soluzione: Mai eseguire più di una allocazione esplicita di una risorsa in una sola istruzione. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>shared_ptr&lt;Widget&gt; sp1(new Widget(a, b)); // Better, but messy
fun(sp1, new Widget(c, d));
</pre></div>
</div>
<p>La soluzione migliore consiste nell’evitare totalmente l’allocazione esplicita utilizzando le funzioni factory che restituiscono gli oggetti posseduti:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>fun(make_shared&lt;Widget&gt;(a, b), make_shared&lt;Widget&gt;(c, d)); // Best
</pre></div>
</div>
<p>Se non ce n’è uno scriversi il proprio factory wrapper.</p>
</section>
<section id="id841">
<h5>Imposizione<a class="headerlink" href="#id841" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare le espressioni con più allocazioni esplicite di risorse (problema: quante allocazioni di risorse dirette si possono riconoscere?)</p></li>
</ul>
</section>
</section>
<section id="r-14-avoid-parameters-prefer-span">
<h4><a name="Rr-ap"></a>R.14: Evitare parametri <code class="docutils literal notranslate"><span class="pre">[]</span></code>, preferire <code class="docutils literal notranslate"><span class="pre">span</span></code><a class="headerlink" href="#r-14-avoid-parameters-prefer-span" title="Link to this heading">¶</a></h4>
<section id="id842">
<h5>Motivo<a class="headerlink" href="#id842" title="Link to this heading">¶</a></h5>
<p>Un array si riduce ad un puntatore, perdendo così la propria dimensione, aprendo la possibilità di errori sul range. Usare <code class="docutils literal notranslate"><span class="pre">span</span></code> per preservare l’informazione sulla dimensione.</p>
</section>
<section id="id843">
<h5>Esempio<a class="headerlink" href="#id843" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int[]);          // not recommended

void f(int*);           // not recommended for multiple objects
                        // (a pointer should point to a single object, do not subscript)

void f(gsl::span&lt;int&gt;); // good, recommended
</pre></div>
</div>
</section>
<section id="id844">
<h5>Imposizione<a class="headerlink" href="#id844" title="Link to this heading">¶</a></h5>
<p>Segnalare i parametri <code class="docutils literal notranslate"><span class="pre">[]</span></code>. Usare, invece, <code class="docutils literal notranslate"><span class="pre">span</span></code>.</p>
</section>
</section>
<section id="r-15-always-overload-matched-allocation-deallocation-pairs">
<h4><a name="Rr-pair"></a>R.15: Eseguire sempre l’overload dell’accoppiata allocazione/de-allocazione<a class="headerlink" href="#r-15-always-overload-matched-allocation-deallocation-pairs" title="Link to this heading">¶</a></h4>
<section id="id845">
<h5>Motivo<a class="headerlink" href="#id845" title="Link to this heading">¶</a></h5>
<p>Altrimenti si ottengono operazioni disaccoppiate e caos.</p>
</section>
<section id="id846">
<h5>Esempio<a class="headerlink" href="#id846" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {
    // ...
    void* operator new(size_t s);
    void operator delete(void*);
    // ...
};
</pre></div>
</div>
</section>
<section id="id847">
<h5>Nota<a class="headerlink" href="#id847" title="Link to this heading">¶</a></h5>
<p>Se si vuole che non venga de-allocata la memoria, si aggiunge <code class="docutils literal notranslate"><span class="pre">=delete</span></code> all’operazione di de-allocazione. Non lasciarla senza dichiarazione.</p>
</section>
<section id="id848">
<h5>Imposizione<a class="headerlink" href="#id848" title="Link to this heading">¶</a></h5>
<p>Segnalare le accoppiate incomplete.</p>
</section>
</section>
</section>
<section id="r-smart-smart-pointers">
<h3><a name="SS-smart"></a>R.smart: I puntatori smart<a class="headerlink" href="#r-smart-smart-pointers" title="Link to this heading">¶</a></h3>
<section id="r-20-use-unique-ptr-or-shared-ptr-to-represent-ownership">
<h4><a name="Rr-owner"></a>R.20: Utilizzare <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> e <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> per rappresentare il possesso<a class="headerlink" href="#r-20-use-unique-ptr-or-shared-ptr-to-represent-ownership" title="Link to this heading">¶</a></h4>
<section id="id849">
<h5>Motivo<a class="headerlink" href="#id849" title="Link to this heading">¶</a></h5>
<p>Si possono prevenire i leak delle risorse.</p>
</section>
<section id="id850">
<h5>Esempio<a class="headerlink" href="#id850" title="Link to this heading">¶</a></h5>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    X* p1 { new X };              // bad, p1 will leak
    auto p2 = make_unique&lt;X&gt;();   // good, unique ownership
    auto p3 = make_shared&lt;X&gt;();   // good, shared ownership
}
</pre></div>
</div>
<p>Con ciò si avrà un leak dell’oggetto usato per inizializzare <code class="docutils literal notranslate"><span class="pre">p1</span></code> (solamente).</p>
</section>
<section id="id851">
<h5>Imposizione<a class="headerlink" href="#id851" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Semplice) Avvisare se il valore di ritorno di <code class="docutils literal notranslate"><span class="pre">new</span></code> è assegnato ad un puntatore semplice.</p></li>
<li><p>(Semplice) Avvisare se il risultato di una funzione che restituisce un puntatore proprietario «raw» viene assegnato a un puntatore «raw».</p></li>
</ul>
</section>
</section>
<section id="r-21-prefer-unique-ptr-over-shared-ptr-unless-you-need-to-share-ownership">
<h4><a name="Rr-unique"></a>R.21: Preferire <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> a <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> a meno che non sia necessario condividere il possesso<a class="headerlink" href="#r-21-prefer-unique-ptr-over-shared-ptr-unless-you-need-to-share-ownership" title="Link to this heading">¶</a></h4>
<section id="id852">
<h5>Motivo<a class="headerlink" href="#id852" title="Link to this heading">¶</a></h5>
<p>Un <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> è concettualmente più semplice e prevedibile (si sa quando viene distrutto) e più veloce (non mantiene implicitamente un conteggio sull’utilizzo).</p>
</section>
<section id="id853">
<h5>Esempio, cattivo<a class="headerlink" href="#id853" title="Link to this heading">¶</a></h5>
<p>Questo aggiunge e mantiene inutilmente un conteggio dei riferimenti.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    shared_ptr&lt;Base&gt; base = make_shared&lt;Derived&gt;();
    // use base locally, without copying it -- refcount never exceeds 1
} // destroy base
</pre></div>
</div>
</section>
<section id="id854">
<h5>Esempio<a class="headerlink" href="#id854" title="Link to this heading">¶</a></h5>
<p>Questo è più efficiente:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    unique_ptr&lt;Base&gt; base = make_unique&lt;Derived&gt;();
    // use base locally
} // destroy base
</pre></div>
</div>
</section>
<section id="id855">
<h5>Imposizione<a class="headerlink" href="#id855" title="Link to this heading">¶</a></h5>
<p>(Semplice) Avvisare se una funzione usa uno <code class="docutils literal notranslate"><span class="pre">Shared_pointer</span></code> con un oggetto allocato nella funzione, ma non restituisce mai lo <code class="docutils literal notranslate"><span class="pre">Shared_pointer</span></code> né lo passa ad una funzione che richiede uno <code class="docutils literal notranslate"><span class="pre">Shared_pointer&amp;</span></code>. Suggerire, invece, l’uso di <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code>.</p>
</section>
</section>
<section id="r-22-use-make-shared-to-make-shared-ptrs">
<h4><a name="Rr-make_shared"></a>R.22: Usare <code class="docutils literal notranslate"><span class="pre">make_shared()</span></code> per creare gli <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>s<a class="headerlink" href="#r-22-use-make-shared-to-make-shared-ptrs" title="Link to this heading">¶</a></h4>
<section id="id856">
<h5>Motivo<a class="headerlink" href="#id856" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">make_shared</span></code> fornisce un’istruzione più concisa della costruzione. Offre inoltre l’opportunità di eliminare un’allocazione separata per i conteggi dei riferimento, posizionando il conteggio di <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> vicino al proprio oggetto. Garantisce inoltre la sicurezza delle eccezioni in espressioni complesse (nel codice precedente a C++17).</p>
</section>
<section id="id857">
<h5>Esempio<a class="headerlink" href="#id857" title="Link to this heading">¶</a></h5>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>shared_ptr&lt;X&gt; p1 { new X{2} }; // bad
auto p = make_shared&lt;X&gt;(2);    // good
</pre></div>
</div>
<p>La versione <code class="docutils literal notranslate"><span class="pre">make_shared()</span></code> indica <code class="docutils literal notranslate"><span class="pre">X</span></code> una sola volta, quindi è solitamente più breve (oltre che più veloce) della versione col <code class="docutils literal notranslate"><span class="pre">new</span></code> esplicito.</p>
</section>
<section id="id858">
<h5>Imposizione<a class="headerlink" href="#id858" title="Link to this heading">¶</a></h5>
<p>(Semplice) Avvisare se uno <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> è costruito partendo dal risultato di un <code class="docutils literal notranslate"><span class="pre">new</span></code> anziché da <code class="docutils literal notranslate"><span class="pre">make_shared</span></code>.</p>
</section>
</section>
<section id="r-23-use-make-unique-to-make-unique-ptrs">
<h4><a name="Rr-make_unique"></a>R.23: Usare <code class="docutils literal notranslate"><span class="pre">make_unique()</span></code> per creare gli <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code><a class="headerlink" href="#r-23-use-make-unique-to-make-unique-ptrs" title="Link to this heading">¶</a></h4>
<section id="id859">
<h5>Motivo<a class="headerlink" href="#id859" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">make_unique</span></code> fornisce una dichiarazione più concisa della costruzione. Garantisce inoltre la sicurezza delle eccezioni in espressioni complesse (nel codice precedente a C++17).</p>
</section>
<section id="id860">
<h5>Esempio<a class="headerlink" href="#id860" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unique_ptr&lt;Foo&gt; p {new Foo{7}};    // OK: but repetitive

auto q = make_unique&lt;Foo&gt;(7);      // Better: no repetition of Foo
</pre></div>
</div>
</section>
<section id="id861">
<h5>Imposizione<a class="headerlink" href="#id861" title="Link to this heading">¶</a></h5>
<p>(Semplice) Avvisare se uno <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> è costruito partendo dal risultato di un <code class="docutils literal notranslate"><span class="pre">new</span></code> anziché da <code class="docutils literal notranslate"><span class="pre">make_unique</span></code>.</p>
</section>
</section>
<section id="r-24-use-std-weak-ptr-to-break-cycles-of-shared-ptrs">
<h4><a name="Rr-weak_ptr"></a>R.24: Usare <code class="docutils literal notranslate"><span class="pre">std::weak_ptr</span></code> per interrompere i cicli degli <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>s<a class="headerlink" href="#r-24-use-std-weak-ptr-to-break-cycles-of-shared-ptrs" title="Link to this heading">¶</a></h4>
<section id="id862">
<h5>Motivo<a class="headerlink" href="#id862" title="Link to this heading">¶</a></h5>
<p>Gli <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> si basano sul conteggio degli utilizzi e sull’uso dei conteggi per una struttura ciclica che non va mai a zero, c’è quindi bisogno di un meccanismo per sapere quando distruggere una struttura ciclica.</p>
</section>
<section id="id863">
<h5>Esempio<a class="headerlink" href="#id863" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;memory&gt;

class bar;

class foo {
public:
  explicit foo(const std::shared_ptr&lt;bar&gt;&amp; forward_reference)
    : forward_reference_(forward_reference)
  { }
private:
  std::shared_ptr&lt;bar&gt; forward_reference_;
};

class bar {
public:
  explicit bar(const std::weak_ptr&lt;foo&gt;&amp; back_reference)
    : back_reference_(back_reference)
  { }
  void do_something()
  {
    if (auto shared_back_reference = back_reference_.lock()) {
      // Use *shared_back_reference
    }
  }
private:
  std::weak_ptr&lt;foo&gt; back_reference_;
};
</pre></div>
</div>
</section>
<section id="id864">
<h5>Nota<a class="headerlink" href="#id864" title="Link to this heading">¶</a></h5>
<p>??? (HS [Herb Sutter]: Molte persone dicono «interrompere cicli», mentre io penso che «proprietà condivisa [shared ownership] temporanea» sia più pertinente). ???(BS [Bjarne Stroustrup]: Interrompere cicli è quello che si deve fare; condividere temporaneamente la proprietà è come farlo. Si può «temporaneamente condividere la proprietà» semplicemente usando un altro <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>).</p>
</section>
<section id="id865">
<h5>Imposizione<a class="headerlink" href="#id865" title="Link to this heading">¶</a></h5>
<p>??? probabilmente impossibile. Se potessimo rilevare staticamente i cicli, non avremmo bisogno di <code class="docutils literal notranslate"><span class="pre">weak_ptr</span></code></p>
</section>
</section>
<section id="r-30-take-smart-pointers-as-parameters-only-to-explicitly-express-lifetime-semantics">
<h4><a name="Rr-smartptrparam"></a>R.30: Prendere gli smart pointer come parametri solo per esprimere esplicitamente la semantica della durata [lifetime]<a class="headerlink" href="#r-30-take-smart-pointers-as-parameters-only-to-explicitly-express-lifetime-semantics" title="Link to this heading">¶</a></h4>
<p>Cfr. <a class="reference internal" href="#Rf-smart"><span class="xref myst">F.7</span></a>.</p>
</section>
<section id="r-31-if-you-have-non-std-smart-pointers-follow-the-basic-pattern-from-std">
<h4><a name="Rr-smart"></a>R.31: Se si hanno smart pointer non-<code class="docutils literal notranslate"><span class="pre">std</span></code>, seguire il pattern base di <code class="docutils literal notranslate"><span class="pre">std</span></code><a class="headerlink" href="#r-31-if-you-have-non-std-smart-pointers-follow-the-basic-pattern-from-std" title="Link to this heading">¶</a></h4>
<section id="id866">
<h5>Motivo<a class="headerlink" href="#id866" title="Link to this heading">¶</a></h5>
<p>Le regole nella sezione seguente funzionano anche per altri tipi di puntatori intelligenti personalizzati e di terze parti e sono molto utili per diagnosticare errori comuni dei puntatori intelligenti che causano problemi di prestazioni e correttezza. Si vuole che le regole funzionino per tutti gli smart pointer utilizzati.</p>
<p>Qualsiasi tipo (compreso il template primario e la specializzazione) che sovraccarica [overload] il <code class="docutils literal notranslate"><span class="pre">*</span></code> unario e il <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> è considerato uno smart pointer:</p>
<ul class="simple">
<li><p>Se è copiabile, è riconosciuto come uno <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> reference-counted [a conteggio dei riferimenti].</p></li>
<li><p>Se non è copiabile, lo si riconosce come un <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> unico.</p></li>
</ul>
</section>
<section id="id867">
<h5>Esempio, cattivo<a class="headerlink" href="#id867" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// use Boost&#39;s intrusive_ptr
#include &lt;boost/intrusive_ptr.hpp&gt;
void f(boost::intrusive_ptr&lt;widget&gt; p)  // error under rule &#39;sharedptrparam&#39;
{
    p-&gt;foo();
}

// use Microsoft&#39;s CComPtr
#include &lt;atlbase.h&gt;
void f(CComPtr&lt;widget&gt; p)               // error under rule &#39;sharedptrparam&#39;
{
    p-&gt;foo();
}
</pre></div>
</div>
<p>Entrambi i casi sono errori secondo la <a class="reference internal" href="#Rr-smartptrparam"><span class="xref myst">linea-guida <code class="docutils literal notranslate"><span class="pre">sharedptrparam</span></code></span></a>: <code class="docutils literal notranslate"><span class="pre">p</span></code> è uno <code class="docutils literal notranslate"><span class="pre">Shared_pointer</span></code>, ma qui non viene usato niente della sua condivisibilità e il passarlo per valore è un tacito peggioramento; queste funzioni dovrebbero accettare uno smart pointer solo se devono partecipare alla gestione del ciclo di vita del widget. Altrimenti dovrebbero accettare un <code class="docutils literal notranslate"><span class="pre">widget*</span></code>, se può essere <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>. Altrimenti, ed idealmente, la funzione dovrebbe accettare un <code class="docutils literal notranslate"><span class="pre">widget&amp;</span></code>. Questi puntatori intelligenti corrispondono al concetto dello <code class="docutils literal notranslate"><span class="pre">Shared_pointer</span></code>, quindi queste regole per applicare le linee-guida funzionano su di essi in ogni caso e li espongono ad un comune peggioramento.</p>
</section>
</section>
<section id="r-32-take-a-unique-ptr-widget-parameter-to-express-that-a-function-assumes-ownership-of-a-widget">
<h4><a name="Rr-uniqueptrparam"></a>R.32: Prendere un parametro <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;widget&gt;</span></code> per esprimere che una funzione assume la proprietà di un <code class="docutils literal notranslate"><span class="pre">widget</span></code><a class="headerlink" href="#r-32-take-a-unique-ptr-widget-parameter-to-express-that-a-function-assumes-ownership-of-a-widget" title="Link to this heading">¶</a></h4>
<section id="id868">
<h5>Motivo<a class="headerlink" href="#id868" title="Link to this heading">¶</a></h5>
<p>Usando <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> in questo modo si documenta e si rafforza il trasferimento della proprietà della chiamata di funzione.</p>
</section>
<section id="id869">
<h5>Esempio<a class="headerlink" href="#id869" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void sink(unique_ptr&lt;widget&gt;); // takes ownership of the widget

void uses(widget*);            // just uses the widget
</pre></div>
</div>
</section>
<section id="id870">
<h5>Esempio, cattivo<a class="headerlink" href="#id870" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void thinko(const unique_ptr&lt;widget&gt;&amp;); // usually not what you want
</pre></div>
</div>
</section>
<section id="id871">
<h5>Imposizione<a class="headerlink" href="#id871" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Semplice) Avvisare se una funzione prende un parametro <code class="docutils literal notranslate"><span class="pre">Unique_pointer&lt;T&gt;</span></code> per riferimento lvalue e non assegna ad esso né ci chiama <code class="docutils literal notranslate"><span class="pre">reset()</span></code> in almeno un ramo del codice. Suggerire, invece, di prendere un <code class="docutils literal notranslate"><span class="pre">T*</span></code> o un <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>.</p></li>
<li><p>(Sempice) ((Foundation)) Avvisare se una funzione accetta un parametro <code class="docutils literal notranslate"><span class="pre">Unique_pointer&lt;T&gt;</span></code> per riferimento a <code class="docutils literal notranslate"><span class="pre">const</span></code>. Suggerire, invece, di prendere un <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T*</span></code> o un <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T&amp;</span></code> instead.</p></li>
</ul>
</section>
</section>
<section id="r-33-take-a-unique-ptr-widget-parameter-to-express-that-a-function-reseats-the-widget">
<h4><a name="Rr-reseat"></a>R.33: Prendere un parametro <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;widget&gt;&amp;</span></code> per esprimere che una funzione riposiziona [reseats] il <code class="docutils literal notranslate"><span class="pre">widget</span></code><a class="headerlink" href="#r-33-take-a-unique-ptr-widget-parameter-to-express-that-a-function-reseats-the-widget" title="Link to this heading">¶</a></h4>
<section id="id872">
<h5>Motivo<a class="headerlink" href="#id872" title="Link to this heading">¶</a></h5>
<p>Usando <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> in questo modo si documenta e si rafforza la semantica del ricollocamento [reseating] della chiamata.</p>
</section>
<section id="id873">
<h5>Nota<a class="headerlink" href="#id873" title="Link to this heading">¶</a></h5>
<p>«reseat» (ricollocare) significa «fare in modo che un puntatore o un puntatore intelligente si riferiscano a un oggetto diverso».</p>
</section>
<section id="id874">
<h5>Esempio<a class="headerlink" href="#id874" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void reseat(unique_ptr&lt;widget&gt;&amp;); // &quot;will&quot; or &quot;might&quot; reseat pointer
</pre></div>
</div>
</section>
<section id="id875">
<h5>Esempio, cattivo<a class="headerlink" href="#id875" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void thinko(const unique_ptr&lt;widget&gt;&amp;); // usually not what you want
</pre></div>
</div>
</section>
<section id="id876">
<h5>Imposizione<a class="headerlink" href="#id876" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Semplice) Avvisare se una funzione prende un parametro <code class="docutils literal notranslate"><span class="pre">Unique_pointer&lt;T&gt;</span></code> per riferimento lvalue e non assegna ad esso né ci chiama <code class="docutils literal notranslate"><span class="pre">reset()</span></code> in almeno un ramo del codice. Suggerire, invece, di prendere un <code class="docutils literal notranslate"><span class="pre">T*</span></code> o un <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>.</p></li>
<li><p>(Sempice) ((Foundation)) Avvisare se una funzione accetta un parametro <code class="docutils literal notranslate"><span class="pre">Unique_pointer&lt;T&gt;</span></code> per riferimento a <code class="docutils literal notranslate"><span class="pre">const</span></code>. Suggerire, invece, di prendere un <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T*</span></code> o un <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T&amp;</span></code> instead.</p></li>
</ul>
</section>
</section>
<section id="r-34-take-a-shared-ptr-widget-parameter-to-express-shared-ownership">
<h4><a name="Rr-sharedptrparam-owner"></a>R.34: Prendere un parametro <code class="docutils literal notranslate"><span class="pre">shared_ptr&lt;widget&gt;</span></code> per esprimere la proprietà condivisa<a class="headerlink" href="#r-34-take-a-shared-ptr-widget-parameter-to-express-shared-ownership" title="Link to this heading">¶</a></h4>
<section id="id877">
<h5>Motivo<a class="headerlink" href="#id877" title="Link to this heading">¶</a></h5>
<p>Ciò rende esplicita la condivisione della proprietà della funzione.</p>
</section>
<section id="id878">
<h5>Esempio, buono<a class="headerlink" href="#id878" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class WidgetUser
{
public:
    // WidgetUser will share ownership of the widget
    explicit WidgetUser(std::shared_ptr&lt;widget&gt; w) noexcept:
        m_widget{std::move(w)} {}
    // ...
private:
    std::shared_ptr&lt;widget&gt; m_widget;
};
</pre></div>
</div>
</section>
<section id="id879">
<h5>Imposizione<a class="headerlink" href="#id879" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Semplice) Avvisare se una funzione prende un parametro <code class="docutils literal notranslate"><span class="pre">Shared_pointer&lt;T&gt;</span></code> per riferimento lvalue e non lo assegna né ci chiama il <code class="docutils literal notranslate"><span class="pre">reset()</span></code> in almeno un ramo del codice. Suggerire, invece, di prendere un <code class="docutils literal notranslate"><span class="pre">T*</span></code> o un <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>.</p></li>
<li><p>(Semplice) ((Foundation)) Avvisare se una funzione prende uno <code class="docutils literal notranslate"><span class="pre">Shared_pointer&lt;T&gt;</span></code> per valore o per riferimento a <code class="docutils literal notranslate"><span class="pre">const</span></code> e non lo copia né lo sposta [move] verso un altro <code class="docutils literal notranslate"><span class="pre">Shared_pointer</span></code> in almeno un ramo del codice. Suggerire, invece, di prendere un <code class="docutils literal notranslate"><span class="pre">T*</span></code> o un <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>.</p></li>
<li><p>(Semplice) ((Foundation)) Avvisare se una funzione accetta un parametro <code class="docutils literal notranslate"><span class="pre">Shared_pointer&lt;T&gt;</span></code> per riferimento rvalue. Suggerire, invece, di passare per valore.</p></li>
</ul>
</section>
</section>
<section id="r-35-take-a-shared-ptr-widget-parameter-to-express-that-a-function-might-reseat-the-shared-pointer">
<h4><a name="Rr-sharedptrparam"></a>R.35: Prendere un parametro <code class="docutils literal notranslate"><span class="pre">shared_ptr&lt;widget&gt;&amp;</span></code> per esprimere che una funzione può ricollocare [reseat] lo shared pointer<a class="headerlink" href="#r-35-take-a-shared-ptr-widget-parameter-to-express-that-a-function-might-reseat-the-shared-pointer" title="Link to this heading">¶</a></h4>
<section id="id880">
<h5>Motivo<a class="headerlink" href="#id880" title="Link to this heading">¶</a></h5>
<p>Ciò rende esplicito il ricollocamento [reseat] della funzione.</p>
</section>
<section id="id881">
<h5>Nota<a class="headerlink" href="#id881" title="Link to this heading">¶</a></h5>
<p>Eseguire un «reseat» [ricollocamento] significa «fare in modo che un puntatore o un puntatore intelligente si riferiscano a un oggetto diverso».</p>
</section>
<section id="id882">
<h5>Esempio, buono<a class="headerlink" href="#id882" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void ChangeWidget(std::shared_ptr&lt;widget&gt;&amp; w)
{
    // This will change the callers widget
    w = std::make_shared&lt;widget&gt;(widget{});
}
</pre></div>
</div>
</section>
<section id="id883">
<h5>Imposizione<a class="headerlink" href="#id883" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Semplice) Avvisare se una funzione prende un parametro <code class="docutils literal notranslate"><span class="pre">Shared_pointer&lt;T&gt;</span></code> per riferimento lvalue e non lo assegna né ci chiama il <code class="docutils literal notranslate"><span class="pre">reset()</span></code> in almeno un ramo del codice. Suggerire, invece, di prendere un <code class="docutils literal notranslate"><span class="pre">T*</span></code> o un <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>.</p></li>
<li><p>(Semplice) ((Foundation)) Avvisare se una funzione prende uno <code class="docutils literal notranslate"><span class="pre">Shared_pointer&lt;T&gt;</span></code> per valore o per riferimento a <code class="docutils literal notranslate"><span class="pre">const</span></code> e non lo copia né lo sposta [move] verso un altro <code class="docutils literal notranslate"><span class="pre">Shared_pointer</span></code> in almeno un ramo del codice. Suggerire, invece, di prendere un <code class="docutils literal notranslate"><span class="pre">T*</span></code> o un <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>.</p></li>
<li><p>(Semplice) ((Foundation)) Avvisare se una funzione accetta un parametro <code class="docutils literal notranslate"><span class="pre">Shared_pointer&lt;T&gt;</span></code> per riferimento rvalue. Suggerire, invece, di passare per valore.</p></li>
</ul>
</section>
</section>
<section id="r-36-take-a-const-shared-ptr-widget-parameter-to-express-that-it-might-retain-a-reference-count-to-the-object">
<h4><a name="Rr-sharedptrparam-const"></a>R.36: Prendere un parametro <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">shared_ptr&lt;widget&gt;&amp;</span></code> per esprimere che potrebbe conservare un conteggio dei riferimenti all’oggetto ???<a class="headerlink" href="#r-36-take-a-const-shared-ptr-widget-parameter-to-express-that-it-might-retain-a-reference-count-to-the-object" title="Link to this heading">¶</a></h4>
<section id="id884">
<h5>Motivo<a class="headerlink" href="#id884" title="Link to this heading">¶</a></h5>
<p>Questo rende la funzione ??? esplicita.</p>
</section>
<section id="id885">
<h5>Esempio, buono<a class="headerlink" href="#id885" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void share(shared_ptr&lt;widget&gt;);            // share -- &quot;will&quot; retain refcount

void reseat(shared_ptr&lt;widget&gt;&amp;);          // &quot;might&quot; reseat ptr

void may_share(const shared_ptr&lt;widget&gt;&amp;); // &quot;might&quot; retain refcount
</pre></div>
</div>
</section>
<section id="id886">
<h5>Imposizione<a class="headerlink" href="#id886" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Semplice) Avvisare se una funzione prende un parametro <code class="docutils literal notranslate"><span class="pre">Shared_pointer&lt;T&gt;</span></code> per riferimento lvalue e non lo assegna né ci chiama il <code class="docutils literal notranslate"><span class="pre">reset()</span></code> in almeno un ramo del codice. Suggerire, invece, di prendere un <code class="docutils literal notranslate"><span class="pre">T*</span></code> o un <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>.</p></li>
<li><p>(Semplice) ((Foundation)) Avvisare se una funzione prende uno <code class="docutils literal notranslate"><span class="pre">Shared_pointer&lt;T&gt;</span></code> per valore o per riferimento a <code class="docutils literal notranslate"><span class="pre">const</span></code> e non lo copia né lo sposta [move] verso un altro <code class="docutils literal notranslate"><span class="pre">Shared_pointer</span></code> in almeno un ramo del codice. Suggerire, invece, di prendere un <code class="docutils literal notranslate"><span class="pre">T*</span></code> o un <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>.</p></li>
<li><p>(Semplice) ((Foundation)) Avvisare se una funzione accetta un parametro <code class="docutils literal notranslate"><span class="pre">Shared_pointer&lt;T&gt;</span></code> per riferimento rvalue. Suggerire, invece, di passare per valore.</p></li>
</ul>
</section>
</section>
<section id="r-37-do-not-pass-a-pointer-or-reference-obtained-from-an-aliased-smart-pointer">
<h4><a name="Rr-smartptrget"></a>R.37: Non passare un puntatore o un riferimento ottenuti da un alias di uno smart pointer<a class="headerlink" href="#r-37-do-not-pass-a-pointer-or-reference-obtained-from-an-aliased-smart-pointer" title="Link to this heading">¶</a></h4>
<section id="id887">
<h5>Motivo<a class="headerlink" href="#id887" title="Link to this heading">¶</a></h5>
<p>La violazione di questa regola è la causa numero uno della perdita del conteggio dei riferimenti e del ritrovarsi con un puntatore appeso [dangling]. Le funzioni dovrebbero preferire di passare i puntatori semplici e i riferimenti lungo la catena delle chiamate. Nella parte iniziale dell’albero delle chiamate, dove si ottiene il puntatore semplice o il riferimento da un puntatore intelligente, che mantiene in vita l’oggetto. È necessario assicurarsi che il puntatore intelligente non possa essere inavvertitamente ripristinato o riassegnato nel resto della catena delle chiamate.</p>
</section>
<section id="id888">
<h5>Nota<a class="headerlink" href="#id888" title="Link to this heading">¶</a></h5>
<p>Per fare ciò, a volte è necessario tenere una copia locale di un puntatore intelligente, che mantiene saldamente in vita l’oggetto per la durata della funzione e della sequenza delle chiamate.</p>
</section>
<section id="id889">
<h5>Esempio<a class="headerlink" href="#id889" title="Link to this heading">¶</a></h5>
<p>Si consideri questo codice:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// global (static or heap), or aliased local ...
shared_ptr&lt;widget&gt; g_p = ...;

void f(widget&amp; w)
{
    g();
    use(w);  // A
}

void g()
{
    g_p = ...; // oops, if this was the last shared_ptr to that widget, destroys the widget
}
</pre></div>
</div>
<p>Quanto segue non deve superare la revisione del codice:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void my_code()
{
    // BAD: passing pointer or reference obtained from a non-local smart pointer
    //      that could be inadvertently reset somewhere inside f or its callees
    f(*g_p);

    // BAD: same reason, just passing it as a &quot;this&quot; pointer
    g_p-&gt;func();
}
</pre></div>
</div>
<p>La correzione è semplice – si prende una copia locale del puntatore per «mantenere un ref count» per la propria catena delle chiamate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void my_code()
{
    // cheap: 1 increment covers this entire function and all the call trees below us
    auto pin = g_p;

    // GOOD: passing pointer or reference obtained from a local unaliased smart pointer
    f(*pin);

    // GOOD: same reason
    pin-&gt;func();
}
</pre></div>
</div>
</section>
<section id="id890">
<h5>Imposizione<a class="headerlink" href="#id890" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>(Semplice) Avvisare se un puntatore o un riferimento ottenuto da una variabile smart pointer (<code class="docutils literal notranslate"><span class="pre">Unique_pointer</span></code> o <code class="docutils literal notranslate"><span class="pre">Shared_pointer</span></code>) che sia non-locale, o che sia locale ma potenzialmente un alias, venga utilizzato nella chiamata di una funzione. Se il puntatore intelligente è uno <code class="docutils literal notranslate"><span class="pre">Shared_pointer</span></code> allora suggerire, invece, di prendere una copia locale dello smart pointer per ottenerne un puntatore o un riferimento.</p></li>
</ul>
</section>
</section>
</section>
</section>
<section id="es-expressions-and-statements">
<h2><a name="S-expr"></a>ES: Espressioni e istruzioni<a class="headerlink" href="#es-expressions-and-statements" title="Link to this heading">¶</a></h2>
<p>Le espressioni e le istruzioni sono il modo più semplice e diretto per esprimere azioni e calcoli. Le dichiarazioni in uno scope locale sono istruzioni.</p>
<p>Per le regole sulla nomenclatura, sui commenti e l’indentazione, cfr. <a class="reference internal" href="#S-naming"><span class="xref myst">NL: Nomenclatura e layout</span></a>.</p>
<p>Regole generali:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Res-lib"><span class="xref myst">ES.1: Preferire la libreria standard alle altre librerie e al «codice artigianale»</span></a></p></li>
<li><p><a class="reference internal" href="#Res-abstr"><span class="xref myst">ES.2: Preferire astrazioni adatte all’uso diretto delle funzionalità del linguaggio</span></a></p></li>
<li><p><a class="reference internal" href="#Res-DRY"><span class="xref myst">ES.3: Non ripetersi, evitare codice ridondante</span></a></p></li>
</ul>
<p>Regole sulle dichiarazioni:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Res-scope"><span class="xref myst">ES.5: Tenere gli scope piccoli</span></a></p></li>
<li><p><a class="reference internal" href="#Res-cond"><span class="xref myst">ES.6: Dichiarare i nomi nella parte di inizializzazione e in quella delle condizioni delle istruzioni-for per limitarne lo scope</span></a></p></li>
<li><p><a class="reference internal" href="#Res-name-length"><span class="xref myst">ES.7: Mantenere brevi i nomi comuni e locali mentre quelli meno comuni e non-locali più lunghi</span></a></p></li>
<li><p><a class="reference internal" href="#Res-name-similar"><span class="xref myst">ES.8: Evitare similitudini tra i nomi</span></a></p></li>
<li><p><a class="reference internal" href="#Res-not-CAPS"><span class="xref myst">ES.9: Evitare nomi <code class="docutils literal notranslate"><span class="pre">TUTTO_IN_MAIUSCOLO</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Res-name-one"><span class="xref myst">ES.10: Dichiarare un (solo) nome per ogni dichiarazione</span></a></p></li>
<li><p><a class="reference internal" href="#Res-auto"><span class="xref myst">ES.11: Usare <code class="docutils literal notranslate"><span class="pre">auto</span></code> per evitare la ripetizione ridondante del nome dei tipi</span></a></p></li>
<li><p><a class="reference internal" href="#Res-reuse"><span class="xref myst">ES.12: Non riutilizzare i nomi all’interno di scope annidati</span></a></p></li>
<li><p><a class="reference internal" href="#Res-always"><span class="xref myst">ES.20: Inizializzare sempre un oggetto</span></a></p></li>
<li><p><a class="reference internal" href="#Res-introduce"><span class="xref myst">ES.21: Non introdurre una variabile (o una costante) prima che ne sia necessario l’uso</span></a></p></li>
<li><p><a class="reference internal" href="#Res-init"><span class="xref myst">ES.22: Non dichiarare una variabile fin quando non si abbia un valore con cui inizializzarla</span></a></p></li>
<li><p><a class="reference internal" href="#Res-list"><span class="xref myst">ES.23: Preferire la sintassi di inizializzazione <code class="docutils literal notranslate"><span class="pre">{}</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Res-unique"><span class="xref myst">ES.24: Usare un <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;T&gt;</span></code> per contenere i puntatori</span></a></p></li>
<li><p><a class="reference internal" href="#Res-const"><span class="xref myst">ES.25: Dichiarare un oggetto <code class="docutils literal notranslate"><span class="pre">const</span></code> o <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> a meno che non se ne voglia, in seguito, modificare il valore</span></a></p></li>
<li><p><a class="reference internal" href="#Res-recycle"><span class="xref myst">ES.26: Non usare una variabile per due usi non correlati</span></a></p></li>
<li><p><a class="reference internal" href="#Res-stack"><span class="xref myst">ES.27: Usare <code class="docutils literal notranslate"><span class="pre">std::array</span></code> o <code class="docutils literal notranslate"><span class="pre">stack_array</span></code> per gli array sullo stack</span></a></p></li>
<li><p><a class="reference internal" href="#Res-lambda-init"><span class="xref myst">ES.28: Usare le lambda per delle inizializzazioni complesse, specialmente di variabili <code class="docutils literal notranslate"><span class="pre">const</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Res-macros"><span class="xref myst">ES.30: Non usare le macro per manipolare il testo del programma</span></a></p></li>
<li><p><a class="reference internal" href="#Res-macros2"><span class="xref myst">ES.31: Non usare le macro per le costanti o le «funzioni»</span></a></p></li>
<li><p><a class="reference internal" href="#Res-ALL_CAPS"><span class="xref myst">ES.32: Usare il <code class="docutils literal notranslate"><span class="pre">TUTTO_IN_MAIUSCOLO</span></code> per tutti i nomi delle macro</span></a></p></li>
<li><p><a class="reference internal" href="#Res-MACROS"><span class="xref myst">ES.33: Se è necessario usare le macro, dargli dei nomi univoci</span></a></p></li>
<li><p><a class="reference internal" href="#Res-ellipses"><span class="xref myst">ES.34: Non definire una funzione variadica (C-style)</span></a></p></li>
</ul>
<p>Regole sulle espressioni:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Res-complicated"><span class="xref myst">ES.40: Evitare espressioni complicate</span></a></p></li>
<li><p><a class="reference internal" href="#Res-parens"><span class="xref myst">ES.41: In caso di dubbio sulla precedenza degli operatori, usare le parentesi</span></a></p></li>
<li><p><a class="reference internal" href="#Res-ptr"><span class="xref myst">ES.42: Usare in modo semplice e diretto i puntatori</span></a></p></li>
<li><p><a class="reference internal" href="#Res-order"><span class="xref myst">ES.43: Evitare espressioni con un ordine di valutazione incerto</span></a></p></li>
<li><p><a class="reference internal" href="#Res-order-fct"><span class="xref myst">ES.44: Non dipendere dall’ordine di valutazione degli argomenti di una funzione</span></a></p></li>
<li><p><a class="reference internal" href="#Res-magic"><span class="xref myst">ES.45: Evitare «costanti magiche»; utilizzare costanti simboliche</span></a></p></li>
<li><p><a class="reference internal" href="#Res-narrowing"><span class="xref myst">ES.46: Evitare le conversioni «narrowing»</span></a></p></li>
<li><p><a class="reference internal" href="#Res-nullptr"><span class="xref myst">ES.47: Usare <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> anziché  <code class="docutils literal notranslate"><span class="pre">0</span></code> o <code class="docutils literal notranslate"><span class="pre">NULL</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Res-casts"><span class="xref myst">ES.48: Evitare i cast</span></a></p></li>
<li><p><a class="reference internal" href="#Res-casts-named"><span class="xref myst">ES.49: Se si deve usare un cast, si utilizzi un «named cast»</span></a></p></li>
<li><p><a class="reference internal" href="#Res-casts-const"><span class="xref myst">ES.50: Non eseguire il cast da un <code class="docutils literal notranslate"><span class="pre">const</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Res-range-checking"><span class="xref myst">ES.55: Evitare la necessità di controllare i range</span></a></p></li>
<li><p><a class="reference internal" href="#Res-move"><span class="xref myst">ES.56: Scrivere <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> solo quando è necessario spostare esplicitamente un oggetto in un altro scope</span></a></p></li>
<li><p><a class="reference internal" href="#Res-new"><span class="xref myst">ES.60: Evitare <code class="docutils literal notranslate"><span class="pre">new</span></code> e <code class="docutils literal notranslate"><span class="pre">delete</span></code> al di fuori delle funzioni di gestione delle risorse</span></a></p></li>
<li><p><a class="reference internal" href="#Res-del"><span class="xref myst">ES.61: Eseguire il delete degli array con <code class="docutils literal notranslate"><span class="pre">delete[]</span></code> e usando <code class="docutils literal notranslate"><span class="pre">delete</span></code> per il resto</span></a></p></li>
<li><p><a class="reference internal" href="#Res-arr2"><span class="xref myst">ES.62: Non confrontare i puntatori in diversi array</span></a></p></li>
<li><p><a class="reference internal" href="#Res-slice"><span class="xref myst">ES.63: Non provocare «slice»</span></a></p></li>
<li><p><a class="reference internal" href="#Res-construct"><span class="xref myst">ES.64: Usare la notazione  <code class="docutils literal notranslate"><span class="pre">T{e}</span></code> per la costruzione</span></a></p></li>
<li><p><a class="reference internal" href="#Res-deref"><span class="xref myst">ES.65: Non de-referenziare un puntatore non valido</span></a></p></li>
</ul>
<p>Regole sulle istruzioni:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Res-switch-if"><span class="xref myst">ES.70: Preferire l’istruzione <code class="docutils literal notranslate"><span class="pre">switch</span></code> all’istruzione <code class="docutils literal notranslate"><span class="pre">if</span></code>potendo scegliere</span></a></p></li>
<li><p><a class="reference internal" href="#Res-for-range"><span class="xref myst">ES.71: Preferire un’istruzione range-<code class="docutils literal notranslate"><span class="pre">for</span></code> ad un’istruzione <code class="docutils literal notranslate"><span class="pre">for</span></code> potendo scegliere</span></a></p></li>
<li><p><a class="reference internal" href="#Res-for-while"><span class="xref myst">ES.72: Preferire un’istruzione <code class="docutils literal notranslate"><span class="pre">for</span></code> ad un’istruzione <code class="docutils literal notranslate"><span class="pre">while</span></code> quando c’è un’ovvia variabile del ciclo</span></a></p></li>
<li><p><a class="reference internal" href="#Res-while-for"><span class="xref myst">ES.73: Preferire un’istruzione <code class="docutils literal notranslate"><span class="pre">while</span></code> ad un’istruzione <code class="docutils literal notranslate"><span class="pre">for</span></code> quando non è ovvia la variabile del ciclo</span></a></p></li>
<li><p><a class="reference internal" href="#Res-for-init"><span class="xref myst">ES.74: Dichiarare la variabile del ciclo nella parte dell’inizializzatore dell’istruzione <code class="docutils literal notranslate"><span class="pre">for</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Res-do"><span class="xref myst">ES.75: Evitare l’istruzione <code class="docutils literal notranslate"><span class="pre">do</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Res-goto"><span class="xref myst">ES.76: Evitare il <code class="docutils literal notranslate"><span class="pre">goto</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Res-continue"><span class="xref myst">ES.77: Minimizzare l’uso di <code class="docutils literal notranslate"><span class="pre">break</span></code> e <code class="docutils literal notranslate"><span class="pre">continue</span></code> nei cicli</span></a></p></li>
<li><p><a class="reference internal" href="#Res-break"><span class="xref myst">ES.78: Non fare affidamento ai proseguimenti impliciti nelle istruzioni <code class="docutils literal notranslate"><span class="pre">switch</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Res-default"><span class="xref myst">ES.79: Usare <code class="docutils literal notranslate"><span class="pre">default</span></code> per gestire i (soli) casi comuni</span></a></p></li>
<li><p><a class="reference internal" href="#Res-noname"><span class="xref myst">ES.84: Non tentare di dichiarare una variabile locale senza nome</span></a></p></li>
<li><p><a class="reference internal" href="#Res-empty"><span class="xref myst">ES.85: Rendere visibili le istruzioni vuote</span></a></p></li>
<li><p><a class="reference internal" href="#Res-loop-counter"><span class="xref myst">ES.86: Evitare di modificare le variabili di controllo dei cicli nel corpo dei cicli for</span></a></p></li>
<li><p><a class="reference internal" href="#Res-if"><span class="xref myst">ES.87: Non aggiungere dei ridondanti <code class="docutils literal notranslate"><span class="pre">==</span></code> o <code class="docutils literal notranslate"><span class="pre">!=</span></code> alle condizioni</span></a></p></li>
</ul>
<p>Regole sull’aritmetica:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Res-mix"><span class="xref myst">ES.100: Non mischiare l’aritmetica con segno con quella senza segno</span></a></p></li>
<li><p><a class="reference internal" href="#Res-unsigned"><span class="xref myst">ES.101: Usare i tipi unsigned per la gestione dei bit</span></a></p></li>
<li><p><a class="reference internal" href="#Res-signed"><span class="xref myst">ES.102: Usare i tipi con segno per l’aritmetica</span></a></p></li>
<li><p><a class="reference internal" href="#Res-overflow"><span class="xref myst">ES.103: Evitare l’overflow</span></a></p></li>
<li><p><a class="reference internal" href="#Res-underflow"><span class="xref myst">ES.104: Evitare l’underflow</span></a></p></li>
<li><p><a class="reference internal" href="#Res-zero"><span class="xref myst">ES.105: Non dividere per lo zero intero</span></a></p></li>
<li><p><a class="reference internal" href="#Res-nonnegative"><span class="xref myst">ES.106: Non tentare di evitare i valori negativi utilizzando <code class="docutils literal notranslate"><span class="pre">unsigned</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Res-subscripts"><span class="xref myst">ES.107: Non usare <code class="docutils literal notranslate"><span class="pre">unsigned</span></code> per l’indicizzazione, preferire <code class="docutils literal notranslate"><span class="pre">gsl::index</span></code></span></a></p></li>
</ul>
<section id="es-1-prefer-the-standard-library-to-other-libraries-and-to-handcrafted-code">
<h3><a name="Res-lib"></a>ES.1: Preferire la libreria standard alle altre librerie e al «codice artigianale»<a class="headerlink" href="#es-1-prefer-the-standard-library-to-other-libraries-and-to-handcrafted-code" title="Link to this heading">¶</a></h3>
<section id="id891">
<h4>Motivo<a class="headerlink" href="#id891" title="Link to this heading">¶</a></h4>
<p>Il codice che usa una libreria può risultare molto più facile da scrivere rispetto al codice che lavora direttamente con le funzionalità del linguaggio, molto più breve, tende ad avere un livello di astrazione più alto, inoltre il codice della libreria è presumibilmente già testato. La ISO C++ Standard Library è tra le librerie più conosciute e meglio testate. È disponibile come parte di tutte le implementazioni del C++.</p>
</section>
<section id="id892">
<h4>Esempio<a class="headerlink" href="#id892" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto sum = accumulate(begin(a), end(a), 0.0);   // good
</pre></div>
</div>
<p>una versione «range» di <code class="docutils literal notranslate"><span class="pre">accumulate</span></code> sarebbe ancora meglio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto sum = accumulate(v, 0.0); // better
</pre></div>
</div>
<p>ma non codificare a mano un algoritmo ben noto:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int max = v.size();   // bad: verbose, purpose unstated
double sum = 0.0;
for (int i = 0; i &lt; max; ++i)
    sum = sum + v[i];
</pre></div>
</div>
</section>
<section id="id893">
<h4>Eccezione<a class="headerlink" href="#id893" title="Link to this heading">¶</a></h4>
<p>Grandi parti della libreria standard si basano sull’allocazione dinamica (free store). Tali parti, in particolare i contenitori ma non gli algoritmi, non sono idonee per alcune applicazioni fortemente real-time ed embedded. In questi casi, si prenda in considerazione la possibilità di fornire/usare delle strutture simili, p.es., un contenitore simile alla libreria standard implementato con un «pool allocator» [in memoria].</p>
</section>
<section id="id894">
<h4>Imposizione<a class="headerlink" href="#id894" title="Link to this heading">¶</a></h4>
<p>Non facile. ??? Cercare loop disordinati, cicli nidificati, funzioni lunghe, assenza di chiamate di funzione, mancanza di utilizzo di tipi nativi. Complessità ciclomatica?</p>
</section>
</section>
<section id="es-2-prefer-suitable-abstractions-to-direct-use-of-language-features">
<h3><a name="Res-abstr"></a>ES.2: Preferire astrazioni adatte all’uso diretto delle funzionalità del linguaggio<a class="headerlink" href="#es-2-prefer-suitable-abstractions-to-direct-use-of-language-features" title="Link to this heading">¶</a></h3>
<section id="id895">
<h4>Motivo<a class="headerlink" href="#id895" title="Link to this heading">¶</a></h4>
<p>Una «astrazione adatta» (p.es., libreria o classe) è più vicina ai concetti dell’applicazione che al semplice linguaggio, porta ad un codice più breve e più chiaro ed è probabilmente testato meglio.</p>
</section>
<section id="id896">
<h4>Esempio<a class="headerlink" href="#id896" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;string&gt; read1(istream&amp; is)   // good
{
    vector&lt;string&gt; res;
    for (string s; is &gt;&gt; s;)
        res.push_back(s);
    return res;
}
</pre></div>
</div>
<p>Quello equivalente più tradizionale e a livello più basso è più lungo, più disordinato, difficile da correggere, e probabilmente più lento:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char** read2(istream&amp; is, int maxelem, int maxstring, int* nread)   // bad: verbose and incomplete
{
    auto res = new char*[maxelem];
    int elemcount = 0;
    while (is &amp;&amp; elemcount &lt; maxelem) {
        auto s = new char[maxstring];
        is.read(s, maxstring);
        res[elemcount++] = s;
    }
    *nread = elemcount;
    return res;
}
</pre></div>
</div>
<p>Una volta aggiunto il controllo per l’overflow e la gestione degli errori questo codice diventa piuttosto disordinato e si verifica il problema di ricordarsi di eseguire il <code class="docutils literal notranslate"><span class="pre">delete</span></code> del puntatore restituito e delle stringhe C-style che l’array contiene.</p>
</section>
<section id="id897">
<h4>Imposizione<a class="headerlink" href="#id897" title="Link to this heading">¶</a></h4>
<p>Non facile. ??? Cercare loop disordinati, cicli nidificati, funzioni lunghe, assenza di chiamate di funzione, mancanza di utilizzo di tipi nativi. Complessità ciclomatica?</p>
</section>
</section>
<section id="es-3-don-t-repeat-yourself-avoid-redundant-code">
<h3><a name="Res-DRY"></a>ES.3: Non ripetersi, evitare codice ridondante<a class="headerlink" href="#es-3-don-t-repeat-yourself-avoid-redundant-code" title="Link to this heading">¶</a></h3>
<p>Il codice duplicato o altrimenti ridondante oscura le intenzioni, rende più difficile la comprensione della logica e rende più difficile la manutenzione, oltre ad altri problemi. Spesso deriva dalla programmazione taglia-e-incolla.</p>
<p>Usare gli algoritmi standard dove appropriato, anziché scrivere una propria implementazione.</p>
<p><strong>Vedere anche</strong>: <a class="reference internal" href="#Rsl-lib"><span class="xref myst">SL.1</span></a>, <a class="reference internal" href="#Res-auto"><span class="xref myst">ES.11</span></a></p>
<section id="id898">
<h4>Esempio<a class="headerlink" href="#id898" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void func(bool flag)    // Bad, duplicated code.
{
    if (flag) {
        x();
        y();
    }
    else {
        x();
        z();
    }
}

void func(bool flag)    // Better, no duplicated code.
{
    x();

    if (flag)
        y();
    else
        z();
}
</pre></div>
</div>
</section>
<section id="id899">
<h4>Imposizione<a class="headerlink" href="#id899" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Usare un analizzatore statico. Intercetterà almeno alcuni costrutti ridondanti.</p></li>
<li><p>Revisione del codice</p></li>
</ul>
</section>
</section>
<section id="es-dcl-declarations">
<h3>ES.dcl: Dichiarazioni<a class="headerlink" href="#es-dcl-declarations" title="Link to this heading">¶</a></h3>
<p>Una dichiarazione è un’istruzione. Una dichiarazione introduce un nome in uno scope e potrebbe causare la costruzione di un oggetto.</p>
<section id="es-5-keep-scopes-small">
<h4><a name="Res-scope"></a>ES.5: Tenere gli scope piccoli<a class="headerlink" href="#es-5-keep-scopes-small" title="Link to this heading">¶</a></h4>
<section id="id900">
<h5>Motivo<a class="headerlink" href="#id900" title="Link to this heading">¶</a></h5>
<p>Leggibilità. Minimizzare la ritenzione delle risorse. Evitare l’abuso accidentale del valore.</p>
<p><strong>Formulazione alternativa</strong>: Non dichiarare inutilmente un nome in un grande scope.</p>
</section>
<section id="id901">
<h5>Esempio<a class="headerlink" href="#id901" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use()
{
    int i;    // bad: i is needlessly accessible after loop
    for (i = 0; i &lt; 20; ++i) { /* ... */ }
    // no intended use of i here
    for (int i = 0; i &lt; 20; ++i) { /* ... */ }  // good: i is local to for-loop

    if (auto pc = dynamic_cast&lt;Circle*&gt;(ps)) {  // good: pc is local to if-statement
        // ... deal with Circle ...
    }
    else {
        // ... handle error ...
    }
}
</pre></div>
</div>
</section>
<section id="id902">
<h5>Esempio, cattivo<a class="headerlink" href="#id902" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use(const string&amp; name)
{
    string fn = name + &quot;.txt&quot;;
    ifstream is {fn};
    Record r;
    is &gt;&gt; r;
    // ... 200 lines of code without intended use of fn or is ...
}
</pre></div>
</div>
<p>Questa funzione è comunque troppo lunga, ma il punto è che le risorse utilizzate da <code class="docutils literal notranslate"><span class="pre">fn</span></code> e l’handle del file tenuto da <code class="docutils literal notranslate"><span class="pre">is</span></code> vengono conservati per molto più tempo del necessario e quell’uso imprevisto di <code class="docutils literal notranslate"><span class="pre">is</span></code> e <code class="docutils literal notranslate"><span class="pre">fn</span></code> potrebbe avvenire in seguito nella funzione. In questo caso, potrebbe essere una buona idea prendere in considerazione la lettura:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Record load_record(const string&amp; name)
{
    string fn = name + &quot;.txt&quot;;
    ifstream is {fn};
    Record r;
    is &gt;&gt; r;
    return r;
}

void use(const string&amp; name)
{
    Record r = load_record(name);
    // ... 200 lines of code ...
}
</pre></div>
</div>
</section>
<section id="id903">
<h5>Imposizione<a class="headerlink" href="#id903" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare una variabile del ciclo dichiarata al di fuori del ciclo e non usata dopo di esso</p></li>
<li><p>Segnalare quando le risorse costose, come gli handle dei file e i lock non vengono usati per N-righe (con un N adatto</p></li>
</ul>
</section>
</section>
<section id="es-6-declare-names-in-for-statement-initializers-and-conditions-to-limit-scope">
<h4><a name="Res-cond"></a>ES.6: Dichiarare i nomi nella parte di inizializzazione e in quella delle condizioni delle istruzioni-for per limitarne lo scope<a class="headerlink" href="#es-6-declare-names-in-for-statement-initializers-and-conditions-to-limit-scope" title="Link to this heading">¶</a></h4>
<section id="id904">
<h5>Motivo<a class="headerlink" href="#id904" title="Link to this heading">¶</a></h5>
<p>Leggibilità. Limitare la visibilità della variabile allo scope del loop. Evitare di utilizzare la variabile del loop per altri usi dopo il ciclo. Minimizzare la ritenzione delle risorse.</p>
</section>
<section id="id905">
<h5>Esempio<a class="headerlink" href="#id905" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use()
{
    for (string s; cin &gt;&gt; s;)
        v.push_back(s);

    for (int i = 0; i &lt; 20; ++i) {   // good: i is local to for-loop
        // ...
    }

    if (auto pc = dynamic_cast&lt;Circle*&gt;(ps)) {   // good: pc is local to if-statement
        // ... deal with Circle ...
    }
    else {
        // ... handle error ...
    }
}
</pre></div>
</div>
</section>
<section id="id906">
<h5>Esempio, da non fare<a class="headerlink" href="#id906" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int j;                            // BAD: j is visible outside the loop
for (j = 0; j &lt; 100; ++j) {
    // ...
}
// j is still visible here and isn&#39;t needed
</pre></div>
</div>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Res-recycle"><span class="xref myst">Non usare una variabile per due usi non correlati</span></a></p>
</section>
<section id="id907">
<h5>Imposizione<a class="headerlink" href="#id907" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Avvisare quando una variabile modificata in un’istruzione <code class="docutils literal notranslate"><span class="pre">for</span></code> è dichiarata esternamente al loop e non viene usata esternamente al ciclo.</p></li>
<li><p>(difficile) Segnalare le variabili dei loop dichiarate prima del ciclo ed usate dopo di esso per un uso non correlato.</p></li>
</ul>
<p><strong>Discussione</strong>: Racchiudere la variabile del loop nello scope del body del loop aiuta molto gli ottimizzatori. Riconoscere che imporre che la variabile sia accessibile solamente all’interno del body del loop sblocca alcune ottimizzazioni quali l’hoisting [spostare le variabili all’inizio], strength reduction [sostituzione di operazioni onerose con altre più economiche], loop-invariant code motion [spostare istruzioni al di fuori del loop], ecc.</p>
</section>
<section id="c-17-and-c-20-example">
<h5>Esempio C++17 e C++20<a class="headerlink" href="#c-17-and-c-20-example" title="Link to this heading">¶</a></h5>
<p>Nota: C++17 e C++20 hanno anche gli inizializzatori per le istruzioni <code class="docutils literal notranslate"><span class="pre">if</span></code>, <code class="docutils literal notranslate"><span class="pre">switch</span></code>, e range-<code class="docutils literal notranslate"><span class="pre">for</span></code>. Questi richiedono il supporto del C++17 e del C++20.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>map&lt;int, string&gt; mymap;

if (auto result = mymap.insert(value); result.second) {
    // insert succeeded, and result is valid for this block
    use(result.first);  // ok
    // ...
} // result is destroyed here
</pre></div>
</div>
</section>
<section id="c-17-and-c-20-enforcement-if-using-a-c-17-or-c-20-compiler">
<h5>Imposizione C++17 e C++20 (se si usa un compilatore C++17 o C++20)<a class="headerlink" href="#c-17-and-c-20-enforcement-if-using-a-c-17-or-c-20-compiler" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare variabili di selezione/loop dichiarate prima del body e non usate dopo</p></li>
<li><p>(difficile) Segnalare le variabili di selezione/loop dichiarate prima del body ed usate dopo il body per un uso non correlato.</p></li>
</ul>
</section>
</section>
<section id="es-7-keep-common-and-local-names-short-and-keep-uncommon-and-non-local-names-longer">
<h4><a name="Res-name-length"></a>ES.7: Mantenere brevi i nomi  comuni e locali mentre quelli meno comuni e non-locali più lunghi<a class="headerlink" href="#es-7-keep-common-and-local-names-short-and-keep-uncommon-and-non-local-names-longer" title="Link to this heading">¶</a></h4>
<section id="id908">
<h5>Motivo<a class="headerlink" href="#id908" title="Link to this heading">¶</a></h5>
<p>Leggibilità. Ridurre la possibilità di conflitti tra nomi non locali non correlati.</p>
</section>
<section id="id909">
<h5>Esempio<a class="headerlink" href="#id909" title="Link to this heading">¶</a></h5>
<p>Nomi locali brevi aumentano la leggibilità:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;    // good
void print(ostream&amp; os, const vector&lt;T&gt;&amp; v)
{
    for (gsl::index i = 0; i &lt; v.size(); ++i)
        os &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;;
}
</pre></div>
</div>
<p>Un indice è convenzionalmente chiamato <code class="docutils literal notranslate"><span class="pre">i</span></code> e non c’è alcun indizio sul significato del vettore in questa generica funzione, quindi <code class="docutils literal notranslate"><span class="pre">v</span></code> è un nome buono come un altro. Da confrontare con</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename Element_type&gt;   // bad: verbose, hard to read
void print(ostream&amp; target_stream, const vector&lt;Element_type&gt;&amp; current_vector)
{
    for (gsl::index current_element_index = 0;
         current_element_index &lt; current_vector.size();
         ++current_element_index
    )
    target_stream &lt;&lt; current_vector[current_element_index] &lt;&lt; &#39;\n&#39;;
}
</pre></div>
</div>
<p>Sì, è una caricatura, ma c’è di peggio.</p>
</section>
<section id="id910">
<h5>Esempio<a class="headerlink" href="#id910" title="Link to this heading">¶</a></h5>
<p>Nomi non-locali corti e non convenzionali in codice criptico:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use1(const string&amp; s)
{
    // ...
    tt(s);   // bad: what is tt()?
    // ...
}
</pre></div>
</div>
<p>Meglio, ci sono nomi leggibili di entità non-locali:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use1(const string&amp; s)
{
    // ...
    trim_tail(s);   // better
    // ...
}
</pre></div>
</div>
<p>Qui, c’è la possibilità che il lettore sappia cosa significa <code class="docutils literal notranslate"><span class="pre">trim_tail</span></code> e che possa ricordarlo dopo averlo cercato.</p>
</section>
<section id="id911">
<h5>Esempio, cattivo<a class="headerlink" href="#id911" title="Link to this heading">¶</a></h5>
<p>I nomi degli argomenti di funzioni grandi sono “de facto” non locali e dovrebbero essere significativi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void complicated_algorithm(vector&lt;Record&gt;&amp; vr, const vector&lt;int&gt;&amp; vi, map&lt;string, int&gt;&amp; out)
// read from events in vr (marking used Records) for the indices in
// vi placing (name, index) pairs into out
{
    // ... 500 lines of code using vr, vi, and out ...
}
</pre></div>
</div>
<p>Si raccomanda di mantenere brevi le funzioni, ma quella regola non è universalmente rispettata e la nomenclatura lo dovrebbe rispecchiare.</p>
</section>
<section id="id912">
<h5>Imposizione<a class="headerlink" href="#id912" title="Link to this heading">¶</a></h5>
<p>Controllare la lunghezza dei nomi locali e non. Tenere conto anche della lunghezza della funzione.</p>
</section>
</section>
<section id="es-8-avoid-similar-looking-names">
<h4><a name="Res-name-similar"></a>ES.8: Evitare similitudini tra i nomi<a class="headerlink" href="#es-8-avoid-similar-looking-names" title="Link to this heading">¶</a></h4>
<section id="id913">
<h5>Motivo<a class="headerlink" href="#id913" title="Link to this heading">¶</a></h5>
<p>Chiarezza e leggibilità del codice. Nomi troppo simili rallentano la comprensione e aumentano la probabilità di errori.</p>
</section>
<section id="id914">
<h5>Esempio, cattivo<a class="headerlink" href="#id914" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (readable(i1 + l1 + ol + o1 + o0 + ol + o1 + I0 + l0)) surprise();
</pre></div>
</div>
</section>
<section id="id915">
<h5>Esempio, cattivo<a class="headerlink" href="#id915" title="Link to this heading">¶</a></h5>
<p>Non dichiarare un non-tipo con lo stesso nome di un tipo nello stesso scope. Ciò elimina la necessità di chiarire le ambiguità con una parola chiave come <code class="docutils literal notranslate"><span class="pre">struct</span></code> o <code class="docutils literal notranslate"><span class="pre">enum</span></code>. Rimuove anche una fonte di errori, poiché <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">X</span></code> può dichiarare implicitamente <code class="docutils literal notranslate"><span class="pre">X</span></code> se fallisce la ricerca [lookup].</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct foo { int n; };
struct foo foo();       // BAD, foo is a type already in scope
struct foo x = foo();   // requires disambiguation
</pre></div>
</div>
</section>
<section id="id916">
<h5>Eccezione<a class="headerlink" href="#id916" title="Link to this heading">¶</a></h5>
<p>I file header più antichi potrebbero dichiarare non-tipi e tipi con lo stesso nome nello stesso scope.</p>
</section>
<section id="id917">
<h5>Imposizione<a class="headerlink" href="#id917" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Controllare i nomi rispetto ad un elenco di combinazioni note di lettere e numeri.</p></li>
<li><p>Segnalare una dichiarazione di una variabile, una funzione, o un enumeratore che nasconde una classe o una enumerazione dichiarata nello stesso scope.</p></li>
</ul>
</section>
</section>
<section id="es-9-avoid-all-caps-names">
<h4><a name="Res-not-CAPS"></a>ES.9: Evitare nomi <code class="docutils literal notranslate"><span class="pre">TUTTO_IN_MAIUSCOLO</span></code><a class="headerlink" href="#es-9-avoid-all-caps-names" title="Link to this heading">¶</a></h4>
<section id="id918">
<h5>Motivo<a class="headerlink" href="#id918" title="Link to this heading">¶</a></h5>
<p>Tali nomi sono comunemente usati per le macro. Quindi, i nomi <code class="docutils literal notranslate"><span class="pre">TUTTO_IN_MAIUSCOLO</span></code> sono vulnerabili alla sostituzione non intenzionale delle macro.</p>
</section>
<section id="id919">
<h5>Esempio<a class="headerlink" href="#id919" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// somewhere in some header:
#define NE !=

// somewhere else in some other header:
enum Coord { N, NE, NW, S, SE, SW, E, W };

// somewhere third in some poor programmer&#39;s .cpp:
switch (direction) {
case N:
    // ...
case NE:
    // ...
// ...
}
</pre></div>
</div>
</section>
<section id="id920">
<h5>Nota<a class="headerlink" href="#id920" title="Link to this heading">¶</a></h5>
<p>Non usare il <code class="docutils literal notranslate"><span class="pre">TUTTO_IN_MAIUSCOLO</span></code> per le costanti solo perché le macro venivano usate per le costanti.</p>
</section>
<section id="id921">
<h5>Imposizione<a class="headerlink" href="#id921" title="Link to this heading">¶</a></h5>
<p>Segnalare gli usi del TUTTO_IN_MAIUSCOLO. Per il codice più vecchio, accettare il TUTTO_IN_MAIUSCOLO per i nomi delle macro e segnalare i nomi delle macro che non siano in TUTTO_IN_MAIUSCOLO.</p>
</section>
</section>
<section id="es-10-declare-one-name-only-per-declaration">
<h4><a name="Res-name-one"></a>ES.10: Dichiarare un (solo) nome per ogni dichiarazione<a class="headerlink" href="#es-10-declare-one-name-only-per-declaration" title="Link to this heading">¶</a></h4>
<section id="id922">
<h5>Motivo<a class="headerlink" href="#id922" title="Link to this heading">¶</a></h5>
<p>Una dichiarazione per ogni riga aumenta la leggibilità ed evita errori relativi alla grammatica C/C++. Inoltre, lascia spazio a un commento di fine riga più descrittivo.</p>
</section>
<section id="id923">
<h5>Esempio, cattivo<a class="headerlink" href="#id923" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char *p, c, a[7], *pp[7], **aa[10];   // yuck!
</pre></div>
</div>
</section>
<section id="id924">
<h5>Eccezione<a class="headerlink" href="#id924" title="Link to this heading">¶</a></h5>
<p>Una dichiarazione di funzione può contenere diverse dichiarazioni di argomenti di funzione.</p>
</section>
<section id="id925">
<h5>Eccezione<a class="headerlink" href="#id925" title="Link to this heading">¶</a></h5>
<p>Un’associazione strutturata [structured binding] (C++17) è specificamente progettata per introdurre diverse variabili:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto [iter, inserted] = m.insert_or_assign(k, val);
if (inserted) { /* new entry was inserted */ }
</pre></div>
</div>
</section>
<section id="id926">
<h5>Esempio<a class="headerlink" href="#id926" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class InputIterator, class Predicate&gt;
bool any_of(InputIterator first, InputIterator last, Predicate pred);
</pre></div>
</div>
<p>o meglio usando i concetti:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool any_of(input_iterator auto first, input_iterator auto last, predicate auto pred);
</pre></div>
</div>
</section>
<section id="id927">
<h5>Esempio<a class="headerlink" href="#id927" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double scalbn(double x, int n);   // OK: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2
</pre></div>
</div>
<p>o:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double scalbn(    // better: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2
    double x,     // base value
    int n         // exponent
);
</pre></div>
</div>
<p>o:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// better: base * pow(FLT_RADIX, exponent); FLT_RADIX is usually 2
double scalbn(double base, int exponent);
</pre></div>
</div>
</section>
<section id="id928">
<h5>Esempio<a class="headerlink" href="#id928" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int a = 10, b = 11, c = 12, d, e = 14, f = 15;
</pre></div>
</div>
<p>In un lungo elenco di dichiaratori, è facile trascurare una variabile non inizializzata.</p>
</section>
<section id="id929">
<h5>Imposizione<a class="headerlink" href="#id929" title="Link to this heading">¶</a></h5>
<p>Segnalare le dichiarazioni di variabili o costanti con dichiaratori multipli (p.es., <code class="docutils literal notranslate"><span class="pre">int*</span> <span class="pre">p,</span> <span class="pre">q;</span></code>)</p>
</section>
</section>
<section id="es-11-use-auto-to-avoid-redundant-repetition-of-type-names">
<h4><a name="Res-auto"></a>ES.11: Usare <code class="docutils literal notranslate"><span class="pre">auto</span></code> per evitare la ripetizione ridondante del nome dei tipi<a class="headerlink" href="#es-11-use-auto-to-avoid-redundant-repetition-of-type-names" title="Link to this heading">¶</a></h4>
<section id="id930">
<h5>Motivo<a class="headerlink" href="#id930" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>La semplice ripetizione è noiosa e soggetta a errori.</p></li>
<li><p>Quando si usa <code class="docutils literal notranslate"><span class="pre">auto</span></code>, il nome dell’entità dichiarata si trova in una posizione fissa nella dichiarazione, aumentando la leggibilità.</p></li>
<li><p>In una dichiarazione di una funzione template il tipo di ritorno può essere un tipo membro.</p></li>
</ul>
</section>
<section id="id931">
<h5>Esempio<a class="headerlink" href="#id931" title="Link to this heading">¶</a></h5>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto p = v.begin();      // vector&lt;DataRecord&gt;::iterator
auto z1 = v[3];          // makes copy of DataRecord
auto&amp; z2 = v[3];         // avoids copy
const auto&amp; z3 = v[3];   // const and avoids copy
auto h = t.future();
auto q = make_unique&lt;int[]&gt;(s);
auto f = [](int x) { return x + 10; };
</pre></div>
</div>
<p>In ciascun caso, ci si risparmia la scrittura di un tipo lungo e difficile da ricordare che il compilatore già conosce ma che un programmatore potrebbe scrivere in modo sbagliato.</p>
</section>
<section id="id932">
<h5>Esempio<a class="headerlink" href="#id932" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class T&gt;
auto Container&lt;T&gt;::first() -&gt; Iterator;   // Container&lt;T&gt;::Iterator
</pre></div>
</div>
</section>
<section id="id933">
<h5>Eccezione<a class="headerlink" href="#id933" title="Link to this heading">¶</a></h5>
<p>Evitare <code class="docutils literal notranslate"><span class="pre">auto</span></code> per gli elenchi di inizializzatori e nei casi in cui si conosce esattamente quale tipo si vuole e dove un inizializzatore potrebbe richiedere una conversione.</p>
</section>
<section id="id934">
<h5>Esempio<a class="headerlink" href="#id934" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto lst = { 1, 2, 3 };   // lst is an initializer list
auto x{1};   // x is an int (in C++17; initializer_list in C++11)
</pre></div>
</div>
</section>
<section id="id935">
<h5>Nota<a class="headerlink" href="#id935" title="Link to this heading">¶</a></h5>
<p>A partire dal C++20, possiamo (e dovremmo) usare i concetti per essere più specifici sul tipo che stiamo deducendo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// ...
forward_iterator auto p = algo(x, y, z);
</pre></div>
</div>
</section>
<section id="example-c-17">
<h5>Esempio (C++17)<a class="headerlink" href="#example-c-17" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>std::set&lt;int&gt; values;
// ...
auto [ position, newly_inserted ] = values.insert(5);   // break out the members of the std::pair
</pre></div>
</div>
</section>
<section id="id936">
<h5>Imposizione<a class="headerlink" href="#id936" title="Link to this heading">¶</a></h5>
<p>Segnalare la ripetizione ridondante dei nomi dei tipi in una dichiarazione.</p>
</section>
</section>
<section id="es-12-do-not-reuse-names-in-nested-scopes">
<h4><a name="Res-reuse"></a>ES.12: Non riutilizzare i nomi all’interno di scope annidati<a class="headerlink" href="#es-12-do-not-reuse-names-in-nested-scopes" title="Link to this heading">¶</a></h4>
<section id="id937">
<h5>Motivo<a class="headerlink" href="#id937" title="Link to this heading">¶</a></h5>
<p>È facile confondersi su quale variabile venga utilizzata. Può causare problemi di manutenzione.</p>
</section>
<section id="id938">
<h5>Esempio, cattivo<a class="headerlink" href="#id938" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int d = 0;
// ...
if (cond) {
    // ...
    d = 9;
    // ...
}
else {
    // ...
    int d = 7;
    // ...
    d = value_to_be_returned;
    // ...
}

return d;
</pre></div>
</div>
<p>Se questa è una grande istruzione <code class="docutils literal notranslate"><span class="pre">if</span></code>, è facile trascurare il fatto che una nuova <code class="docutils literal notranslate"><span class="pre">d</span></code> è stata introdotta nello scope più interno. Questa è una nota fonte di bug. Talvolta tale riutilizzo di un nome in uno scope interno è detto «shadowing».</p>
</section>
<section id="id939">
<h5>Nota<a class="headerlink" href="#id939" title="Link to this heading">¶</a></h5>
<p>Lo shadowing è un problema principalmente quando le funzioni sono troppo grandi e troppo complesse.</p>
</section>
<section id="id940">
<h5>Esempio<a class="headerlink" href="#id940" title="Link to this heading">¶</a></h5>
<p>Lo shadowing degli argomenti di una funzione nel blocco più esterno è impedito dal linguaggio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int x)
{
    int x = 4;  // error: reuse of function argument name

    if (x) {
        int x = 7;  // allowed, but bad
        // ...
    }
}
</pre></div>
</div>
</section>
<section id="id941">
<h5>Esempio, cattivo<a class="headerlink" href="#id941" title="Link to this heading">¶</a></h5>
<p>Anche il riutilizzo del nome di un membro come una variabile locale può essere un problema:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct S {
    int m;
    void f(int x);
};

void S::f(int x)
{
    m = 7;    // assign to member
    if (x) {
        int m = 9;
        // ...
        m = 99; // assign to local variable
        // ...
    }
}
</pre></div>
</div>
</section>
<section id="id942">
<h5>Eccezione<a class="headerlink" href="#id942" title="Link to this heading">¶</a></h5>
<p>Spesso si riutilizzano i nomi delle funzioni di una classe base in una classe derivata:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct B {
    void f(int);
};

struct D : B {
    void f(double);
    using B::f;
};
</pre></div>
</div>
<p>Questo è fonte di errori. Ad esempio, se avessimo dimenticato la dichiarazione di using, una chiamata a <code class="docutils literal notranslate"><span class="pre">d.f(1)</span></code> non avrebbe trovato la versione <code class="docutils literal notranslate"><span class="pre">int</span></code> di <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<p>??? C’è la necessità di una regola specifica per lo shadowing/hiding nelle gerarchie delle classi?</p>
</section>
<section id="id943">
<h5>Imposizione<a class="headerlink" href="#id943" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare il riutilizzo di un nome negli scope locali nidificati</p></li>
<li><p>Segnalare il riutilizzo di un nome di un membro come variabile locale in una funzione membro</p></li>
<li><p>Segnalare il riutilizzo di un nome globale come variabile locale o il nome di un membro</p></li>
<li><p>Segnalare il riutilizzo di un nome di un membro di una classe base in una classe derivata (ad eccezione dei nomi delle funzioni)</p></li>
</ul>
</section>
</section>
<section id="es-20-always-initialize-an-object">
<h4><a name="Res-always"></a>ES.20: Inizializzare sempre un oggetto<a class="headerlink" href="#es-20-always-initialize-an-object" title="Link to this heading">¶</a></h4>
<section id="id944">
<h5>Motivo<a class="headerlink" href="#id944" title="Link to this heading">¶</a></h5>
<p>Evitare errori usato-prima-della-assegnazione e l’associato comportamento indefinito. Evitare i problemi di comprensione di una inizializzazione complessa. Semplificare il refactoring.</p>
</section>
<section id="id945">
<h5>Esempio<a class="headerlink" href="#id945" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use(int arg)
{
    int i;   // bad: uninitialized variable
    // ...
    i = 7;   // initialize i
}
</pre></div>
</div>
<p>No, <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">7</span></code> non inizializza <code class="docutils literal notranslate"><span class="pre">i</span></code>; lo assegna. Inoltre, <code class="docutils literal notranslate"><span class="pre">i</span></code> può essere letta nella parte <code class="docutils literal notranslate"><span class="pre">...</span></code>. Meglio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use(int arg)   // OK
{
    int i = 7;   // OK: initialized
    string s;    // OK: default initialized
    // ...
}
</pre></div>
</div>
</section>
<section id="id946">
<h5>Nota<a class="headerlink" href="#id946" title="Link to this heading">¶</a></h5>
<p>La regola <em>inizializzare sempre</em> è deliberatamente più forte della regola del linguaggio <em>un oggetto deve essere inizializzato prima di essere usato</em>. Quest’ultima regola, più rilassata, rileva i bug tecnici, ma:</p>
<ul class="simple">
<li><p>Porta a un codice meno leggibile</p></li>
<li><p>Incoraggia a dichiarare i nomi in scope più ampi del necessario</p></li>
<li><p>Porta ad una più difficile lettura del codice</p></li>
<li><p>Porta a bug logici incoraggiando un codice complesso</p></li>
<li><p>Ostacola il refactoring</p></li>
</ul>
<p>La regola <em>inizializzare sempre</em> è una regola di stile volta a migliorare la manutenibilità, nonché è una regola che protegge dagli errori usato-prima-della-assegnazione.</p>
</section>
<section id="id947">
<h5>Esempio<a class="headerlink" href="#id947" title="Link to this heading">¶</a></h5>
<p>Ecco un esempio che viene spesso considerato per dimostrare la necessità di una regola più rilassata per l’inizializzazione</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>widget i;    // &quot;widget&quot; a type that&#39;s expensive to initialize, possibly a large trivial type
widget j;

if (cond) {  // bad: i and j are initialized &quot;late&quot;
    i = f1();
    j = f2();
}
else {
    i = f3();
    j = f4();
}
</pre></div>
</div>
<p>Questo non può essere banalmente riscritto per inizializzare <code class="docutils literal notranslate"><span class="pre">i</span></code> e <code class="docutils literal notranslate"><span class="pre">j</span></code> con gli inizializzatori. Si noti che per i tipi con un costruttore di default, il tentativo di posticipare l’inizializzazione porta semplicemente a una inizializzazione di default seguita da una assegnazione. Una popolare motivazione per questi esempi è «l’efficienza», ma un compilatore che possa rilevare se si è incappati in un errore usato-prima-della-assegnazione può anche eliminare ogni ridondante inizializzazione duplicata.</p>
<p>Supponendo che vi sia una connessione logica tra <code class="docutils literal notranslate"><span class="pre">i</span></code> e <code class="docutils literal notranslate"><span class="pre">j</span></code>, tale connessione dovrebbe probabilmente essere espressa nel codice:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pair&lt;widget, widget&gt; make_related_widgets(bool x)
{
    return (x) ? {f1(), f2()} : {f3(), f4()};
}

auto [i, j] = make_related_widgets(cond);    // C++17
</pre></div>
</div>
<p>Se la funzione <code class="docutils literal notranslate"><span class="pre">make_related_widgets</span></code> è altrimenti ridondante, possiamo eliminarla usando una lambda <a class="reference internal" href="#Res-lambda-init"><span class="xref myst">ES.28</span></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto [i, j] = [x] { return (x) ? pair{f1(), f2()} : pair{f3(), f4()} }();    // C++17
</pre></div>
</div>
<p>L’uso di un valore che rappresenta il «non-inizializzato» è un sintomo di un problema e non una soluzione:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>widget i = uninit;  // bad
widget j = uninit;

// ...
use(i);         // possibly used before set
// ...

if (cond) {     // bad: i and j are initialized &quot;late&quot;
    i = f1();
    j = f2();
}
else {
    i = f3();
    j = f4();
}
</pre></div>
</div>
<p>Ora il compilatore non può nemmeno semplicemente rilevare un usato-prima-della-assegnazione. Inoltre, abbiamo introdotto una complessità nello spazio degli stati per il widget: quali operazioni sono valide su un widget <code class="docutils literal notranslate"><span class="pre">uninit</span></code> e quali no?</p>
</section>
<section id="id948">
<h5>Nota<a class="headerlink" href="#id948" title="Link to this heading">¶</a></h5>
<p>L’inizializzazione complessa è stata popolare per decenni con i programmatori più abili. È stata anche una delle principali fonti di errori e complessità. Molti di questi errori vengono introdotti durante gli anni di manutenzione dopo l’implementazione iniziale.</p>
</section>
<section id="id949">
<h5>Esempio<a class="headerlink" href="#id949" title="Link to this heading">¶</a></h5>
<p>Questa regola riguarda i dati membri.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {
public:
    X(int i, int ci) : m2{i}, cm2{ci} {}
    // ...

private:
    int m1 = 7;
    int m2;
    int m3;

    const int cm1 = 7;
    const int cm2;
    const int cm3;
};
</pre></div>
</div>
<p>Il compilatore segnala il <code class="docutils literal notranslate"><span class="pre">cm3</span></code> non inizializzato perché è un <code class="docutils literal notranslate"><span class="pre">const</span></code>, ma non rileva l’assenza di inizializzazione di <code class="docutils literal notranslate"><span class="pre">m3</span></code>. Di solito, una rara inizializzazione del membro spurio giustifica l’assenza di errori per la mancanza di inizializzazione e spesso un ottimizzatore può eliminare un’inizializzazione ridondante (p.es., un’inizializzazione che si verifica immediatamente prima di un’assegnazione).</p>
</section>
<section id="id950">
<h5>Eccezione<a class="headerlink" href="#id950" title="Link to this heading">¶</a></h5>
<p>Se si sta dichiarando un oggetto che sta per essere inizializzato dall’input, l’inizializzazione causerebbe una doppia inizializzazione. Tuttavia, si tenga presente che ciò potrebbe lasciare dati non inizializzati dopo l’input – cosa che è stata una fertile fonte di errori e violazioni della sicurezza:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>constexpr int max = 8 * 1024;
int buf[max];         // OK, but suspicious: uninitialized
f.read(buf, max);
</pre></div>
</div>
<p>Il costo di inizializzazione di tale array potrebbe essere significativo in alcune situazioni. Tuttavia, tali esempi tendono a lasciare accessibili le variabili non inizializzate, quindi dovrebbero essere trattate con sospetto.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>constexpr int max = 8 * 1024;
int buf[max] = {};   // zero all elements; better in some situations
f.read(buf, max);
</pre></div>
</div>
<p>A causa delle regole di inizializzazione restrittive per gli array e <code class="docutils literal notranslate"><span class="pre">std::array</span></code>, offrono gli esempi più convincenti della necessità di questa eccezione.</p>
<p>Se possibile, utilizzare una funzione di libreria nota per non andare in overflow. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>string s;   // s is default initialized to &quot;&quot;
cin &gt;&gt; s;   // s expands to hold the string
</pre></div>
</div>
<p>Non considerare le variabili semplici che sono oggetto delle operazioni di input come eccezioni a questa regola:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int i;   // bad
// ...
cin &gt;&gt; i;
</pre></div>
</div>
<p>Nel caso non raro in cui gli oggetti dell’input e le operazioni di input sono separate (come non dovrebbero essere) sorge la possibilità dell’usato-prima-della-assegnazione.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int i2 = 0;   // better, assuming that zero is an acceptable value for i2
// ...
cin &gt;&gt; i2;
</pre></div>
</div>
<p>Un buon ottimizzatore dovrebbe conoscere le operazioni di input ed eliminare l’operazione ridondante.</p>
</section>
<section id="id951">
<h5>Nota<a class="headerlink" href="#id951" title="Link to this heading">¶</a></h5>
<p>A volte, una lambda può essere utilizzata come inizializzatore per evitare una variabile non inizializzata:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>error_code ec;
Value v = [&amp;] {
    auto p = get_value();   // get_value() returns a pair&lt;error_code, Value&gt;
    ec = p.first;
    return p.second;
}();
</pre></div>
</div>
<p>o forse:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Value v = [] {
    auto p = get_value();   // get_value() returns a pair&lt;error_code, Value&gt;
    if (p.first) throw Bad_value{p.first};
    return p.second;
}();
</pre></div>
</div>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Res-lambda-init"><span class="xref myst">ES.28</span></a></p>
</section>
<section id="id952">
<h5>Imposizione<a class="headerlink" href="#id952" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare ogni variabile non inizializzata. Non segnalare le variabili dei tipi user-defined con costruttori di default.</p></li>
<li><p>Controllare che un buffer non inizializzato venga scritto <em>immediatamente</em> dopo la dichiarazione. Il passaggio di una variabile non inizializzata come riferimento ad un argomento non-<code class="docutils literal notranslate"><span class="pre">const</span></code> può essere considerato come una scrittura nella variabile.</p></li>
</ul>
</section>
</section>
<section id="es-21-don-t-introduce-a-variable-or-constant-before-you-need-to-use-it">
<h4><a name="Res-introduce"></a>ES.21: Non introdurre una variabile (o una costante) prima che ne sia necessario l’uso<a class="headerlink" href="#es-21-don-t-introduce-a-variable-or-constant-before-you-need-to-use-it" title="Link to this heading">¶</a></h4>
<section id="id953">
<h5>Motivo<a class="headerlink" href="#id953" title="Link to this heading">¶</a></h5>
<p>Leggibilità. Per limitare lo scope in cui si può usare la variabile.</p>
</section>
<section id="id954">
<h5>Esempio<a class="headerlink" href="#id954" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int x = 7;
// ... no use of x here ...
++x;
</pre></div>
</div>
</section>
<section id="id955">
<h5>Imposizione<a class="headerlink" href="#id955" title="Link to this heading">¶</a></h5>
<p>Segnalare le dichiarazioni che sono distanti dal loro primo utilizzo.</p>
</section>
</section>
<section id="es-22-don-t-declare-a-variable-until-you-have-a-value-to-initialize-it-with">
<h4><a name="Res-init"></a>ES.22: Non dichiarare una variabile fin quando non si abbia un valore con cui inizializzarla<a class="headerlink" href="#es-22-don-t-declare-a-variable-until-you-have-a-value-to-initialize-it-with" title="Link to this heading">¶</a></h4>
<section id="id956">
<h5>Motivo<a class="headerlink" href="#id956" title="Link to this heading">¶</a></h5>
<p>Leggibilità. Limitare lo scope in cui sia possibile usare una variabile. Per non rischiare l’usato-prima-della-assegnazione. L’inizializzazione è spesso più efficiente dell’assegnazione.</p>
</section>
<section id="id957">
<h5>Esempio, cattivo<a class="headerlink" href="#id957" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>string s;
// ... no use of s here ...
s = &quot;what a waste&quot;;
</pre></div>
</div>
</section>
<section id="id958">
<h5>Esempio, cattivo<a class="headerlink" href="#id958" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SomeLargeType var;  // Hard-to-read CaMeLcAsEvArIaBlE

if (cond)   // some non-trivial condition
    Set(&amp;var);
else if (cond2 || !cond3) {
    var = Set2(3.14);
}
else {
    var = 0;
    for (auto&amp; e : something)
        var += e;
}

// use var; that this isn&#39;t done too early can be enforced statically with only control flow
</pre></div>
</div>
<p>Questo andrebbe bene se ci fosse un’inizializzazione di default per <code class="docutils literal notranslate"><span class="pre">SomeLargeType</span></code> che non fosse troppo costosa. Altrimenti, un programmatore potrebbe benissimo chiedersi se sia stato coperto ogni possibile percorso attraverso la rete delle condizioni. In caso contrario, abbiamo un bug «usato-prima-della-assegnazione». Questa è una trappola per la manutenzione.</p>
<p>Per gli inizializzatori di moderata complessità, comprese le variabili <code class="docutils literal notranslate"><span class="pre">const</span></code>, si prenda in considerazione l’uso di una lambda per definire l’inizializzatore; cfr. <a class="reference internal" href="#Res-lambda-init"><span class="xref myst">ES.28</span></a>.</p>
</section>
<section id="id959">
<h5>Imposizione<a class="headerlink" href="#id959" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare le dichiarazioni con inizializzazione di default che vengono assegnate prima di essere lette.</p></li>
<li><p>Segnalare qualsiasi calcolo complicato dopo una variabile non inizializzata e prima che sia usata.</p></li>
</ul>
</section>
</section>
<section id="es-23-prefer-the-initializer-syntax">
<h4><a name="Res-list"></a>ES.23: Preferire la sintassi di inizializzazione <code class="docutils literal notranslate"><span class="pre">{}</span></code><a class="headerlink" href="#es-23-prefer-the-initializer-syntax" title="Link to this heading">¶</a></h4>
<section id="id960">
<h5>Motivo<a class="headerlink" href="#id960" title="Link to this heading">¶</a></h5>
<p>Preferire <code class="docutils literal notranslate"><span class="pre">{}</span></code>. Le regole per l’inizializzazione <code class="docutils literal notranslate"><span class="pre">{}</span></code> sono più semplici, più generali, meno ambigue e più sicure delle altre forme di inizializzazione.</p>
<p>Usare <code class="docutils literal notranslate"><span class="pre">=</span></code> solo quando si è sicuri che non ci possano essere conversioni «narrowing». Per i tipi aritmetici nativi, usare <code class="docutils literal notranslate"><span class="pre">=</span></code> solo con <code class="docutils literal notranslate"><span class="pre">auto</span></code>.</p>
<p>Evitare l’inizializzazione <code class="docutils literal notranslate"><span class="pre">()</span></code>, che da adito ad ambiguità nel parser.</p>
</section>
<section id="id961">
<h5>Esempio<a class="headerlink" href="#id961" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int x {f(99)};
int y = x;
vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6};
</pre></div>
</div>
</section>
<section id="id962">
<h5>Eccezione<a class="headerlink" href="#id962" title="Link to this heading">¶</a></h5>
<p>Per i contenitori, esiste una tradizione sull’uso di <code class="docutils literal notranslate"><span class="pre">{...}</span></code> per un elenco di elementi e <code class="docutils literal notranslate"><span class="pre">(...)</span></code> per le dimensioni:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;int&gt; v1(10);    // vector of 10 elements with the default value 0
vector&lt;int&gt; v2{10};    // vector of 1 element with the value 10

vector&lt;int&gt; v3(1, 2);  // vector of 1 element with the value 2
vector&lt;int&gt; v4{1, 2};  // vector of 2 elements with the values 1 and 2
</pre></div>
</div>
</section>
<section id="id963">
<h5>Nota<a class="headerlink" href="#id963" title="Link to this heading">¶</a></h5>
<p>Gli inizializzatori <code class="docutils literal notranslate"><span class="pre">{}</span></code> non consentono le conversioni «narrowing» (e questo di solito è una cosa buona) e permettono i costruttori espliciti (il che va bene, si sta inizializzando intenzionalmente una nuova variabile).</p>
</section>
<section id="id964">
<h5>Esempio<a class="headerlink" href="#id964" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int x {7.9};   // error: narrowing
int y = 7.9;   // OK: y becomes 7. Hope for a compiler warning
int z {gsl::narrow_cast&lt;int&gt;(7.9)};    // OK: you asked for it
auto zz = gsl::narrow_cast&lt;int&gt;(7.9);  // OK: you asked for it
</pre></div>
</div>
</section>
<section id="id965">
<h5>Nota<a class="headerlink" href="#id965" title="Link to this heading">¶</a></h5>
<p>L’inizializzazione <code class="docutils literal notranslate"><span class="pre">{}</span></code> si può usare per quasi tutte le inizializzazioni; non le altre forme di inizializzazione:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto p = new vector&lt;int&gt; {1, 2, 3, 4, 5};   // initialized vector
D::D(int a, int b) :m{a, b} {   // member initializer (e.g., m might be a pair)
    // ...
};
X var {};   // initialize var to be empty
struct S {
    int m {7};   // default initializer for a member
    // ...
};
</pre></div>
</div>
<p>Per questo motivo, l’inizializzazione <code class="docutils literal notranslate"><span class="pre">{}</span></code> è spesso chiamata «inizializzazione uniforme» (sebbene purtroppo siano rimaste alcune irregolarità).</p>
</section>
<section id="id966">
<h5>Nota<a class="headerlink" href="#id966" title="Link to this heading">¶</a></h5>
<p>L’inizializzazione di una variabile dichiarata usando <code class="docutils literal notranslate"><span class="pre">auto</span></code> con un singolo valore, ad esempio, <code class="docutils literal notranslate"><span class="pre">{v}</span></code>, ha avuto risultati a sorpresa fino al C++17. Le regole del C++17 sono meno aleatorie:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto x1 {7};        // x1 is an int with the value 7
auto x2 = {7};      // x2 is an initializer_list&lt;int&gt; with an element 7

auto x11 {7, 8};    // error: two initializers
auto x22 = {7, 8};  // x22 is an initializer_list&lt;int&gt; with elements 7 and 8
</pre></div>
</div>
<p>Usare <code class="docutils literal notranslate"><span class="pre">={...}</span></code> se si vuole veramente una <code class="docutils literal notranslate"><span class="pre">initializer_list&lt;T&gt;</span></code></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto fib10 = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55};   // fib10 is a list
</pre></div>
</div>
</section>
<section id="id967">
<h5>Nota<a class="headerlink" href="#id967" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">={}</span></code> dà un’inizializzazione copia mentre <code class="docutils literal notranslate"><span class="pre">{}</span></code> dà un’inizializzazione diretta. Similmente alla stessa distinzione tra l’inizializzazione-copia e l’inizializzazione-diretta, ciò può portare a delle sorprese. <code class="docutils literal notranslate"><span class="pre">{}</span></code> accetta costruttori <code class="docutils literal notranslate"><span class="pre">explicit</span></code>; <code class="docutils literal notranslate"><span class="pre">={}</span></code> no. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Z { explicit Z() {} };

Z z1{};     // OK: direct initialization, so we use explicit constructor
Z z2 = {};  // error: copy initialization, so we cannot use the explicit constructor
</pre></div>
</div>
<p>Usare la semplice inizializzazione-<code class="docutils literal notranslate"><span class="pre">{}</span></code> a meno che non si desiderino disabilitare esplicitamente i costruttori.</p>
</section>
<section id="id968">
<h5>Esempio<a class="headerlink" href="#id968" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
void f()
{
    T x1(1);    // T initialized with 1
    T x0();     // bad: function declaration (often a mistake)

    T y1 {1};   // T initialized with 1
    T y0 {};    // default initialized T
    // ...
}
</pre></div>
</div>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#???"><span class="xref myst">Discussione</span></a></p>
</section>
<section id="id969">
<h5>Imposizione<a class="headerlink" href="#id969" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare l’uso di <code class="docutils literal notranslate"><span class="pre">=</span></code> per inizializzare i tipi aritmetici in cui si verifica il «narrowing».</p></li>
<li><p>Segnalare gli usi della sintassi di inizializzazione <code class="docutils literal notranslate"><span class="pre">()</span></code> che sono in realtà delle dichiarazioni. (Molti compilatori dovrebbero già segnalarlo).</p></li>
</ul>
</section>
</section>
<section id="es-24-use-a-unique-ptr-t-to-hold-pointers">
<h4><a name="Res-unique"></a>ES.24: Usare un <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;T&gt;</span></code> per contenere i puntatori<a class="headerlink" href="#es-24-use-a-unique-ptr-t-to-hold-pointers" title="Link to this heading">¶</a></h4>
<section id="id970">
<h5>Motivo<a class="headerlink" href="#id970" title="Link to this heading">¶</a></h5>
<p>L’uso di <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> è il modo più semplice per evirare «leak». È affidabile, fa sì che il sistema di tipi faccia gran parte del lavoro per convalidare la sicurezza della proprietà [ownership], aumenta la leggibilità e ha costi a runtime pari a zero o quasi zero.</p>
</section>
<section id="id971">
<h5>Esempio<a class="headerlink" href="#id971" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use(bool leak)
{
    auto p1 = make_unique&lt;int&gt;(7);   // OK
    int* p2 = new int{7};            // bad: might leak
    // ... no assignment to p2 ...
    if (leak) return;
    // ... no assignment to p2 ...
    vector&lt;int&gt; v(7);
    v.at(7) = 0;                    // exception thrown
    delete p2;                      // too late to prevent leaks
    // ...
}
</pre></div>
</div>
<p>Se <code class="docutils literal notranslate"><span class="pre">leak</span> <span class="pre">==</span> <span class="pre">true</span></code> l’oggetto puntato da <code class="docutils literal notranslate"><span class="pre">p2</span></code> è perso [leak] e l’oggetto puntato da <code class="docutils literal notranslate"><span class="pre">p1</span></code> non lo è. Lo stesso vale quando <code class="docutils literal notranslate"><span class="pre">at()</span></code> solleva un errore. In entrambi i casi, l’istruzione <code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">p2</span></code> non viene raggiunta.</p>
</section>
<section id="id972">
<h5>Imposizione<a class="headerlink" href="#id972" title="Link to this heading">¶</a></h5>
<p>Si cercano i puntatori che siano destinatari di <code class="docutils literal notranslate"><span class="pre">new</span></code>, <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> e le funzioni che potrebbero restituire tali puntatori.</p>
</section>
</section>
<section id="es-25-declare-an-object-const-or-constexpr-unless-you-want-to-modify-its-value-later-on">
<h4><a name="Res-const"></a>ES.25: Dichiarare un oggetto <code class="docutils literal notranslate"><span class="pre">const</span></code> o <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> a meno che non se ne voglia, in seguito, modificare il valore<a class="headerlink" href="#es-25-declare-an-object-const-or-constexpr-unless-you-want-to-modify-its-value-later-on" title="Link to this heading">¶</a></h4>
<section id="id973">
<h5>Motivo<a class="headerlink" href="#id973" title="Link to this heading">¶</a></h5>
<p>In questo modo non è possibile modificare il valore per errore. In questo modo si potrebbe dare opportunità di ottimizzazione del compilatore.</p>
</section>
<section id="id974">
<h5>Esempio<a class="headerlink" href="#id974" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int n)
{
    const int bufmax = 2 * n + 2;  // good: we can&#39;t change bufmax by accident
    int xmax = n;                  // suspicious: is xmax intended to change?
    // ...
}
</pre></div>
</div>
</section>
<section id="id975">
<h5>Imposizione<a class="headerlink" href="#id975" title="Link to this heading">¶</a></h5>
<p>Cercare se una variabile viene effettivamente mutata e la segnala se non lo è. Sfortunatamente, potrebbe essere impossibile rilevare quando una non-<code class="docutils literal notranslate"><span class="pre">const</span></code> non era <em>destinata</em> a cambiare (rispetto a quando semplicemente non è stata variata).</p>
</section>
</section>
<section id="es-26-don-t-use-a-variable-for-two-unrelated-purposes">
<h4><a name="Res-recycle"></a>ES.26: Non usare una variabile per due usi non correlati<a class="headerlink" href="#es-26-don-t-use-a-variable-for-two-unrelated-purposes" title="Link to this heading">¶</a></h4>
<section id="id976">
<h5>Motivo<a class="headerlink" href="#id976" title="Link to this heading">¶</a></h5>
<p>Leggibilità e sicurezza.</p>
</section>
<section id="id977">
<h5>Esempio, cattivo<a class="headerlink" href="#id977" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use()
{
    int i;
    for (i = 0; i &lt; 20; ++i) { /* ... */ }
    for (i = 0; i &lt; 200; ++i) { /* ... */ } // bad: i recycled
}
</pre></div>
</div>
</section>
<section id="id978">
<h5>Nota<a class="headerlink" href="#id978" title="Link to this heading">¶</a></h5>
<p>Come ottimizzazione, si potrebbe voler ri-utilizzare un buffer come un block-note, ma anche in questo caso si preferisca limitare lo “scope” della variabile il più possibile e si faccia attenzione a non provocare bug dai dati lasciati in un buffer riciclato in quanto questa è una comune sorgente di bug sulla sicurezza.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void write_to_file()
{
    std::string buffer;             // to avoid reallocations on every loop iteration
    for (auto&amp; o : objects) {
        // First part of the work.
        generate_first_string(buffer, o);
        write_to_file(buffer);

        // Second part of the work.
        generate_second_string(buffer, o);
        write_to_file(buffer);

        // etc...
    }
}
</pre></div>
</div>
</section>
<section id="id979">
<h5>Imposizione<a class="headerlink" href="#id979" title="Link to this heading">¶</a></h5>
<p>Segnalare le variabili riciclate.</p>
</section>
</section>
<section id="es-27-use-std-array-or-stack-array-for-arrays-on-the-stack">
<h4><a name="Res-stack"></a>ES.27: Usare <code class="docutils literal notranslate"><span class="pre">std::array</span></code> o <code class="docutils literal notranslate"><span class="pre">stack_array</span></code> per gli array sullo stack<a class="headerlink" href="#es-27-use-std-array-or-stack-array-for-arrays-on-the-stack" title="Link to this heading">¶</a></h4>
<section id="id980">
<h5>Motivo<a class="headerlink" href="#id980" title="Link to this heading">¶</a></h5>
<p>Sono leggibili e non implicitamente convertiti in puntatori. Non vengono confusi con le estensioni non-standard degli array nativi [built-in].</p>
</section>
<section id="id981">
<h5>Esempio, cattivo<a class="headerlink" href="#id981" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const int n = 7;
int m = 9;

void f()
{
    int a1[n];
    int a2[m];   // error: not ISO C++
    // ...
}
</pre></div>
</div>
</section>
<section id="id982">
<h5>Nota<a class="headerlink" href="#id982" title="Link to this heading">¶</a></h5>
<p>La definizione di <code class="docutils literal notranslate"><span class="pre">a1</span></code> è C++ legale e c’è sempre stata. C’è molto codice come questo. Tuttavia, è soggetto a errori, soprattutto quando la dimensione [bound] non è locale. Inoltre, è una fonte «popolare» di errori (overflow del buffer, puntatori dalla conversione [decay] degli array, ecc.). La definizione di <code class="docutils literal notranslate"><span class="pre">a2</span></code> è C ma non C++ ed è considerato un rischio per la sicurezza</p>
</section>
<section id="id983">
<h5>Esempio<a class="headerlink" href="#id983" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const int n = 7;
int m = 9;

void f()
{
    array&lt;int, n&gt; a1;
    stack_array&lt;int&gt; a2(m);
    // ...
}
</pre></div>
</div>
</section>
<section id="id984">
<h5>Imposizione<a class="headerlink" href="#id984" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare gli array con dimensioni [bound] non-costanti (VLA [Variable Length Array] del C)</p></li>
<li><p>Segnalare gli array con dimensioni costanti non-locali</p></li>
</ul>
</section>
</section>
<section id="es-28-use-lambdas-for-complex-initialization-especially-of-const-variables">
<h4><a name="Res-lambda-init"></a>ES.28: Usare le lambda per delle inizializzazioni complesse, specialmente di variabili <code class="docutils literal notranslate"><span class="pre">const</span></code><a class="headerlink" href="#es-28-use-lambdas-for-complex-initialization-especially-of-const-variables" title="Link to this heading">¶</a></h4>
<section id="id985">
<h5>Motivo<a class="headerlink" href="#id985" title="Link to this heading">¶</a></h5>
<p>Incapsula bene l’inizializzazione locale, inclusa la pulizia delle variabili necessaria solo per l’inizializzazione, senza la necessità di creare una funzione non locale e non riutilizzabile. Funziona anche con variabili che dovrebbero essere <code class="docutils literal notranslate"><span class="pre">const</span></code> ma solo dopo alcune operazioni di inizializzazione.</p>
</section>
<section id="id986">
<h5>Esempio, cattivo<a class="headerlink" href="#id986" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>widget x;   // should be const, but:
for (auto i = 2; i &lt;= N; ++i) {          // this could be some
    x += some_obj.do_something_with(i);  // arbitrarily long code
}                                        // needed to initialize x
// from here, x should be const, but we can&#39;t say so in code in this style
</pre></div>
</div>
</section>
<section id="id987">
<h5>Esempio, buono<a class="headerlink" href="#id987" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const widget x = [&amp;] {
    widget val;                                // assume that widget has a default constructor
    for (auto i = 2; i &lt;= N; ++i) {            // this could be some
        val += some_obj.do_something_with(i);  // arbitrarily long code
    }                                          // needed to initialize x
    return val;
}();
</pre></div>
</div>
<p>Se possibile, si riducano le condizioni ad un semplice insieme di alternative (p.es., un <code class="docutils literal notranslate"><span class="pre">enum</span></code>) e non si confonda la selezione con l’inizializzazione.</p>
</section>
<section id="id988">
<h5>Imposizione<a class="headerlink" href="#id988" title="Link to this heading">¶</a></h5>
<p>Difficile. Nel migliore dei casi è una euristica. Cercare una variabile non inizializzata seguita da un ciclo in cui la si assegna.</p>
</section>
</section>
<section id="es-30-don-t-use-macros-for-program-text-manipulation">
<h4><a name="Res-macros"></a>ES.30: Non usare le macro per manipolare il testo del programma<a class="headerlink" href="#es-30-don-t-use-macros-for-program-text-manipulation" title="Link to this heading">¶</a></h4>
<section id="id989">
<h5>Motivo<a class="headerlink" href="#id989" title="Link to this heading">¶</a></h5>
<p>Le macro sono una delle principali fonti di bug. Le macro non obbediscono alle normali regole di scope e dei tipi. Le macro fanno sì che il lettore umano veda qualcosa di diverso da ciò che vede il compilatore. Le macro complicano gli strumenti di building.</p>
</section>
<section id="id990">
<h5>Esempio, cattivo<a class="headerlink" href="#id990" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define Case break; case   /* BAD */
</pre></div>
</div>
<p>Questa macro dall’aspetto innocuo trasforma una singola <code class="docutils literal notranslate"><span class="pre">c</span></code> minuscola invece di una <code class="docutils literal notranslate"><span class="pre">C</span></code> in un brutto bug sul controllo del flusso.</p>
</section>
<section id="id991">
<h5>Nota<a class="headerlink" href="#id991" title="Link to this heading">¶</a></h5>
<p>Questa regola non vieta l’uso delle macro per il «controllo della configurazione» usate negli <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code>, ecc.</p>
<p>In futuro, è probabile che i moduli eliminino la necessità di macro nel controllo della configurazione.</p>
</section>
<section id="id992">
<h5>Nota<a class="headerlink" href="#id992" title="Link to this heading">¶</a></h5>
<p>Questa regola ha lo scopo di scoraggiare anche l’uso di <code class="docutils literal notranslate"><span class="pre">#</span></code> per la «stringification» e di <code class="docutils literal notranslate"><span class="pre">##</span></code> per la concatenazione. Come è solito per le macro, ci sono usi «per lo più innocui», ma anche questi possono creare problemi a tool, come i “completatori” automatici, gli analizzatori statici, e i debugger. Spesso il desiderio di utilizzare macro fantasiose è un segno di un design troppo complesso. Inoltre, <code class="docutils literal notranslate"><span class="pre">#</span></code> e <code class="docutils literal notranslate"><span class="pre">##</span></code> incoraggiano la definizione e l’uso delle macro:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define CAT(a, b) a ## b
#define STRINGIFY(a) #a

void f(int x, int y)
{
    string CAT(x, y) = &quot;asdf&quot;;   // BAD: hard for tools to handle (and ugly)
    string sx2 = STRINGIFY(x);
    // ...
}
</pre></div>
</div>
<p>Esistono soluzioni alternative per la gestione delle stringhe di basso livello utilizzando le macro. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum E { a, b };

template&lt;int x&gt;
constexpr const char* stringify()
{
    switch (x) {
    case a: return &quot;a&quot;;
    case b: return &quot;b&quot;;
    }
}

void f()
{
    string s1 = stringify&lt;a&gt;();
    string s2 = stringify&lt;b&gt;();
    // ...
}
</pre></div>
</div>
<p>Questo non è conveniente come una macro da definire, ma altrettanto facile da usare, ha zero overhead ed è tipizzato e ha uno scope.</p>
<p>In futuro, è probabile che la riflessione statica [static reflection] elimini gli ultimi bisogni del preprocessore per la manipolazione del testo del programma.</p>
</section>
<section id="id993">
<h5>Imposizione<a class="headerlink" href="#id993" title="Link to this heading">¶</a></h5>
<p>Ci si allarmi quando si vede una macro che non sia usata per il controllo del sorgente (p.es., <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code>)</p>
</section>
</section>
<section id="es-31-don-t-use-macros-for-constants-or-functions">
<h4><a name="Res-macros2"></a>ES.31: Non usare le macro per le costanti o le «funzioni»<a class="headerlink" href="#es-31-don-t-use-macros-for-constants-or-functions" title="Link to this heading">¶</a></h4>
<section id="id994">
<h5>Motivo<a class="headerlink" href="#id994" title="Link to this heading">¶</a></h5>
<p>Le macro sono una delle principali fonti di bug. Le macro non obbediscono alle normali regole di scope e dei tipi. Le macro non obbediscono alle solite regole per il passaggio degli argomenti. Le macro fanno sì che il lettore umano veda qualcosa di diverso da ciò che vede il compilatore. Le macro complicano gli strumenti di building.</p>
</section>
<section id="id995">
<h5>Esempio, cattivo<a class="headerlink" href="#id995" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define PI 3.14
#define SQUARE(a, b) (a * b)
</pre></div>
</div>
<p>Anche se non avessimo lasciato un ben noto bug in <code class="docutils literal notranslate"><span class="pre">SQUARE</span></code> ci sono corrette alternative molto migliori; per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>constexpr double pi = 3.14;
template&lt;typename T&gt; T square(T a, T b) { return a * b; }
</pre></div>
</div>
</section>
<section id="id996">
<h5>Imposizione<a class="headerlink" href="#id996" title="Link to this heading">¶</a></h5>
<p>Ci si allarmi quando si vede una macro che non sia usata per il controllo del sorgente (p.es., <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code>)</p>
</section>
</section>
<section id="es-32-use-all-caps-for-all-macro-names">
<h4><a name="Res-ALL_CAPS"></a>ES.32: Usare il <code class="docutils literal notranslate"><span class="pre">TUTTO_IN_MAIUSCOLO</span></code> per tutti i nomi delle macro<a class="headerlink" href="#es-32-use-all-caps-for-all-macro-names" title="Link to this heading">¶</a></h4>
<section id="id997">
<h5>Motivo<a class="headerlink" href="#id997" title="Link to this heading">¶</a></h5>
<p>Convenzione. Leggibilità. Distinzione delle macro.</p>
</section>
<section id="id998">
<h5>Esempio<a class="headerlink" href="#id998" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define forever for (;;)   /* very BAD */

#define FOREVER for (;;)   /* Still evil, but at least visible to humans */
</pre></div>
</div>
</section>
<section id="id999">
<h5>Imposizione<a class="headerlink" href="#id999" title="Link to this heading">¶</a></h5>
<p>Ci si allarmi quando si vede una macro in minuscolo.</p>
</section>
</section>
<section id="es-33-if-you-must-use-macros-give-them-unique-names">
<h4><a name="Res-MACROS"></a>ES.33: Se è necessario usare le macro, dargli dei nomi univoci<a class="headerlink" href="#es-33-if-you-must-use-macros-give-them-unique-names" title="Link to this heading">¶</a></h4>
<section id="id1000">
<h5>Motivo<a class="headerlink" href="#id1000" title="Link to this heading">¶</a></h5>
<p>Le macro non obbediscono alle regole dello scope.</p>
</section>
<section id="id1001">
<h5>Esempio<a class="headerlink" href="#id1001" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define MYCHAR        /* BAD, will eventually clash with someone else&#39;s MYCHAR*/

#define ZCORP_CHAR    /* Still evil, but less likely to clash */
</pre></div>
</div>
</section>
<section id="id1002">
<h5>Nota<a class="headerlink" href="#id1002" title="Link to this heading">¶</a></h5>
<p>Evitare le macro se possibile: <a class="reference internal" href="#Res-macros"><span class="xref myst">ES.30</span></a>, <a class="reference internal" href="#Res-macros2"><span class="xref myst">ES.31</span></a> e <a class="reference internal" href="#Res-ALL_CAPS"><span class="xref myst">ES.32</span></a>. Tuttavia, ci sono miliardi di righe di codice disseminate di macro e una lunga tradizione sull’uso e sull’abuso delle macro. Se si è costretti a utilizzare le macro, si utilizzino nomi lunghi e prefissi possibilmente univoci (ad esempio, il nome della propria organizzazione) per ridurre la probabilità di un conflitto.</p>
</section>
<section id="id1003">
<h5>Imposizione<a class="headerlink" href="#id1003" title="Link to this heading">¶</a></h5>
<p>Emettere un warning sui nomi di macro troppo brevi.</p>
</section>
</section>
<section id="es-34-don-t-define-a-c-style-variadic-function">
<h4><a name="Res-ellipses"></a> ES.34: Non definire una funzione variadica (C-style)<a class="headerlink" href="#es-34-don-t-define-a-c-style-variadic-function" title="Link to this heading">¶</a></h4>
<section id="id1004">
<h5>Motivo<a class="headerlink" href="#id1004" title="Link to this heading">¶</a></h5>
<p>Non è «type safe». Richiede un codice disordinato per il-cast-e-pieno-di-macro per funzionare correttamente.</p>
</section>
<section id="id1005">
<h5>Esempio<a class="headerlink" href="#id1005" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;cstdarg&gt;

// &quot;severity&quot; followed by a zero-terminated list of char*s; write the C-style strings to cerr
void error(int severity ...)
{
    va_list ap;             // a magic type for holding arguments
    va_start(ap, severity); // arg startup: &quot;severity&quot; is the first argument of error()

    for (;;) {
        // treat the next var as a char*; no checking: a cast in disguise
        char* p = va_arg(ap, char*);
        if (!p) break;
        cerr &lt;&lt; p &lt;&lt; &#39; &#39;;
    }

    va_end(ap);             // arg cleanup (don&#39;t forget this)

    cerr &lt;&lt; &#39;\n&#39;;
    if (severity) exit(severity);
}

void use()
{
    error(7, &quot;this&quot;, &quot;is&quot;, &quot;an&quot;, &quot;error&quot;, nullptr);
    error(7); // crash
    error(7, &quot;this&quot;, &quot;is&quot;, &quot;an&quot;, &quot;error&quot;);  // crash
    const char* is = &quot;is&quot;;
    string an = &quot;an&quot;;
    error(7, &quot;this&quot;, is, an, &quot;error&quot;); // crash
}
</pre></div>
</div>
<p><strong>Alternativa</strong>: L’overloading. I template. I template variadici.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;iostream&gt;

void error(int severity)
{
    std::cerr &lt;&lt; &#39;\n&#39;;
    std::exit(severity);
}

template&lt;typename T, typename... Ts&gt;
constexpr void error(int severity, T head, Ts... tail)
{
    std::cerr &lt;&lt; head;
    error(severity, tail...);
}

void use()
{
    error(7); // No crash!
    error(5, &quot;this&quot;, &quot;is&quot;, &quot;not&quot;, &quot;an&quot;, &quot;error&quot;); // No crash!

    std::string an = &quot;an&quot;;
    error(7, &quot;this&quot;, &quot;is&quot;, &quot;not&quot;, an, &quot;error&quot;); // No crash!

    error(5, &quot;oh&quot;, &quot;no&quot;, nullptr); // Compile error! No need for nullptr.
}
</pre></div>
</div>
</section>
<section id="id1006">
<h5>Nota<a class="headerlink" href="#id1006" title="Link to this heading">¶</a></h5>
<p>Questo è fondamentalmente il modo in cui è implementato <code class="docutils literal notranslate"><span class="pre">printf</span></code>.</p>
</section>
<section id="id1007">
<h5>Imposizione<a class="headerlink" href="#id1007" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare le definizioni in stile C delle funzioni variadiche.</p></li>
<li><p>Segnalare <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;cstdarg&gt;</span></code> e <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;stdarg.h&gt;</span></code></p></li>
</ul>
</section>
</section>
</section>
<section id="es-expr-expressions">
<h3>ES.expr: Espressioni<a class="headerlink" href="#es-expr-expressions" title="Link to this heading">¶</a></h3>
<p>Le espressioni cambiano i valori.</p>
<section id="es-40-avoid-complicated-expressions">
<h4><a name="Res-complicated"></a>ES.40: Evitare espressioni complicate<a class="headerlink" href="#es-40-avoid-complicated-expressions" title="Link to this heading">¶</a></h4>
<section id="id1008">
<h5>Motivo<a class="headerlink" href="#id1008" title="Link to this heading">¶</a></h5>
<p>Le espressioni complicate sono soggette a errori.</p>
</section>
<section id="id1009">
<h5>Esempio<a class="headerlink" href="#id1009" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// bad: assignment hidden in subexpression
while ((c = getc()) != -1)

// bad: two non-local variables assigned in sub-expressions
while ((cin &gt;&gt; c1, cin &gt;&gt; c2), c1 == c2)

// better, but possibly still too complicated
for (char c1, c2; cin &gt;&gt; c1 &gt;&gt; c2 &amp;&amp; c1 == c2;)

// OK: if i and j are not aliased
int x = ++i + ++j;

// OK: if i != j and i != k
v[i] = v[j] + v[k];

// bad: multiple assignments &quot;hidden&quot; in subexpressions
x = a + (b = f()) + (c = g()) * 7;

// bad: relies on commonly misunderstood precedence rules
x = a &amp; b + c * d &amp;&amp; e ^ f == 7;

// bad: undefined behavior
x = x++ + x++ + ++x;
</pre></div>
</div>
<p>Alcune di queste espressioni sono incondizionatamente cattive (p.es., si basano su comportamenti indefiniti). Altre sono semplicemente così complicate e/o insolite che persino i bravi programmatori potrebbero fraintenderle o trascurare un problema nella fretta.</p>
</section>
<section id="id1010">
<h5>Nota<a class="headerlink" href="#id1010" title="Link to this heading">¶</a></h5>
<p>Il C++17 inasprisce le regole per l’ordine di valutazione (da sinistra a destra, tranne da destra a sinistra nelle assegnazioni, e l’ordine di valutazione degli argomenti della funzione non è specificato; <a class="reference internal" href="#Res-order"><span class="xref myst">cfr. ES.43</span></a>), ma ciò non cambia il fatto che le espressioni complicate sono potenzialmente confuse.</p>
</section>
<section id="id1011">
<h5>Nota<a class="headerlink" href="#id1011" title="Link to this heading">¶</a></h5>
<p>Un programmatore dovrebbe conoscere e utilizzare le regole di base per le espressioni.</p>
</section>
<section id="id1012">
<h5>Esempio<a class="headerlink" href="#id1012" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>x = k * y + z;             // OK

auto t1 = k * y;           // bad: unnecessarily verbose
x = t1 + z;

if (0 &lt;= x &amp;&amp; x &lt; max)   // OK

auto t1 = 0 &lt;= x;        // bad: unnecessarily verbose
auto t2 = x &lt; max;
if (t1 &amp;&amp; t2)            // ...
</pre></div>
</div>
</section>
<section id="id1013">
<h5>Imposizione<a class="headerlink" href="#id1013" title="Link to this heading">¶</a></h5>
<p>Difficile. Quanto complicata deve essere un’espressione per essere considerata complicata? Anche scrivere calcoli come dichiarazioni con una sola operazione è fonte di confusione. Cose da considerare:</p>
<ul class="simple">
<li><p>effetti collaterali: gli effetti collaterali su più variabili non locali (per qualche definizioni di non locale) possono insospettire, specialmente se gli effetti collaterali sono in sottoespressioni separate</p></li>
<li><p>scrive su variabili con alias [aliased]</p></li>
<li><p>più di N operatori (e quanto dovrebbe valere N?)</p></li>
<li><p>dipendenza da sottili regole di precedenza</p></li>
<li><p>usa un comportamento indefinito (possiamo capire tutto il comportamento indefinito?)</p></li>
<li><p>comportamento definito dall’implementazione?</p></li>
<li><p>???</p></li>
</ul>
</section>
</section>
<section id="es-41-if-in-doubt-about-operator-precedence-parenthesize">
<h4><a name="Res-parens"></a>ES.41: In caso di dubbio sulla precedenza degli operatori, usare le parentesi<a class="headerlink" href="#es-41-if-in-doubt-about-operator-precedence-parenthesize" title="Link to this heading">¶</a></h4>
<section id="id1014">
<h5>Motivo<a class="headerlink" href="#id1014" title="Link to this heading">¶</a></h5>
<p>Evitare errori. Leggibilità. Non tutti ricordano a memoria la tabella degli operatori.</p>
</section>
<section id="id1015">
<h5>Esempio<a class="headerlink" href="#id1015" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const unsigned int flag = 2;
unsigned int a = flag;

if (a &amp; flag != 0)  // bad: means a&amp;(flag != 0)
</pre></div>
</div>
<p>Nota: Si raccomanda ai programmatori di prendere visione della tabella delle precedenze per le operazioni aritmetiche, quella delle operazioni logiche, ma si prenda in considerazione di mescolare le operazioni logiche bit a bit con gli altri operatori che necessitano delle parentesi.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if ((a &amp; flag) != 0)  // OK: works as intended
</pre></div>
</div>
</section>
<section id="id1016">
<h5>Nota<a class="headerlink" href="#id1016" title="Link to this heading">¶</a></h5>
<p>Si dovrebbe essere abbastanza esperti da non aver bisogno delle parentesi per:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (a &lt; 0 || a &lt;= max) {
    // ...
}
</pre></div>
</div>
</section>
<section id="id1017">
<h5>Imposizione<a class="headerlink" href="#id1017" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare le combinazioni di operazioni logiche con altri operatori.</p></li>
<li><p>Segnalare gli operatori di assegnazioni non come un operatore all’estrema sinistra.</p></li>
<li><p>???</p></li>
</ul>
</section>
</section>
<section id="es-42-keep-use-of-pointers-simple-and-straightforward">
<h4><a name="Res-ptr"></a>ES.42: Usare in modo semplice e diretto i puntatori<a class="headerlink" href="#es-42-keep-use-of-pointers-simple-and-straightforward" title="Link to this heading">¶</a></h4>
<section id="id1018">
<h5>Motivo<a class="headerlink" href="#id1018" title="Link to this heading">¶</a></h5>
<p>La gestione dei puntatori complicati è una delle principali fonti di errori.</p>
</section>
<section id="id1019">
<h5>Nota<a class="headerlink" href="#id1019" title="Link to this heading">¶</a></h5>
<p>Usare, invece, <code class="docutils literal notranslate"><span class="pre">gsl::span</span></code>. I puntatori dovrebbero <a class="reference internal" href="#Ri-array"><span class="xref myst">fare riferimento solo a singoli oggetti</span></a>. L’aritmetica dei puntatori è fragile e facile da sbagliare, la fonte di molti, molti bug e violazioni della sicurezza. <code class="docutils literal notranslate"><span class="pre">span</span></code> è un tipo sicuro, col controllo dei limiti [bounds-checked], per l’accesso ai dati degli array. L’accesso a un array con limiti noti che utilizza una costante come indice può essere convalidato dal compilatore.</p>
</section>
<section id="id1020">
<h5>Esempio, cattivo<a class="headerlink" href="#id1020" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int* p, int count)
{
    if (count &lt; 2) return;

    int* q = p + 1;    // BAD

    ptrdiff_t d;
    int n;
    d = (p - &amp;n);      // OK
    d = (q - p);       // OK

    int n = *p++;      // BAD

    if (count &lt; 6) return;

    p[4] = 1;          // BAD

    p[count - 1] = 2;  // BAD

    use(&amp;p[0], 3);     // BAD
}
</pre></div>
</div>
</section>
<section id="id1021">
<h5>Esempio, buono<a class="headerlink" href="#id1021" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(span&lt;int&gt; a) // BETTER: use span in the function declaration
{
    if (a.size() &lt; 2) return;

    int n = a[0];      // OK

    span&lt;int&gt; q = a.subspan(1); // OK

    if (a.size() &lt; 6) return;

    a[4] = 1;          // OK

    a[a.size() - 1] = 2;  // OK

    use(a.data(), 3);  // OK
}
</pre></div>
</div>
</section>
<section id="id1022">
<h5>Nota<a class="headerlink" href="#id1022" title="Link to this heading">¶</a></h5>
<p>L’indicizzazione tramite una variabile è difficile da convalidare sia per i tool che per gli umani. <code class="docutils literal notranslate"><span class="pre">span</span></code> è un tipo sicuro, col controllo dei limiti [bounds-checked], per l’accesso ai dati degli array. <code class="docutils literal notranslate"><span class="pre">at()</span></code> è un’ulteriore alternativa che garantisce che i singoli accessi controllino i limiti. Se sono necessari iteratori per accedere a un array, utilizzare gli iteratori da uno <code class="docutils literal notranslate"><span class="pre">span</span></code> costruito sull’array.</p>
</section>
<section id="id1023">
<h5>Esempio, cattivo<a class="headerlink" href="#id1023" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(array&lt;int, 10&gt; a, int pos)
{
    a[pos / 2] = 1; // BAD
    a[pos - 1] = 2; // BAD
    a[-1] = 3;    // BAD (but easily caught by tools) -- no replacement, just don&#39;t do this
    a[10] = 4;    // BAD (but easily caught by tools) -- no replacement, just don&#39;t do this
}
</pre></div>
</div>
</section>
<section id="id1024">
<h5>Esempio, buono<a class="headerlink" href="#id1024" title="Link to this heading">¶</a></h5>
<p>Usare uno <code class="docutils literal notranslate"><span class="pre">span</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f1(span&lt;int, 10&gt; a, int pos) // A1: Change parameter type to use span
{
    a[pos / 2] = 1; // OK
    a[pos - 1] = 2; // OK
}

void f2(array&lt;int, 10&gt; arr, int pos) // A2: Add local span and use that
{
    span&lt;int&gt; a = {arr.data(), pos};
    a[pos / 2] = 1; // OK
    a[pos - 1] = 2; // OK
}
</pre></div>
</div>
<p>Usare <code class="docutils literal notranslate"><span class="pre">at()</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f3(array&lt;int, 10&gt; a, int pos) // ALTERNATIVE B: Use at() for access
{
    at(a, pos / 2) = 1; // OK
    at(a, pos - 1) = 2; // OK
}
</pre></div>
</div>
</section>
<section id="id1025">
<h5>Esempio, cattivo<a class="headerlink" href="#id1025" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    int arr[COUNT];
    for (int i = 0; i &lt; COUNT; ++i)
        arr[i] = i; // BAD, cannot use non-constant indexer
}
</pre></div>
</div>
</section>
<section id="id1026">
<h5>Esempio, buono<a class="headerlink" href="#id1026" title="Link to this heading">¶</a></h5>
<p>Usare uno <code class="docutils literal notranslate"><span class="pre">span</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f1()
{
    int arr[COUNT];
    span&lt;int&gt; av = arr;
    for (int i = 0; i &lt; COUNT; ++i)
        av[i] = i;
}
</pre></div>
</div>
<p>Usare uno <code class="docutils literal notranslate"><span class="pre">span</span></code> e range-<code class="docutils literal notranslate"><span class="pre">for</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f1a()
{
     int arr[COUNT];
     span&lt;int, COUNT&gt; av = arr;
     int i = 0;
     for (auto&amp; e : av)
         e = i++;
}
</pre></div>
</div>
<p>Usare <code class="docutils literal notranslate"><span class="pre">at()</span></code> per l’accesso:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f2()
{
    int arr[COUNT];
    for (int i = 0; i &lt; COUNT; ++i)
        at(arr, i) = i;
}
</pre></div>
</div>
<p>Usare un range-<code class="docutils literal notranslate"><span class="pre">for</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f3()
{
    int arr[COUNT];
    int i = 0;
    for (auto&amp; e : arr)
         e = i++;
}
</pre></div>
</div>
</section>
<section id="id1027">
<h5>Nota<a class="headerlink" href="#id1027" title="Link to this heading">¶</a></h5>
<p>I tool possono proporre una riscrittura degli accessi agli array che implichi, invece, l’uso di espressioni di indici dinamici <code class="docutils literal notranslate"><span class="pre">at()</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int a[10];

void f(int i, int j)
{
    a[i + j] = 12;      // BAD, could be rewritten as ...
    at(a, i + j) = 12;  // OK -- bounds-checked
}
</pre></div>
</div>
</section>
<section id="id1028">
<h5>Esempio<a class="headerlink" href="#id1028" title="Link to this heading">¶</a></h5>
<p>Trasformare un array in un puntatore (come essenzialmente fa sempre il linguaggio) toglie la possibilità di controllare i limiti, quindi lo si eviti</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void g(int* p);

void f()
{
    int a[5];
    g(a);        // BAD: are we trying to pass an array?
    g(&amp;a[0]);    // OK: passing one object
}
</pre></div>
</div>
<p>Se si vuole passare un array, diciamo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void g(int* p, size_t length);  // old (dangerous) code

void g1(span&lt;int&gt; av); // BETTER: get g() changed.

void f2()
{
    int a[5];
    span&lt;int&gt; av = a;

    g(av.data(), av.size());   // OK, if you have no choice
    g1(a);                     // OK -- no decay here, instead use implicit span ctor
}
</pre></div>
</div>
</section>
<section id="id1029">
<h5>Imposizione<a class="headerlink" href="#id1029" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare qualsiasi operazione aritmetica su un’espressione di tipo puntatore che dia come risultato un valore di tipo puntatore.</p></li>
<li><p>Segnalare qualsiasi espressione di indicizzazione su un’espressione o una variabile di tipo array (sia un array statico che uno <code class="docutils literal notranslate"><span class="pre">std::array</span></code>) in cui l’indicizzatore non è un’espressione costante in fase di compilazione con un valore compreso tra <code class="docutils literal notranslate"><span class="pre">0</span></code> e il limite superiore dell’array.</p></li>
<li><p>Segnalare qualsiasi espressione che si baserebbe sulla conversione implicita di un array in un puntatore.</p></li>
</ul>
<p>Questa regola fa parte del <a class="reference internal" href="#SS-bounds"><span class="xref myst">profilo di sicurezza dei limiti</span></a>.</p>
</section>
</section>
<section id="es-43-avoid-expressions-with-undefined-order-of-evaluation">
<h4><a name="Res-order"></a>ES.43: Evitare espressioni con un ordine di valutazione incerto<a class="headerlink" href="#es-43-avoid-expressions-with-undefined-order-of-evaluation" title="Link to this heading">¶</a></h4>
<section id="id1030">
<h5>Motivo<a class="headerlink" href="#id1030" title="Link to this heading">¶</a></h5>
<p>Non si ha alcuna idea di cosa faccia questo codice. Portabilità. Anche se sembra fare qualcosa di ragionevole, potrebbe fare altro su un altro compilatore (p.es., la successiva release del proprio compilatore) o con un diverso settaggio dell’ottimizzatore.</p>
</section>
<section id="id1031">
<h5>Nota<a class="headerlink" href="#id1031" title="Link to this heading">¶</a></h5>
<p>Il C++17 inasprisce le regole per l’ordine di valutazione: da-sinistra-a-destra, tranne da destra a sinistra nelle assegnazioni, e l’ordine di valutazione degli argomenti della funzione non è specificato.</p>
<p>Tuttavia, si ricordi che il codice potrebbe essere compilato con un compilatore pre-C++17 (p.es., tramite il taglia-incolla) quindi non ci si comporti troppo da esperti..</p>
</section>
<section id="id1032">
<h5>Esempio<a class="headerlink" href="#id1032" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>v[i] = ++i;   //  the result is undefined
</pre></div>
</div>
<p>Una buona regola empirica è che non si dovrebbe leggere due volte un valore in un’espressione che si sta scrivendo.</p>
</section>
<section id="id1033">
<h5>Imposizione<a class="headerlink" href="#id1033" title="Link to this heading">¶</a></h5>
<p>Può essere rilevato da un buon analizzatore.</p>
</section>
</section>
<section id="es-44-don-t-depend-on-order-of-evaluation-of-function-arguments">
<h4><a name="Res-order-fct"></a>ES.44: Non dipendere dall’ordine di valutazione degli argomenti di una funzione<a class="headerlink" href="#es-44-don-t-depend-on-order-of-evaluation-of-function-arguments" title="Link to this heading">¶</a></h4>
<section id="id1034">
<h5>Motivo<a class="headerlink" href="#id1034" title="Link to this heading">¶</a></h5>
<p>Perché quell’ordine non è specificato.</p>
</section>
<section id="id1035">
<h5>Nota<a class="headerlink" href="#id1035" title="Link to this heading">¶</a></h5>
<p>Il C++17 inasprisce le regole per l’ordine di valutazione, ma l’ordine di valutazione degli argomenti della funzione non è ancora specificato.</p>
</section>
<section id="id1036">
<h5>Esempio<a class="headerlink" href="#id1036" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int i = 0;
f(++i, ++i);
</pre></div>
</div>
<p>Prima del C++17, il comportamento non era indefinito, quindi poteva essere qualsiasi cosa (p.es., <code class="docutils literal notranslate"><span class="pre">f(2,</span> <span class="pre">2)</span></code>). Dal C++17, questo codice non ha più un comportamento indefinito, ma non è ancora specificato quale argomento viene valutato per primo. La chiamata sarà <code class="docutils literal notranslate"><span class="pre">f(1,</span> <span class="pre">2)</span></code> o <code class="docutils literal notranslate"><span class="pre">f(2,</span> <span class="pre">1)</span></code>, ma non si sa quale delle due.</p>
</section>
<section id="id1037">
<h5>Esempio<a class="headerlink" href="#id1037" title="Link to this heading">¶</a></h5>
<p>Gli operatori sovraccaricati [overload] possono portare a problemi con l’ordine di valutazione:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>f1()-&gt;m(f2());          // m(f1(), f2())
cout &lt;&lt; f1() &lt;&lt; f2();   // operator&lt;&lt;(operator&lt;&lt;(cout, f1()), f2())
</pre></div>
</div>
<p>In C++17, questi esempi funzionano come previsto (da sinistra a destra) e le assegnazioni vengono valutate da destra a sinistra (proprio come gli = lo sono da destra a sinistra)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>f1() = f2();    // undefined behavior in C++14; in C++17, f2() is evaluated before f1()
</pre></div>
</div>
</section>
<section id="id1038">
<h5>Imposizione<a class="headerlink" href="#id1038" title="Link to this heading">¶</a></h5>
<p>Può essere rilevato da un buon analizzatore.</p>
</section>
</section>
<section id="es-45-avoid-magic-constants-use-symbolic-constants">
<h4><a name="Res-magic"></a>ES.45: Evitare «costanti magiche»; utilizzare costanti simboliche<a class="headerlink" href="#es-45-avoid-magic-constants-use-symbolic-constants" title="Link to this heading">¶</a></h4>
<section id="id1039">
<h5>Motivo<a class="headerlink" href="#id1039" title="Link to this heading">¶</a></h5>
<p>Le costanti senza nome incluse in espressioni vengono facilmente trascurate e sono spesso difficili da capire:</p>
</section>
<section id="id1040">
<h5>Esempio<a class="headerlink" href="#id1040" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (int m = 1; m &lt;= 12; ++m)   // don&#39;t: magic constant 12
    cout &lt;&lt; month[m] &lt;&lt; &#39;\n&#39;;
</pre></div>
</div>
<p>No, non tutti sanno che ci sono 12 mesi, in un anno, numerati 1..12. Meglio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// months are indexed 1..12
constexpr int first_month = 1;
constexpr int last_month = 12;

for (int m = first_month; m &lt;= last_month; ++m)   // better
    cout &lt;&lt; month[m] &lt;&lt; &#39;\n&#39;;
</pre></div>
</div>
<p>Ancora meglio, non esporre le costanti:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (auto m : month)
    cout &lt;&lt; m &lt;&lt; &#39;\n&#39;;
</pre></div>
</div>
</section>
<section id="id1041">
<h5>Imposizione<a class="headerlink" href="#id1041" title="Link to this heading">¶</a></h5>
<p>Segnalare i valori letterali nel codice. Far passare <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>, <code class="docutils literal notranslate"><span class="pre">\n</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>, ed altri in un elenco di valori ammessi.</p>
</section>
</section>
<section id="es-46-avoid-lossy-narrowing-truncating-arithmetic-conversions">
<h4><a name="Res-narrowing"></a>ES.46: Evitare conversioni aritmetiche con perdita (narrowing, troncamenti)<a class="headerlink" href="#es-46-avoid-lossy-narrowing-truncating-arithmetic-conversions" title="Link to this heading">¶</a></h4>
<section id="id1042">
<h5>Motivo<a class="headerlink" href="#id1042" title="Link to this heading">¶</a></h5>
<p>Una conversione narrowing distrugge l’informazione, spesso in modo inaspettato.</p>
</section>
<section id="id1043">
<h5>Esempio, cattivo<a class="headerlink" href="#id1043" title="Link to this heading">¶</a></h5>
<p>Un esempio chiave è il narrowing semplice:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double d = 7.9;
int i = d;    // bad: narrowing: i becomes 7
i = (int) d;  // bad: we&#39;re going to claim this is still not explicit enough

void f(int x, long y, double d)
{
    char c1 = x;   // bad: narrowing
    char c2 = y;   // bad: narrowing
    char c3 = d;   // bad: narrowing
}
</pre></div>
</div>
</section>
<section id="id1044">
<h5>Nota<a class="headerlink" href="#id1044" title="Link to this heading">¶</a></h5>
<p>La libreria di supporto delle linee guida offre un’operazione <code class="docutils literal notranslate"><span class="pre">narrow_cast</span></code> per specificare che il narrowing è accettabile e un <code class="docutils literal notranslate"><span class="pre">narrow</span></code> («narrow if») che genera un’eccezione se un troncamento butta via delle informazioni:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>i = gsl::narrow_cast&lt;int&gt;(d);   // OK (you asked for it): narrowing: i becomes 7
i = gsl::narrow&lt;int&gt;(d);        // OK: throws narrowing_error
</pre></div>
</div>
<p>Includiamo anche i cast aritmetici con perdita, come ad esempio da un tipo a virgola mobile negativo a un tipo intero senza segno:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double d = -7.9;
unsigned u = 0;

u = d;                               // bad: narrowing
u = gsl::narrow_cast&lt;unsigned&gt;(d);   // OK (you asked for it): u becomes 4294967289
u = gsl::narrow&lt;unsigned&gt;(d);        // OK: throws narrowing_error
</pre></div>
</div>
</section>
<section id="id1045">
<h5>Nota<a class="headerlink" href="#id1045" title="Link to this heading">¶</a></h5>
<p>Questa regola non si applica alle <a class="reference external" href="https://en.cppreference.com/w/cpp/language/implicit_conversion#Contextual_conversions">conversioni contestuali in bool</a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (ptr) do_something(*ptr);   // OK: ptr is used as a condition
bool b = ptr;                  // bad: narrowing
</pre></div>
</div>
</section>
<section id="id1046">
<h5>Imposizione<a class="headerlink" href="#id1046" title="Link to this heading">¶</a></h5>
<p>Un buon analizzatore può rilevare tutte le conversioni narrowing. Tuttavia, segnalare tutte le conversioni narrowing porterà a molti falsi positivi. Suggerimenti:</p>
<ul class="simple">
<li><p>Segnalare tutte le conversioni da virgola-mobile a intero (forse solo <code class="docutils literal notranslate"><span class="pre">float</span></code>-&gt;<code class="docutils literal notranslate"><span class="pre">char</span></code> e <code class="docutils literal notranslate"><span class="pre">double</span></code>-&gt;<code class="docutils literal notranslate"><span class="pre">int</span></code>. Questo è un punto oscuro! c’è bisogno di dati).</p></li>
<li><p>Segnalare tutti i <code class="docutils literal notranslate"><span class="pre">long</span></code>-&gt;<code class="docutils literal notranslate"><span class="pre">char</span></code> (Si sospetta che <code class="docutils literal notranslate"><span class="pre">int</span></code>-&gt;<code class="docutils literal notranslate"><span class="pre">char</span></code> sia molto comune. Questo è un punto oscuro! c’è bisogno di dati).</p></li>
<li><p>Considerare specialmente sospette le conversioni narrowing per gli argomenti delle funzioni.</p></li>
</ul>
</section>
</section>
<section id="es-47-use-nullptr-rather-than-0-or-null">
<h4><a name="Res-nullptr"></a>ES.47: Usare <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> anziché <code class="docutils literal notranslate"><span class="pre">0</span></code> o <code class="docutils literal notranslate"><span class="pre">NULL</span></code><a class="headerlink" href="#es-47-use-nullptr-rather-than-0-or-null" title="Link to this heading">¶</a></h4>
<section id="id1047">
<h5>Motivo<a class="headerlink" href="#id1047" title="Link to this heading">¶</a></h5>
<p>Leggibilità. Ridurre al minimo le sorprese: <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> non può confondersi con un <code class="docutils literal notranslate"><span class="pre">int</span></code>. <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> ha anche un tipo ben specificato (molto restrittivo), e quindi funziona in più scenari in cui la deduzione del tipo potrebbe fare la cosa sbagliata con  <code class="docutils literal notranslate"><span class="pre">NULL</span></code> o <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</section>
<section id="id1048">
<h5>Esempio<a class="headerlink" href="#id1048" title="Link to this heading">¶</a></h5>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int);
void f(char*);
f(0);         // call f(int)
f(nullptr);   // call f(char*)
</pre></div>
</div>
</section>
<section id="id1049">
<h5>Imposizione<a class="headerlink" href="#id1049" title="Link to this heading">¶</a></h5>
<p>Segnalare l’uso di <code class="docutils literal notranslate"><span class="pre">0</span></code> e <code class="docutils literal notranslate"><span class="pre">NULL</span></code> per i puntatori. La trasformazione potrebbe essere aiutata da una semplice trasformazione del programma.</p>
</section>
</section>
<section id="es-48-avoid-casts">
<h4><a name="Res-casts"></a>ES.48: Evitare i cast<a class="headerlink" href="#es-48-avoid-casts" title="Link to this heading">¶</a></h4>
<section id="id1050">
<h5>Motivo<a class="headerlink" href="#id1050" title="Link to this heading">¶</a></h5>
<p>I cast sono una fonte ben nota di errori e rendono inaffidabili alcune ottimizzazioni.</p>
</section>
<section id="id1051">
<h5>Esempio, cattivo<a class="headerlink" href="#id1051" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double d = 2;
auto p = (long*)&amp;d;
auto q = (long long*)&amp;d;
cout &lt;&lt; d &lt;&lt; &#39; &#39; &lt;&lt; *p &lt;&lt; &#39; &#39; &lt;&lt; *q &lt;&lt; &#39;\n&#39;;
</pre></div>
</div>
<p>Cosa credete che questo frammento stampi? Il risultato è definito nella migliore delle ipotesi. Io ho ottenuto</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2 0 4611686018427387904
</pre></div>
</div>
<p>Aggiungendo</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*q = 666;
cout &lt;&lt; d &lt;&lt; &#39; &#39; &lt;&lt; *p &lt;&lt; &#39; &#39; &lt;&lt; *q &lt;&lt; &#39;\n&#39;;
</pre></div>
</div>
<p>Io ho ottenuto</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>3.29048e-321 666 666
</pre></div>
</div>
<p>Sorpresi? Sono contento che il programma non vada in crash.</p>
</section>
<section id="id1052">
<h5>Nota<a class="headerlink" href="#id1052" title="Link to this heading">¶</a></h5>
<p>I programmatori che scrivono cast in genere presumono di sapere cosa stanno facendo o che scrivere un cast rende il programma «più facile da leggere». Infatti, spesso disabilitano le regole generali sull’uso dei valori. La risoluzione dell’overload è l’istanziazione dei template solitamente scelgono la funzione giusta se c’è una funzione giusta da selezionare. Se non c’è, forse dovrebbe esserci, piuttosto che applicare una correzione locale (cast).</p>
</section>
<section id="id1053">
<h5>Note<a class="headerlink" href="#id1053" title="Link to this heading">¶</a></h5>
<p>I cast sono necessari in un linguaggio di programmazione di sistemi.  Ad esempio, come altrimenti si potrebbe ottenere l’indirizzo del registro di un dispositivo in un puntatore?  Tuttavia, dei cast se ne abusa gravemente, nonché sono una delle principali fonti di errori.</p>
<p>Se si sente la necessità di parecchi cast, potrebbe essere un fondamentale problema progettuale.</p>
<p>Il <a class="reference internal" href="#Pro-type-reinterpretcast"><span class="xref myst">profilo del tipo</span></a> vieta il <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> e i cast C-style.</p>
<p>Mai eseguire il cast a <code class="docutils literal notranslate"><span class="pre">(void)</span></code> per ignorare un valore di ritorno <code class="docutils literal notranslate"><span class="pre">[[nodiscard]]</span></code>. Se si vuole deliberatamente scartare un tale risultato, ci si rifletta bene sul fatto che potrebbe essere una pessima idea (solitamente c’è un buon motivo per cui l’autore della funzione o del tipo restituito ha usato <code class="docutils literal notranslate"><span class="pre">[[nodiscard]]</span></code>). Se si pensa ancora che sia appropriato e si abbia il consenso del revisore del codice, si usa <code class="docutils literal notranslate"><span class="pre">std::ignore</span> <span class="pre">=</span></code> per disattivare il warning in modo semplice, portatile e facile da ritrovare con grep.</p>
</section>
<section id="id1054">
<h5>Alternative<a class="headerlink" href="#id1054" title="Link to this heading">¶</a></h5>
<p>I cast sono ampiamente (ab) usati. Il C++ moderno ha delle regole e dei costrutti che eliminano la necessità di cast in molti contesti, come</p>
<ul class="simple">
<li><p>Nell’uso dei template</p></li>
<li><p>Usare <code class="docutils literal notranslate"><span class="pre">std::variant</span></code></p></li>
<li><p>Nell’affidarsi a conversioni implicite ben definite e sicure tra i i tipi di puntatori</p></li>
<li><p>Usare <code class="docutils literal notranslate"><span class="pre">std::ignore</span> <span class="pre">=</span></code> per ignorare i valori <code class="docutils literal notranslate"><span class="pre">[[nodiscard]]</span></code>.</p></li>
</ul>
</section>
<section id="id1055">
<h5>Imposizione<a class="headerlink" href="#id1055" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare tutti i cast C-style, compresi quelli a <code class="docutils literal notranslate"><span class="pre">void</span></code>.</p></li>
<li><p>Segnalare II cast in stile funzione utilizzando <code class="docutils literal notranslate"><span class="pre">Type(value)</span></code>. Utilizzare, invece, <code class="docutils literal notranslate"><span class="pre">Type{value}</span></code> che non è restrittivo. (Cfr. <a class="reference internal" href="#Res-construct"><span class="xref myst">ES.64</span></a>.)</p></li>
<li><p>Segnalare i <a class="reference internal" href="#Pro-type-identitycast"><span class="xref myst">cast identici</span></a> tra tipi puntatori, dove i tipi dei sorgenti e dei destinatari sono gli stessi (#Pro-type-identitycast).</p></li>
<li><p>Segnalare il cast esplicito di un puntatore che potrebbe essere <a class="reference internal" href="#Pro-type-implicitpointercast"><span class="xref myst">implicito</span></a>.</p></li>
</ul>
</section>
</section>
<section id="es-49-if-you-must-use-a-cast-use-a-named-cast">
<h4><a name="Res-casts-named"></a>ES.49: Se si deve usare un cast, si utilizzi un «named cast»<a class="headerlink" href="#es-49-if-you-must-use-a-cast-use-a-named-cast" title="Link to this heading">¶</a></h4>
<section id="id1056">
<h5>Motivo<a class="headerlink" href="#id1056" title="Link to this heading">¶</a></h5>
<p>Leggibilità. Evitare errori. I «named cast» sono più specifici di un cast di tipo C o di un cast funzionale, consentendo al compilatore di rilevare alcuni errori.</p>
<p>I «named cast» sono:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">static_cast</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const_cast</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::move</span></code>         // <code class="docutils literal notranslate"><span class="pre">move(x)</span></code> è un riferimento rvalue a <code class="docutils literal notranslate"><span class="pre">x</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::forward</span></code>      // <code class="docutils literal notranslate"><span class="pre">forward&lt;T&gt;(x)</span></code> è un riferimento rvalue o uno lvalue a <code class="docutils literal notranslate"><span class="pre">x</span></code> a seconda di <code class="docutils literal notranslate"><span class="pre">T</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gsl::narrow_cast</span></code>  // <code class="docutils literal notranslate"><span class="pre">narrow_cast&lt;T&gt;(x)</span></code> è <code class="docutils literal notranslate"><span class="pre">static_cast&lt;T&gt;(x)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gsl::narrow</span></code>       // <code class="docutils literal notranslate"><span class="pre">narrow&lt;T&gt;(x)</span></code> è uno <code class="docutils literal notranslate"><span class="pre">static_cast&lt;T&gt;(x)</span></code> se <code class="docutils literal notranslate"><span class="pre">static_cast&lt;T&gt;(x)</span> <span class="pre">==</span> <span class="pre">x</span></code> o solleva un <code class="docutils literal notranslate"><span class="pre">narrowing_error</span></code></p></li>
</ul>
</section>
<section id="id1057">
<h5>Esempio<a class="headerlink" href="#id1057" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class B { /* ... */ };
class D { /* ... */ };

template&lt;typename D&gt; D* upcast(B* pb)
{
    D* pd0 = pb;                        // error: no implicit conversion from B* to D*
    D* pd1 = (D*)pb;                    // legal, but what is done?
    D* pd2 = static_cast&lt;D*&gt;(pb);       // error: D is not derived from B
    D* pd3 = reinterpret_cast&lt;D*&gt;(pb);  // OK: on your head be it!
    D* pd4 = dynamic_cast&lt;D*&gt;(pb);      // OK: return nullptr
    // ...
}
</pre></div>
</div>
<p>L’esempio è stato sintetizzato da un vero bug in cui <code class="docutils literal notranslate"><span class="pre">D</span></code> era derivato da <code class="docutils literal notranslate"><span class="pre">B</span></code>, ma qualcuno ha eseguito il refactorng della gerarchia. Il cast in stile C è pericoloso perché può fare qualsiasi tipo di conversione, privandoci di qualsiasi protezione dagli errori (ora e in futuro).</p>
</section>
<section id="id1058">
<h5>Nota<a class="headerlink" href="#id1058" title="Link to this heading">¶</a></h5>
<p>Invece, quando si converte senza perdita di informazioni (p.es. da <code class="docutils literal notranslate"><span class="pre">float</span></code> a <code class="docutils literal notranslate"><span class="pre">double</span></code> o da <code class="docutils literal notranslate"><span class="pre">int32</span></code> a <code class="docutils literal notranslate"><span class="pre">int64</span></code>), si può usare l’inizializzazione tra parenesi graffe.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double d {some_float};
int64_t i {some_int32};
</pre></div>
</div>
<p>Ciò rende chiaro che la conversione del tipo era prevista e impedisce anche le conversioni tra tipi che potrebbero comportare una perdita di precisione. (È un errore di compilazione tentare di inizializzare un <code class="docutils literal notranslate"><span class="pre">float</span></code> da un <code class="docutils literal notranslate"><span class="pre">double</span></code> in questo modo, per esempio).</p>
</section>
<section id="id1059">
<h5>Nota<a class="headerlink" href="#id1059" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> può essere essenziale, ma gli usi essenziali (p.es., trasformare un indirizzo macchina in un puntatore) non sono sicuri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto p = reinterpret_cast&lt;Device_register&gt;(0x800);  // inherently dangerous
</pre></div>
</div>
</section>
<section id="id1060">
<h5>Imposizione<a class="headerlink" href="#id1060" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare tutti i cast C-style, compresi quelli a <code class="docutils literal notranslate"><span class="pre">void</span></code>.</p></li>
<li><p>Segnalare II cast in stile funzione utilizzando <code class="docutils literal notranslate"><span class="pre">Type(value)</span></code>. Utilizzare, invece, <code class="docutils literal notranslate"><span class="pre">Type{value}</span></code> che non è restrittivo. (Cfr. <a class="reference internal" href="#Res-construct"><span class="xref myst">ES.64</span></a>.)</p></li>
<li><p>Il <a class="reference internal" href="#Pro-type-reinterpretcast"><span class="xref myst">profilo del tipo</span></a> vieta il <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code>.</p></li>
<li><p>Il <a class="reference internal" href="#Pro-type-arithmeticcast"><span class="xref myst">profilo del tipo</span></a> mette in guardia sull’uso di uno <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> tra i tipi aritmetici.</p></li>
</ul>
</section>
</section>
<section id="es-50-don-t-cast-away-const">
<h4><a name="Res-casts-const"></a>ES.50: Non eseguire il cast da un <code class="docutils literal notranslate"><span class="pre">const</span></code><a class="headerlink" href="#es-50-don-t-cast-away-const" title="Link to this heading">¶</a></h4>
<section id="id1061">
<h5>Motivo<a class="headerlink" href="#id1061" title="Link to this heading">¶</a></h5>
<p>Contraddice il <code class="docutils literal notranslate"><span class="pre">const</span></code>. Se la variabile è effettivamente dichiarata <code class="docutils literal notranslate"><span class="pre">const</span></code>, la modifica porta ad un comportamento indefinito.</p>
</section>
<section id="id1062">
<h5>Esempio, cattivo<a class="headerlink" href="#id1062" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(const int&amp; x)
{
    const_cast&lt;int&amp;&gt;(x) = 42;   // BAD
}

static int i = 0;
static const int j = 0;

f(i); // silent side effect
f(j); // undefined behavior
</pre></div>
</div>
</section>
<section id="id1063">
<h5>Esempio<a class="headerlink" href="#id1063" title="Link to this heading">¶</a></h5>
<p>Talvolta, si potrebbe essere tentati di ricorrere a <code class="docutils literal notranslate"><span class="pre">const_cast</span></code> per evitare la duplicazione del codice, ad esempio quando si hanno due funzioni di accesso che differiscono solo per un <code class="docutils literal notranslate"><span class="pre">const</span></code> ma con implementazioni simili. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Bar;

class Foo {
public:
    // BAD, duplicates logic
    Bar&amp; get_bar()
    {
        /* complex logic around getting a non-const reference to my_bar */
    }

    const Bar&amp; get_bar() const
    {
        /* same complex logic around getting a const reference to my_bar */
    }
private:
    Bar my_bar;
};
</pre></div>
</div>
<p>Preferire, invece, la condivisione delle implementazioni. Normalmente, si può solo avere la funzione non-<code class="docutils literal notranslate"><span class="pre">const</span></code> che chiama la funzione <code class="docutils literal notranslate"><span class="pre">const</span></code>. Tuttavia, quando esiste una logica complessa, ciò può portare al seguente pattern che ricorre ancora a un <code class="docutils literal notranslate"><span class="pre">const_cast</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Foo {
public:
    // not great, non-const calls const version but resorts to const_cast
    Bar&amp; get_bar()
    {
        return const_cast&lt;Bar&amp;&gt;(static_cast&lt;const Foo&amp;&gt;(*this).get_bar());
    }
    const Bar&amp; get_bar() const
    {
        /* the complex logic around getting a const reference to my_bar */
    }
private:
    Bar my_bar;
};
</pre></div>
</div>
<p>Sebbene questo modello sia sicuro quando applicato correttamente, poiché il chiamante deve avere avuto un oggetto non-<code class="docutils literal notranslate"><span class="pre">const</span></code> per cominciare, non è l’ideale perché la sicurezza è difficile da ottenersi automaticamente come regola di un checker.</p>
<p>Preferire, invece, mettere il codice comune in una funzione helper comune – e trasformarlo in un template in modo da dedurre il  <code class="docutils literal notranslate"><span class="pre">const</span></code>. Questo non usa affatto alcun <code class="docutils literal notranslate"><span class="pre">const_cast</span></code> at all:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Foo {
public:                         // good
          Bar&amp; get_bar()       { return get_bar_impl(*this); }
    const Bar&amp; get_bar() const { return get_bar_impl(*this); }
private:
    Bar my_bar;

    template&lt;class T&gt;           // good, deduces whether T is const or non-const
    static auto&amp; get_bar_impl(T&amp; t)
        { /* the complex logic around getting a possibly-const reference to my_bar */ }
};
</pre></div>
</div>
<p>Nota: Non eseguire grandi lavori indipendenti all’interno di un template, questo porta ad un aumento del codice. Per esempio, un ulteriore miglioramento sarebbe se tutte le parti di <code class="docutils literal notranslate"><span class="pre">get_bar_impl</span></code> potessero essere indipendenti e e fattorizzate in una funzione comune non-template, per una riduzione potenzialmente grande della dimensione del codice.</p>
</section>
<section id="id1064">
<h5>Eccezione<a class="headerlink" href="#id1064" title="Link to this heading">¶</a></h5>
<p>Potrebbe essere necessario eliminare <code class="docutils literal notranslate"><span class="pre">const</span></code> chiamando funzioni con un incorretto <code class="docutils literal notranslate"><span class="pre">const</span></code>. È preferibile racchiudere queste funzioni inline <code class="docutils literal notranslate"><span class="pre">const</span></code>-corrette con dei wrapper per incapsulare in un unico posto il cast.</p>
</section>
<section id="id1065">
<h5>Esempio<a class="headerlink" href="#id1065" title="Link to this heading">¶</a></h5>
<p>A volte, «eliminare il  <code class="docutils literal notranslate"><span class="pre">const</span></code>» è per consentire l’aggiornamento di alcune informazioni transitorie su di un oggetto altrimenti immutabile. Esempi sono il caching, la memoizzazione e il pre-calcolo. Tali esempi spesso gestiti anche o meglio usando <code class="docutils literal notranslate"><span class="pre">mutable</span></code> o una indirezione anziché una <code class="docutils literal notranslate"><span class="pre">const_cast</span></code>.</p>
<p>Si prenda in considerazione la possibilità di memorizzare i risultati, calcolati in precedenza, di un’operazione costosa:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int compute(int x); // compute a value for x; assume this to be costly

class Cache {   // some type implementing a cache for an int-&gt;int operation
public:
    pair&lt;bool, int&gt; find(int x) const;   // is there a value for x?
    void set(int x, int v);             // make y the value for x
    // ...
private:
    // ...
};

class X {
public:
    int get_val(int x)
    {
        auto p = cache.find(x);
        if (p.first) return p.second;
        int val = compute(x);
        cache.set(x, val); // insert value for x
        return val;
    }
    // ...
private:
    Cache cache;
};
</pre></div>
</div>
<p>Qui, <code class="docutils literal notranslate"><span class="pre">get_val()</span></code> è logicamente costante, quindi lo si vorrebbe rendere un membro <code class="docutils literal notranslate"><span class="pre">const</span></code>. Per fare ciò si deve ancora mutare <code class="docutils literal notranslate"><span class="pre">cache</span></code>, quindi a volte si ricorre ad un <code class="docutils literal notranslate"><span class="pre">const_cast</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {   // Suspicious solution based on casting
public:
    int get_val(int x) const
    {
        auto p = cache.find(x);
        if (p.first) return p.second;
        int val = compute(x);
        const_cast&lt;Cache&amp;&gt;(cache).set(x, val);   // ugly
        return val;
    }
    // ...
private:
    Cache cache;
};
</pre></div>
</div>
<p>Fortunatamente, esiste una soluzione migliore: Si indica che <code class="docutils literal notranslate"><span class="pre">cache</span></code> è mutabile anche per un oggetto <code class="docutils literal notranslate"><span class="pre">const</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {   // better solution
public:
    int get_val(int x) const
    {
        auto p = cache.find(x);
        if (p.first) return p.second;
        int val = compute(x);
        cache.set(x, val);
        return val;
    }
    // ...
private:
    mutable Cache cache;
};
</pre></div>
</div>
<p>Una soluzione alternativa sarebbe quella di memorizzare un puntatore alla <code class="docutils literal notranslate"><span class="pre">cache</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {   // OK, but slightly messier solution
public:
    int get_val(int x) const
    {
        auto p = cache-&gt;find(x);
        if (p.first) return p.second;
        int val = compute(x);
        cache-&gt;set(x, val);
        return val;
    }
    // ...
private:
    unique_ptr&lt;Cache&gt; cache;
};
</pre></div>
</div>
<p>Questa soluzione è la più flessibile, ma richiede la costruzione e la distruzione esplicite di <code class="docutils literal notranslate"><span class="pre">*cache</span></code> (molto probabilmente nel costruttore e nel distruttore di <code class="docutils literal notranslate"><span class="pre">X</span></code>).</p>
<p>In ogni variant, ci si deve proteggere contro i conflitti dei dati [data race] sulla <code class="docutils literal notranslate"><span class="pre">cache</span></code> nel codice multi-threaded, forse utilizzando un <code class="docutils literal notranslate"><span class="pre">std::mutex</span></code>.</p>
</section>
<section id="id1066">
<h5>Imposizione<a class="headerlink" href="#id1066" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare i <code class="docutils literal notranslate"><span class="pre">const_cast</span></code>s.</p></li>
<li><p>Questa regola fa parte del <a class="reference internal" href="#Pro-type-constcast"><span class="xref myst">profilo di sicurezza del tipo</span></a> per il relativo Profilo.</p></li>
</ul>
</section>
</section>
<section id="es-55-avoid-the-need-for-range-checking">
<h4><a name="Res-range-checking"></a>ES.55: Evitare la necessità di controllare i range<a class="headerlink" href="#es-55-avoid-the-need-for-range-checking" title="Link to this heading">¶</a></h4>
<section id="id1067">
<h5>Motivo<a class="headerlink" href="#id1067" title="Link to this heading">¶</a></h5>
<p>I costrutti che non possono andare in overflow non lo fanno (e solitamente funzionano più velocemente):</p>
</section>
<section id="id1068">
<h5>Esempio<a class="headerlink" href="#id1068" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (auto&amp; x : v)      // print all elements of v
    cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;

auto p = find(v, x);   // find x in v
</pre></div>
</div>
</section>
<section id="id1069">
<h5>Imposizione<a class="headerlink" href="#id1069" title="Link to this heading">¶</a></h5>
<p>Cercare i controlli espliciti sui range suggerendo euristicamente delle alternative.</p>
</section>
</section>
<section id="es-56-write-std-move-only-when-you-need-to-explicitly-move-an-object-to-another-scope">
<h4><a name="Res-move"></a>ES.56: Scrivere <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> solo quando è necessario spostare esplicitamente un oggetto in un altro scope<a class="headerlink" href="#es-56-write-std-move-only-when-you-need-to-explicitly-move-an-object-to-another-scope" title="Link to this heading">¶</a></h4>
<section id="id1070">
<h5>Motivo<a class="headerlink" href="#id1070" title="Link to this heading">¶</a></h5>
<p>Solitamente si sposta anziché copiare, per evitare duplicazioni e per migliorare le prestazioni.</p>
<p>Uno spostamento [move] solitamente lascia dietro di sé un oggetto vuoto (<a class="reference internal" href="#Rc-move-semantic"><span class="xref myst">C.64</span></a>), che può sorprendere e persino essere pericoloso, quindi si cerca di evitare lo spostamento dagli lvalues (vi si potrà accedere in seguito).</p>
</section>
<section id="id1071">
<h5>Note<a class="headerlink" href="#id1071" title="Link to this heading">¶</a></h5>
<p>Lo spostamento viene fatto implicitamente quando l’origine è un rvalue (p.es., il valore nella gestione di un <code class="docutils literal notranslate"><span class="pre">return</span></code> o il risultato di una funzione), quindi non si complichi inutilmente il codice, in questi casi, scrivendo esplicitamente <code class="docutils literal notranslate"><span class="pre">move</span></code>. Si scrivano, invece, brevi funzioni che restituiscano valori, e sia il ritorno della funzione che l’accettazione del ritorno da parte del chiamante saranno naturalmente ottimizzati.</p>
<p>In generale, seguire le linee-guide in questo documento (incluso il non rendere gli scope delle variabili inutilmente ampi, scrivendo funzioni brevi che restituiscono valori, restituendo variabili locali) aiuta ad eliminare il più possibile la necessità dei <code class="docutils literal notranslate"><span class="pre">std::move</span></code> espliciti.</p>
<p>Il <code class="docutils literal notranslate"><span class="pre">move</span></code> esplicito è necessario per spostare [move] esplicitamente un oggetto in un altro scope, in particolare per passarlo a una funzione «sink» e nelle stesse implementazioni delle operazioni di move (costruttore di move, operatore di assegnazione del move) e nell’operazione di swap.</p>
</section>
<section id="id1072">
<h5>Esempio, cattivo<a class="headerlink" href="#id1072" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void sink(X&amp;&amp; x);   // sink takes ownership of x

void user()
{
    X x;
    // error: cannot bind an lvalue to a rvalue reference
    sink(x);
    // OK: sink takes the contents of x, x must now be assumed to be empty
    sink(std::move(x));

    // ...

    // probably a mistake
    use(x);
}
</pre></div>
</div>
<p>Solitamente, viene usato un <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> come argomento di un parametro <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>. E dopo averlo fatto, si suppone che l’oggetto sia stato spostato via (cfr. <a class="reference internal" href="#Rc-move-semantic"><span class="xref myst">C.64</span></a>) e che non se ne debba leggere lo stato finché non lo si imposti ad un nuovo valore.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    string s1 = &quot;supercalifragilisticexpialidocious&quot;;

    string s2 = s1;             // ok, takes a copy
    assert(s1 == &quot;supercalifragilisticexpialidocious&quot;);  // ok

    // bad, if you want to keep using s1&#39;s value
    string s3 = move(s1);

    // bad, assert will likely fail, s1 likely changed
    assert(s1 == &quot;supercalifragilisticexpialidocious&quot;);
}
</pre></div>
</div>
</section>
<section id="id1073">
<h5>Esempio<a class="headerlink" href="#id1073" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void sink(unique_ptr&lt;widget&gt; p);  // pass ownership of p to sink()

void f()
{
    auto w = make_unique&lt;widget&gt;();
    // ...
    sink(std::move(w));               // ok, give to sink()
    // ...
    sink(w);    // Error: unique_ptr is carefully designed so that you cannot copy it
}
</pre></div>
</div>
</section>
<section id="id1074">
<h5>Note<a class="headerlink" href="#id1074" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">std::move()</span></code> è un cast a <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> sotto mentite spoglie; di per sé non sposta nulla, ma contrassegna un oggetto nominato come candidato allo spostamento. Il linguaggio conosce già i casi comuni dove è possibile spostare gli oggetti, specialmente quando si restituiscono i valori delle funzioni, quindi non si complichi il codice con un ridondante <code class="docutils literal notranslate"><span class="pre">std::move()</span></code>.</p>
<p>Non scrivere mai <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> solo perché qualcuno ha detto che «è più efficiente». In generale, non si devono credere alle affermazioni sulla «efficienza» senza dati (???). In generale, non complicare il proprio codice senza motivo (??). Mai scrivere <code class="docutils literal notranslate"><span class="pre">std::move()</span></code> per un oggetto const, esso viene silenziosamente trasformato in una copia (cfr. Item 23 in <a class="reference internal" href="#Meyers15"><span class="xref myst">Meyers15</span></a>)</p>
</section>
<section id="id1075">
<h5>Esempio, cattivo<a class="headerlink" href="#id1075" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;int&gt; make_vector()
{
    vector&lt;int&gt; result;
    // ... load result with data
    return std::move(result);       // bad; just write &quot;return result;&quot;
}
</pre></div>
</div>
<p>Mai scrivere <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">move(local_variable);</span></code>, perché il linguaggio già sa che la variabile è un candidato per il move. Scrivere <code class="docutils literal notranslate"><span class="pre">move</span></code> in questo codice non aiuta e può in effetti essere dannoso perché su alcuni compilatori interferisce col RVO (l’ottimizzazione del valore di ritorno) creando un’ulteriore alias di riferimento alla variabile locale.</p>
</section>
<section id="id1076">
<h5>Esempio, cattivo<a class="headerlink" href="#id1076" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;int&gt; v = std::move(make_vector());   // bad; the std::move is entirely redundant
</pre></div>
</div>
<p>Mai scrivere <code class="docutils literal notranslate"><span class="pre">move</span></code> per un valore di ritorno come <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">move(f());</span></code> dove <code class="docutils literal notranslate"><span class="pre">f</span></code> ritorna per valore. Il linguaggio già sa che un valore restituito è un oggetto temporaneo che può essere trasferito [moved].</p>
</section>
<section id="id1077">
<h5>Esempio<a class="headerlink" href="#id1077" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void mover(X&amp;&amp; x)
{
    call_something(std::move(x));         // ok
    call_something(std::forward&lt;X&gt;(x));   // bad, don&#39;t std::forward an rvalue reference
    call_something(x);                    // suspicious, why not std::move?
}

template&lt;class T&gt;
void forwarder(T&amp;&amp; t)
{
    call_something(std::move(t));         // bad, don&#39;t std::move a forwarding reference
    call_something(std::forward&lt;T&gt;(t));   // ok
    call_something(t);                    // suspicious, why not std::forward?
}
</pre></div>
</div>
</section>
<section id="id1078">
<h5>Imposizione<a class="headerlink" href="#id1078" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare l’uso di <code class="docutils literal notranslate"><span class="pre">std::move(x)</span></code> dove <code class="docutils literal notranslate"><span class="pre">x</span></code> è un rvalue o il linguaggio lo tratterà già come un rvalue, compreso <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">std::move(local_variable);</span></code> e <code class="docutils literal notranslate"><span class="pre">std::move(f())</span></code> su una funzione che restituisce per valore.</p></li>
<li><p>Segnalare le funzioni che prendono un parametro <code class="docutils literal notranslate"><span class="pre">S&amp;&amp;</span></code> se non c’è alcun overload <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">S&amp;</span></code> che si prenda cura degli lvalue.</p></li>
<li><p>Segnalare un argomento spostato con <code class="docutils literal notranslate"><span class="pre">std::move</span></code>, passato a un parametro, tranne quando il tipo di parametro è un riferimento rvalue <code class="docutils literal notranslate"><span class="pre">X&amp;&amp;</span></code> o quando il tipo è «move-only» e il parametro viene passato per valore.</p></li>
<li><p>Segnalare quando <code class="docutils literal notranslate"><span class="pre">std::move</span></code> viene applicato ad un «forwarding» del riferimento (<code class="docutils literal notranslate"><span class="pre">T&amp;&amp;</span></code> dove <code class="docutils literal notranslate"><span class="pre">T</span></code> è un tipo di parametro template). Usare, invece, <code class="docutils literal notranslate"><span class="pre">std::forward</span></code>.</p></li>
<li><p>Segnalare quando <code class="docutils literal notranslate"><span class="pre">std::move</span></code> viene applicato ad un valore diverso da un riferimento rvalue a un non-const. (Un caso più generale della regola precedente per coprire i casi non-forwarding).</p></li>
<li><p>Segnalare quando <code class="docutils literal notranslate"><span class="pre">std::forward</span></code> viene applicato ad un riferimento rvalue (<code class="docutils literal notranslate"><span class="pre">X&amp;&amp;</span></code> dove <code class="docutils literal notranslate"><span class="pre">X</span></code> è un tipo parametro non-template). Usare, invece, <code class="docutils literal notranslate"><span class="pre">std::move</span></code>.</p></li>
<li><p>Segnalare quando <code class="docutils literal notranslate"><span class="pre">std::forward</span></code> viene applicato ad un riferimento diverso dal forwarding. (Un caso più generale della regola precedente per coprire i casi non-moving).</p></li>
<li><p>Segnalare quando un oggetto viene potenzialmente spostato [move] e la successiva operazione è un’operazione <code class="docutils literal notranslate"><span class="pre">const</span></code>; dovrebbe esserci prima un’operazione non-<code class="docutils literal notranslate"><span class="pre">const</span></code>, idealmente un’assegnazione, per resettare subito il valore dell’oggetto.</p></li>
</ul>
</section>
</section>
<section id="es-60-avoid-new-and-delete-outside-resource-management-functions">
<h4><a name="Res-new"></a>ES.60: Evitare <code class="docutils literal notranslate"><span class="pre">new</span></code> e <code class="docutils literal notranslate"><span class="pre">delete</span></code> al di fuori delle funzioni di gestione delle risorse<a class="headerlink" href="#es-60-avoid-new-and-delete-outside-resource-management-functions" title="Link to this heading">¶</a></h4>
<section id="id1079">
<h5>Motivo<a class="headerlink" href="#id1079" title="Link to this heading">¶</a></h5>
<p>La gestione diretta delle risorse nel codice di un’applicazione è soggetta ad errori ed è noiosa.</p>
</section>
<section id="id1080">
<h5>Nota<a class="headerlink" href="#id1080" title="Link to this heading">¶</a></h5>
<p>Questa è anche nota come la regola del «Nessun semplice [naked] <code class="docutils literal notranslate"><span class="pre">new</span></code>!»</p>
</section>
<section id="id1081">
<h5>Esempio, cattivo<a class="headerlink" href="#id1081" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int n)
{
    auto p = new X[n];   // n default constructed Xs
    // ...
    delete[] p;
}
</pre></div>
</div>
<p>Può esserci del codice nella parte <code class="docutils literal notranslate"><span class="pre">...</span></code> che non esegue mai il <code class="docutils literal notranslate"><span class="pre">delete</span></code>.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#S-resource"><span class="xref myst">R: Gestione delle risorse</span></a></p>
</section>
<section id="id1082">
<h5>Imposizione<a class="headerlink" href="#id1082" title="Link to this heading">¶</a></h5>
<p>Segnalare i [naked] <code class="docutils literal notranslate"><span class="pre">new</span></code> e i [naked] <code class="docutils literal notranslate"><span class="pre">delete</span></code>.</p>
</section>
</section>
<section id="es-61-delete-arrays-using-delete-and-non-arrays-using-delete">
<h4><a name="Res-del"></a>ES.61: Eseguire il delete degli array con <code class="docutils literal notranslate"><span class="pre">delete[]</span></code> e usando <code class="docutils literal notranslate"><span class="pre">delete</span></code> per il resto<a class="headerlink" href="#es-61-delete-arrays-using-delete-and-non-arrays-using-delete" title="Link to this heading">¶</a></h4>
<section id="id1083">
<h5>Motivo<a class="headerlink" href="#id1083" title="Link to this heading">¶</a></h5>
<p>Questo è ciò che richiede il linguaggio e gli errori possono portare ad errori nel rilascio delle risorse e/o corrompere la memoria.</p>
</section>
<section id="id1084">
<h5>Esempio, cattivo<a class="headerlink" href="#id1084" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int n)
{
    auto p = new X[n];   // n default constructed Xs
    // ...
    delete p;   // error: just delete the object p, rather than delete the array p[]
}
</pre></div>
</div>
</section>
<section id="id1085">
<h5>Nota<a class="headerlink" href="#id1085" title="Link to this heading">¶</a></h5>
<p>Questo esempio non solo viola la <a class="reference internal" href="#Res-new"><span class="xref myst">regola di nessun <code class="docutils literal notranslate"><span class="pre">new</span></code> [naked]</span></a> come nel precedente esempio, ma presenta molti altri problemi.</p>
</section>
<section id="id1086">
<h5>Imposizione<a class="headerlink" href="#id1086" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare <code class="docutils literal notranslate"><span class="pre">new</span></code> e <code class="docutils literal notranslate"><span class="pre">delete</span></code> non corrispondenti se si trovano nello stesso scope.</p></li>
<li><p>Segnalare <code class="docutils literal notranslate"><span class="pre">new</span></code> e <code class="docutils literal notranslate"><span class="pre">delete</span></code> non corrispondenti se si trovano in una coppia costruttore/distruttore.</p></li>
</ul>
</section>
</section>
<section id="es-62-don-t-compare-pointers-into-different-arrays">
<h4><a name="Res-arr2"></a>ES.62: Non confrontare i puntatori in diversi array<a class="headerlink" href="#es-62-don-t-compare-pointers-into-different-arrays" title="Link to this heading">¶</a></h4>
<section id="id1087">
<h5>Motivo<a class="headerlink" href="#id1087" title="Link to this heading">¶</a></h5>
<p>Il risultato è indefinito.</p>
</section>
<section id="id1088">
<h5>Esempio, cattivo<a class="headerlink" href="#id1088" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    int a1[7];
    int a2[9];
    if (&amp;a1[5] &lt; &amp;a2[7]) {}       // bad: undefined
    if (0 &lt; &amp;a1[5] - &amp;a2[7]) {}   // bad: undefined
}
</pre></div>
</div>
</section>
<section id="id1089">
<h5>Nota<a class="headerlink" href="#id1089" title="Link to this heading">¶</a></h5>
<p>Questo esempio presenta molti più problemi.</p>
</section>
<section id="id1090">
<h5>Imposizione<a class="headerlink" href="#id1090" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="es-63-don-t-slice">
<h4><a name="Res-slice"></a>ES.63: Non provocare «slice»<a class="headerlink" href="#es-63-don-t-slice" title="Link to this heading">¶</a></h4>
<section id="id1091">
<h5>Motivo<a class="headerlink" href="#id1091" title="Link to this heading">¶</a></h5>
<p>Lo slicing – ovvero la copia di solo una parte di un oggetto tramite l’assegnazione o l’inizializzazione – molto spesso porta a errori perché l’oggetto doveva essere considerato nella sua interezza. Nei rari casi in cui lo slicing è voluto, il codice può sorprendere.</p>
</section>
<section id="id1092">
<h5>Esempio<a class="headerlink" href="#id1092" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Shape { /* ... */ };
class Circle : public Shape { /* ... */ Point c; int r; };

Circle c { {0, 0}, 42 };
Shape s {c};    // copy construct only the Shape part of Circle
s = c;          // or copy assign only the Shape part of Circle

void assign(const Shape&amp; src, Shape&amp; dest)
{
    dest = src;
}
Circle c2 { {1, 1}, 43 };
assign(c, c2);   // oops, not the whole state is transferred
assert(c == c2); // if we supply copying, we should also provide comparison,
                 // but this will likely return false
</pre></div>
</div>
<p>Il risultato sarà privo di significato perché il centro e il raggio non verranno copiati da <code class="docutils literal notranslate"><span class="pre">c</span></code> in <code class="docutils literal notranslate"><span class="pre">s</span></code>. La prima difesa contro questo è <a class="reference internal" href="#Rc-copy-virtual"><span class="xref myst">definire la classe base  <code class="docutils literal notranslate"><span class="pre">Shape</span></code> in modo che non lo consenta</span></a>.</p>
</section>
<section id="id1093">
<h5>Alternativa<a class="headerlink" href="#id1093" title="Link to this heading">¶</a></h5>
<p>Se si intende eseguire lo slice, se ne definisca un’operazione esplicita. Ciò evita al lettore un po” di confusione. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Smiley : public Circle {
    public:
    Circle copy_circle();
    // ...
};

Smiley sm { /* ... */ };
Circle c1 {sm};  // ideally prevented by the definition of Circle
Circle c2 {sm.copy_circle()};
</pre></div>
</div>
</section>
<section id="id1094">
<h5>Imposizione<a class="headerlink" href="#id1094" title="Link to this heading">¶</a></h5>
<p>Emettere un warning contro lo slicing.</p>
</section>
</section>
<section id="es-64-use-the-t-e-notation-for-construction">
<h4><a name="Res-construct"></a>ES.64: Usare la notazione <code class="docutils literal notranslate"><span class="pre">T{e}</span></code> per la costruzione<a class="headerlink" href="#es-64-use-the-t-e-notation-for-construction" title="Link to this heading">¶</a></h4>
<section id="id1095">
<h5>Motivo<a class="headerlink" href="#id1095" title="Link to this heading">¶</a></h5>
<p>La sintassi per la costruzione <code class="docutils literal notranslate"><span class="pre">T{e}</span></code> rende esplicito che si desidera la costruzione. La sintassi della costruzione <code class="docutils literal notranslate"><span class="pre">T{e}</span></code> non consente il [narrowing]. <code class="docutils literal notranslate"><span class="pre">T{e}</span></code> è l’unica espressione generale sicura per la costruzione di un valore di tipo <code class="docutils literal notranslate"><span class="pre">T</span></code> da un’espressione <code class="docutils literal notranslate"><span class="pre">e</span></code>. Le notazioni dei cast <code class="docutils literal notranslate"><span class="pre">T(e)</span></code> e <code class="docutils literal notranslate"><span class="pre">(T)e</span></code> non sono né sicure né generali.</p>
</section>
<section id="id1096">
<h5>Esempio<a class="headerlink" href="#id1096" title="Link to this heading">¶</a></h5>
<p>Per i tipi nativi, la notazione per la costruzione protegge dal narrowing e dalla reinterpretazione</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use(char ch, int i, double d, char* p, long long lng)
{
    int x1 = int{ch};     // OK, but redundant
    int x2 = int{d};      // error: double-&gt;int narrowing; use a cast if you need to
    int x3 = int{p};      // error: pointer to-&gt;int; use a reinterpret_cast if you really need to
    int x4 = int{lng};    // error: long long-&gt;int narrowing; use a cast if you need to

    int y1 = int(ch);     // OK, but redundant
    int y2 = int(d);      // bad: double-&gt;int narrowing; use a cast if you need to
    int y3 = int(p);      // bad: pointer to-&gt;int; use a reinterpret_cast if you really need to
    int y4 = int(lng);    // bad: long long-&gt;int narrowing; use a cast if you need to

    int z1 = (int)ch;     // OK, but redundant
    int z2 = (int)d;      // bad: double-&gt;int narrowing; use a cast if you need to
    int z3 = (int)p;      // bad: pointer to-&gt;int; use a reinterpret_cast if you really need to
    int z4 = (int)lng;    // bad: long long-&gt;int narrowing; use a cast if you need to
}
</pre></div>
</div>
<p>Le conversioni intere in/da puntatori sono implementazioni definite quando si usano le notazioni <code class="docutils literal notranslate"><span class="pre">T(e)</span></code> o <code class="docutils literal notranslate"><span class="pre">(T)e</span></code>, e non sono portabili tra le piattaforme con dimensioni diverse degli interi e dei puntatori.</p>
</section>
<section id="id1097">
<h5>Nota<a class="headerlink" href="#id1097" title="Link to this heading">¶</a></h5>
<p><a class="reference internal" href="#Res-casts"><span class="xref myst">Evitare i cast</span></a> (conversione esplicita del tipo) e, se lo si deve fare, <a class="reference internal" href="#Res-casts-named"><span class="xref myst">preferire i «named cast»</span></a>.</p>
</section>
<section id="id1098">
<h5>Nota<a class="headerlink" href="#id1098" title="Link to this heading">¶</a></h5>
<p>Se non è ambiguo, la <code class="docutils literal notranslate"><span class="pre">T</span></code> può essere lasciata fuori da <code class="docutils literal notranslate"><span class="pre">T{e}</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>complex&lt;double&gt; f(complex&lt;double&gt;);

auto z = f({2*pi, 1});
</pre></div>
</div>
</section>
<section id="id1099">
<h5>Nota<a class="headerlink" href="#id1099" title="Link to this heading">¶</a></h5>
<p>La notazione della costruzione è la più generale <a class="reference internal" href="#Res-list"><span class="xref myst">notazione dell’inizializzatore</span></a>.</p>
</section>
<section id="id1100">
<h5>Eccezione<a class="headerlink" href="#id1100" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">std::vector</span></code> ed altri contenitori sono stati definiti prima di avere <code class="docutils literal notranslate"><span class="pre">{}</span></code> come notazione per la costruzione. Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;string&gt; vs {10};                           // ten empty strings
vector&lt;int&gt; vi1 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  // ten elements 1..10
vector&lt;int&gt; vi2 {10};                             // one element with the value 10
</pre></div>
</div>
<p>Come si ottiene un <code class="docutils literal notranslate"><span class="pre">vector</span></code> di 10 <code class="docutils literal notranslate"><span class="pre">int</span></code> inizializzati col default?</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;int&gt; v3(10); // ten elements with value 0
</pre></div>
</div>
<p>L’uso di <code class="docutils literal notranslate"><span class="pre">()</span></code> anziché di <code class="docutils literal notranslate"><span class="pre">{}</span></code> per il numero degli elementi è convenzionale (risalente ai primi anni “80), difficile da cambiare, ma resta un errore di progetto: per un contenitore dove il tipo dell’elemento si può confondere col numero degli elementi, si ha un’ambiguità da risolvere. La soluzione convenzionale consiste nell’interpretare <code class="docutils literal notranslate"><span class="pre">{10}</span></code> come un elenco di un elemento ed usare <code class="docutils literal notranslate"><span class="pre">(10)</span></code> per distinguere una dimensione.</p>
<p>Non c’è bisogno di ripetere questo errore nel nuovo codice. Si può definire un tipo per rappresentare il numero degli elementi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Count { int n; };

template&lt;typename T&gt;
class Vector {
public:
    Vector(Count n);                     // n default-initialized elements
    Vector(initializer_list&lt;T&gt; init);    // init.size() elements
    // ...
};

Vector&lt;int&gt; v1{10};
Vector&lt;int&gt; v2{Count{10}};
Vector&lt;Count&gt; v3{Count{10}};    // yes, there is still a very minor problem
</pre></div>
</div>
<p>Il principale problema lasciato è quello di trovare un nome adatto per <code class="docutils literal notranslate"><span class="pre">Count</span></code>.</p>
</section>
<section id="id1101">
<h5>Imposizione<a class="headerlink" href="#id1101" title="Link to this heading">¶</a></h5>
<p>Segnalare i cast di tipo C <code class="docutils literal notranslate"><span class="pre">(T)e</span></code> e quelli in stile funzionale <code class="docutils literal notranslate"><span class="pre">T(e)</span></code>.</p>
</section>
</section>
<section id="es-65-don-t-dereference-an-invalid-pointer">
<h4><a name="Res-deref"></a>ES.65: Non de-referenziare un puntatore non valido<a class="headerlink" href="#es-65-don-t-dereference-an-invalid-pointer" title="Link to this heading">¶</a></h4>
<section id="id1102">
<h5>Motivo<a class="headerlink" href="#id1102" title="Link to this heading">¶</a></h5>
<p>Dereferenziare un puntatore non valido, come <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>, è un comportamento indefinito, che di solito porta ad arresti anomali immediati, risultati errati o corruzione della memoria.</p>
</section>
<section id="id1103">
<h5>Nota<a class="headerlink" href="#id1103" title="Link to this heading">¶</a></h5>
<p>Per puntatore qui si intende qualsiasi riferimento indiretto a un oggetto, incluso equivalentemente un iteratore o una vista.</p>
</section>
<section id="id1104">
<h5>Nota<a class="headerlink" href="#id1104" title="Link to this heading">¶</a></h5>
<p>Questa è una regola ovvia e ben conosciuta del linguaggio, ma può essere ben difficile da seguire. Sono necessari un buon stile di codifica, una libreria di supporto e l’analisi statica per eliminare le violazioni senza un ulteriore lavoro. Questa è una parte importante della discussione sul <a class="reference internal" href="#Stroustrup15"><span class="xref myst">modello del C++ per la sicurezza dei tipi e delle risorse</span></a>.</p>
<p><strong>Si veda anche</strong>:</p>
<ul class="simple">
<li><p>Usare <a class="reference internal" href="#Rr-raii"><span class="xref myst">RAII</span></a> per evitare i problemi sul ciclo-di-vita [lifetime].</p></li>
<li><p>Usare <a class="reference internal" href="#Rf-unique_ptr"><span class="xref myst">unique_ptr</span></a> per evitare i problemi sul ciclo-di-vita [lifetime].</p></li>
<li><p>Usare <a class="reference internal" href="#Rf-shared_ptr"><span class="xref myst">shared_ptr</span></a> per evitare i problemi sul ciclo-di-vita [lifetime].</p></li>
<li><p>Usare i <a class="reference internal" href="#Rf-ptr-ref"><span class="xref myst">riferimenti</span></a> quando non è possibile <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</p></li>
<li><p>Usare <a class="reference internal" href="#Rf-nullptr"><span class="xref myst">not_null</span></a> per rilevare in anticipo un inatteso <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</p></li>
<li><p>Usare il <a class="reference internal" href="#SS-bounds"><span class="xref myst">profilo dei [bound]</span></a> per evitare gli errori sui range.</p></li>
</ul>
</section>
<section id="id1105">
<h5>Esempio<a class="headerlink" href="#id1105" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    int x = 0;
    int* p = &amp;x;

    if (condition()) {
        int y = 0;
        p = &amp;y;
    } // invalidates p

    *p = 42;            // BAD, p might be invalid if the branch was taken
}
</pre></div>
</div>
<p>Per risolvere il problema, o si prolunga la durata dell’oggetto a cui si intende fare riferimento col puntatore, o si riduce la durata del puntatore (si sposta la dereferenza prima che finisca la durata dell’oggetto puntato).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f1()
{
    int x = 0;
    int* p = &amp;x;

    int y = 0;
    if (condition()) {
        p = &amp;y;
    }

    *p = 42;            // OK, p points to x or y and both are still in scope
}
</pre></div>
</div>
<p>Sfortunatamente, la maggior parte dei problemi sui puntatori non validi sono più difficili da individuare e più difficili da risolvere.</p>
</section>
<section id="id1106">
<h5>Esempio<a class="headerlink" href="#id1106" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int* p)
{
    int x = *p; // BAD: how do we know that p is valid?
}
</pre></div>
</div>
<p>Esiste un’enorme quantità di codice simile. La maggior parte funziona – dopo molti test – ma isolatamente è impossibile dire se <code class="docutils literal notranslate"><span class="pre">p</span></code> potrebbe essere <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>. Di conseguenza, anche questa è una delle principali fonti di errori. Esistono molti approcci per affrontare questo potenziale problema:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f1(int* p) // deal with nullptr
{
    if (!p) {
        // deal with nullptr (allocate, return, throw, make p point to something, whatever
    }
    int x = *p;
}
</pre></div>
</div>
<p>Ci sono due potenziali problemi col test per il <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>:</p>
<ul class="simple">
<li><p>non è sempre ovvio cosa fare se troviamo <code class="docutils literal notranslate"><span class="pre">nullptr</span></code></p></li>
<li><p>il test può essere ridondante e/o relativamente costoso</p></li>
<li><p>non è ovvio se il test deve proteggere da una violazione o è parte della logica richiesta.</p></li>
</ul>
<!-- comment needed for code block after list -->
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f2(int* p) // state that p is not supposed to be nullptr
{
    assert(p);
    int x = *p;
}
</pre></div>
</div>
<p>Ciò comporterebbe un costo solo quando viene abilitato il controllo dell’asserzione e fornisce informazioni utili a un compilatore/analizzatore. Funzionerebbe ancora meglio se/quando il C++ avesse un supporto diretto per i contratti [contract]:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f3(int* p) // state that p is not supposed to be nullptr
    [[expects: p]]
{
    int x = *p;
}
</pre></div>
</div>
<p>In alternativa, si potrebbe usare <code class="docutils literal notranslate"><span class="pre">gsl::not_null</span></code> per assicurarsi che <code class="docutils literal notranslate"><span class="pre">p</span></code> non sia <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(not_null&lt;int*&gt; p)
{
    int x = *p;
}
</pre></div>
</div>
<p>Questi rimedi si occupano solo di <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>. Si tenga presente che esistono altri modi per ottenere un puntatore invalido.</p>
</section>
<section id="id1107">
<h5>Esempio<a class="headerlink" href="#id1107" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int* p)  // old code, doesn&#39;t use owner
{
    delete p;
}

void g()        // old code: uses naked new
{
    auto q = new int{7};
    f(q);
    int x = *q; // BAD: dereferences invalid pointer
}
</pre></div>
</div>
</section>
<section id="id1108">
<h5>Esempio<a class="headerlink" href="#id1108" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    vector&lt;int&gt; v(10);
    int* p = &amp;v[5];
    v.push_back(99); // could reallocate v&#39;s elements
    int x = *p; // BAD: dereferences potentially invalid pointer
}
</pre></div>
</div>
</section>
<section id="id1109">
<h5>Imposizione<a class="headerlink" href="#id1109" title="Link to this heading">¶</a></h5>
<p>Questa regola fa parte del <a class="reference internal" href="#SS-lifetime"><span class="xref myst">profilo di sicurezza dei limiti</span></a></p>
<ul class="simple">
<li><p>Segnalare una dereferenza di un puntatore che punta ad un oggetto che è uscito dallo scope</p></li>
<li><p>Segnalare una dereferenza di un puntatore che potrebbe essere stato invalidato da un’assegnazione con <code class="docutils literal notranslate"><span class="pre">nullptr</span></code></p></li>
<li><p>Segnalare una dereferenza di un puntatore che potrebbe essere stato invalidato da un <code class="docutils literal notranslate"><span class="pre">delete</span></code></p></li>
<li><p>Segnalare una dereferenza di un puntatore a un elemento di un contenitore che potrebbe essere stato invalidato per dereferenza</p></li>
</ul>
</section>
</section>
</section>
<section id="es-stmt-statements">
<h3>ES.stmt: Istruzioni<a class="headerlink" href="#es-stmt-statements" title="Link to this heading">¶</a></h3>
<p>Le istruzioni controllano il flusso di controllo (ad eccezione delle chiamate alla funzione e degli errori, che sono espressioni).</p>
<section id="es-70-prefer-a-switch-statement-to-an-if-statement-when-there-is-a-choice">
<h4><a name="Res-switch-if"></a>ES.70: Preferire l’istruzione <code class="docutils literal notranslate"><span class="pre">switch</span></code> all’istruzione <code class="docutils literal notranslate"><span class="pre">if</span></code> potendo scegliere<a class="headerlink" href="#es-70-prefer-a-switch-statement-to-an-if-statement-when-there-is-a-choice" title="Link to this heading">¶</a></h4>
<section id="id1110">
<h5>Motivo<a class="headerlink" href="#id1110" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Leggibilità.</p></li>
<li><p>Efficienza: Uno <code class="docutils literal notranslate"><span class="pre">switch</span></code> effettua un confronto tra costanti ed è solitamente più ottimizzato di una serie di test con una sequenza di <code class="docutils literal notranslate"><span class="pre">if</span></code>-<code class="docutils literal notranslate"><span class="pre">then</span></code>-<code class="docutils literal notranslate"><span class="pre">else</span></code>.</p></li>
<li><p>Uno <code class="docutils literal notranslate"><span class="pre">switch</span></code> consente di effettuare un controllo euristico della consistenza. Per esempio, sono stati considerati tutti i valori di una <code class="docutils literal notranslate"><span class="pre">enum</span></code>? Se no, c’è un <code class="docutils literal notranslate"><span class="pre">default</span></code>?</p></li>
</ul>
</section>
<section id="id1111">
<h5>Esempio<a class="headerlink" href="#id1111" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use(int n)
{
    switch (n) {   // good
    case 0:
        // ...
        break;
    case 7:
        // ...
        break;
    default:
        // ...
        break;
    }
}
</pre></div>
</div>
<p>anziché:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void use2(int n)
{
    if (n == 0)   // bad: if-then-else chain comparing against a set of constants
        // ...
    else if (n == 7)
        // ...
}
</pre></div>
</div>
</section>
<section id="id1112">
<h5>Imposizione<a class="headerlink" href="#id1112" title="Link to this heading">¶</a></h5>
<p>Segnalare le sequenze di <code class="docutils literal notranslate"><span class="pre">if</span></code>-<code class="docutils literal notranslate"><span class="pre">then</span></code>-<code class="docutils literal notranslate"><span class="pre">else</span></code> che confrontano (solo) con costanti.</p>
</section>
</section>
<section id="es-71-prefer-a-range-for-statement-to-a-for-statement-when-there-is-a-choice">
<h4><a name="Res-for-range"></a>ES.71: Preferire un’istruzione range-<code class="docutils literal notranslate"><span class="pre">for</span></code> ad un’istruzione for` potendo scegliere<a class="headerlink" href="#es-71-prefer-a-range-for-statement-to-a-for-statement-when-there-is-a-choice" title="Link to this heading">¶</a></h4>
<section id="id1113">
<h5>Motivo<a class="headerlink" href="#id1113" title="Link to this heading">¶</a></h5>
<p>Leggibilità. Prevenzione degli errori. Efficienza.</p>
</section>
<section id="id1114">
<h5>Esempio<a class="headerlink" href="#id1114" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (gsl::index i = 0; i &lt; v.size(); ++i)   // bad
    cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;;

for (auto p = v.begin(); p != v.end(); ++p)   // bad
    cout &lt;&lt; *p &lt;&lt; &#39;\n&#39;;

for (auto&amp; x : v)    // OK
    cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;

for (gsl::index i = 1; i &lt; v.size(); ++i) // touches two elements: can&#39;t be a range-for
    cout &lt;&lt; v[i] + v[i - 1] &lt;&lt; &#39;\n&#39;;

for (gsl::index i = 0; i &lt; v.size(); ++i) // possible side effect: can&#39;t be a range-for
    cout &lt;&lt; f(v, &amp;v[i]) &lt;&lt; &#39;\n&#39;;

for (gsl::index i = 0; i &lt; v.size(); ++i) { // body messes with loop variable: can&#39;t be a range-for
    if (i % 2 != 0)
        cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;; // output odd elements
}
</pre></div>
</div>
<p>n umano o un buon analizzatore statico potrebbe determinare che non ci sono effetti collaterali su <code class="docutils literal notranslate"><span class="pre">v</span></code> in <code class="docutils literal notranslate"><span class="pre">f(v,</span> <span class="pre">&amp;v[i])</span></code> in modo che si possa riscrivere il loop.</p>
<p>In genere è meglio evitare di «scombussolare la variabile del loop» nel suo body.</p>
</section>
<section id="id1115">
<h5>Nota<a class="headerlink" href="#id1115" title="Link to this heading">¶</a></h5>
<p>Non usare costose copie della variabile del loop in un ciclo range-<code class="docutils literal notranslate"><span class="pre">for</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (string s : vs) // ...
</pre></div>
</div>
<p>Questo copierà ogni elemento di <code class="docutils literal notranslate"><span class="pre">vs</span></code> in <code class="docutils literal notranslate"><span class="pre">s</span></code>. Meglio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (string&amp; s : vs) // ...
</pre></div>
</div>
<p>Meglio ancora, se la variabile del loop non viene modificata o copiata:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (const string&amp; s : vs) // ...
</pre></div>
</div>
</section>
<section id="id1116">
<h5>Imposizione<a class="headerlink" href="#id1116" title="Link to this heading">¶</a></h5>
<p>Cercare i loop, se un tradizionale ciclo cerca solamente ogni elemento di una sequenza e non ci sono effetti collaterali su quello che fa con gli elementi, si riscriva il loop utilizzando un range-<code class="docutils literal notranslate"><span class="pre">for</span></code>.</p>
</section>
</section>
<section id="es-72-prefer-a-for-statement-to-a-while-statement-when-there-is-an-obvious-loop-variable">
<h4><a name="Res-for-while"></a>ES.72: Preferire un’istruzione <code class="docutils literal notranslate"><span class="pre">for</span></code> ad un’istruzione <code class="docutils literal notranslate"><span class="pre">while</span></code> quando c’è un’ovvia variabile del ciclo<a class="headerlink" href="#es-72-prefer-a-for-statement-to-a-while-statement-when-there-is-an-obvious-loop-variable" title="Link to this heading">¶</a></h4>
<section id="id1117">
<h5>Motivo<a class="headerlink" href="#id1117" title="Link to this heading">¶</a></h5>
<p>Leggibilità: si ha «davanti» tutta la logica del ciclo. Lo scope della variabile del loop può essere limitato.</p>
</section>
<section id="id1118">
<h5>Esempio<a class="headerlink" href="#id1118" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (gsl::index i = 0; i &lt; vec.size(); i++) {
    // do work
}
</pre></div>
</div>
</section>
<section id="id1119">
<h5>Esempio, cattivo<a class="headerlink" href="#id1119" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int i = 0;
while (i &lt; vec.size()) {
    // do work
    i++;
}
</pre></div>
</div>
</section>
<section id="id1120">
<h5>Imposizione<a class="headerlink" href="#id1120" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="es-73-prefer-a-while-statement-to-a-for-statement-when-there-is-no-obvious-loop-variable">
<h4><a name="Res-while-for"></a>ES.73: Preferire un’istruzione <code class="docutils literal notranslate"><span class="pre">while</span></code> ad un’istruzione <code class="docutils literal notranslate"><span class="pre">for</span></code> quando non è ovvia la variabile del ciclo<a class="headerlink" href="#es-73-prefer-a-while-statement-to-a-for-statement-when-there-is-no-obvious-loop-variable" title="Link to this heading">¶</a></h4>
<section id="id1121">
<h5>Motivo<a class="headerlink" href="#id1121" title="Link to this heading">¶</a></h5>
<p>Leggibilità.</p>
</section>
<section id="id1122">
<h5>Esempio<a class="headerlink" href="#id1122" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int events = 0;
for (; wait_for_event(); ++events) {  // bad, confusing
    // ...
}
</pre></div>
</div>
<p>Il «ciclo event» è fuorviante perché il contatore degli eventi, <code class="docutils literal notranslate"><span class="pre">events</span></code>, non ha niente a che fare con la condizione del loop (<code class="docutils literal notranslate"><span class="pre">wait_for_event()</span></code>). Meglio</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int events = 0;
while (wait_for_event()) {      // better
    ++events;
    // ...
}
</pre></div>
</div>
</section>
<section id="id1123">
<h5>Imposizione<a class="headerlink" href="#id1123" title="Link to this heading">¶</a></h5>
<p>Segnalare le azioni negli inizializzatori dei <code class="docutils literal notranslate"><span class="pre">for</span></code> e negli incrementi dei <code class="docutils literal notranslate"><span class="pre">for</span></code> che non sono in relazione con la condizione del <code class="docutils literal notranslate"><span class="pre">for</span></code>.</p>
</section>
</section>
<section id="es-74-prefer-to-declare-a-loop-variable-in-the-initializer-part-of-a-for-statement">
<h4><a name="Res-for-init"></a>ES.74: Dichiarare la variabile del ciclo nella parte dell’inizializzatore dell’istruzione <code class="docutils literal notranslate"><span class="pre">for</span></code><a class="headerlink" href="#es-74-prefer-to-declare-a-loop-variable-in-the-initializer-part-of-a-for-statement" title="Link to this heading">¶</a></h4>
<p>Cfr. <a class="reference internal" href="#Res-cond"><span class="xref myst">ES.6</span></a></p>
</section>
<section id="es-75-avoid-do-statements">
<h4><a name="Res-do"></a>ES.75: Evitare l’istruzione <code class="docutils literal notranslate"><span class="pre">do</span></code><a class="headerlink" href="#es-75-avoid-do-statements" title="Link to this heading">¶</a></h4>
<section id="id1124">
<h5>Motivo<a class="headerlink" href="#id1124" title="Link to this heading">¶</a></h5>
<p>Leggibilità, prevenzione degli errori. La condizione per terminare sta alla fine (dove non si può ignorare) e la condizione non è verificata al primo passaggio.</p>
</section>
<section id="id1125">
<h5>Esempio<a class="headerlink" href="#id1125" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int x;
do {
    cin &gt;&gt; x;
    // ...
} while (x &lt; 0);
</pre></div>
</div>
</section>
<section id="id1126">
<h5>Nota<a class="headerlink" href="#id1126" title="Link to this heading">¶</a></h5>
<p>Sì, ci sono buoni esempi in cui un’istruzione <code class="docutils literal notranslate"><span class="pre">do</span></code> risulta una soluzione chiara, ma anche molti errori.</p>
</section>
<section id="id1127">
<h5>Imposizione<a class="headerlink" href="#id1127" title="Link to this heading">¶</a></h5>
<p>Segnalare le istruzioni <code class="docutils literal notranslate"><span class="pre">do</span></code>.</p>
</section>
</section>
<section id="es-76-avoid-goto">
<h4><a name="Res-goto"></a>ES.76: Evitare il <code class="docutils literal notranslate"><span class="pre">goto</span></code><a class="headerlink" href="#es-76-avoid-goto" title="Link to this heading">¶</a></h4>
<section id="id1128">
<h5>Motivo<a class="headerlink" href="#id1128" title="Link to this heading">¶</a></h5>
<p>Leggibilità, prevenzione degli errori. Esistono strutture di controllo migliori per gli umani; il <code class="docutils literal notranslate"><span class="pre">goto</span></code> è per il codice generato dalla macchina.</p>
</section>
<section id="id1129">
<h5>Eccezione<a class="headerlink" href="#id1129" title="Link to this heading">¶</a></h5>
<p>Uscire da un ciclo annidato. In questo caso, saltare sempre in avanti.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (int i = 0; i &lt; imax; ++i)
    for (int j = 0; j &lt; jmax; ++j) {
        if (a[i][j] &gt; elem_max) goto finished;
        // ...
    }
finished:
// ...
</pre></div>
</div>
</section>
<section id="id1130">
<h5>Esempio, cattivo<a class="headerlink" href="#id1130" title="Link to this heading">¶</a></h5>
<p>C’è un largo uso del blocco goto-exit del C:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    // ...
        goto exit;
    // ...
        goto exit;
    // ...
exit:
    // ... common cleanup code ...
}
</pre></div>
</div>
<p>Questa è una simulazione ad-hoc dei distruttori. Si dichiarino le proprie risorse con gli handle con i distruttori che ripuliscono tutto. Se per qualche motivo non si può gestire la ripulitura delle variabili usate con i distruttori, si prenda in considerazione <code class="docutils literal notranslate"><span class="pre">gsl::finally()</span></code> come un’alternativa di pulizia più leggibile al <code class="docutils literal notranslate"><span class="pre">goto</span> <span class="pre">exit</span></code></p>
</section>
<section id="id1131">
<h5>Imposizione<a class="headerlink" href="#id1131" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare i <code class="docutils literal notranslate"><span class="pre">goto</span></code>. Meglio ancora segnalare tutti i <code class="docutils literal notranslate"><span class="pre">goto</span></code> che non saltano da un ciclo nidificato all’istruzione immediatamente dopo al ciclo più esterno.</p></li>
</ul>
</section>
</section>
<section id="es-77-minimize-the-use-of-break-and-continue-in-loops">
<h4><a name="Res-continue"></a>ES.77: Minimizzare l’uso di <code class="docutils literal notranslate"><span class="pre">break</span></code> e <code class="docutils literal notranslate"><span class="pre">continue</span></code> nei cicli<a class="headerlink" href="#es-77-minimize-the-use-of-break-and-continue-in-loops" title="Link to this heading">¶</a></h4>
<section id="id1132">
<h5>Motivo<a class="headerlink" href="#id1132" title="Link to this heading">¶</a></h5>
<p>Nel body di un ciclo un po” più complesso, è facile tralasciare un <code class="docutils literal notranslate"><span class="pre">break</span></code> o un <code class="docutils literal notranslate"><span class="pre">continue</span></code>.</p>
<p>Un <code class="docutils literal notranslate"><span class="pre">break</span></code> in un ciclo ha un significato terribilmente diverso da un <code class="docutils literal notranslate"><span class="pre">break</span></code> in un’istruzione <code class="docutils literal notranslate"><span class="pre">switch</span></code> (e si possono avere istruzioni <code class="docutils literal notranslate"><span class="pre">switch</span></code> in un ciclo e un ciclo in un “case” di uno <code class="docutils literal notranslate"><span class="pre">switch</span></code>).</p>
</section>
<section id="id1133">
<h5>Esempio<a class="headerlink" href="#id1133" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>switch(x) {
case 1 :
    while (/* some condition */) {
        // ...
    break;
    } // Oops! break switch or break while intended?
case 2 :
    // ...
    break;
}
</pre></div>
</div>
</section>
<section id="id1134">
<h5>Alternativa<a class="headerlink" href="#id1134" title="Link to this heading">¶</a></h5>
<p>Spesso, un loop che richiede un <code class="docutils literal notranslate"><span class="pre">break</span></code> è un buon candidato per una funzione (algoritmo), nel qual caso il <code class="docutils literal notranslate"><span class="pre">break</span></code> diventa un <code class="docutils literal notranslate"><span class="pre">return</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//Original code: break inside loop
void use1()
{
    std::vector&lt;T&gt; vec = {/* initialized with some values */};
    T value;
    for (const T item : vec) {
        if (/* some condition*/) {
            value = item;
            break;
        }
    }
    /* then do something with value */
}

//BETTER: create a function and return inside loop
T search(const std::vector&lt;T&gt; &amp;vec)
{
    for (const T &amp;item : vec) {
        if (/* some condition*/) return item;
    }
    return T(); //default value
}

void use2()
{
    std::vector&lt;T&gt; vec = {/* initialized with some values */};
    T value = search(vec);
    /* then do something with value */
}
</pre></div>
</div>
<p>Spesso, un ciclo che usa il <code class="docutils literal notranslate"><span class="pre">continue</span></code> può essere equivalentemente e chiaramente espresso da un’istruzione <code class="docutils literal notranslate"><span class="pre">if</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (int item : vec) {  // BAD
    if (item%2 == 0) continue;
    if (item == 5) continue;
    if (item &gt; 10) continue;
    /* do something with item */
}

for (int item : vec) {  // GOOD
    if (item%2 != 0 &amp;&amp; item != 5 &amp;&amp; item &lt;= 10) {
        /* do something with item */
    }
}
</pre></div>
</div>
</section>
<section id="id1135">
<h5>Nota<a class="headerlink" href="#id1135" title="Link to this heading">¶</a></h5>
<p>Se è davvero necessario interrompere un loop, un <code class="docutils literal notranslate"><span class="pre">break</span></code> è in generale la migliore delle alternative al <a class="reference internal" href="#Res-loop-counter"><span class="xref myst">modificare la variabile del loop</span></a> o al <a class="reference internal" href="#Res-goto"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">goto</span></code></span></a>:</p>
</section>
<section id="id1136">
<h5>Imposizione<a class="headerlink" href="#id1136" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="es-78-don-t-rely-on-implicit-fallthrough-in-switch-statements">
<h4><a name="Res-break"></a>ES.78: Non fare affidamento ai proseguimenti impliciti nelle istruzioni <code class="docutils literal notranslate"><span class="pre">switch</span></code><a class="headerlink" href="#es-78-don-t-rely-on-implicit-fallthrough-in-switch-statements" title="Link to this heading">¶</a></h4>
<section id="id1137">
<h5>Motivo<a class="headerlink" href="#id1137" title="Link to this heading">¶</a></h5>
<p>Finire sempre un <code class="docutils literal notranslate"><span class="pre">case</span></code> non vuoto con un <code class="docutils literal notranslate"><span class="pre">break</span></code>. Tralasciare accidentalmente un <code class="docutils literal notranslate"><span class="pre">break</span></code> è un bug abbastanza comune. Affidarsi deliberatamente al proseguimento implicito può rappresentare un pericolo per la manutenzione e dovrebbe essere un fatto raro ed esplicito.</p>
</section>
<section id="id1138">
<h5>Esempio<a class="headerlink" href="#id1138" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>switch (eventType) {
case Information:
    update_status_bar();
    break;
case Warning:
    write_event_log();
    // Bad - implicit fallthrough
case Error:
    display_error_window();
    break;
}
</pre></div>
</div>
<p>Label di casi multipli di una singola istruzione è OK:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>switch (x) {
case &#39;a&#39;:
case &#39;b&#39;:
case &#39;f&#39;:
    do_something(x);
    break;
}
</pre></div>
</div>
<p>Anche le istruzioni return nell’etichetta di un case sono OK:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>switch (x) {
case &#39;a&#39;:
    return 1;
case &#39;b&#39;:
    return 2;
case &#39;c&#39;:
    return 3;
}
</pre></div>
</div>
</section>
<section id="id1139">
<h5>Eccezioni<a class="headerlink" href="#id1139" title="Link to this heading">¶</a></h5>
<p>In rari casi se si ritiene opportuno il proseguimento implicito, si dev’essere espliciti ed usare la notazione <code class="docutils literal notranslate"><span class="pre">[[fallthrough]]</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>switch (eventType) {
case Information:
    update_status_bar();
    break;
case Warning:
    write_event_log();
    [[fallthrough]];
case Error:
    display_error_window();
    break;
}
</pre></div>
</div>
</section>
<section id="id1140">
<h5>Nota<a class="headerlink" href="#id1140" title="Link to this heading">¶</a></h5>
</section>
<section id="id1141">
<h5>Imposizione<a class="headerlink" href="#id1141" title="Link to this heading">¶</a></h5>
<p>Segnalare tutti i proseguimenti [fallthrough] impliciti nei <code class="docutils literal notranslate"><span class="pre">case</span></code> non vuoti.</p>
</section>
</section>
<section id="es-79-use-default-to-handle-common-cases-only">
<h4><a name="Res-default"></a>ES.79: Usare <code class="docutils literal notranslate"><span class="pre">default</span></code> per gestire i (soli) casi comuni<a class="headerlink" href="#es-79-use-default-to-handle-common-cases-only" title="Link to this heading">¶</a></h4>
<section id="id1142">
<h5>Motivo<a class="headerlink" href="#id1142" title="Link to this heading">¶</a></h5>
<p>Chiarezza del codice.  Migliori opportunità per il rilevamento degli errori.</p>
</section>
<section id="id1143">
<h5>Esempio<a class="headerlink" href="#id1143" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum E { a, b, c, d };

void f1(E x)
{
    switch (x) {
    case a:
        do_something();
        break;
    case b:
        do_something_else();
        break;
    default:
        take_the_default_action();
        break;
    }
}
</pre></div>
</div>
<p>Qui è chiaro che esiste un’azione di default e che i casi <code class="docutils literal notranslate"><span class="pre">a</span></code> e <code class="docutils literal notranslate"><span class="pre">b</span></code> sono speciali.</p>
</section>
<section id="id1144">
<h5>Esempio<a class="headerlink" href="#id1144" title="Link to this heading">¶</a></h5>
<p>Ma cosa succede se non c’è un’azione di default e si vogliono gestire solo casi specifici? In tal caso, si inserisca un default vuoto o altrimenti sarà impossibile sapere se si intendevano gestire tutti i casi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f2(E x)
{
    switch (x) {
    case a:
        do_something();
        break;
    case b:
        do_something_else();
        break;
    default:
        // do nothing for the rest of the cases
        break;
    }
}
</pre></div>
</div>
<p>Omettendo il <code class="docutils literal notranslate"><span class="pre">default</span></code>, un manutentore e/o un compilatore potrebbe ragionevolmente presumere che si intendano gestire tutti i casi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f2(E x)
{
    switch (x) {
    case a:
        do_something();
        break;
    case b:
    case c:
        do_something_else();
        break;
    }
}
</pre></div>
</div>
<p>È stato dimenticato il case <code class="docutils literal notranslate"><span class="pre">d</span></code> o lo si è deliberatamente tralasciato? La dimenticanza di un case solitamente avviene quando viene aggiunto un elemento ad un enumerazione e chi lo ha fatto non è riuscito a inserirlo in tutti gli switch che usano quell’enumeratore.</p>
</section>
<section id="id1145">
<h5>Imposizione<a class="headerlink" href="#id1145" title="Link to this heading">¶</a></h5>
<p>Segnalare le istruzioni <code class="docutils literal notranslate"><span class="pre">switch</span></code> basate su una enumerazione che non gestiscono tutte le enumerazioni e non hanno un <code class="docutils literal notranslate"><span class="pre">default</span></code>. Questo potrebbe produrre troppi falsi positivi in certi tipi di codice; in tal caso, segnalare solo gli <code class="docutils literal notranslate"><span class="pre">switch</span></code> che gestiscono la maggior parte ma non tutti (questa era la strategia del primissimo compilatore C++).</p>
</section>
</section>
<section id="es-84-don-t-try-to-declare-a-local-variable-with-no-name">
<h4><a name="Res-noname"></a>ES.84: Non tentare di dichiarare una variabile locale senza nome<a class="headerlink" href="#es-84-don-t-try-to-declare-a-local-variable-with-no-name" title="Link to this heading">¶</a></h4>
<section id="id1146">
<h5>Motivo<a class="headerlink" href="#id1146" title="Link to this heading">¶</a></h5>
<p>Non c’è nulla di simile. Quello che ad un umano appare come una variabile senza un nome per un compilatore è un’istruzione che consiste in un temporaneo che subito esce dallo scope.</p>
</section>
<section id="id1147">
<h5>Esempio, cattivo<a class="headerlink" href="#id1147" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    lock_guard&lt;mutex&gt;{mx};   // Bad
    // ...
}
</pre></div>
</div>
<p>Questo dichiara un oggetto <code class="docutils literal notranslate"><span class="pre">lock_guard</span></code> anonimo che esce immediatamente dallo scope vicino al punto e virgola. Non è un errore insolito. In particolare, questo esempio può portare a conflitti difficili da trovare.</p>
</section>
<section id="id1148">
<h5>Nota<a class="headerlink" href="#id1148" title="Link to this heading">¶</a></h5>
<p>Gli argomenti di funzioni senza nome vanno bene.</p>
</section>
<section id="id1149">
<h5>Imposizione<a class="headerlink" href="#id1149" title="Link to this heading">¶</a></h5>
<p>Segnalare le istruzioni che sono solo temporanee.</p>
</section>
</section>
<section id="es-85-make-empty-statements-visible">
<h4><a name="Res-empty"></a>ES.85: Rendere visibili le istruzioni vuote<a class="headerlink" href="#es-85-make-empty-statements-visible" title="Link to this heading">¶</a></h4>
<section id="id1150">
<h5>Motivo<a class="headerlink" href="#id1150" title="Link to this heading">¶</a></h5>
<p>Leggibilità.</p>
</section>
<section id="id1151">
<h5>Esempio<a class="headerlink" href="#id1151" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (i = 0; i &lt; max; ++i);   // BAD: the empty statement is easily overlooked
v[i] = f(v[i]);

for (auto x : v) {           // better
    // nothing
}
v[i] = f(v[i]);
</pre></div>
</div>
</section>
<section id="id1152">
<h5>Imposizione<a class="headerlink" href="#id1152" title="Link to this heading">¶</a></h5>
<p>Segnalare le istruzioni vuote che non sono blocchi e non contengono commenti.</p>
</section>
</section>
<section id="es-86-avoid-modifying-loop-control-variables-inside-the-body-of-raw-for-loops">
<h4><a name="Res-loop-counter"></a>ES.86: Evitare di modificare le variabili di controllo dei cicli nel corpo dei cicli for<a class="headerlink" href="#es-86-avoid-modifying-loop-control-variables-inside-the-body-of-raw-for-loops" title="Link to this heading">¶</a></h4>
<section id="id1153">
<h5>Motivo<a class="headerlink" href="#id1153" title="Link to this heading">¶</a></h5>
<p>Il controllo del loop dovrebbe consentire il corretto ragionamento su quello che avviene all’interno del ciclo. Modificare i contatori dei loop sia nell’espressione dell’iterazione che nel corpo del loop è una perenne fonte di sorprese e bug.</p>
</section>
<section id="id1154">
<h5>Esempio<a class="headerlink" href="#id1154" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (int i = 0; i &lt; 10; ++i) {
    // no updates to i -- ok
}

for (int i = 0; i &lt; 10; ++i) {
    //
    if (/* something */) ++i; // BAD
    //
}

bool skip = false;
for (int i = 0; i &lt; 10; ++i) {
    if (skip) { skip = false; continue; }
    //
    if (/* something */) skip = true;  // Better: using two variables for two concepts.
    //
}
</pre></div>
</div>
</section>
<section id="id1155">
<h5>Imposizione<a class="headerlink" href="#id1155" title="Link to this heading">¶</a></h5>
<p>Segnalare le variabili che vengono potenzialmente aggiornate (hanno un uso non-<code class="docutils literal notranslate"><span class="pre">const</span></code>) sia nel controllo dell’iterazione del loop che nel suo body.</p>
</section>
</section>
<section id="es-87-don-t-add-redundant-or-to-conditions">
<h4><a name="Res-if"></a>ES.87: Non aggiungere dei ridondanti <code class="docutils literal notranslate"><span class="pre">==</span></code> o <code class="docutils literal notranslate"><span class="pre">!=</span></code> alle condizioni<a class="headerlink" href="#es-87-don-t-add-redundant-or-to-conditions" title="Link to this heading">¶</a></h4>
<section id="id1156">
<h5>Motivo<a class="headerlink" href="#id1156" title="Link to this heading">¶</a></h5>
<p>Questo evita la prolissità ed elimina delle opportunità per sbagliare. Aiuta a rendere lo stile coerente e convenzionale.</p>
</section>
<section id="id1157">
<h5>Esempio<a class="headerlink" href="#id1157" title="Link to this heading">¶</a></h5>
<p>Per definizione, una condizione in un’istruzione <code class="docutils literal notranslate"><span class="pre">if</span></code>, <code class="docutils literal notranslate"><span class="pre">while</span></code> o un <code class="docutils literal notranslate"><span class="pre">for</span></code> sceglie tra <code class="docutils literal notranslate"><span class="pre">true</span></code> e <code class="docutils literal notranslate"><span class="pre">false</span></code>. Un valore numerico viene confrontato con <code class="docutils literal notranslate"><span class="pre">0</span></code> e il valore di un puntatore con <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// These all mean &quot;if p is not nullptr&quot;
if (p) { ... }            // good
if (p != 0) { ... }       // redundant !=0, bad: don&#39;t use 0 for pointers
if (p != nullptr) { ... } // redundant !=nullptr, not recommended
</pre></div>
</div>
<p>Spesso, <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(p)</span></code> viene letto come «se <code class="docutils literal notranslate"><span class="pre">p</span></code> è valido» che è una diretta espressione dell’intento dei programmatori, mentre <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(p</span> <span class="pre">!=</span> <span class="pre">nullptr)</span></code> sarebbe una soluzione prolissa.</p>
</section>
<section id="id1158">
<h5>Esempio<a class="headerlink" href="#id1158" title="Link to this heading">¶</a></h5>
<p>Questa regola è particolarmente utile quando una dichiarazione viene utilizzata come condizione</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (auto pc = dynamic_cast&lt;Circle*&gt;(ps)) { ... } // execute if ps points to a kind of Circle, good

if (auto pc = dynamic_cast&lt;Circle*&gt;(ps); pc != nullptr) { ... } // not recommended
</pre></div>
</div>
</section>
<section id="id1159">
<h5>Esempio<a class="headerlink" href="#id1159" title="Link to this heading">¶</a></h5>
<p>Si noti che, nelle condizioni, sono applicate le conversioni implicite in bool. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (string s; cin &gt;&gt; s; ) v.push_back(s);
</pre></div>
</div>
<p>Ciò richiama, di <code class="docutils literal notranslate"><span class="pre">istream</span></code>, <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">bool()</span></code>.</p>
</section>
<section id="id1160">
<h5>Nota<a class="headerlink" href="#id1160" title="Link to this heading">¶</a></h5>
<p>Il confronto esplicito di un numero intero con <code class="docutils literal notranslate"><span class="pre">0</span></code> non è generalmente ridondante. Il motivo è che (al contrario di puntatori e dei booleani) un numero intero ha spesso più di due valori ragionevoli. Inoltre <code class="docutils literal notranslate"><span class="pre">0</span></code> (zero) viene spesso utilizzato per indicare un successo. Di conseguenza, è meglio essere specifici sul confronto.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int i)
{
    if (i)            // suspect
    // ...
    if (i == success) // possibly better
    // ...
}
</pre></div>
</div>
<p>Si ricordi sempre che un intero può avere più di due valori.</p>
</section>
<section id="id1161">
<h5>Esempio, cattivo<a class="headerlink" href="#id1161" title="Link to this heading">¶</a></h5>
<p>È stato notato che</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if(strcmp(p1, p2)) { ... }   // are the two C-style strings equal? (mistake!)
</pre></div>
</div>
<p>è un comune errore da principianti. Se si usano stringhe in stile C, si devono conoscere bene le funzioni <code class="docutils literal notranslate"><span class="pre">&lt;cstring&gt;</span></code>. Essere prolisso scrivendo</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if(strcmp(p1, p2) != 0) { ... }   // are the two C-style strings equal? (mistake!)
</pre></div>
</div>
<p>non basterebbe a salvare la situazione.</p>
</section>
<section id="id1162">
<h5>Nota<a class="headerlink" href="#id1162" title="Link to this heading">¶</a></h5>
<p>La condizione opposta viene espressa più facilmente con una negazione:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// These all mean &quot;if p is nullptr&quot;
if (!p) { ... }           // good
if (p == 0) { ... }       // redundant == 0, bad: don&#39;t use 0 for pointers
if (p == nullptr) { ... } // redundant == nullptr, not recommended
</pre></div>
</div>
</section>
<section id="id1163">
<h5>Imposizione<a class="headerlink" href="#id1163" title="Link to this heading">¶</a></h5>
<p>Semplice, basta controllare l’uso ridondante di <code class="docutils literal notranslate"><span class="pre">!=</span></code> e <code class="docutils literal notranslate"><span class="pre">==</span></code> nelle condizioni.</p>
</section>
</section>
</section>
<section id="arithmetic">
<h3><a name="SS-numbers"></a>Aritmetica<a class="headerlink" href="#arithmetic" title="Link to this heading">¶</a></h3>
<section id="es-100-don-t-mix-signed-and-unsigned-arithmetic">
<h4><a name="Res-mix"></a>ES.100: Non mischiare l’aritmetica con segno con quella senza segno<a class="headerlink" href="#es-100-don-t-mix-signed-and-unsigned-arithmetic" title="Link to this heading">¶</a></h4>
<section id="id1164">
<h5>Motivo<a class="headerlink" href="#id1164" title="Link to this heading">¶</a></h5>
<p>Evitare risultati errati.</p>
</section>
<section id="id1165">
<h5>Esempio<a class="headerlink" href="#id1165" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int x = -3;
unsigned int y = 7;

cout &lt;&lt; x - y &lt;&lt; &#39;\n&#39;;  // unsigned result, possibly 4294967286
cout &lt;&lt; x + y &lt;&lt; &#39;\n&#39;;  // unsigned result: 4
cout &lt;&lt; x * y &lt;&lt; &#39;\n&#39;;  // unsigned result, possibly 4294967275
</pre></div>
</div>
<p>È più difficile individuare il problema in esempi più realistici.</p>
</section>
<section id="id1166">
<h5>Nota<a class="headerlink" href="#id1166" title="Link to this heading">¶</a></h5>
<p>Sfortunatamente, il C++ usa interi con segno per gli indici degli array e la libreria standard usa interi senza segno per gli indici dei contenitori. Questo preclude la coerenza. Usare <code class="docutils literal notranslate"><span class="pre">gsl::index</span></code> per gli indici; <a class="reference internal" href="#Res-subscripts"><span class="xref myst">cfr. ES.107</span></a>.</p>
</section>
<section id="id1167">
<h5>Imposizione<a class="headerlink" href="#id1167" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>I compilatori già lo sanno e talvolta emettono dei warning.</p></li>
<li><p>(Per evitare confusione) Non segnalare un confronto tra signed/unsigned dove uno degli argomenti è <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> o una chiamata alla <code class="docutils literal notranslate"><span class="pre">.size()</span></code> di un container e l’altro è <code class="docutils literal notranslate"><span class="pre">ptrdiff_t</span></code>.</p></li>
</ul>
</section>
</section>
<section id="es-101-use-unsigned-types-for-bit-manipulation">
<h4><a name="Res-unsigned"></a>ES.101: Usare i tipi unsigned per la gestione dei bit<a class="headerlink" href="#es-101-use-unsigned-types-for-bit-manipulation" title="Link to this heading">¶</a></h4>
<section id="id1168">
<h5>Motivo<a class="headerlink" href="#id1168" title="Link to this heading">¶</a></h5>
<p>I tipi senza segno supportano la gestione dei bit senza le sorprese del bit del segno.</p>
</section>
<section id="id1169">
<h5>Esempio<a class="headerlink" href="#id1169" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned char x = 0b1010&#39;1010;
unsigned char y = ~x;   // y == 0b0101&#39;0101;
</pre></div>
</div>
</section>
<section id="id1170">
<h5>Nota<a class="headerlink" href="#id1170" title="Link to this heading">¶</a></h5>
<p>I tipi senza segno possono anche essere utili per l’aritmetica modulare. Tuttavia, se si vuole l’aritmetica modulare, si aggiungano i commenti necessari, evidenziando il comportamento “arrotolato”, in quanto questo codice può meravigliare alcuni programmatori.</p>
</section>
<section id="id1171">
<h5>Imposizione<a class="headerlink" href="#id1171" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Quasi impossibile in generale a causa dell’utilizzo di indici unsigned nella libreria standard</p></li>
<li><p>???</p></li>
</ul>
</section>
</section>
<section id="es-102-use-signed-types-for-arithmetic">
<h4><a name="Res-signed"></a>ES.102: Usare i tipi con segno per l’aritmetica<a class="headerlink" href="#es-102-use-signed-types-for-arithmetic" title="Link to this heading">¶</a></h4>
<section id="id1172">
<h5>Motivo<a class="headerlink" href="#id1172" title="Link to this heading">¶</a></h5>
<p>Poiché la maggior parte dell’aritmetica è considerata avere un segno; <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code> restituisce un numero negativo quando <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">x</span></code> tranne nei rari casi in cui si vuole veramente l’aritmetica modulare.</p>
</section>
<section id="id1173">
<h5>Esempio<a class="headerlink" href="#id1173" title="Link to this heading">¶</a></h5>
<p>L’aritmetica senza segno può dare risultati sorprendenti se non ce lo si aspetta. Ciò è ancora più vero per l’aritmetica mista signed e unsigned.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T, typename T2&gt;
T subtract(T x, T2 y)
{
    return x - y;
}

void test()
{
    int s = 5;
    unsigned int us = 5;
    cout &lt;&lt; subtract(s, 7) &lt;&lt; &#39;\n&#39;;       // -2
    cout &lt;&lt; subtract(us, 7u) &lt;&lt; &#39;\n&#39;;     // 4294967294
    cout &lt;&lt; subtract(s, 7u) &lt;&lt; &#39;\n&#39;;      // -2
    cout &lt;&lt; subtract(us, 7) &lt;&lt; &#39;\n&#39;;      // 4294967294
    cout &lt;&lt; subtract(s, us + 2) &lt;&lt; &#39;\n&#39;;  // -2
    cout &lt;&lt; subtract(us, s + 2) &lt;&lt; &#39;\n&#39;;  // 4294967294
}
</pre></div>
</div>
<p>Qui siamo stati molto espliciti su ciò che sta accadendo, ma se si fosse visto <code class="docutils literal notranslate"><span class="pre">us</span> <span class="pre">-</span> <span class="pre">(s</span> <span class="pre">+</span> <span class="pre">2)</span></code> or <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">+=</span> <span class="pre">2;</span> <span class="pre">...;</span> <span class="pre">us</span> <span class="pre">-</span> <span class="pre">s</span></code>, sarebbe giustamente sorto il sospetto che il risultato stampato sarebbe stato <code class="docutils literal notranslate"><span class="pre">4294967294</span></code>?</p>
</section>
<section id="id1174">
<h5>Eccezione<a class="headerlink" href="#id1174" title="Link to this heading">¶</a></h5>
<p>Usare i tipi unsigned se si vuole veramente l’aritmetica modulare - aggiungere i commenti opportuni evidenziando il comportamento “arrotolato”, in quanto questo codice può meravigliare alcuni programmatori.</p>
</section>
<section id="id1175">
<h5>Esempio<a class="headerlink" href="#id1175" title="Link to this heading">¶</a></h5>
<p>La libreria standard usa i tipi unsigned per gli indici. L’array nativo usa i tipi signed per gli indici. Ciò genera inevitabili sorprese (e bug).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int a[10];
for (int i = 0; i &lt; 10; ++i) a[i] = i;
vector&lt;int&gt; v(10);
// compares signed to unsigned; some compilers warn, but we should not
for (gsl::index i = 0; i &lt; v.size(); ++i) v[i] = i;

int a2[-2];         // error: negative size

// OK, but the number of ints (4294967294) is so large that we should get an exception
vector&lt;int&gt; v2(-2);
</pre></div>
</div>
<p>Usare <code class="docutils literal notranslate"><span class="pre">gsl::index</span></code> per gli indici; <a class="reference internal" href="#Res-subscripts"><span class="xref myst">cfr. ES.107</span></a>.</p>
</section>
<section id="id1176">
<h5>Imposizione<a class="headerlink" href="#id1176" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare l’aritmetica tra signed e unsigned</p></li>
<li><p>Segnalare i risultati dell’aritmetica unsigned assegnati o stampati come signed.</p></li>
<li><p>Segnalare i letterali negativi (p.es. <code class="docutils literal notranslate"><span class="pre">-2</span></code>) usati come indici per i container.</p></li>
<li><p>(Per evitare confusione) Non segnalare un confronto tra signed/unsigned dove uno degli argomenti è <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> o una chiamata alla <code class="docutils literal notranslate"><span class="pre">.size()</span></code> di un container e l’altro è <code class="docutils literal notranslate"><span class="pre">ptrdiff_t</span></code>.</p></li>
</ul>
</section>
</section>
<section id="es-103-don-t-overflow">
<h4><a name="Res-overflow"></a>ES.103: Evitare l’overflow<a class="headerlink" href="#es-103-don-t-overflow" title="Link to this heading">¶</a></h4>
<section id="id1177">
<h5>Motivo<a class="headerlink" href="#id1177" title="Link to this heading">¶</a></h5>
<p>Solitamente l’overflow rende l’algoritmo numerico senza senso. Incrementando un valore oltre il suo valore massimo può corrompere la memoria e portare a un comportamento indefinito.</p>
</section>
<section id="id1178">
<h5>Esempio, cattivo<a class="headerlink" href="#id1178" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int a[10];
a[10] = 7;   // bad, array bounds overflow

for (int n = 0; n &lt;= 10; ++n)
    a[n] = 9;   // bad, array bounds overflow
</pre></div>
</div>
</section>
<section id="id1179">
<h5>Esempio, cattivo<a class="headerlink" href="#id1179" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int n = numeric_limits&lt;int&gt;::max();
int m = n + 1;   // bad, numeric overflow
</pre></div>
</div>
</section>
<section id="id1180">
<h5>Esempio, cattivo<a class="headerlink" href="#id1180" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int area(int h, int w) { return h * w; }

auto a = area(10&#39;000&#39;000, 100&#39;000&#39;000);   // bad, numeric overflow
</pre></div>
</div>
</section>
<section id="id1181">
<h5>Eccezione<a class="headerlink" href="#id1181" title="Link to this heading">¶</a></h5>
<p>Usare i tipi unsigned se si vuole veramente l’aritmetica modulare.</p>
<p><strong>Alternativa</strong>: Per le applicazioni critiche dove possono capitare degli overhead, usare un tipo intero [range-checked] e/o un floating-point.</p>
</section>
<section id="id1182">
<h5>Imposizione<a class="headerlink" href="#id1182" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="es-104-don-t-underflow">
<h4><a name="Res-underflow"></a>ES.104: Evitare l’underflow<a class="headerlink" href="#es-104-don-t-underflow" title="Link to this heading">¶</a></h4>
<section id="id1183">
<h5>Motivo<a class="headerlink" href="#id1183" title="Link to this heading">¶</a></h5>
<p>Decrementando un valore oltre il suo valore minimo può portare alla corruzione della memoria e a comportamenti indefiniti.</p>
</section>
<section id="id1184">
<h5>Esempio, cattivo<a class="headerlink" href="#id1184" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int a[10];
a[-2] = 7;   // bad

int n = 101;
while (n--)
    a[n - 1] = 9;   // bad (twice)
</pre></div>
</div>
</section>
<section id="id1185">
<h5>Eccezione<a class="headerlink" href="#id1185" title="Link to this heading">¶</a></h5>
<p>Usare i tipi unsigned se si vuole veramente l’aritmetica modulare.</p>
</section>
<section id="id1186">
<h5>Imposizione<a class="headerlink" href="#id1186" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="es-105-don-t-divide-by-integer-zero">
<h4><a name="Res-zero"></a>ES.105: Non dividere per lo zero intero<a class="headerlink" href="#es-105-don-t-divide-by-integer-zero" title="Link to this heading">¶</a></h4>
<section id="id1187">
<h5>Motivo<a class="headerlink" href="#id1187" title="Link to this heading">¶</a></h5>
<p>Il risultato è indefinito e probabilmente si ha un crash.</p>
</section>
<section id="id1188">
<h5>Nota<a class="headerlink" href="#id1188" title="Link to this heading">¶</a></h5>
<p>Questo vale anche per <code class="docutils literal notranslate"><span class="pre">%</span></code>.</p>
</section>
<section id="id1189">
<h5>Esempio, cattivo<a class="headerlink" href="#id1189" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int divide(int a, int b)
{
    // BAD, should be checked (e.g., in a precondition)
    return a / b;
}
</pre></div>
</div>
</section>
<section id="id1190">
<h5>Esempio, buono<a class="headerlink" href="#id1190" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int divide(int a, int b)
{
    // good, address via precondition (and replace with contracts once C++ gets them)
    Expects(b != 0);
    return a / b;
}

double divide(double a, double b)
{
    // good, address via using double instead
    return a / b;
}
</pre></div>
</div>
<p><strong>Alternativa</strong>: Per le applicazioni critiche dove possono capitare degli overhead, usare un tipo intero [range-checked] e/o un floating-point.</p>
</section>
<section id="id1191">
<h5>Imposizione<a class="headerlink" href="#id1191" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare la divisione per un valore intero che possa valere zero</p></li>
</ul>
</section>
</section>
<section id="es-106-don-t-try-to-avoid-negative-values-by-using-unsigned">
<h4><a name="Res-nonnegative"></a>ES.106: Non tentare di evitare i valori negativi utilizzando <code class="docutils literal notranslate"><span class="pre">unsigned</span></code><a class="headerlink" href="#es-106-don-t-try-to-avoid-negative-values-by-using-unsigned" title="Link to this heading">¶</a></h4>
<section id="id1192">
<h5>Motivo<a class="headerlink" href="#id1192" title="Link to this heading">¶</a></h5>
<p>Scegliere un <code class="docutils literal notranslate"><span class="pre">unsigned</span></code> implica molti cambiamenti al solito funzionamento degli interi, compresa l’aritmetica modulare, può sopprimere i warning riguardanti l’overflow, ed aprire la porta agli errori sui mix signed/unsigned. L’uso di <code class="docutils literal notranslate"><span class="pre">unsigned</span></code> in realtà non elimina la possibilità di valori negativi.</p>
</section>
<section id="id1193">
<h5>Esempio<a class="headerlink" href="#id1193" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned int u1 = -2;   // Valid: the value of u1 is 4294967294
int i1 = -2;
unsigned int u2 = i1;   // Valid: the value of u2 is 4294967294
int i2 = u2;            // Valid: the value of i2 is -2
</pre></div>
</div>
<p>I problemi con questi costrutti (perfettamente legali) sono difficili da evidenziare nel codice reale e sono la fonte di molti errori del mondo reale. Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned area(unsigned height, unsigned width) { return height*width; } // [see also](#Ri-expects)
// ...
int height;
cin &gt;&gt; height;
auto a = area(height, 2);   // if the input is -2 a becomes 4294967292
</pre></div>
</div>
<p>Si ricordi che <code class="docutils literal notranslate"><span class="pre">-1</span></code> quando viene assegnato ad un <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> diventa il più grande numero <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>. Inoltre, poiché l’aritmetica senza segno è l’aritmetica modulare, la moltiplicazione non genera overflow, ma si “arrotola”.</p>
</section>
<section id="id1194">
<h5>Esempio<a class="headerlink" href="#id1194" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned max = 100000;    // &quot;accidental typo&quot;, I mean to say 10&#39;000
unsigned short x = 100;
while (x &lt; max) x += 100; // infinite loop
</pre></div>
</div>
<p>Se <code class="docutils literal notranslate"><span class="pre">x</span></code> fosse stato un signed <code class="docutils literal notranslate"><span class="pre">short</span></code>, avremmo potuto avvertire del comportamento indefinito dovuto all’overflow.</p>
</section>
<section id="id1195">
<h5>Alternative<a class="headerlink" href="#id1195" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>usare interi signed e controllare che <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code></p></li>
<li><p>usare un tipo intero positivo</p></li>
<li><p>usare un sotto-indice [subrange] di tipo intero</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Assert(-1</span> <span class="pre">&lt;</span> <span class="pre">x)</span></code></p></li>
</ul>
<p>Per esempio</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Positive {
    int val;
    Positive(int x) :val{x} { Assert(0 &lt; x); }
    operator int() { return val; }
};

int f(Positive arg) { return arg; }

int r1 = f(2);
int r2 = f(-2);  // throws
</pre></div>
</div>
</section>
<section id="id1196">
<h5>Nota<a class="headerlink" href="#id1196" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
<section id="id1197">
<h5>Imposizione<a class="headerlink" href="#id1197" title="Link to this heading">¶</a></h5>
<p>Cfr. le imposizioni di ES.100.</p>
</section>
</section>
<section id="es-107-don-t-use-unsigned-for-subscripts-prefer-gsl-index">
<h4><a name="Res-subscripts"></a>ES.107: Non usare <code class="docutils literal notranslate"><span class="pre">unsigned</span></code> per l’indicizzazione, preferire <code class="docutils literal notranslate"><span class="pre">gsl::index</span></code><a class="headerlink" href="#es-107-don-t-use-unsigned-for-subscripts-prefer-gsl-index" title="Link to this heading">¶</a></h4>
<section id="id1198">
<h5>Motivo<a class="headerlink" href="#id1198" title="Link to this heading">¶</a></h5>
<p>Per evitare la confusione tra signed e unsigned. Per consentire una migliore ottimizzazione. Per consentire un migliore rilevamento degli errori. Per evitare le insidie con <code class="docutils literal notranslate"><span class="pre">auto</span></code> e <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
</section>
<section id="id1199">
<h5>Esempio, cattivo<a class="headerlink" href="#id1199" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;int&gt; vec = /*...*/;

for (int i = 0; i &lt; vec.size(); i += 2)                    // might not be big enough
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (unsigned i = 0; i &lt; vec.size(); i += 2)               // risk wraparound
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (auto i = 0; i &lt; vec.size(); i += 2)                   // might not be big enough
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (vector&lt;int&gt;::size_type i = 0; i &lt; vec.size(); i += 2) // verbose
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (auto i = vec.size()-1; i &gt;= 0; i -= 2)                // bug
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (int i = vec.size()-1; i &gt;= 0; i -= 2)                 // might not be big enough
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
</pre></div>
</div>
</section>
<section id="id1200">
<h5>Esempio, buono<a class="headerlink" href="#id1200" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;int&gt; vec = /*...*/;

for (gsl::index i = 0; i &lt; vec.size(); i += 2)             // ok
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (gsl::index i = vec.size()-1; i &gt;= 0; i -= 2)          // ok
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
</pre></div>
</div>
</section>
<section id="id1201">
<h5>Nota<a class="headerlink" href="#id1201" title="Link to this heading">¶</a></h5>
<p>L’array nativo consente l’indicizzazione con segno. I container della libreria standard usano indici unsigned. Pertanto, non è possibile alcuna soluzione perfetta e pienamente compatibile (a meno che e fin quando i container della libreria standard non modificheranno l’odierno uso degli indici signed in futuro). Dati i noti problemi con i mix tra signed e unsigned, è meglio attenersi agli interi (signed) di dimensioni sufficienti, che è garantito da <code class="docutils literal notranslate"><span class="pre">gsl::index</span></code>.</p>
</section>
<section id="id1202">
<h5>Esempio<a class="headerlink" href="#id1202" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
struct My_container {
public:
    // ...
    T&amp; operator[](gsl::index i);    // not unsigned
    // ...
};
</pre></div>
</div>
</section>
<section id="id1203">
<h5>Esempio<a class="headerlink" href="#id1203" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>??? demonstrate improved code generation and potential for error detection ???
</pre></div>
</div>
</section>
<section id="id1204">
<h5>Alternative<a class="headerlink" href="#id1204" title="Link to this heading">¶</a></h5>
<p>Alternative per gli utenti</p>
<ul class="simple">
<li><p>usare gli algoritmi</p></li>
<li><p>usare il range-for</p></li>
<li><p>usare iteratori/puntatori</p></li>
</ul>
</section>
<section id="id1205">
<h5>Imposizione<a class="headerlink" href="#id1205" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Molto complicato, fin quando i container della libreria standard sbagliano.</p></li>
<li><p>(Per evitare confusione) Non segnalare un confronto tra signed/unsigned dove uno degli argomenti è <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> o una chiamata alla <code class="docutils literal notranslate"><span class="pre">.size()</span></code> di un container e l’altro è <code class="docutils literal notranslate"><span class="pre">ptrdiff_t</span></code>.</p></li>
</ul>
</section>
</section>
</section>
</section>
<section id="per-performance">
<h2><a name="S-performance"></a>Per: Prestazione<a class="headerlink" href="#per-performance" title="Link to this heading">¶</a></h2>
<p>??? questa sezione dovrebbe stare nella guida principale???</p>
<p>Questa sezione contiene le regole per le persone che necessitano di prestazioni elevate e una bassa latenza. Cioè, queste sono regole che riguardano come utilizzare il minor tempo e il minor numero possibile di risorse per realizzare un’attività in un tempo prevedibilmente breve. Le regole in questa sezione sono più restrittive ed intrusive di quelle necessarie per molte (la maggior parte) delle applicazioni. Non cercare ingenuamente di seguirle nel codice generico: raggiungere gli obiettivi di bassa latenza richiede un lavoro extra.</p>
<p>Riepilogo sulle regole per le prestazioni:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rper-reason"><span class="xref myst">Per.1: Non ottimizzare senza motivo</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-Knuth"><span class="xref myst">Per.2: Non ottimizzare prematuramente</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-critical"><span class="xref myst">Per.3: Non ottimizzare qualcosa che non è critico per le prestazioni</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-simple"><span class="xref myst">Per.4: Non dare per scontato che il codice complicato sia necessariamente più veloce del codice semplice</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-low"><span class="xref myst">Per.5: Non dare per scontato che il codice di basso livello sia necessariamente più veloce di quello ad alto livello</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-measure"><span class="xref myst">Per.6: Non fare affermazioni sulle prestazioni senza fare misurazioni</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-efficiency"><span class="xref myst">Per.7: Progettare per consentire l’ottimizzazione</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-type"><span class="xref myst">Per.10: Affidarsi al sistema di tipo statico</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-Comp"><span class="xref myst">Per.11: Spostare il calcolo dal run-time alla compilazione</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-alias"><span class="xref myst">Per.12: Eliminare gli alias ridondanti</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-indirect"><span class="xref myst">Per.13: Eliminare le indirezioni ridondanti</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-alloc"><span class="xref myst">Per.14: Minimizzare il numero di allocazioni e de-allocazioni</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-alloc0"><span class="xref myst">Per.15: Non allocare su un ramo critico</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-compact"><span class="xref myst">Per.16: Usare strutture dati compatte</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-struct"><span class="xref myst">Per.17: Dichiarare per primi i membri più usati di una struct time-critical</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-space"><span class="xref myst">Per.18: Lo spazio è tempo</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-access"><span class="xref myst">Per.19: Accesso prevedibile alla memoria</span></a></p></li>
<li><p><a class="reference internal" href="#Rper-context"><span class="xref myst">Per.30: Evitare i [context switch] sui percorsi [path] critici</span></a></p></li>
</ul>
<section id="per-1-don-t-optimize-without-reason">
<h3><a name="Rper-reason"></a>Per.1: Non ottimizzare senza motivo<a class="headerlink" href="#per-1-don-t-optimize-without-reason" title="Link to this heading">¶</a></h3>
<section id="id1206">
<h4>Motivo<a class="headerlink" href="#id1206" title="Link to this heading">¶</a></h4>
<p>Se non è necessaria alcuna ottimizzazione, i principali risultati corrisponderanno a più errori e costi di manutenzione più elevati.</p>
</section>
<section id="id1207">
<h4>Nota<a class="headerlink" href="#id1207" title="Link to this heading">¶</a></h4>
<p>Alcuni ottimizzano per abitudine o perché è divertente.</p>
<p>???</p>
</section>
</section>
<section id="per-2-don-t-optimize-prematurely">
<h3><a name="Rper-Knuth"></a>Per.2: Non ottimizzare prematuramente<a class="headerlink" href="#per-2-don-t-optimize-prematurely" title="Link to this heading">¶</a></h3>
<section id="id1208">
<h4>Motivo<a class="headerlink" href="#id1208" title="Link to this heading">¶</a></h4>
<p>Il codice ottimizzato in modo elaborato è in genere più grande e più difficile da modificare rispetto a quello non ottimizzato.</p>
<p>???</p>
</section>
</section>
<section id="per-3-don-t-optimize-something-that-s-not-performance-critical">
<h3><a name="Rper-critical"></a>Per.3: Non ottimizzare qualcosa che non è critico per le prestazioni<a class="headerlink" href="#per-3-don-t-optimize-something-that-s-not-performance-critical" title="Link to this heading">¶</a></h3>
<section id="id1209">
<h4>Motivo<a class="headerlink" href="#id1209" title="Link to this heading">¶</a></h4>
<p>L’ottimizzazione di una parte non critica per le prestazioni di un programma non ha alcun effetto sulle prestazioni del sistema.</p>
</section>
<section id="id1210">
<h4>Nota<a class="headerlink" href="#id1210" title="Link to this heading">¶</a></h4>
<p>Se il proprio programma trascorre la maggior parte del tempo ad aspettare il web o un essere umano, l’ottimizzazione del calcolo in memoria è probabilmente inutile.</p>
<p>In altre parole: Se il programma impiega il 4% del suo tempo di elaborazione facendo il calcolo A e il 40% del tempo per il calcolo B, un miglioramento del 50% su A impatta quanto un miglioramento del 5% su B. (Se non si sa quanto tempo impiegano A e B, cfr. <a href="#Rper-reason">Per.1</a> e <a href="#Rper-Knuth">Per.2</a>.)</p>
</section>
</section>
<section id="per-4-don-t-assume-that-complicated-code-is-necessarily-faster-than-simple-code">
<h3><a name="Rper-simple"></a>Per.4: Non dare per scontato che il codice complicato sia necessariamente più veloce del codice semplice<a class="headerlink" href="#per-4-don-t-assume-that-complicated-code-is-necessarily-faster-than-simple-code" title="Link to this heading">¶</a></h3>
<section id="id1211">
<h4>Motivo<a class="headerlink" href="#id1211" title="Link to this heading">¶</a></h4>
<p>Il codice semplice può essere molto veloce. Gli ottimizzatori a volte fanno meraviglie con un codice semplice</p>
</section>
<section id="id1212">
<h4>Esempio, buono<a class="headerlink" href="#id1212" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// clear expression of intent, fast execution

vector&lt;uint8_t&gt; v(100000);

for (auto&amp; c : v)
    c = ~c;
</pre></div>
</div>
</section>
<section id="id1213">
<h4>Esempio, cattivo<a class="headerlink" href="#id1213" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// intended to be faster, but is often slower

vector&lt;uint8_t&gt; v(100000);

for (size_t i = 0; i &lt; v.size(); i += sizeof(uint64_t)) {
    uint64_t&amp; quad_word = *reinterpret_cast&lt;uint64_t*&gt;(&amp;v[i]);
    quad_word = ~quad_word;
}
</pre></div>
</div>
</section>
<section id="id1214">
<h4>Nota<a class="headerlink" href="#id1214" title="Link to this heading">¶</a></h4>
<p>???</p>
<p>???</p>
</section>
</section>
<section id="per-5-don-t-assume-that-low-level-code-is-necessarily-faster-than-high-level-code">
<h3><a name="Rper-low"></a>Per.5: Non dare per scontato che il codice di basso livello sia necessariamente più veloce di quello ad alto livello<a class="headerlink" href="#per-5-don-t-assume-that-low-level-code-is-necessarily-faster-than-high-level-code" title="Link to this heading">¶</a></h3>
<section id="id1215">
<h4>Motivo<a class="headerlink" href="#id1215" title="Link to this heading">¶</a></h4>
<p>Il codice di basso livello talvolta inibisce le ottimizzazioni. Gli ottimizzatori a volte fanno meraviglie con un codice di alto livello.</p>
</section>
<section id="id1216">
<h4>Nota<a class="headerlink" href="#id1216" title="Link to this heading">¶</a></h4>
<p>???</p>
<p>???</p>
</section>
</section>
<section id="per-6-don-t-make-claims-about-performance-without-measurements">
<h3><a name="Rper-measure"></a>Per.6: Non fare affermazioni sulle prestazioni senza fare misurazioni<a class="headerlink" href="#per-6-don-t-make-claims-about-performance-without-measurements" title="Link to this heading">¶</a></h3>
<section id="id1217">
<h4>Motivo<a class="headerlink" href="#id1217" title="Link to this heading">¶</a></h4>
<p>Quello delle performance è un campo disseminato di falsi miti e folclore. I moderni hardware ed ottimizzatori sfidano ingenui assunti; anche gli esperti vengono regolarmente sorpresi.</p>
</section>
<section id="id1218">
<h4>Nota<a class="headerlink" href="#id1218" title="Link to this heading">¶</a></h4>
<p>Ottenere buone misurazioni delle prestazioni può risultare difficile e richiedere strumenti specializzati.</p>
</section>
<section id="id1219">
<h4>Nota<a class="headerlink" href="#id1219" title="Link to this heading">¶</a></h4>
<p>Alcuni semplici micro-benchmark che usano il <code class="docutils literal notranslate"><span class="pre">time</span></code> di Unix o il <code class="docutils literal notranslate"><span class="pre">&lt;chrono&gt;</span></code> della libreria standard possono aiutare a dissipare i miti più ovvi. Se non si riesce a misurare accuratamente tutto il sistema, si provi almeno a misurare alcune delle operazioni e algoritmi chiave. Un profiler può aiutare a capire quali parti del sistema sono critiche per le prestazioni. Spesso, ci si sorprenderà.</p>
<p>???</p>
</section>
</section>
<section id="per-7-design-to-enable-optimization">
<h3><a name="Rper-efficiency"></a>Per.7: Progettare per consentire l’ottimizzazione<a class="headerlink" href="#per-7-design-to-enable-optimization" title="Link to this heading">¶</a></h3>
<section id="id1220">
<h4>Motivo<a class="headerlink" href="#id1220" title="Link to this heading">¶</a></h4>
<p>Perché spesso si deve ottimizzare il progetto iniziale. Perché un progetto che ignora la possibilità di un successivo miglioramento è difficile da modificare.</p>
</section>
<section id="id1221">
<h4>Esempio<a class="headerlink" href="#id1221" title="Link to this heading">¶</a></h4>
<p>Dal C (e dal C++) standard:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void qsort (void* base, size_t num, size_t size, int (*compar)(const void*, const void*));
</pre></div>
</div>
<p>Quando c’è stato bisogno di ordinare la memoria? In realtà, si ordinano sequenze di elementi, in genere memorizzati in contenitori. Una chiamata a <code class="docutils literal notranslate"><span class="pre">qsort</span></code> elimina molte informazioni utili (p.es., il tipo degli elementi), costringe l’utente a ripetere le informazioni già note  (p.es., la dimensione degli elementi), ed obbliga a scrivere altro codice (p.es., una funzione per confrontare i <code class="docutils literal notranslate"><span class="pre">double</span></code>). Ciò implica un lavoro aggiuntivo per il programmatore, soggetto a errori e si priva il compilatore delle informazioni necessarie per l’ottimizzazione.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double data[100];
// ... fill a ...

// 100 chunks of memory of sizeof(double) starting at
// address data using the order defined by compare_doubles
qsort(data, 100, sizeof(double), compare_doubles);
</pre></div>
</div>
<p>Dal punto di vista della progettazione dell’interfaccia, <code class="docutils literal notranslate"><span class="pre">qsort</span></code> getta via informazioni utili.</p>
<p>Si può fare di meglio (nel C++98)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename Iter&gt;
    void sort(Iter b, Iter e);  // sort [b:e)

sort(data, data + 100);
</pre></div>
</div>
<p>Qui, si usano le conoscenze del compilatore sulla dimensione dell’array, il tipo degli elementi e su come confrontare i <code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
<p>Col C++20 possiamo fare ancora meglio</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// sortable specifies that c must be a
// random-access sequence of elements comparable with &lt;
void sort(sortable auto&amp; c);

sort(c);
</pre></div>
</div>
<p>La chiave è passare informazioni sufficienti per scegliere una buona implementazione. In questo, le interfacce <code class="docutils literal notranslate"><span class="pre">sort</span></code> mostrano qui un ulteriore punto debole: Si basano implicitamente sul tipo di elemento che abbia definito il «minore di» (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>). Per completare l’interfaccia, abbiamo bisogno di una seconda versione che accetti un criterio di confronto:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// compare elements of c using r
template&lt;random_access_range R, class C&gt; requires sortable&lt;R, C&gt;
void sort(R&amp;&amp; r, C c);
</pre></div>
</div>
<p>La specifica di <code class="docutils literal notranslate"><span class="pre">sort</span></code> della libreria standard di propone due versioni e altro ancora.</p>
</section>
<section id="id1222">
<h4>Nota<a class="headerlink" href="#id1222" title="Link to this heading">¶</a></h4>
<p>Si dice che l’ottimizzazione prematura sia <a class="reference internal" href="#Rper-Knuth"><span class="xref myst">la fonte di tutti i mali</span></a>, ma questo non è un motivo per disdegnare le prestazioni. Non è mai prematuro considerare ciò che rende un progetto migliorabile e migliorare le prestazioni è un miglioramento comunemente desiderato. Si cerchi di creare un insieme di abitudini che per default si traducano in un codice efficiente, gestibile e ottimizzabile. In particolare, quando si scrive una funzione che non sia un dettaglio di implementazione una tantum, considerare</p>
<ul class="simple">
<li><p>Passaggio delle informazioni: Preferire delle semplici <a class="reference internal" href="#S-interfaces"><span class="xref myst">interfacce</span></a> che trasportino abbastanza informazioni per un successivo miglioramento dell’implementazione. Si noti che le informazioni fluiscono dentro e fuori da un’implementazione attraverso le interfacce che si forniscono.</p></li>
<li><p>Dati compatti: Per default, <a class="reference internal" href="#Rper-compact"><span class="xref myst">usare dati compatti</span></a>, come in <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> e <a class="reference internal" href="#Rper-access"><span class="xref myst">accedervi in modo sistematico</span></a>. Se si ritiene di aver bisogno di una struttura collegata, provare a creare l’interfaccia in modo che questa struttura non venga vista dagli utenti.</p></li>
<li><p>Argomenti passati e restituiti dalla funzione: Distinguere tra dati mutabili e non-mutabili. Non imporre l’onere di una gestione delle risorse ai propri utenti. Non imporre false indirezione a run-time ai propri clienti. Usare <a class="reference internal" href="#Rf-conventional"><span class="xref myst">modi convenzionali</span></a> per passare le informazioni attraverso l’interfaccia; modi non convenzionali e/o modi «ottimizzati» per il passaggio dei dati possono seriamente complicare le successive ottimizzazioni.</p></li>
<li><p>Astrazione: Non generalizzare eccessivamente; un progetto  che cerca di soddisfare ogni possibile uso (ed abuso) e che rifiuta ogni decisione progettuale successiva (utilizzando indirezioni durante la compilazione o a  run-time) è solitamente un pasticcio complicato, rigonfio e difficile da capire. Generalizzare da esempi concreti, preservando le prestazioni. Non generalizzare basandosi su mere speculazioni sulle future necessità. L’ideale è una generalizzazione «zero-overhead».</p></li>
<li><p>Librerie: Usare librerie con delle buone interfacce. Se non è disponibile una libreria se ne crei una imitando lo stile dell’interfaccia di una buona libreria. La <a class="reference internal" href="#sl-the-standard-library"><span class="xref myst">libreria standard</span></a> è il primo buon posto per ispirarsi.</p></li>
<li><p>Isolamento: Isolare il proprio codice da quello disordinato e/o vecchio stile fornendo un’interfaccia adatta. Questo è talvolta detto «fornire un wrapper» per il codice utile/necessario ma disordinato. Non lasciare che i cattivi progetti «si insinuino» nel proprio codice.</p></li>
</ul>
</section>
<section id="id1223">
<h4>Esempio<a class="headerlink" href="#id1223" title="Link to this heading">¶</a></h4>
<p>Si consideri:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class ForwardIterator, class T&gt;
bool binary_search(ForwardIterator first, ForwardIterator last, const T&amp; val);
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">binary_search(begin(c),</span> <span class="pre">end(c),</span> <span class="pre">7)</span></code> dirà se <code class="docutils literal notranslate"><span class="pre">7</span></code> è in <code class="docutils literal notranslate"><span class="pre">c</span></code> oppure no. Tuttavia, non dirà dove si trova quel <code class="docutils literal notranslate"><span class="pre">7</span></code> e se ci sono più di un <code class="docutils literal notranslate"><span class="pre">7</span></code>.</p>
<p>A volte, è sufficiente restituire la minima quantità di informazioni (qui, <code class="docutils literal notranslate"><span class="pre">true</span></code> o <code class="docutils literal notranslate"><span class="pre">false</span></code>), ma una buona interfaccia restituisce le informazioni necessarie al chiamante. Quindi, la libreria standard offre anche</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class ForwardIterator, class T&gt;
ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T&amp; val);
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">lower_bound</span></code> restituisce un iteratore alla prima corrispondenza se c’è, altrimenti al primo elemento maggiore di <code class="docutils literal notranslate"><span class="pre">val</span></code>, o <code class="docutils literal notranslate"><span class="pre">last</span></code> se nessun elemento è stato trovato.</p>
<p>Tuttavia, <code class="docutils literal notranslate"><span class="pre">lower_bound</span></code> non restituisce ancora informazioni sufficienti per tutti gli usi, quindi la libreria standard propone anche</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class ForwardIterator, class T&gt;
pair&lt;ForwardIterator, ForwardIterator&gt;
equal_range(ForwardIterator first, ForwardIterator last, const T&amp; val);
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">equal_range</span></code> restituisce una <code class="docutils literal notranslate"><span class="pre">pair</span></code> [coppia] di iteratori il primo e uno oltre l’ultima corrispondenza.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto r = equal_range(begin(c), end(c), 7);
for (auto p = r.first; p != r.second; ++p)
    cout &lt;&lt; *p &lt;&lt; &#39;\n&#39;;
</pre></div>
</div>
<p>Ovviamente, queste tre interfacce sono implementate con lo stesso codice di base. Sono semplicemente tre modi per presentare agli utenti l’algoritmo di ricerca binaria di base, che vanno da quelle che restituiscono le informazioni più semplici («semplifica le cose semplici!») a quelle più complete, ma non sempre necessarie, («non nascondere informazioni utili»). Naturalmente, la creazione di un tale set di interfacce richiede esperienza e conoscenza del dominio.</p>
</section>
<section id="id1224">
<h4>Nota<a class="headerlink" href="#id1224" title="Link to this heading">¶</a></h4>
<p>Non creare banalmente l’interfaccia in modo che corrisponda alla prima implementazione e al primo caso d’uso a cui si pensa. Una volta completata l’implementazione iniziale, la si esamini; una volta distribuita, sarà difficile porre rimedio agli errori.</p>
</section>
<section id="id1225">
<h4>Nota<a class="headerlink" href="#id1225" title="Link to this heading">¶</a></h4>
<p>Una necessità di efficienza non implica una necessità di <a class="reference internal" href="#Rper-low"><span class="xref myst">codice a basso-livello</span></a>. Il codice di alto livello non è necessariamente lento o prolisso.</p>
</section>
<section id="id1226">
<h4>Nota<a class="headerlink" href="#id1226" title="Link to this heading">¶</a></h4>
<p>Le cose hanno dei costi. Non si dev’essere paranoici sui costi (i moderni computer sono veramente molto veloci), ma si deve avere un’idea approssimativa dell’ordine di grandezza del costo di quello che si usa. Per esempio, avere idea del costo di un accesso alla memoria, una chiamata a una funzione, il confronto tra stringhe, una chiamata di sistema, una accesso al disco, e un messaggio tramite la rete.</p>
</section>
<section id="id1227">
<h4>Nota<a class="headerlink" href="#id1227" title="Link to this heading">¶</a></h4>
<p>Se si riesce a pensare a una sola implementazione, probabilmente non si ha qualcosa per cui poter escogitare un’interfaccia stabile. Forse, è solo un dettaglio implementativo - non tutte le parti del codice hanno bisogno di un’interfaccia stabile - ma ci si prenda una pausa e si facciano delle considerazioni. Una domanda che può essere utile è «quale interfaccia sarebbe necessaria se questa operazione dovesse essere implementata usando più thread? essere vettorizzata?»</p>
</section>
<section id="id1228">
<h4>Nota<a class="headerlink" href="#id1228" title="Link to this heading">¶</a></h4>
<p>Questa regola non contraddice la regola <a class="reference internal" href="#Rper-Knuth"><span class="xref myst">Non ottimizzare prematuramente</span></a>. Essa la completa, incoraggiando gli sviluppatori a consentire un’ottimizzazione successiva, appropriata e non-prematura, se e dove necessario.</p>
</section>
<section id="id1229">
<h4>Imposizione<a class="headerlink" href="#id1229" title="Link to this heading">¶</a></h4>
<p>Difficile. Forse cercando gli argomenti della funzione <code class="docutils literal notranslate"><span class="pre">void*</span></code> si troveranno esempi di interfacce che ostacolano la successiva ottimizzazione.</p>
</section>
</section>
<section id="per-10-rely-on-the-static-type-system">
<h3><a name="Rper-type"></a>Per.10: Affidarsi al sistema di tipo statico<a class="headerlink" href="#per-10-rely-on-the-static-type-system" title="Link to this heading">¶</a></h3>
<section id="id1230">
<h4>Motivo<a class="headerlink" href="#id1230" title="Link to this heading">¶</a></h4>
<p>Le violazioni dei tipi, i tipi deboli (p.es. i <code class="docutils literal notranslate"><span class="pre">void*</span></code>), e il codice a basso-livello (p.es., manipolazione di sequenze come singoli byte) rendono il lavoro dell’ottimizzatore molto più difficile. Il codice semplice spesso si ottimizza meglio del codice complicato fatto a mano.</p>
<p>???</p>
</section>
</section>
<section id="per-11-move-computation-from-run-time-to-compile-time">
<h3><a name="Rper-Comp"></a>Per.11: Spostare il calcolo dal run-time alla compilazione<a class="headerlink" href="#per-11-move-computation-from-run-time-to-compile-time" title="Link to this heading">¶</a></h3>
<section id="id1231">
<h4>Motivo<a class="headerlink" href="#id1231" title="Link to this heading">¶</a></h4>
<p>Per ridurre la dimensione del codice e il tempo di esecuzione. Per evitare i conflitti dei dati [data race] utilizzando le costanti. Per rilevare gli errori in fase di compilazione (eliminando così la necessità di un codice per la gestione degli errori).</p>
</section>
<section id="id1232">
<h4>Esempio<a class="headerlink" href="#id1232" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double square(double d) { return d*d; }
static double s2 = square(2);    // old-style: dynamic initialization

constexpr double ntimes(double d, int n)   // assume 0 &lt;= n
{
        double m = 1;
        while (n--) m *= d;
        return m;
}
constexpr double s3 {ntimes(2, 3)};  // modern-style: compile-time initialization
</pre></div>
</div>
<p>Il codice come l’inizializzazione di <code class="docutils literal notranslate"><span class="pre">s2</span></code> non è raro, specialmente per un’inizializzazione che sia un po” più complicata di <code class="docutils literal notranslate"><span class="pre">square()</span></code>. Tuttavia, rispetto all’inizializzazione di <code class="docutils literal notranslate"><span class="pre">s3</span></code> ci sono due problemi:</p>
<ul class="simple">
<li><p>si subisce l’overhead di una chiamata durante l’esecuzione</p></li>
<li><p>un altro thread potrebbe accedere a <code class="docutils literal notranslate"><span class="pre">s2</span></code> prima che avvenga l’inizializzazione.</p></li>
</ul>
<p>Note: non si può avere un conflitto su una costante.</p>
</section>
<section id="id1233">
<h4>Esempio<a class="headerlink" href="#id1233" title="Link to this heading">¶</a></h4>
<p>Si prenda in considerazione una popolare tecnica per fornire un handle per memorizzare piccoli oggetti nell’handle stesso e quelli più grandi sull’heap.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>constexpr int on_stack_max = 20;

template&lt;typename T&gt;
struct Scoped {     // store a T in Scoped
        // ...
    T obj;
};

template&lt;typename T&gt;
struct On_heap {    // store a T on the free store
        // ...
        T* objp;
};

template&lt;typename T&gt;
using Handle = typename std::conditional&lt;(sizeof(T) &lt;= on_stack_max),
                    Scoped&lt;T&gt;,      // first alternative
                    On_heap&lt;T&gt;      // second alternative
               &gt;::type;

void f()
{
    Handle&lt;double&gt; v1;                   // the double goes on the stack
    Handle&lt;std::array&lt;double, 200&gt;&gt; v2;  // the array goes on the free store
    // ...
}
</pre></div>
</div>
<p>Si supponga che <code class="docutils literal notranslate"><span class="pre">Scoped</span></code> e <code class="docutils literal notranslate"><span class="pre">On_heap</span></code> abbiano delle interfacce utente compatibili. Qui si calcola il tipo ottimale da utilizzare in fase di compilazione. Esistono tecniche simili per selezionare la funzione ottimale da chiamare.</p>
</section>
<section id="id1234">
<h4>Nota<a class="headerlink" href="#id1234" title="Link to this heading">¶</a></h4>
<p>L’ideale è <em>non</em> per cercare di eseguire tutto in fase di compilazione. Ovviamente, la maggior parte dei calcoli dipende dagli input, quindi non si possono spostare in fase di compilazione, ma al di là di questo vincolo logico c’è il fatto che il calcolo complesso in fase di compilazione ne può aumentare notevolmente i tempi e complicare il debug. È anche possibile che si rallenti il codice mediante il calcolo in fase di compilazione. Questo è certamente raro, ma scomponendo un calcolo generale in sotto-calcoli separatamente ottimali, è possibile rendere meno efficace la cache delle istruzioni.</p>
</section>
<section id="id1235">
<h4>Imposizione<a class="headerlink" href="#id1235" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Cercare le funzioni più semplici che potrebbero essere constexpr (ma non lo sono).</p></li>
<li><p>Cercare le funzioni chiamate con tutti gli argomenti con espressioni costanti.</p></li>
<li><p>Cercare le macro che potrebbero essere constexpr.</p></li>
</ul>
</section>
</section>
<section id="per-12-eliminate-redundant-aliases">
<h3><a name="Rper-alias"></a>Per.12: Eliminare gli alias ridondanti<a class="headerlink" href="#per-12-eliminate-redundant-aliases" title="Link to this heading">¶</a></h3>
<p>???</p>
</section>
<section id="per-13-eliminate-redundant-indirections">
<h3><a name="Rper-indirect"></a>Per.13: Eliminare le indirezioni ridondanti<a class="headerlink" href="#per-13-eliminate-redundant-indirections" title="Link to this heading">¶</a></h3>
<p>???</p>
</section>
<section id="per-14-minimize-the-number-of-allocations-and-deallocations">
<h3><a name="Rper-alloc"></a>Per.14: Minimizzare il numero di allocazioni e de-allocazioni<a class="headerlink" href="#per-14-minimize-the-number-of-allocations-and-deallocations" title="Link to this heading">¶</a></h3>
<p>???</p>
</section>
<section id="per-15-do-not-allocate-on-a-critical-branch">
<h3><a name="Rper-alloc0"></a>Per.15: Non allocare su un ramo critico<a class="headerlink" href="#per-15-do-not-allocate-on-a-critical-branch" title="Link to this heading">¶</a></h3>
<p>???</p>
</section>
<section id="per-16-use-compact-data-structures">
<h3><a name="Rper-compact"></a>Per.16: Usare strutture dati compatte<a class="headerlink" href="#per-16-use-compact-data-structures" title="Link to this heading">¶</a></h3>
<section id="id1236">
<h4>Motivo<a class="headerlink" href="#id1236" title="Link to this heading">¶</a></h4>
<p>Le prestazioni sono solitamente dominate dai tempi di accesso alla memoria.</p>
<p>???</p>
</section>
</section>
<section id="per-17-declare-the-most-used-member-of-a-time-critical-struct-first">
<h3><a name="Rper-struct"></a>Per.17: Dichiarare per primi i membri più usati di una struct time-critical<a class="headerlink" href="#per-17-declare-the-most-used-member-of-a-time-critical-struct-first" title="Link to this heading">¶</a></h3>
<p>???</p>
</section>
<section id="per-18-space-is-time">
<h3><a name="Rper-space"></a>Per.18: Lo spazio è tempo<a class="headerlink" href="#per-18-space-is-time" title="Link to this heading">¶</a></h3>
<section id="id1237">
<h4>Motivo<a class="headerlink" href="#id1237" title="Link to this heading">¶</a></h4>
<p>Le prestazioni sono solitamente dominate dai tempi di accesso alla memoria.</p>
<p>???</p>
</section>
</section>
<section id="per-19-access-memory-predictably">
<h3><a name="Rper-access"></a>Per.19: Accesso prevedibile alla memoria<a class="headerlink" href="#per-19-access-memory-predictably" title="Link to this heading">¶</a></h3>
<section id="id1238">
<h4>Motivo<a class="headerlink" href="#id1238" title="Link to this heading">¶</a></h4>
<p>Le prestazioni sono molto sensibili alle prestazioni della cache e gli algoritmi della cache favoriscono il semplice accesso (solitamente lineare) ai dati adiacenti.</p>
</section>
<section id="id1239">
<h4>Esempio<a class="headerlink" href="#id1239" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int matrix[rows][cols];

// bad
for (int c = 0; c &lt; cols; ++c)
    for (int r = 0; r &lt; rows; ++r)
        sum += matrix[r][c];

// good
for (int r = 0; r &lt; rows; ++r)
    for (int c = 0; c &lt; cols; ++c)
        sum += matrix[r][c];
</pre></div>
</div>
</section>
</section>
<section id="per-30-avoid-context-switches-on-the-critical-path">
<h3><a name="Rper-context"></a>Per.30: Evitare i [context switch] sui percorsi [path] critici<a class="headerlink" href="#per-30-avoid-context-switches-on-the-critical-path" title="Link to this heading">¶</a></h3>
<p>???</p>
</section>
</section>
<section id="cp-concurrency-and-parallelism">
<h2><a name="S-concurrency"></a>CP: Concorrenza e parallelismo<a class="headerlink" href="#cp-concurrency-and-parallelism" title="Link to this heading">¶</a></h2>
<p>Spesso si vuole che i computer facciano molte cose contemporaneamente (o almeno che sembrino eseguirle nello stesso tempo). I motivi per volerlo sono vari (p.es., aspettare molti eventi con un singolo processore, elaborare molti flussi di dati simultaneamente o utilizzare tante infrastrutture hardware) e questo lo fanno delle strutture basilari per espletare la concorrenza e il parallelismo. Qui, si parla di alcuni principi e regole per usare le strutture del C++ standard ISO per espletare la concorrenza e il parallelismo.</p>
<p>I thread sono le fondamenta a livello macchina per la programmazione concorrente e parallela. I thread consentono l’esecuzione di più sezioni di un programma indipendentemente, condividendo la stessa memoria. La programmazione concorrente è complicata, perché proteggere i dati condivisi tra i thread è più facile a dirsi che a farsi. Eseguire un codice single-thread esistente in modo concorrente può risultare banale come aggiungere strategicamente <code class="docutils literal notranslate"><span class="pre">std::async</span></code> o <code class="docutils literal notranslate"><span class="pre">std::thread</span></code>, o può essere necessario riscrivere tutto, a seconda che il codice originale sia stato scritto in modo thread-friendly.</p>
<p>Le regole della concorrenza/parallelismo in questo documento sono progettate tenendo tre obiettivi in mente:</p>
<ul class="simple">
<li><p>Aiutare a scrivere codice utilizzabile in un ambiente con thread</p></li>
<li><p>Illustrare un modo pulito e sicuro per utilizzare le primitive del threading fornite dalla libreria standard</p></li>
<li><p>Offrire indicazioni su cosa fare quando la concorrenza e il parallelismo non raggiungono le prestazioni necessarie</p></li>
</ul>
<p>È anche importante notare che la concorrenza in C++ è una storia incompiuta. Il C++11 ha introdotto molte primitive centrali per la concorrenza, il C++14 e il C++17 le hanno migliorate, e c’è molto interesse nel semplificare la scrittura di programmi concorrenti in C++. Si prevede che alcune di queste linee-guida relative alla libreria cambieranno significativamente nel tempo.</p>
<p>Questa sezione richiede molto lavoro (ovviamente). Si noti che si inizia con le regole riguardanti i non esperti. I veri esperti devono aspettare un po”; i contributi sono ben accetti, ma per favore, si pensi alla maggior parte dei programmatori che stanno lottando per far funzionare correttamente e in modo performante i loro programmi concorrenti.</p>
<p>Riepilogo delle regole sul parallelismo e la concorrenza:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rconc-multi"><span class="xref myst">CP.1: Si assuma che il proprio codice girerà come parte in un programma multi-threaded</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-races"><span class="xref myst">CP.2: Evitare i conflitti dei dati [data race]</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-data"><span class="xref myst">CP.3: Minimizzare la condivisione esplicita dei dati scrivibili</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-task"><span class="xref myst">CP.4: Pensare in termini di task, anziché di thread</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-volatile"><span class="xref myst">CP.8: Non cercare di usare <code class="docutils literal notranslate"><span class="pre">volatile</span></code> per la sincronizzazione</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-tools"><span class="xref myst">CP.9: Quando possibile utilizzare i tool per validare il proprio codice concorrente</span></a></p></li>
</ul>
<p><strong>Si veda anche</strong>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#SScp-con"><span class="xref myst">CP.con: Concorrenza</span></a></p></li>
<li><p><a class="reference internal" href="#SScp-coro"><span class="xref myst">CP.coro: Coroutine</span></a></p></li>
<li><p><a class="reference internal" href="#SScp-par"><span class="xref myst">CP.par: Parallelismo</span></a></p></li>
<li><p><a class="reference internal" href="#SScp-mess"><span class="xref myst">CP.mess: Passaggio dei messaggi</span></a></p></li>
<li><p><a class="reference internal" href="#SScp-vec"><span class="xref myst">CP.vec: Vettorizzazione</span></a></p></li>
<li><p><a class="reference internal" href="#SScp-free"><span class="xref myst">CP.free: Programmazione senza lock</span></a></p></li>
<li><p><a class="reference internal" href="#SScp-etc"><span class="xref myst">CP.etc: Ecc. regole della concorrenza</span></a></p></li>
</ul>
<section id="cp-1-assume-that-your-code-will-run-as-part-of-a-multi-threaded-program">
<h3><a name="Rconc-multi"></a>CP.1: Si assuma che il proprio codice girerà come parte in un programma multi-threaded<a class="headerlink" href="#cp-1-assume-that-your-code-will-run-as-part-of-a-multi-threaded-program" title="Link to this heading">¶</a></h3>
<section id="id1240">
<h4>Motivo<a class="headerlink" href="#id1240" title="Link to this heading">¶</a></h4>
<p>È difficile essere certi che la concorrenza non sia utilizzata ora e che non verrà utilizzata in futuro. Il codice si riutilizza. Le librerie che non utilizzano i thread potrebbero essere utilizzate da un’altra parte in un programma che utilizza i thread. Si noti che questa regola si applica subito al codice della libreria e meno urgentemente alle applicazioni singole. Tuttavia, nel tempo, pezzi di codice possono apparire in luoghi inaspettati.</p>
</section>
<section id="id1241">
<h4>Esempio, cattivo<a class="headerlink" href="#id1241" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double cached_computation(int x)
{
    // bad: these statics cause data races in multi-threaded usage
    static int cached_x = 0.0;
    static double cached_result = COMPUTATION_OF_ZERO;

    if (cached_x != x) {
        cached_x = x;
        cached_result = computation(x);
    }
    return cached_result;
}
</pre></div>
</div>
<p>Sebbene <code class="docutils literal notranslate"><span class="pre">cached_computation</span></code> funziona perfettamente in un ambiente single-thread, in uno multi-threaded le due variabili <code class="docutils literal notranslate"><span class="pre">static</span></code> provocano conflitti e quindi un comportamento indefinito.</p>
</section>
<section id="id1242">
<h4>Esempio, buono<a class="headerlink" href="#id1242" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ComputationCache {
    int cached_x = 0;
    double cached_result = COMPUTATION_OF_ZERO;

    double compute(int x) {
        if (cached_x != x) {
            cached_x = x;
            cached_result = computation(x);
        }
        return cached_result;
    }
};
</pre></div>
</div>
<p>Qui la cache viene memorizzata come un dato membro di un oggetto <code class="docutils literal notranslate"><span class="pre">ComputationCache</span></code>, anziché come uno stato statico condiviso. Questa refactoring essenzialmente delega la responsabilità al chiamante: un programma single-threaded potrebbe ancora decidere di avere un <code class="docutils literal notranslate"><span class="pre">ComputationCache</span></code> globale, mentre un programma multi-threaded potrebbe avere un’istanza <code class="docutils literal notranslate"><span class="pre">ComputationCache</span></code> per ciascun thread o una per ciascun «contesto» per qualsiasi definizione di «contesto».
La funzione refactored non tenta più di gestire l’allocazione di <code class="docutils literal notranslate"><span class="pre">cached_x</span></code>. In questo senso, questa è un’applicazione del «Single Responsibility Principle».</p>
<p>In questo specifico esempio, il refactoring per la sicurezza del thread migliora anche la riutilizzabilità nei programmi single-threaded. Non è difficile immaginare che un programma a thread singolo potrebbe volere due istanze <code class="docutils literal notranslate"><span class="pre">ComputationCache</span></code> per usarle in diverse parti del programma, senza che i dati memorizzati nella cache vengano sovrascritti a vicenda.</p>
<p>Ci sono molti altri modi con cui si può migliorare la sicurezza dei thread al codice scritto per un ambiente multi-threaded standard (ovvero, uno in cui l’unica forma di concorrenza sia <code class="docutils literal notranslate"><span class="pre">std::thread</span></code>):</p>
<ul class="simple">
<li><p>Contrassegnare le variabili di stato come <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> anziché <code class="docutils literal notranslate"><span class="pre">static</span></code>.</p></li>
<li><p>Implementare il controllo della concorrenza, ad esempio, proteggendo l’accesso alle due variabili <code class="docutils literal notranslate"><span class="pre">static</span></code> con uno <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">std::mutex</span></code>.</p></li>
<li><p>Rifiutare di compilare e/o eseguire in un ambiente multi-thread.</p></li>
<li><p>Fornire due implementazioni: una per ambienti a singolo thread e un’altra per ambienti a thread multipli.</p></li>
</ul>
</section>
<section id="id1243">
<h4>Eccezione<a class="headerlink" href="#id1243" title="Link to this heading">¶</a></h4>
<p>Il codice che non viene mai eseguito in un ambiente multi-thread.</p>
<p>Fare attenzione: ci sono molti esempi in cui il codice «riconosciuto» che non girava in un programma multi-thread è stato inserito in un programma multi-thread, spesso dopo anni.. Solitamente, questi programmi portano ad un penoso lavoro per rimuovere i conflitti. Pertanto, il codice che non dovrebbe mai essere eseguito in un ambiente multi-thread dovrebbe essere chiaramente etichettato come tale e idealmente dotato di meccanismi, durante la compilazione o a run-time, per rilevare tempestivamente i bug di utilizzo.</p>
</section>
</section>
<section id="cp-2-avoid-data-races">
<h3><a name="Rconc-races"></a>CP.2: Evitare i conflitti dei dati [data race]<a class="headerlink" href="#cp-2-avoid-data-races" title="Link to this heading">¶</a></h3>
<section id="id1244">
<h4>Motivo<a class="headerlink" href="#id1244" title="Link to this heading">¶</a></h4>
<p>Se non lo si fa, niente garantisce il funzionamento e persistono dei subdoli errori.</p>
</section>
<section id="id1245">
<h4>Nota<a class="headerlink" href="#id1245" title="Link to this heading">¶</a></h4>
<p>In breve, se due thread possono accedere contemporaneamente allo stesso oggetto (senza sincronizzazione), e almeno uno scrive (eseguendo un’operazione non-<code class="docutils literal notranslate"><span class="pre">const</span></code>), si ha un conflitto [data race]. Per ulteriori informazioni su come utilizzare bene la sincronizzazione per eliminare i conflitti, si consulti un buon libro sulla concorrenza (Vedere <a class="reference internal" href="#Rconc-literature"><span class="xref myst">Studiare attentamente la bibliografia</span></a>).</p>
</section>
<section id="id1246">
<h4>Esempio, cattivo<a class="headerlink" href="#id1246" title="Link to this heading">¶</a></h4>
<p>Esistono molti esempi di conflitti, alcuni dei quali girano in software di produzione in questo preciso momento. Un semplicissimo esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int get_id()
{
  static int id = 1;
  return id++;
}
</pre></div>
</div>
<p>L’incremento qui è un esempio di conflitto [data race]. Questo può andar male in molti modi, tra cui:</p>
<ul class="simple">
<li><p>Il thread A carica il valore di <code class="docutils literal notranslate"><span class="pre">id</span></code>, Il contesto del sistema operativo disattiva A per un po”, durante il quale altri thread creano centinaia di ID. Quando torna in esecuzione il thread A, <code class="docutils literal notranslate"><span class="pre">id</span></code> viene riscritto col valore di <code class="docutils literal notranslate"><span class="pre">id</span></code> letto da A più uno.</p></li>
<li><p>I thread A e B caricano <code class="docutils literal notranslate"><span class="pre">id</span></code> e lo incrementano simultaneamente.  Entrambi ottengono lo stesso ID.</p></li>
</ul>
<p>Le variabili static locali sono una comune fonte di conflitti [data race].</p>
</section>
<section id="id1247">
<h4>Esempio, cattivo:<a class="headerlink" href="#id1247" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(fstream&amp; fs, regex pattern)
{
    array&lt;double, max&gt; buf;
    int sz = read_vec(fs, buf, max);            // read from fs into buf
    gsl::span&lt;double&gt; s {buf};
    // ...
    auto h1 = async([&amp;] { sort(std::execution::par, s); });     // spawn a task to sort
    // ...
    auto h2 = async([&amp;] { return find_all(buf, sz, pattern); });   // spawn a task to find matches
    // ...
}
</pre></div>
</div>
<p>Qui, si ha un (brutto) conflitto tra gli elementi di <code class="docutils literal notranslate"><span class="pre">buf</span></code> (<code class="docutils literal notranslate"><span class="pre">sort</span></code> leggerà e scriverà). Tutti i conflitti [data race] sono brutti. Qui, si è riusciti ad avere un conflitto tra i dati sullo stack. Non tutti i conflitti sono facili da evidenziare come questo.</p>
</section>
<section id="id1248">
<h4>Esempio, cattivo:<a class="headerlink" href="#id1248" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// code not controlled by a lock

unsigned val;

if (val &lt; 5) {
    // ... other thread can change val here ...
    switch (val) {
    case 0: // ...
    case 1: // ...
    case 2: // ...
    case 3: // ...
    case 4: // ...
    }
}
</pre></div>
</div>
<p>Ora, un compilatore che non sa che <code class="docutils literal notranslate"><span class="pre">val</span></code> può cambiare, molto probabilmente implementerà quello <code class="docutils literal notranslate"><span class="pre">switch</span></code> usando una tabella dei salti con cinque voci. Quindi, un <code class="docutils literal notranslate"><span class="pre">val</span></code> al di fuori dell’intervallo <code class="docutils literal notranslate"><span class="pre">[0..4]</span></code> provocherà un salto ad un indirizzo che può puntare ovunque nel programma e l’esecuzione proseguirà da lì. Davvero, «tutto può accadere» se si ha un conflitto. In realtà, può capitare di peggio: guardando il codice generato si potrebbe essere in grado di determinare dove salterà per un dato valore; questo può essere un rischio per la sicurezza.</p>
</section>
<section id="id1249">
<h4>Imposizione<a class="headerlink" href="#id1249" title="Link to this heading">¶</a></h4>
<p>Se possibile, fare almeno qualcosa. Ci sono tool commerciali ed open-source che cercano di risolvere questo problema, ma si tenga presente che le soluzioni hanno un costo e dei punti ignoti. I tool statici spesso hanno molti falsi positivi mentre quelli a run-time spesso hanno un costo elevato. Si spera in strumenti migliori. Utilizzando più tool si possono rilevare più problemi che con uno solo.</p>
<p>Ci sono altri modi per attenuare la possibilità di conflitti:</p>
<ul class="simple">
<li><p>Evitare i dati globali</p></li>
<li><p>Evitare le variabili <code class="docutils literal notranslate"><span class="pre">static</span></code></p></li>
<li><p>Usare più tipi concreti sullo stack (e non passare troppi puntatori)</p></li>
<li><p>Usare maggiormente dati immutabili (letterali, <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> e <code class="docutils literal notranslate"><span class="pre">const</span></code>)</p></li>
</ul>
</section>
</section>
<section id="cp-3-minimize-explicit-sharing-of-writable-data">
<h3><a name="Rconc-data"></a>CP.3: Minimizzare la condivisione esplicita dei dati scrivibili<a class="headerlink" href="#cp-3-minimize-explicit-sharing-of-writable-data" title="Link to this heading">¶</a></h3>
<section id="id1250">
<h4>Motivo<a class="headerlink" href="#id1250" title="Link to this heading">¶</a></h4>
<p>Se non si condividono dati scrivibili, non si hanno conflitti. Meno condivisione si fa, minori possibilità si hanno di dimenticare di sincronizzare l’accesso (ottenendo conflitti). Meno condivisione si fa, minori possibilità si hanno di aspettare per un lock (migliorando le prestazioni).</p>
</section>
<section id="id1251">
<h4>Esempio<a class="headerlink" href="#id1251" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool validate(const vector&lt;Reading&gt;&amp;);
Graph&lt;Temp_node&gt; temperature_gradients(const vector&lt;Reading&gt;&amp;);
Image altitude_map(const vector&lt;Reading&gt;&amp;);
// ...

void process_readings(const vector&lt;Reading&gt;&amp; surface_readings)
{
    auto h1 = async([&amp;] { if (!validate(surface_readings)) throw Invalid_data{}; });
    auto h2 = async([&amp;] { return temperature_gradients(surface_readings); });
    auto h3 = async([&amp;] { return altitude_map(surface_readings); });
    // ...
    h1.get();
    auto v2 = h2.get();
    auto v3 = h3.get();
    // ...
}
</pre></div>
</div>
<p>Senza quelle <code class="docutils literal notranslate"><span class="pre">const</span></code>, si dovrebbe rivedere ogni funzione richiamata in modo asincrono per un potenziale conflitto su <code class="docutils literal notranslate"><span class="pre">surface_readings</span></code>. Rendere <code class="docutils literal notranslate"><span class="pre">surface_readings</span></code> per essere <code class="docutils literal notranslate"><span class="pre">const</span></code> (rispetto a questa funzione) consente il ragionamento utilizzando solo il corpo della funzione.</p>
</section>
<section id="id1252">
<h4>Nota<a class="headerlink" href="#id1252" title="Link to this heading">¶</a></h4>
<p>I dati immutabili si possono condividere in modo sicuro ed efficientemente. Non è necessario alcun lock: Non si può avere un conflitto su una costante. Si veda anche <a class="reference internal" href="#SScp-mess"><span class="xref myst">CP.mess: Passaggio dei Parametri</span></a> e <a class="reference internal" href="#Rconc-data-by-value"><span class="xref myst">CP.31: preferire il passaggio per valore</span></a>.</p>
</section>
<section id="id1253">
<h4>Imposizione<a class="headerlink" href="#id1253" title="Link to this heading">¶</a></h4>
<p>???</p>
</section>
</section>
<section id="cp-4-think-in-terms-of-tasks-rather-than-threads">
<h3><a name="Rconc-task"></a>CP.4: Pensare in termini di task, anziché di thread<a class="headerlink" href="#cp-4-think-in-terms-of-tasks-rather-than-threads" title="Link to this heading">¶</a></h3>
<section id="id1254">
<h4>Motivo<a class="headerlink" href="#id1254" title="Link to this heading">¶</a></h4>
<p>Un <code class="docutils literal notranslate"><span class="pre">thread</span></code> è l’implementazione di un concetto, un modo di pensare alla macchina. Un task è una nozione di applicazione, qualcosa che ci piacerebbe fare, preferibilmente contemporaneamente ad altre attività. I concetti dell’applicazione sono più facili da immaginare.</p>
</section>
<section id="id1255">
<h4>Esempio<a class="headerlink" href="#id1255" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void some_fun(const std::string&amp; msg)
{
    std::thread publisher([=] { std::cout &lt;&lt; msg; });      // bad: less expressive
                                                           //      and more error-prone
    auto pubtask = std::async([=] { std::cout &lt;&lt; msg; });  // OK
    // ...
    publisher.join();
}
</pre></div>
</div>
</section>
<section id="id1256">
<h4>Nota<a class="headerlink" href="#id1256" title="Link to this heading">¶</a></h4>
<p>Ad eccezione di <code class="docutils literal notranslate"><span class="pre">async()</span></code>, le funzioni della libreria standard sono low-level, machine-oriented, a livello di thread-e-lock. Questa è un fondamento necessario, ma si deve cercare di aumentare il livello di astrazione: per produttività, per affidabilità e per prestazione. Questo è un potente argomento per usare librerie a più alto livello, più orientate alle applicazioni (se possibile, basate sulle funzioni della libreria standard).</p>
</section>
<section id="id1257">
<h4>Imposizione<a class="headerlink" href="#id1257" title="Link to this heading">¶</a></h4>
<p>???</p>
</section>
</section>
<section id="cp-8-don-t-try-to-use-volatile-for-synchronization">
<h3><a name="Rconc-volatile"></a>CP.8: Non cercare di usare  <code class="docutils literal notranslate"><span class="pre">volatile</span></code> per la sincronizzazione<a class="headerlink" href="#cp-8-don-t-try-to-use-volatile-for-synchronization" title="Link to this heading">¶</a></h3>
<section id="id1258">
<h4>Motivo<a class="headerlink" href="#id1258" title="Link to this heading">¶</a></h4>
<p>In C++, diversamente da altri linguaggi, <code class="docutils literal notranslate"><span class="pre">volatile</span></code> non fornisce l’atomicità, non sincronizza tra i thread, e non impedisce il riordino delle istruzioni (né il compilatore né l’hardware). Semplicemente non ha nulla a che fare con la concorrenza.</p>
</section>
<section id="id1259">
<h4>Esempio, cattivo:<a class="headerlink" href="#id1259" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int free_slots = max_slots; // current source of memory for objects

Pool* use()
{
    if (int n = free_slots--) return &amp;pool[n];
}
</pre></div>
</div>
<p>Qui c’è un problema: Questo è un codice perfettamente valido in un programma a thread singolo, ma ci sono due thread che lo eseguono e c’è una condizione di «race» su <code class="docutils literal notranslate"><span class="pre">free_slots</span></code> in cui due i thread possono ottenere lo stesso valore e <code class="docutils literal notranslate"><span class="pre">free_slots</span></code>. Questo è (ovviamente) un brutto conflitto e gli esperti di altri linguaggi potrebbero cercare di risolvere in questo modo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>volatile int free_slots = max_slots; // current source of memory for objects

Pool* use()
{
    if (int n = free_slots--) return &amp;pool[n];
}
</pre></div>
</div>
<p>Questo non ha alcun effetto sulla sincronizzazione: Il conflitto resta!</p>
<p>Il meccanismo del C++ per questo è scrivere <code class="docutils literal notranslate"><span class="pre">atomic</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>atomic&lt;int&gt; free_slots = max_slots; // current source of memory for objects

Pool* use()
{
    if (int n = free_slots--) return &amp;pool[n];
}
</pre></div>
</div>
<p>Ora l’operazione <code class="docutils literal notranslate"><span class="pre">--</span></code> è atomica, anziché una sequenza leggi-incrementa-scrivi dove un altro thread potrebbe inserirsi tra le operazioni.</p>
</section>
<section id="id1260">
<h4>Alternativa<a class="headerlink" href="#id1260" title="Link to this heading">¶</a></h4>
<p>Usare i tipi <code class="docutils literal notranslate"><span class="pre">atomic</span></code> dove si userebbe <code class="docutils literal notranslate"><span class="pre">volatile</span></code> in un altro linguaggio. Usare un <code class="docutils literal notranslate"><span class="pre">mutex</span></code> per esempi più complicati.</p>
</section>
<section id="id1261">
<h4>Si veda anche<a class="headerlink" href="#id1261" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="#Rconc-volatile2"><span class="xref myst">(rari) usi appropriati di  <code class="docutils literal notranslate"><span class="pre">volatile</span></code></span></a></p>
</section>
</section>
<section id="cp-9-whenever-feasible-use-tools-to-validate-your-concurrent-code">
<h3><a name="Rconc-tools"></a>CP.9: Quando possibile utilizzare i tool per validare il proprio codice concorrente<a class="headerlink" href="#cp-9-whenever-feasible-use-tools-to-validate-your-concurrent-code" title="Link to this heading">¶</a></h3>
<p>L’esperienza dimostra che il codice concorrente è estremamente difficile da scrivere correttamente e che il controllo in fase di compilazione, quelli a run-time, ed i test sono meno efficaci nel trovare gli errori sulla concorrenza rispetto a quelli che cercano errori nel codice sequenziale. Subdoli errori di concorrenza possono avere effetti drammaticamente negativi, tra cui la corruzione della memoria, deadlock e vulnerabilità della sicurezza.</p>
<section id="id1262">
<h4>Esempio<a class="headerlink" href="#id1262" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1263">
<h4>Nota<a class="headerlink" href="#id1263" title="Link to this heading">¶</a></h4>
<p>La sicurezza del thread è impegnativa, spesso ha la meglio sui programmatori esperti: gli strumenti costituiscono una importante strategia per mitigare tali rischi. Ci sono molti tool «in giro», sia commerciali che open-source, sia tool per la ricerca che per la produzione. Sfortunatamente le esigenze e i vincoli delle persone differiscono in modo così drammatico che non si possono formulare raccomandazioni specifiche, ma si può menzionare:</p>
<ul class="simple">
<li><p>Strumenti di imposizione [enforcement] statica: sia <a class="reference external" href="http://clang.llvm.org/docs/ThreadSafetyAnalysis.html">clang</a> e qualche più vecchia versione di <a class="reference external" href="https://gcc.gnu.org/wiki/ThreadSafetyAnnotation">GCC</a> hanno qualche supporto per l’annotazione statica delle proprietà sulla sicurezza del thread. L’uso coerente di questa tecnica trasforma molte classi di errori sulla sicurezza dei thread in errori di compilazione. Le annotazioni sono generalmente locali (contrassegnando un particolare dato membro come protetto da un particolare mutex) e solitamente sono facili da imparare. Tuttavia, come con molti tool statici, possono spesso presentare falsi negativi; casi che avrebbero dovuto essere rilevati ma vengono autorizzati.</p></li>
<li><p>strumenti di imposizione [enforcement] dinamica: Il <a class="reference external" href="http://clang.llvm.org/docs/ThreadSanitizer.html">Thread Sanitizer</a> di Clang (aka TSAN) è un potente esempio di strumenti dinamici: esso cambia la compilazione e l’esecuzione del proprio programma aggiungendo un conteggio sull’accesso della memoria, identificando assolutamente i conflitti in una data esecuzione del codice binario. Il suo costo è sia in memoria (5-10x nella maggior parte dei casi) che in rallentamento della CPU (2-20x). Gli strumenti dinamici come questi sono migliori quando vengono applicati ai test di integrazione, ai «canary pushes», o unit di test che operano su thread multipli. Il carico di lavoro è importante: Quando TSAN identifica un problema, si tratta sempre di un vero e proprio confitto [data race],
ma può identificare solo i conflitti visti in una data esecuzione.</p></li>
</ul>
</section>
<section id="id1264">
<h4>Imposizione<a class="headerlink" href="#id1264" title="Link to this heading">¶</a></h4>
<p>Spetta a un costruttore di applicazioni scegliere quali strumenti di supporto sono utili per una particolare applicazione.</p>
</section>
</section>
<section id="cp-con-concurrency">
<h3><a name="SScp-con"></a>CP.con: Concorrenza<a class="headerlink" href="#cp-con-concurrency" title="Link to this heading">¶</a></h3>
<p>Questa sezione si concentra sugli usi relativamente ad-hoc dei thread multipli che comunicano tramite dati condivisi.</p>
<ul class="simple">
<li><p>Per gli algoritmi paralleli, si veda <a class="reference internal" href="#SScp-par"><span class="xref myst">parallelismo</span></a></p></li>
<li><p>Per la comunicazione inter-task senza una esplicita condivisione, si veda <a class="reference internal" href="#SScp-mess"><span class="xref myst">messaging</span></a></p></li>
<li><p>Per il codice vettoriale parallelo, si veda <a class="reference internal" href="#SScp-vec"><span class="xref myst">vettorizzazione</span></a></p></li>
<li><p>Per la programmazione lock-free, si veda <a class="reference internal" href="#SScp-free"><span class="xref myst">lock free</span></a></p></li>
</ul>
<p>Riepilogo delle regole sulla concorrenza:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rconc-raii"><span class="xref myst">CP.20: Usare il RAII, mai il semplice <code class="docutils literal notranslate"><span class="pre">lock()</span></code>/<code class="docutils literal notranslate"><span class="pre">unlock()</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-lock"><span class="xref myst">CP.21: Usare <code class="docutils literal notranslate"><span class="pre">std::lock()</span></code> o <code class="docutils literal notranslate"><span class="pre">std::scoped_lock</span></code> per acquisire <code class="docutils literal notranslate"><span class="pre">mutex</span></code> multipli</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-unknown"><span class="xref myst">CP.22: Mai chiamare codice sconosciuto mentre si tiene un lock (p.es., una callback)</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-join"><span class="xref myst">CP.23: Pensare ad un <code class="docutils literal notranslate"><span class="pre">thread</span></code> congiunto [joining] come contenitore con uno scope</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-detach"><span class="xref myst">CP.24: Pensare ad un <code class="docutils literal notranslate"><span class="pre">thread</span></code> come ad un contenitore globale</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-joining_thread"><span class="xref myst">CP.25: Preferire <code class="docutils literal notranslate"><span class="pre">gsl::joining_thread</span></code> a <code class="docutils literal notranslate"><span class="pre">std::thread</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-detached_thread"><span class="xref myst">CP.26: Non eseguire il <code class="docutils literal notranslate"><span class="pre">detach()</span></code> di un thread</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-data-by-value"><span class="xref myst">CP.31: Passare una piccola quantità di dati tra i thread per valore, anziché per riferimento o puntatore</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-shared"><span class="xref myst">CP.32: Per condividere la proprietà [ownership] tra <code class="docutils literal notranslate"><span class="pre">thread</span></code> non correlati, usare gli <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-switch"><span class="xref myst">CP.40: Minimizzare il [context switching]</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-create"><span class="xref myst">CP.41: Minimizzare la creazione e la distruzione del thread</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-wait"><span class="xref myst">CP.42: Non eseguire un <code class="docutils literal notranslate"><span class="pre">wait</span></code> senza una condizione</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-time"><span class="xref myst">CP.43: Minimizzare il tempo trascorso nella sezione critica</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-name"><span class="xref myst">CP.44: Ricordarsi di dare un nome ai <code class="docutils literal notranslate"><span class="pre">lock_guard</span></code>s e agli <code class="docutils literal notranslate"><span class="pre">unique_lock</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-mutex"><span class="xref myst">CP.50: Definire un <code class="docutils literal notranslate"><span class="pre">mutex</span></code> assieme ai dati che protegge. Usare <code class="docutils literal notranslate"><span class="pre">synchronized_value&lt;T&gt;</span></code> dove possibile</span></a></p></li>
<li><p>??? quando usare uno spinlock</p></li>
<li><p>??? quando usare <code class="docutils literal notranslate"><span class="pre">try_lock()</span></code></p></li>
<li><p>??? quando preferire <code class="docutils literal notranslate"><span class="pre">lock_guard</span></code> a <code class="docutils literal notranslate"><span class="pre">unique_lock</span></code></p></li>
<li><p>??? [Time multiplexing]</p></li>
<li><p>??? quando/come usare <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">thread</span></code></p></li>
</ul>
<section id="cp-20-use-raii-never-plain-lock-unlock">
<h4><a name="Rconc-raii"></a>CP.20: Usare il RAII, mai il semplice <code class="docutils literal notranslate"><span class="pre">lock()</span></code>/<code class="docutils literal notranslate"><span class="pre">unlock()</span></code><a class="headerlink" href="#cp-20-use-raii-never-plain-lock-unlock" title="Link to this heading">¶</a></h4>
<section id="id1265">
<h5>Motivo<a class="headerlink" href="#id1265" title="Link to this heading">¶</a></h5>
<p>Evitare brutti errori con i lock non rilasciati.</p>
</section>
<section id="id1266">
<h5>Esempio, cattivo<a class="headerlink" href="#id1266" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mutex mtx;

void do_stuff()
{
    mtx.lock();
    // ... do stuff ...
    mtx.unlock();
}
</pre></div>
</div>
<p>Prima o poi, qualcuno dimenticherà il <code class="docutils literal notranslate"><span class="pre">mtx.unlock()</span></code>, piazzando un <code class="docutils literal notranslate"><span class="pre">return</span></code> nel <code class="docutils literal notranslate"><span class="pre">...</span> <span class="pre">do</span> <span class="pre">stuff</span> <span class="pre">...</span></code>, generando un’eccezione o qualcosa del genere.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mutex mtx;

void do_stuff()
{
    unique_lock&lt;mutex&gt; lck {mtx};
    // ... do stuff ...
}
</pre></div>
</div>
</section>
<section id="id1267">
<h5>Imposizione<a class="headerlink" href="#id1267" title="Link to this heading">¶</a></h5>
<p>Segnalare le chiamate del membro <code class="docutils literal notranslate"><span class="pre">lock()</span></code> e <code class="docutils literal notranslate"><span class="pre">unlock()</span></code>.  ???</p>
</section>
</section>
<section id="cp-21-use-std-lock-or-std-scoped-lock-to-acquire-multiple-mutexes">
<h4><a name="Rconc-lock"></a>CP.21: Usare <code class="docutils literal notranslate"><span class="pre">std::lock()</span></code> o <code class="docutils literal notranslate"><span class="pre">std::scoped_lock</span></code> per acquisire <code class="docutils literal notranslate"><span class="pre">mutex</span></code> multipli<a class="headerlink" href="#cp-21-use-std-lock-or-std-scoped-lock-to-acquire-multiple-mutexes" title="Link to this heading">¶</a></h4>
<section id="id1268">
<h5>Motivo<a class="headerlink" href="#id1268" title="Link to this heading">¶</a></h5>
<p>Per evitare i deadlock sui <code class="docutils literal notranslate"><span class="pre">mutex</span></code> multipli.</p>
</section>
<section id="id1269">
<h5>Esempio<a class="headerlink" href="#id1269" title="Link to this heading">¶</a></h5>
<p>Questo provoca un deadlock:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// thread 1
lock_guard&lt;mutex&gt; lck1(m1);
lock_guard&lt;mutex&gt; lck2(m2);

// thread 2
lock_guard&lt;mutex&gt; lck2(m2);
lock_guard&lt;mutex&gt; lck1(m1);
</pre></div>
</div>
<p>Usare, invece <code class="docutils literal notranslate"><span class="pre">lock()</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// thread 1
lock(m1, m2);
lock_guard&lt;mutex&gt; lck1(m1, adopt_lock);
lock_guard&lt;mutex&gt; lck2(m2, adopt_lock);

// thread 2
lock(m2, m1);
lock_guard&lt;mutex&gt; lck2(m2, adopt_lock);
lock_guard&lt;mutex&gt; lck1(m1, adopt_lock);
</pre></div>
</div>
<p>o (meglio, ma solo in C++17):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// thread 1
scoped_lock&lt;mutex, mutex&gt; lck1(m1, m2);

// thread 2
scoped_lock&lt;mutex, mutex&gt; lck2(m2, m1);
</pre></div>
</div>
<p>Qui, quelli che hanno scritto <code class="docutils literal notranslate"><span class="pre">thread1</span></code> e <code class="docutils literal notranslate"><span class="pre">thread2</span></code> non sono ancora d’accordo sull’ordine dei <code class="docutils literal notranslate"><span class="pre">mutex</span></code>, ma l’ordine non importa più.</p>
</section>
<section id="id1270">
<h5>Nota<a class="headerlink" href="#id1270" title="Link to this heading">¶</a></h5>
<p>Nel codice reale, i <code class="docutils literal notranslate"><span class="pre">mutex</span></code> hanno raramente un nome per rammentare convenientemente al programmatore una relazione e un ordine di acquisizione previsti. Nel codice reale, i <code class="docutils literal notranslate"><span class="pre">mutex</span></code> non sempre sono convenientemente acquisiti su righe consecutive.</p>
</section>
<section id="id1271">
<h5>Nota<a class="headerlink" href="#id1271" title="Link to this heading">¶</a></h5>
<p>Nel C++17 è possibile scrivere semplicemente</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lock_guard lck1(m1, adopt_lock);
</pre></div>
</div>
<p>e dedurre il tipo <code class="docutils literal notranslate"><span class="pre">mutex</span></code>.</p>
</section>
<section id="id1272">
<h5>Imposizione<a class="headerlink" href="#id1272" title="Link to this heading">¶</a></h5>
<p>Rilevare l’acquisizione di <code class="docutils literal notranslate"><span class="pre">mutex</span></code> multipli. Questo è generalmente indecidibile, ma prendere semplici esempi (come quello precedente) è facile.</p>
</section>
</section>
<section id="cp-22-never-call-unknown-code-while-holding-a-lock-e-g-a-callback">
<h4><a name="Rconc-unknown"></a>CP.22: Mai chiamare codice sconosciuto mentre si tiene un lock (p.es., una callback)<a class="headerlink" href="#cp-22-never-call-unknown-code-while-holding-a-lock-e-g-a-callback" title="Link to this heading">¶</a></h4>
<section id="id1273">
<h5>Motivo<a class="headerlink" href="#id1273" title="Link to this heading">¶</a></h5>
<p>Se non si sa cosa faccia un pezzo di codice, si rischia un deadlock.</p>
</section>
<section id="id1274">
<h5>Esempio<a class="headerlink" href="#id1274" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void do_this(Foo* p)
{
    lock_guard&lt;mutex&gt; lck {my_mutex};
    // ... do something ...
    p-&gt;act(my_data);
    // ...
}
</pre></div>
</div>
<p>Se non si sa cosa fa <code class="docutils literal notranslate"><span class="pre">Foo::act</span></code> (forse è una funzione virtuale che invoca una classe membro derivata da una classe non ancora scritta), si potrebbe chiamare <code class="docutils literal notranslate"><span class="pre">do_this</span></code> (ricorsivamente) provocando un deadlock su <code class="docutils literal notranslate"><span class="pre">my_mutex</span></code>. Forse si bloccherà su un mutex diverso e non tornerà in un tempo ragionevole, causando ritardi a qualsiasi codice che chiama <code class="docutils literal notranslate"><span class="pre">do_this</span></code>.</p>
</section>
<section id="id1275">
<h5>Esempio<a class="headerlink" href="#id1275" title="Link to this heading">¶</a></h5>
<p>Un esempio comune del problema di «chiamare codice ignoto» è una chiamata a una funzione che tenta di acquisire l’accesso allo stesso oggetto sottoposto a lock. Tale problema può spesso essere risolto utilizzando un <code class="docutils literal notranslate"><span class="pre">recursive_mutex</span></code>. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>recursive_mutex my_mutex;

template&lt;typename Action&gt;
void do_something(Action f)
{
    unique_lock&lt;recursive_mutex&gt; lck {my_mutex};
    // ... do something ...
    f(this);    // f will do something to *this
    // ...
}
</pre></div>
</div>
<p>Se, come è probabile, <code class="docutils literal notranslate"><span class="pre">f()</span></code> richiama delle operazioni su <code class="docutils literal notranslate"><span class="pre">*this</span></code>, ci si deve assicurare che l’invariante dell’oggetto sia preso prima della chiamata.</p>
</section>
<section id="id1276">
<h5>Imposizione<a class="headerlink" href="#id1276" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare una chiamata a una funzione virtuale prendendo un <code class="docutils literal notranslate"><span class="pre">mutex</span></code> non ricorsivo</p></li>
<li><p>Segnalare la chiamata a una callback prendendo un <code class="docutils literal notranslate"><span class="pre">mutex</span></code> non ricorsivo</p></li>
</ul>
</section>
</section>
<section id="cp-23-think-of-a-joining-thread-as-a-scoped-container">
<h4><a name="Rconc-join"></a>CP.23: Pensare ad un <code class="docutils literal notranslate"><span class="pre">thread</span></code> congiunto [joining] come contenitore con uno scope<a class="headerlink" href="#cp-23-think-of-a-joining-thread-as-a-scoped-container" title="Link to this heading">¶</a></h4>
<section id="id1277">
<h5>Motivo<a class="headerlink" href="#id1277" title="Link to this heading">¶</a></h5>
<p>Per mantenere la sicurezza del puntatore ed evitare i leak, si devono considerare quali puntatori vengono usati da un <code class="docutils literal notranslate"><span class="pre">thread</span></code>. Se un <code class="docutils literal notranslate"><span class="pre">thread</span></code> si unisce [joins], si possono tranquillamente passare i puntatori agli oggetti nello scope <code class="docutils literal notranslate"><span class="pre">thread</span></code> e degli scope racchiusi.</p>
</section>
<section id="id1278">
<h5>Esempio<a class="headerlink" href="#id1278" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int* p)
{
    // ...
    *p = 99;
    // ...
}
int glob = 33;

void some_fct(int* p)
{
    int x = 77;
    joining_thread t0(f, &amp;x);           // OK
    joining_thread t1(f, p);            // OK
    joining_thread t2(f, &amp;glob);        // OK
    auto q = make_unique&lt;int&gt;(99);
    joining_thread t3(f, q.get());      // OK
    // ...
}
</pre></div>
</div>
<p>Un <code class="docutils literal notranslate"><span class="pre">gsl::joining_thread</span></code> è un <code class="docutils literal notranslate"><span class="pre">std::thread</span></code> con un distruttore che si unisce [joins] e che non può essere <code class="docutils literal notranslate"><span class="pre">detached()</span></code>. Per  «OK» si intende che l’oggetto starà nello scope («attivo») finché un <code class="docutils literal notranslate"><span class="pre">thread</span></code> può usare un puntatore ad esso. Il fatto che i <code class="docutils literal notranslate"><span class="pre">thread</span></code> vengano eseguiti contemporaneamente qui  non influisce sui problemi di durata o proprietà; questi <code class="docutils literal notranslate"><span class="pre">thread</span></code> possono essere visti come un solo oggetto funzione chiamato da <code class="docutils literal notranslate"><span class="pre">some_fct</span></code>.</p>
</section>
<section id="id1279">
<h5>Imposizione<a class="headerlink" href="#id1279" title="Link to this heading">¶</a></h5>
<p>Assicurarsi che dei <code class="docutils literal notranslate"><span class="pre">joining_thread</span></code> non eseguano il <code class="docutils literal notranslate"><span class="pre">detach()</span></code>. Successivamente, si applica la solita imposizione sul ciclo di vita [lifetime] e la proprietà [ownership] (per gli oggetti locali).</p>
</section>
</section>
<section id="cp-24-think-of-a-thread-as-a-global-container">
<h4><a name="Rconc-detach"></a>CP.24: Pensare ad un <code class="docutils literal notranslate"><span class="pre">thread</span></code> come ad un contenitore globale<a class="headerlink" href="#cp-24-think-of-a-thread-as-a-global-container" title="Link to this heading">¶</a></h4>
<section id="id1280">
<h5>Motivo<a class="headerlink" href="#id1280" title="Link to this heading">¶</a></h5>
<p>Per mantenere la sicurezza del puntatore ed evitare i leak, si devono considerare quali puntatori vengono usati da un <code class="docutils literal notranslate"><span class="pre">thread</span></code>. Se un <code class="docutils literal notranslate"><span class="pre">thread</span></code> è staccato [detached], si possono tranquillamente passare puntatori a oggetti statici e sull’heap [free store] (solo).</p>
</section>
<section id="id1281">
<h5>Esempio<a class="headerlink" href="#id1281" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int* p)
{
    // ...
    *p = 99;
    // ...
}

int glob = 33;

void some_fct(int* p)
{
    int x = 77;
    std::thread t0(f, &amp;x);           // bad
    std::thread t1(f, p);            // bad
    std::thread t2(f, &amp;glob);        // OK
    auto q = make_unique&lt;int&gt;(99);
    std::thread t3(f, q.get());      // bad
    // ...
    t0.detach();
    t1.detach();
    t2.detach();
    t3.detach();
    // ...
}
</pre></div>
</div>
<p>Con «OK» si intende che l’oggetto rimarrà nello scope («attivo») fin quando un <code class="docutils literal notranslate"><span class="pre">thread</span></code> userà i puntatori ad esso. Con «bad» si intende che un <code class="docutils literal notranslate"><span class="pre">thread</span></code> potrebbe usare un puntatore dopo che l’oggetto puntato è stato distrutto. Il fatto che i <code class="docutils literal notranslate"><span class="pre">thread</span></code> vengano eseguiti contemporaneamente qui  non influisce sui problemi di durata o proprietà; questi <code class="docutils literal notranslate"><span class="pre">thread</span></code> possono essere visti come un solo oggetto funzione chiamato da <code class="docutils literal notranslate"><span class="pre">some_fct</span></code>.</p>
</section>
<section id="id1282">
<h5>Nota<a class="headerlink" href="#id1282" title="Link to this heading">¶</a></h5>
<p>Anche gli oggetti con una durata nello storage statico possono dare problemi se usati dai thread [detached]: se il thread continua fino alla fine del programma, potrebbe stare in esecuzione contemporaneamente alla distruzione di oggetti statici, e quindi l’accesso a tali oggetti potrebbe sollevare un conflitto [race].</p>
</section>
<section id="id1283">
<h5>Nota<a class="headerlink" href="#id1283" title="Link to this heading">¶</a></h5>
<p>Questa regola è ridondante se <a class="reference internal" href="#Rconc-detached_thread"><span class="xref myst">non si esegue il <code class="docutils literal notranslate"><span class="pre">detach()</span></code></span></a> e si <a class="reference internal" href="#Rconc-joining_thread"><span class="xref myst">usa <code class="docutils literal notranslate"><span class="pre">gsl::joining_thread</span></code></span></a>. Tuttavia, la conversione del codice per seguire tali linee-guida potrebbe essere difficile e persino impossibile per le librerie di terze parti. In tali casi, la regola diventa essenziale per la sicurezza della durata e di quella del tipo.</p>
<p>In generale, non si può decidere se viene eseguito un <code class="docutils literal notranslate"><span class="pre">detach()</span></code> per un <code class="docutils literal notranslate"><span class="pre">thread</span></code>, ma i semplici casi comuni sono facili da rilevare. Se non è possibile dimostrare che un <code class="docutils literal notranslate"><span class="pre">thread</span></code> non esegue il <code class="docutils literal notranslate"><span class="pre">detach()</span></code>, si deve assumere che lo faccia e che sopravviva allo scope in cui è stato costruito; Dopo di ciò, si applica la solita imposizione sulla durata e la proprietà [ownership] (per gli oggetti globali).</p>
</section>
<section id="id1284">
<h5>Imposizione<a class="headerlink" href="#id1284" title="Link to this heading">¶</a></h5>
<p>Segnalare i tentativi di passare variabili locali ad un thread di cui si può eseguire il <code class="docutils literal notranslate"><span class="pre">detach()</span></code>.</p>
</section>
</section>
<section id="cp-25-prefer-gsl-joining-thread-over-std-thread">
<h4><a name="Rconc-joining_thread"></a>CP.25: Preferire <code class="docutils literal notranslate"><span class="pre">gsl::joining_thread</span></code> a <code class="docutils literal notranslate"><span class="pre">std::thread</span></code><a class="headerlink" href="#cp-25-prefer-gsl-joining-thread-over-std-thread" title="Link to this heading">¶</a></h4>
<section id="id1285">
<h5>Motivo<a class="headerlink" href="#id1285" title="Link to this heading">¶</a></h5>
<p>Un <code class="docutils literal notranslate"><span class="pre">joining_thread</span></code> è un thread che si unisce [joins] alla fine del suo scope. I thread staccati [detached] sono difficili da monitorare. È più difficile garantire l’assenza di errori nei thread staccati [detached] (e nei thread potenzialmente detached).</p>
</section>
<section id="id1286">
<h5>Esempio, cattivo<a class="headerlink" href="#id1286" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f() { std::cout &lt;&lt; &quot;Hello &quot;; }

struct F {
    void operator()() const { std::cout &lt;&lt; &quot;parallel world &quot;; }
};

int main()
{
    std::thread t1{f};      // f() executes in separate thread
    std::thread t2{F()};    // F()() executes in separate thread
}  // spot the bugs
</pre></div>
</div>
</section>
<section id="id1287">
<h5>Esempio<a class="headerlink" href="#id1287" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f() { std::cout &lt;&lt; &quot;Hello &quot;; }

struct F {
    void operator()() const { std::cout &lt;&lt; &quot;parallel world &quot;; }
};

int main()
{
    std::thread t1{f};      // f() executes in separate thread
    std::thread t2{F()};    // F()() executes in separate thread

    t1.join();
    t2.join();
}  // one bad bug left
</pre></div>
</div>
</section>
<section id="id1288">
<h5>Nota<a class="headerlink" href="#id1288" title="Link to this heading">¶</a></h5>
<p>Creare i «thread immortali» globali, racchiuderli in uno scope, o sull’heap [free store] anziché eseguire il <code class="docutils literal notranslate"><span class="pre">detach()</span></code>. <a class="reference internal" href="#Rconc-detached_thread"><span class="xref myst">Non eseguire il <code class="docutils literal notranslate"><span class="pre">detach</span></code></span></a>.</p>
</section>
<section id="id1289">
<h5>Nota<a class="headerlink" href="#id1289" title="Link to this heading">¶</a></h5>
<p>A causa del vecchio codice e delle librerie di terze parti che usano <code class="docutils literal notranslate"><span class="pre">std::thread</span></code>, questa regola può essere difficile da applicare.</p>
</section>
<section id="id1290">
<h5>Imposizione<a class="headerlink" href="#id1290" title="Link to this heading">¶</a></h5>
<p>Segnalare l’uso di <code class="docutils literal notranslate"><span class="pre">std::thread</span></code>:</p>
<ul class="simple">
<li><p>Suggerire l’utilizzo di <code class="docutils literal notranslate"><span class="pre">gsl::joining_thread</span></code> o <code class="docutils literal notranslate"><span class="pre">std::jthread</span></code> nel C++20.</p></li>
<li><p>Suggerire <a class="reference internal" href="#Rconc-detached_thread"><span class="xref myst">«l’esportazione della proprietà [exporting ownership]»</span></a> in uno scope circoscritto se si esegue il detach.</p></li>
<li><p>Segnalare se non è chiaro se si esegue il join o il detach di un thread.</p></li>
</ul>
</section>
</section>
<section id="cp-26-don-t-detach-a-thread">
<h4><a name="Rconc-detached_thread"></a>CP.26: Non eseguire il <code class="docutils literal notranslate"><span class="pre">detach()</span></code> di un thread<a class="headerlink" href="#cp-26-don-t-detach-a-thread" title="Link to this heading">¶</a></h4>
<section id="id1291">
<h5>Motivo<a class="headerlink" href="#id1291" title="Link to this heading">¶</a></h5>
<p>Spesso, la necessità di sopravvivere allo scope della propria creazione, riguarda l’attività dei <code class="docutils literal notranslate"><span class="pre">thread</span></code>, ma implementare quell’idea con <code class="docutils literal notranslate"><span class="pre">detach</span></code> rende più difficile monitorare e comunicare con il thread detached. In particolare, è più difficile (anche se non impossibile) garantire che il thread sia completato come previsto o che duri per il tempo previsto.</p>
</section>
<section id="id1292">
<h5>Esempio<a class="headerlink" href="#id1292" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void heartbeat();

void use()
{
    std::thread t(heartbeat);             // don&#39;t join; heartbeat is meant to run forever
    t.detach();
    // ...
}
</pre></div>
</div>
<p>Questo è un ragionevole uso di un thread, per cui solitamente si usa il <code class="docutils literal notranslate"><span class="pre">detach()</span></code>. Ci sono comunque dei problemi. Come si può monitorare un thread detached per vedere se è in esecuzione? Qualcosa potrebbe andare storto con heartbeat, e perdere un heartbeat può essere molto grave in un sistema per il quale è necessario. Quindi, è necessario comunicare col thread heartbeat (p.es., tramite uno stream di messaggi o eventi di notifica utilizzando una <code class="docutils literal notranslate"><span class="pre">condition_variable</span></code>).</p>
<p>Una alternativa, e solitamente una soluzione migliore, consiste nel controllarne la durata ponendolo in uno scope al di fuori del suo punto di creazione (o attivazione). Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void heartbeat();

gsl::joining_thread t(heartbeat);             // heartbeat is meant to run &quot;forever&quot;
</pre></div>
</div>
<p>Questo heartbeat funzionerà (eccetto che per un errore, problemi hardware, ecc.) finché durerà il programma.</p>
<p>Talvolta, si deve separare il punto di creazione dal punto della proprietà [ownership]:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void heartbeat();

unique_ptr&lt;gsl::joining_thread&gt; tick_tock {nullptr};

void use()
{
    // heartbeat is meant to run as long as tick_tock lives
    tick_tock = make_unique&lt;gsl::joining_thread&gt;(heartbeat);
    // ...
}
</pre></div>
</div>
</section>
<section id="id1293">
<h5>Imposizione<a class="headerlink" href="#id1293" title="Link to this heading">¶</a></h5>
<p>Segnalare i <code class="docutils literal notranslate"><span class="pre">detach()</span></code>.</p>
</section>
</section>
<section id="cp-31-pass-small-amounts-of-data-between-threads-by-value-rather-than-by-reference-or-pointer">
<h4><a name="Rconc-data-by-value"></a>CP.31: Passare una piccola quantità di dati tra i thread per valore, anziché per riferimento o puntatore<a class="headerlink" href="#cp-31-pass-small-amounts-of-data-between-threads-by-value-rather-than-by-reference-or-pointer" title="Link to this heading">¶</a></h4>
<section id="id1294">
<h5>Motivo<a class="headerlink" href="#id1294" title="Link to this heading">¶</a></h5>
<p>Una piccola quantità di dati è più economica da copiare e da accedervi rispetto alla condivisione mediante un meccanismo di locking. La copia offre naturalmente una proprietà [ownership] esclusiva (semplifica il codice) ed elimina la possibilità di conflitti.</p>
</section>
<section id="id1295">
<h5>Nota<a class="headerlink" href="#id1295" title="Link to this heading">¶</a></h5>
<p>Definire esattamente «piccola quantità» è impossibile.</p>
</section>
<section id="id1296">
<h5>Esempio<a class="headerlink" href="#id1296" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>string modify1(string);
void modify2(string&amp;);

void fct(string&amp; s)
{
    auto res = async(modify1, s);
    async(modify2, s);
}
</pre></div>
</div>
<p>La chiamata a <code class="docutils literal notranslate"><span class="pre">modify1</span></code> implica la copia di due valori <code class="docutils literal notranslate"><span class="pre">string</span></code>; la chiamata a <code class="docutils literal notranslate"><span class="pre">modify2</span></code> no. D’altra parte, l’implementazione di <code class="docutils literal notranslate"><span class="pre">modify1</span></code> è esattamente come la si avrebbe scritta per il codice single-thread, mentre l’implementazione di <code class="docutils literal notranslate"><span class="pre">modify2</span></code> necessiterà di una forma di lock per evitare conflitti. Se la stringa è breve (diciamo 10 caratteri), la chiamata a <code class="docutils literal notranslate"><span class="pre">modify1</span></code> può risultare sorprendentemente veloce; essenzialmente tutto il costo è nello scambio [switch] del <code class="docutils literal notranslate"><span class="pre">thread</span></code>. Se la stringa è lunga (diciamo 1,000,000 di caratteri), copiarla due volte non è una buona idea.</p>
<p>Si noti che questo argomento non ha nulla a che fare con <code class="docutils literal notranslate"><span class="pre">async</span></code> in quanto tale. Si applica ugualmente alle considerazioni sull’opportunità di utilizzare il passaggio dei messaggi o la memoria condivisa.</p>
</section>
<section id="id1297">
<h5>Imposizione<a class="headerlink" href="#id1297" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="cp-32-to-share-ownership-between-unrelated-threads-use-shared-ptr">
<h4><a name="Rconc-shared"></a>CP.32: Per condividere la proprietà [ownership] tra <code class="docutils literal notranslate"><span class="pre">thread</span></code> non correlati, usare gli <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code><a class="headerlink" href="#cp-32-to-share-ownership-between-unrelated-threads-use-shared-ptr" title="Link to this heading">¶</a></h4>
<section id="id1298">
<h5>Motivo<a class="headerlink" href="#id1298" title="Link to this heading">¶</a></h5>
<p>Se i thread non sono correlati (ovvero, non si sa se stanno nello stesso scope o uno nella durata dell’altro) e devono condividere la stessa memoria sull’heap [free store] da cancellare, uno <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> (o equivalente) è il solo modo sicuro per garantire il corretto “delete”.</p>
</section>
<section id="id1299">
<h5>Esempio<a class="headerlink" href="#id1299" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1300">
<h5>Nota<a class="headerlink" href="#id1300" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Un oggetto statico (p.es. un globale) si può condividere perché non è posseduto nel senso che qualche thread è responsabile della sua cancellazione.</p></li>
<li><p>Un oggetto nel [free store] che non viene mail cancellato può essere condiviso.</p></li>
<li><p>Un oggetto posseduto [owned] da un thread può essere condiviso in modo sicuro con un altro purché questo secondo thread non sopravviva al proprietario.</p></li>
</ul>
</section>
<section id="id1301">
<h5>Imposizione<a class="headerlink" href="#id1301" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="cp-40-minimize-context-switching">
<h4><a name="Rconc-switch"></a>CP.40: Minimizzare il [context switching]<a class="headerlink" href="#cp-40-minimize-context-switching" title="Link to this heading">¶</a></h4>
<section id="id1302">
<h5>Motivo<a class="headerlink" href="#id1302" title="Link to this heading">¶</a></h5>
<p>I [context switch] sono costosi.</p>
</section>
<section id="id1303">
<h5>Esempio<a class="headerlink" href="#id1303" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1304">
<h5>Imposizione<a class="headerlink" href="#id1304" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="cp-41-minimize-thread-creation-and-destruction">
<h4><a name="Rconc-create"></a>CP.41: Minimizzare la creazione e la distruzione del thread<a class="headerlink" href="#cp-41-minimize-thread-creation-and-destruction" title="Link to this heading">¶</a></h4>
<section id="id1305">
<h5>Motivo<a class="headerlink" href="#id1305" title="Link to this heading">¶</a></h5>
<p>La creazione del thread è costosa.</p>
</section>
<section id="id1306">
<h5>Esempio<a class="headerlink" href="#id1306" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void worker(Message m)
{
    // process
}

void dispatcher(istream&amp; is)
{
    for (Message m; is &gt;&gt; m; )
        run_list.push_back(new thread(worker, m));
}
</pre></div>
</div>
<p>Ciò genera un <code class="docutils literal notranslate"><span class="pre">thread</span></code> per ogni messaggio, e la <code class="docutils literal notranslate"><span class="pre">run_list</span></code> è presumibilmente fatta per distruggere quei task una volta completati.</p>
<p>Invece, si potrebbe avere una serie di thread di lavoro pre-creati che elaborano i messaggi</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Sync_queue&lt;Message&gt; work;

void dispatcher(istream&amp; is)
{
    for (Message m; is &gt;&gt; m; )
        work.put(m);
}

void worker()
{
    for (Message m; m = work.get(); ) {
        // process
    }
}

void workers()  // set up worker threads (specifically 4 worker threads)
{
    joining_thread w1 {worker};
    joining_thread w2 {worker};
    joining_thread w3 {worker};
    joining_thread w4 {worker};
}
</pre></div>
</div>
</section>
<section id="id1307">
<h5>Nota<a class="headerlink" href="#id1307" title="Link to this heading">¶</a></h5>
<p>Se il proprio sistema ha un buon [thread pool], lo si usi. Se il proprio sistema ha una buona [message queue], la si usi.</p>
</section>
<section id="id1308">
<h5>Imposizione<a class="headerlink" href="#id1308" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="cp-42-don-t-wait-without-a-condition">
<h4><a name="Rconc-wait"></a>CP.42: Non eseguire un <code class="docutils literal notranslate"><span class="pre">wait</span></code> senza una condizione<a class="headerlink" href="#cp-42-don-t-wait-without-a-condition" title="Link to this heading">¶</a></h4>
<section id="id1309">
<h5>Motivo<a class="headerlink" href="#id1309" title="Link to this heading">¶</a></h5>
<p>Un <code class="docutils literal notranslate"><span class="pre">wait</span></code> senza una condizione può perdere un [wakeup] o svegliarsi semplicemente per scoprire che non ha nulla da fare.</p>
</section>
<section id="id1310">
<h5>Esempio, cattivo<a class="headerlink" href="#id1310" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>std::condition_variable cv;
std::mutex mx;

void thread1()
{
    while (true) {
        // do some work ...
        std::unique_lock&lt;std::mutex&gt; lock(mx);
        cv.notify_one();    // wake other thread
    }
}

void thread2()
{
    while (true) {
        std::unique_lock&lt;std::mutex&gt; lock(mx);
        cv.wait(lock);    // might block forever
        // do work ...
    }
}
</pre></div>
</div>
<p>Qui, se qualche altro <code class="docutils literal notranslate"><span class="pre">thread</span></code> “consuma” la notifica di <code class="docutils literal notranslate"><span class="pre">thread1</span></code>, il <code class="docutils literal notranslate"><span class="pre">thread2</span></code> potrebbe aspettare per sempre.</p>
</section>
<section id="id1311">
<h5>Esempio<a class="headerlink" href="#id1311" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
class Sync_queue {
public:
    void put(const T&amp; val);
    void put(T&amp;&amp; val);
    void get(T&amp; val);
private:
    mutex mtx;
    condition_variable cond;    // this controls access
    list&lt;T&gt; q;
};

template&lt;typename T&gt;
void Sync_queue&lt;T&gt;::put(const T&amp; val)
{
    lock_guard&lt;mutex&gt; lck(mtx);
    q.push_back(val);
    cond.notify_one();
}

template&lt;typename T&gt;
void Sync_queue&lt;T&gt;::get(T&amp; val)
{
    unique_lock&lt;mutex&gt; lck(mtx);
    cond.wait(lck, [this] { return !q.empty(); });    // prevent spurious wakeup
    val = q.front();
    q.pop_front();
}
</pre></div>
</div>
<p>Ora se la coda è vuota quando un thread esegue <code class="docutils literal notranslate"><span class="pre">get()</span></code> si attiva (p.es., perché un altro thread ha eseguito un <code class="docutils literal notranslate"><span class="pre">get()</span></code> prima di lui), e si disattiverà immediatamente, aspettando.</p>
</section>
<section id="id1312">
<h5>Imposizione<a class="headerlink" href="#id1312" title="Link to this heading">¶</a></h5>
<p>Segnalare tutti i <code class="docutils literal notranslate"><span class="pre">wait</span></code> senza condizioni.</p>
</section>
</section>
<section id="cp-43-minimize-time-spent-in-a-critical-section">
<h4><a name="Rconc-time"></a>CP.43: Minimizzare il tempo trascorso nella sezione critica<a class="headerlink" href="#cp-43-minimize-time-spent-in-a-critical-section" title="Link to this heading">¶</a></h4>
<section id="id1313">
<h5>Motivo<a class="headerlink" href="#id1313" title="Link to this heading">¶</a></h5>
<p>Meno tempo si passa per un <code class="docutils literal notranslate"><span class="pre">mutex</span></code> preso, minore è la possibilità che un altro <code class="docutils literal notranslate"><span class="pre">thread</span></code> debba aspettare, dato che le sospensioni e le riprese dei <code class="docutils literal notranslate"><span class="pre">thread</span></code> sono costose.</p>
</section>
<section id="id1314">
<h5>Esempio<a class="headerlink" href="#id1314" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void do_something() // bad
{
    unique_lock&lt;mutex&gt; lck(my_lock);
    do0();  // preparation: does not need lock
    do1();  // transaction: needs locking
    do2();  // cleanup: does not need locking
}
</pre></div>
</div>
<p>Qui, si tiene il lock per più tempo del necessario: Non si avrebbe dovuto tenere il lock prima di averne bisogno e lo si doveva rilasciare prima di iniziare la pulizia. Lo si può riscrivere in questo modo</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void do_something() // bad
{
    do0();  // preparation: does not need lock
    my_lock.lock();
    do1();  // transaction: needs locking
    my_lock.unlock();
    do2();  // cleanup: does not need locking
}
</pre></div>
</div>
<p>Ma ciò compromette la sicurezza e viola la regola di <a class="reference internal" href="#Rconc-raii"><span class="xref myst">usare il RAII</span></a> rule. Si aggiunga, invece, un blocco per la sezione critica:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void do_something() // OK
{
    do0();  // preparation: does not need lock
    {
        unique_lock&lt;mutex&gt; lck(my_lock);
        do1();  // transaction: needs locking
    }
    do2();  // cleanup: does not need locking
}
</pre></div>
</div>
</section>
<section id="id1315">
<h5>Imposizione<a class="headerlink" href="#id1315" title="Link to this heading">¶</a></h5>
<p>Impossibile in generale. Segnalare i <code class="docutils literal notranslate"><span class="pre">lock()</span></code> e gli <code class="docutils literal notranslate"><span class="pre">unlock()</span></code> «[naked]».</p>
</section>
</section>
<section id="cp-44-remember-to-name-your-lock-guards-and-unique-locks">
<h4><a name="Rconc-name"></a>CP.44: Ricordarsi di dare un nome ai <code class="docutils literal notranslate"><span class="pre">lock_guard</span></code> e agli <code class="docutils literal notranslate"><span class="pre">unique_lock</span></code>s<a class="headerlink" href="#cp-44-remember-to-name-your-lock-guards-and-unique-locks" title="Link to this heading">¶</a></h4>
<section id="id1316">
<h5>Motivo<a class="headerlink" href="#id1316" title="Link to this heading">¶</a></h5>
<p>Un oggetto locale anonimo è un oggetto temporaneo che esce immediatamente dallo scope.</p>
</section>
<section id="id1317">
<h5>Esempio<a class="headerlink" href="#id1317" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// global mutexes
mutex m1;
mutex m2;

void f()
{
    unique_lock&lt;mutex&gt;(m1); // (A)
    lock_guard&lt;mutex&gt; {m2}; // (B)
    // do work in critical section ...
}
</pre></div>
</div>
<p>Questo sembra abbastanza innocente, ma non lo è. In (A), <code class="docutils literal notranslate"><span class="pre">m1</span></code> è un locale costruito dal default <code class="docutils literal notranslate"><span class="pre">unique_lock</span></code>, che nasconde il globale <code class="docutils literal notranslate"><span class="pre">::m1</span></code> (e non lo blocca). In (B) un temporaneo anonimo <code class="docutils literal notranslate"><span class="pre">lock_guard</span></code> viene costruito e “locca”<code class="docutils literal notranslate"><span class="pre">::m2</span></code>, ma esce subito dallo scope e sblocca nuovamente <code class="docutils literal notranslate"><span class="pre">::m2</span></code>. Per il resto della funzione <code class="docutils literal notranslate"><span class="pre">f()</span></code> nessuno dei due mutex è bloccato.</p>
</section>
<section id="id1318">
<h5>Imposizione<a class="headerlink" href="#id1318" title="Link to this heading">¶</a></h5>
<p>Segnalare tutti i <code class="docutils literal notranslate"><span class="pre">lock_guard</span></code> e gli <code class="docutils literal notranslate"><span class="pre">unique_lock</span></code> senza nome.</p>
</section>
</section>
<section id="cp-50-define-a-mutex-together-with-the-data-it-guards-use-synchronized-value-t-where-possible">
<h4><a name="Rconc-mutex"></a>CP.50: Definire un <code class="docutils literal notranslate"><span class="pre">mutex</span></code> assieme ai dati che protegge. Usare <code class="docutils literal notranslate"><span class="pre">synchronized_value&lt;T&gt;</span></code> dove possibile<a class="headerlink" href="#cp-50-define-a-mutex-together-with-the-data-it-guards-use-synchronized-value-t-where-possible" title="Link to this heading">¶</a></h4>
<section id="id1319">
<h5>Motivo<a class="headerlink" href="#id1319" title="Link to this heading">¶</a></h5>
<p>Dovrebbe essere ovvio al lettore che i dati devono essere protetti e si deve sapere come viene fatto. Ciò riduce la possibilità che venga bloccato il mutex sbagliato o che il mutex non venga bloccato.</p>
<p>L’uso di un <code class="docutils literal notranslate"><span class="pre">synchronized_value&lt;T&gt;</span></code> garantisce che i dati abbiano un mutex e che il giusto mutex venga bloccato quando si accede ai dati. Si veda la <a class="reference external" href="http://wg21.link/p0290">WG21 proposal</a> per aggiungere un <code class="docutils literal notranslate"><span class="pre">synchronized_value</span></code> ad una futura TS o revisione dello standard del C++.</p>
</section>
<section id="id1320">
<h5>Esempio<a class="headerlink" href="#id1320" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Record {
    std::mutex m;   // take this mutex before accessing other members
    // ...
};

class MyClass {
    struct DataRecord {
       // ...
    };
    synchronized_value&lt;DataRecord&gt; data; // Protect the data with a mutex
};
</pre></div>
</div>
</section>
<section id="id1321">
<h5>Imposizione<a class="headerlink" href="#id1321" title="Link to this heading">¶</a></h5>
<p>??? Possibile?</p>
</section>
</section>
</section>
<section id="cp-coro-coroutines">
<h3><a name="SScp-coro"></a>CP.coro: Coroutine<a class="headerlink" href="#cp-coro-coroutines" title="Link to this heading">¶</a></h3>
<p>Questa sezione si concentra sugli usi delle coroutine.</p>
<p>Riepilogo delle regole delle Coroutine:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rcoro-capture"><span class="xref myst">CP.51: Non utilizzare lambda [capturing] che sono coroutine</span></a></p></li>
<li><p><a class="reference internal" href="#Rcoro-locks"><span class="xref myst">CP.52: Non mantenere lock o altre primitive di sincronizzazione tra i punti di sospensione</span></a></p></li>
<li><p><a class="reference internal" href="#Rcoro-reference-parameters"><span class="xref myst">CP.53: I parametri non devono essere passati alle coroutine per riferimento</span></a></p></li>
</ul>
<section id="cp-51-do-not-use-capturing-lambdas-that-are-coroutines">
<h4><a name="Rcoro-capture"></a>CP.51: Non utilizzare lambda [capturing] che sono coroutine<a class="headerlink" href="#cp-51-do-not-use-capturing-lambdas-that-are-coroutines" title="Link to this heading">¶</a></h4>
<section id="id1322">
<h5>Motivo<a class="headerlink" href="#id1322" title="Link to this heading">¶</a></h5>
<p>Gli schemi d’uso corretti con le normali lambda sono pericolosi con le lambda coroutine. Lo schema ovvio di cattura delle variabili risulterà accedere alla memoria liberata dopo il primo punto di sospensione, che per i puntatori intelligenti con contatori dei riferimenti e tipi copiabili.</p>
<p>Una lambda si traduce in un oggetto [closure] con uno storage, spesso sullo stack, che ad un certo punto uscirà dallo scope.  Quando l’oggetto [closure] esce dallo scope usciranno anche le acquisizioni [captures].  Le normali lambda a questo punto hanno terminato l’esecuzione, quindi non è un problema.  Le lambda coroutine possono riprendere da una sospensione dopo che l’oggetto [closure] è stato distrutto e a quel punto tutte le acquisizioni [captures] accederanno alla memoria dopo-che-è-stata-liberata.</p>
</section>
<section id="id1323">
<h5>Esempio, Cattivo<a class="headerlink" href="#id1323" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int value = get_value();
std::shared_ptr&lt;Foo&gt; sharedFoo = get_foo();
{
  const auto lambda = [value, sharedFoo]() -&gt; std::future&lt;void&gt;
  {
    co_await something();
    // &quot;sharedFoo&quot; and &quot;value&quot; have already been destroyed
    // the &quot;shared&quot; pointer didn&#39;t accomplish anything
  };
  lambda();
} // the lambda closure object has now gone out of scope
</pre></div>
</div>
</section>
<section id="example-better">
<h5>Esempio, Migliore<a class="headerlink" href="#example-better" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int value = get_value();
std::shared_ptr&lt;Foo&gt; sharedFoo = get_foo();
{
  // take as by-value parameter instead of as a capture
  const auto lambda = [](auto sharedFoo, auto value) -&gt; std::future&lt;void&gt;
  {
    co_await something();
    // sharedFoo and value are still valid at this point
  };
  lambda(sharedFoo, value);
} // the lambda closure object has now gone out of scope
</pre></div>
</div>
</section>
<section id="example-best">
<h5>Esempio, Ottimale<a class="headerlink" href="#example-best" title="Link to this heading">¶</a></h5>
<p>Usa una funzione per le coroutine.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>std::future&lt;void&gt; Class::do_something(int value, std::shared_ptr&lt;Foo&gt; sharedFoo)
{
  co_await something();
  // sharedFoo and value are still valid at this point
}

void SomeOtherFunction()
{
  int value = get_value();
  std::shared_ptr&lt;Foo&gt; sharedFoo = get_foo();
  do_something(value, sharedFoo);
}
</pre></div>
</div>
</section>
<section id="id1324">
<h5>Imposizione<a class="headerlink" href="#id1324" title="Link to this heading">¶</a></h5>
<p>Segnalare una lambda che è coroutine ed ha una lista capture non vuota.</p>
</section>
</section>
<section id="cp-52-do-not-hold-locks-or-other-synchronization-primitives-across-suspension-points">
<h4><a name="Rcoro-locks"></a>CP.52: Non mantenere lock o altre primitive di sincronizzazione tra i punti di sospensione<a class="headerlink" href="#cp-52-do-not-hold-locks-or-other-synchronization-primitives-across-suspension-points" title="Link to this heading">¶</a></h4>
<section id="id1325">
<h5>Motivo<a class="headerlink" href="#id1325" title="Link to this heading">¶</a></h5>
<p>Questo schema crea un significativo rischio di deadlock.  Alcuni tipi di attese [wait] consentiranno al thread corrente di eseguire ulteriori operazioni fino al completamento dell’operazione asincrona. Se il thread che contiene il lock esegue un lavoro che richiede lo stesso lock, si verificherà un deadlock perché si sta tentando di acquisire un blocco che già si possiede.</p>
<p>Se lil completamento della coroutine avviene su un thread diverso dal quello che ha acquisito il lock, si avrà un comportamento indefinito.  Anche con l’esplicito ritorno al thread originale ci potrebbe essere la generazione di un’eccezione prima del ripristino della coroutine e il risultato sarà che la protezione del lock non viene distrutta.</p>
</section>
<section id="id1326">
<h5>Esempio, Cattivo<a class="headerlink" href="#id1326" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>std::mutex g_lock;

std::future&lt;void&gt; Class::do_something()
{
    std::lock_guard&lt;std::mutex&gt; guard(g_lock);
    co_await something(); // DANGER: coroutine has suspended execution while holding a lock
    co_await somethingElse();
}
</pre></div>
</div>
</section>
<section id="id1327">
<h5>Esempio, Buono<a class="headerlink" href="#id1327" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>std::mutex g_lock;

std::future&lt;void&gt; Class::do_something()
{
    {
        std::lock_guard&lt;std::mutex&gt; guard(g_lock);
        // modify data protected by lock
    }
    co_await something(); // OK: lock has been released before coroutine suspends
    co_await somethingElse();
}
</pre></div>
</div>
</section>
<section id="id1328">
<h5>Nota<a class="headerlink" href="#id1328" title="Link to this heading">¶</a></h5>
<p>Questo schema è negativo anche per le prestazioni. Quando viene raggiunto un punto di sospensione, ad esempio co_await, l’esecuzione della funzione corrente si interrompe e inizia l’esecuzione di un altro codice. Potrebbe trascorrere molto tempo prima che la coroutine riprenda. Per tutto il tempo verrà mantenuto il lock e non potrà essere acquisito da altri thread per eseguire il lavoro.</p>
</section>
<section id="id1329">
<h5>Imposizione<a class="headerlink" href="#id1329" title="Link to this heading">¶</a></h5>
<p>Segnalare tutte le protezione con lock che non vengono distrutte prima della sospensione di una coroutine.</p>
</section>
</section>
<section id="cp-53-parameters-to-coroutines-should-not-be-passed-by-reference">
<h4><a name="Rcoro-reference-parameters"></a>CP.53: I parametri non devono essere passati alle coroutine per riferimento<a class="headerlink" href="#cp-53-parameters-to-coroutines-should-not-be-passed-by-reference" title="Link to this heading">¶</a></h4>
<section id="id1330">
<h5>Motivo<a class="headerlink" href="#id1330" title="Link to this heading">¶</a></h5>
<p>Una volta che una coroutine raggiunge il primo punto di sospensione, ad esempio un co_await, torna la porzione sincrona. Dopo di che, tutti i parametri passati per riferimento restano appesi. Qualsiasi utilizzo oltre a questo punto avrà un comportamento indefinito che può includere la scrittura in una memoria appena liberata.ì</p>
</section>
<section id="id1331">
<h5>Esempio, Cattivo<a class="headerlink" href="#id1331" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>std::future&lt;int&gt; Class::do_something(const std::shared_ptr&lt;int&gt;&amp; input)
{
    co_await something();

    // DANGER: the reference to input may no longer be valid and may be freed memory
    co_return *input + 1;
}
</pre></div>
</div>
</section>
<section id="id1332">
<h5>Esempio, Buono<a class="headerlink" href="#id1332" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>std::future&lt;int&gt; Class::do_something(std::shared_ptr&lt;int&gt; input)
{
    co_await something();
    co_return *input + 1; // input is a copy that is still valid here
}
</pre></div>
</div>
</section>
<section id="id1333">
<h5>Nota<a class="headerlink" href="#id1333" title="Link to this heading">¶</a></h5>
<p>Questo problema non si ha con ii parametri di riferimento a cui si accede solamente prima del primo punto di sospensione. Delle successive modifiche alla function possono aggiungere o spostare punti di sospensione che potrebbero re-introdurre questa classe di bug. Alcuni tipi di coroutine hanno il punto di sospensione prima dell’esecuzione della prima riga di codice nella coroutine, nel qual caso i parametri di riferimento sono sempre insicuri.  È più sicuro passare sempre per valore perché il parametro copiato risiederà nel frame della coroutine a cui è sicuro accedere in tutta la coroutine.</p>
</section>
<section id="id1334">
<h5>Nota<a class="headerlink" href="#id1334" title="Link to this heading">¶</a></h5>
<p>Lo stesso pericolo si applica ai parametri di output.  <a class="reference internal" href="#Rf-out"><span class="xref myst">F.20: Per i valori «out» di output, preferendo valori di ritorno ai parametri di output</span></a> si scoraggiano i parametri di output.  Le coroutines dovrebbero evitarle del tutto.</p>
</section>
<section id="id1335">
<h5>Imposizione<a class="headerlink" href="#id1335" title="Link to this heading">¶</a></h5>
<p>Segnalare tutti i parametri di riferimenti a una coroutine.</p>
</section>
</section>
</section>
<section id="cp-par-parallelism">
<h3><a name="SScp-par"></a>CP.par: Parallelismo<a class="headerlink" href="#cp-par-parallelism" title="Link to this heading">¶</a></h3>
<p>Con «parallelismo» ci si riferisce all’esecuzione di un’attività (più o meno) simultaneamente («in parallelo con») ad altri elementi di dati.</p>
<p>Riepilogo delle regole sul parallelismo:</p>
<ul class="simple">
<li><p>???</p></li>
<li><p>???</p></li>
<li><p>Laddove è appropriato, preferire gli algoritmi paralleli della libreria standard</p></li>
<li><p>Usare gli algoritmi progettati per il parallelismo, non quelli con una dipendenza non necessaria dalla valutazione lineare</p></li>
</ul>
</section>
<section id="cp-mess-message-passing">
<h3><a name="SScp-mess"></a>CP.mess: Passaggio dei messaggi<a class="headerlink" href="#cp-mess-message-passing" title="Link to this heading">¶</a></h3>
<p>Le funzioni della libreria standard sono a livello piuttosto basso, focalizzate sulle necessità vicine alla programmazione critica dell’hardware utilizzando i <code class="docutils literal notranslate"><span class="pre">thread</span></code>, i <code class="docutils literal notranslate"><span class="pre">mutex</span></code>, i tipi <code class="docutils literal notranslate"><span class="pre">atomic</span></code>, ecc. La maggior parte delle persone non dovrebbe lavorare a questo livello: è soggetto a errori e lo sviluppo è lento. Se possibile usare funzioni a più alto livello: librerie di [messaging], algoritmi paralleli e vettorizzazione. Questa sezione tratta il passaggio dei messaggi in modo che un programmatore non debba eseguire la sincronizzazione esplicita.</p>
<p>Riepilogo delle regole sul passaggio dei messaggi:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rconc-future"><span class="xref myst">CP.60: Usare un <code class="docutils literal notranslate"><span class="pre">future</span></code> per restituire un valore da un task concorrente</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-async"><span class="xref myst">CP.61: Usare <code class="docutils literal notranslate"><span class="pre">async()</span></code> per generare [spawn] un task concorrente</span></a></p></li>
<li><p>code di messaggi [message queues]</p></li>
<li><p>Librerie di [messaging]</p></li>
</ul>
<p>???? dovrebbe esserci un «usa X anziché <code class="docutils literal notranslate"><span class="pre">std::async</span></code>» dove X è qualcosa che userebbe un thread pool meglio specificato?</p>
<p>??? Vale la pena di usare <code class="docutils literal notranslate"><span class="pre">std::async</span></code> alla luce delle future (e già esistenti come librerie) funzioni di parallelismo? Cosa dovrebbero raccomandare le linee-guida se qualcuno vuole parallelizzare, ad esempio, <code class="docutils literal notranslate"><span class="pre">std::accumulate</span></code> (con l’ulteriore precondizione della commutatività), o il «merge sort»?</p>
<section id="cp-60-use-a-future-to-return-a-value-from-a-concurrent-task">
<h4><a name="Rconc-future"></a>CP.60: Usare un <code class="docutils literal notranslate"><span class="pre">future</span></code> per restituire un valore da un task concorrente<a class="headerlink" href="#cp-60-use-a-future-to-return-a-value-from-a-concurrent-task" title="Link to this heading">¶</a></h4>
<section id="id1336">
<h5>Motivo<a class="headerlink" href="#id1336" title="Link to this heading">¶</a></h5>
<p>Un <code class="docutils literal notranslate"><span class="pre">future</span></code> preserva la solita semantica del return da una chiamata a una funzione per i task asincroni. Non c’è un lock esplicito e vengono gestiti semplicemente sia il corretto (valore) di ritorno che l’errore (eccezione) restituito.</p>
</section>
<section id="id1337">
<h5>Esempio<a class="headerlink" href="#id1337" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1338">
<h5>Nota<a class="headerlink" href="#id1338" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
<section id="id1339">
<h5>Imposizione<a class="headerlink" href="#id1339" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="cp-61-use-async-to-spawn-concurrent-tasks">
<h4><a name="Rconc-async"></a>CP.61: Usare <code class="docutils literal notranslate"><span class="pre">async()</span></code> per generare [spawn] un task concorrente<a class="headerlink" href="#cp-61-use-async-to-spawn-concurrent-tasks" title="Link to this heading">¶</a></h4>
<section id="id1340">
<h5>Motivo<a class="headerlink" href="#id1340" title="Link to this heading">¶</a></h5>
<p>Simile alla <a class="reference internal" href="#Rr-immediate-alloc"><span class="xref myst">R.12</span></a>, che dice di evitare i puntatori semplici proprietari, si dovrebbero anche evitare i thread semplici [raw] e le [promise] dove possibile. Utilizzare una funzione factory come <code class="docutils literal notranslate"><span class="pre">std::async</span></code>, che gestisce la generazione o il riutilizzo di un thread senza esporre i thread semplici [raw] al proprio codice.</p>
</section>
<section id="id1341">
<h5>Esempio<a class="headerlink" href="#id1341" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int read_value(const std::string&amp; filename)
{
    std::ifstream in(filename);
    in.exceptions(std::ifstream::failbit);
    int value;
    in &gt;&gt; value;
    return value;
}

void async_example()
{
    try {
        std::future&lt;int&gt; f1 = std::async(read_value, &quot;v1.txt&quot;);
        std::future&lt;int&gt; f2 = std::async(read_value, &quot;v2.txt&quot;);
        std::cout &lt;&lt; f1.get() + f2.get() &lt;&lt; &#39;\n&#39;;
    } catch (const std::ios_base::failure&amp; fail) {
        // handle exception here
    }
}
</pre></div>
</div>
</section>
<section id="id1342">
<h5>Nota<a class="headerlink" href="#id1342" title="Link to this heading">¶</a></h5>
<p>Sfortunatamente, <code class="docutils literal notranslate"><span class="pre">std::async</span></code> non è perfetto. Per esempio, non usa un pool di thread, il che significa che potrebbe non riuscire a causa dell’esaurimento delle risorse, anziché accodare i task da utilizzare in seguito. Tuttavia, anche se non puoi usare <code class="docutils literal notranslate"><span class="pre">std::async</span></code>, si dovrebbe preferire la scrittura di una propria funzione factory  <code class="docutils literal notranslate"><span class="pre">future</span></code>-returning, anziché usare le [raw promise].</p>
</section>
<section id="id1343">
<h5>Esempio (cattivo)<a class="headerlink" href="#id1343" title="Link to this heading">¶</a></h5>
<p>Questo esempio mostra due modi diversi per usare <code class="docutils literal notranslate"><span class="pre">std::future</span></code>, ma falliscono nell’evitare la gestione di <code class="docutils literal notranslate"><span class="pre">std::thread</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void async_example()
{
    std::promise&lt;int&gt; p1;
    std::future&lt;int&gt; f1 = p1.get_future();
    std::thread t1([p1 = std::move(p1)]() mutable {
        p1.set_value(read_value(&quot;v1.txt&quot;));
    });
    t1.detach(); // evil

    std::packaged_task&lt;int()&gt; pt2(read_value, &quot;v2.txt&quot;);
    std::future&lt;int&gt; f2 = pt2.get_future();
    std::thread(std::move(pt2)).detach();

    std::cout &lt;&lt; f1.get() + f2.get() &lt;&lt; &#39;\n&#39;;
}
</pre></div>
</div>
</section>
<section id="id1344">
<h5>Esempio (buono)<a class="headerlink" href="#id1344" title="Link to this heading">¶</a></h5>
<p>Questo esempio mostra un modo con cui è possibile seguire seguire lo schema generale impostato da <code class="docutils literal notranslate"><span class="pre">std::async</span></code>, in un contesto in cui lo stesso <code class="docutils literal notranslate"><span class="pre">std::async</span></code> era inaccettabile per andare in produzione.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void async_example(WorkQueue&amp; wq)
{
    std::future&lt;int&gt; f1 = wq.enqueue([]() {
        return read_value(&quot;v1.txt&quot;);
    });
    std::future&lt;int&gt; f2 = wq.enqueue([]() {
        return read_value(&quot;v2.txt&quot;);
    });
    std::cout &lt;&lt; f1.get() + f2.get() &lt;&lt; &#39;\n&#39;;
}
</pre></div>
</div>
<p>Ogni  thread generato per eseguire il codice di <code class="docutils literal notranslate"><span class="pre">read_value</span></code> viene nascosto dietro la chiamata <code class="docutils literal notranslate"><span class="pre">WorkQueue::enqueue</span></code>. Il codice utente si occupa solo degli oggetti <code class="docutils literal notranslate"><span class="pre">future</span></code>, mai con <code class="docutils literal notranslate"><span class="pre">thread</span></code>, <code class="docutils literal notranslate"><span class="pre">promise</span></code> o oggetti <code class="docutils literal notranslate"><span class="pre">packaged_task</span></code>.</p>
</section>
<section id="id1345">
<h5>Imposizione<a class="headerlink" href="#id1345" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
</section>
<section id="cp-vec-vectorization">
<h3><a name="SScp-vec"></a>CP.vec: Vettorizzazione<a class="headerlink" href="#cp-vec-vectorization" title="Link to this heading">¶</a></h3>
<p>La vettorizzazione è una tecnica per eseguire una serie di attività contemporaneamente senza introdurre una sincronizzazione esplicita. Un’operazione viene semplicemente applicata in parallelo agli elementi di una struttura dati (un vettore, un array, ecc.). La vettorizzazione ha la proprietà interessante che spesso non richiede modifiche non locali a un programma. Tuttavia, la vettorizzazione funziona meglio con strutture dati semplici e con algoritmi appositamente creati per abilitarlo.</p>
<p>Riepilogo delle regole sulla vettorizzazione:</p>
<ul class="simple">
<li><p>???</p></li>
<li><p>???</p></li>
</ul>
</section>
<section id="cp-free-lock-free-programming">
<h3><a name="SScp-free"></a>CP.free: Programmazione senza lock<a class="headerlink" href="#cp-free-lock-free-programming" title="Link to this heading">¶</a></h3>
<p>La sincronizzazione con i <code class="docutils literal notranslate"><span class="pre">mutex</span></code> e con le <code class="docutils literal notranslate"><span class="pre">condition_variable</span></code> può risultare relativamente costosa. Inoltre, può provocare deadlock. Per le prestazioni e per eliminare la possibilità di deadlock, a volte si devono usare le complicate funzioni a basso-livello «lock-free» che si basano sul rapido accesso esclusivo («atomico») alla memoria. La programmazione lock-free si usa anche per implementare meccanismi di concorrenza a livello più alto come i <code class="docutils literal notranslate"><span class="pre">thread</span></code> e i <code class="docutils literal notranslate"><span class="pre">mutex</span></code>.</p>
<p>Riepilogo delle regole sulla programmazione lock-free:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rconc-lockfree"><span class="xref myst">CP.100: Non utilizzare la programmazione lock-free a meno che non sia assolutamente necessario</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-distrust"><span class="xref myst">CP.101: Diffidare della combinazione hardware/compilatore</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-literature"><span class="xref myst">CP.102: Studiare attentamente la bibliografia</span></a></p></li>
<li><p>come/quando usare l’atomicità</p></li>
<li><p>evitare l’inedia [starvation]</p></li>
<li><p>usare strutture dati lock-free anziché creare specifici accessi lock-free</p></li>
<li><p><a class="reference internal" href="#Rconc-double"><span class="xref myst">CP.110: Non scriversi il proprio «interblocco ricontrollato» [double-checked locking] per l’inizializzazione</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-double-pattern"><span class="xref myst">CP.111: Usare un pattern convenzionale se è veramente necessario il «double-checked locking»</span></a></p></li>
<li><p>come/quando confrontare e scambiare</p></li>
</ul>
<section id="cp-100-don-t-use-lock-free-programming-unless-you-absolutely-have-to">
<h4><a name="Rconc-lockfree"></a>CP.100: Non utilizzare la programmazione lock-free a meno che non sia assolutamente necessario<a class="headerlink" href="#cp-100-don-t-use-lock-free-programming-unless-you-absolutely-have-to" title="Link to this heading">¶</a></h4>
<section id="id1346">
<h5>Motivo<a class="headerlink" href="#id1346" title="Link to this heading">¶</a></h5>
<p>È soggetta a errori e richiede la conoscenza di un esperto delle funzionalità del linguaggio, dell’architettura della macchina e delle strutture dati.</p>
</section>
<section id="id1347">
<h5>Esempio, cattivo<a class="headerlink" href="#id1347" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>extern atomic&lt;Link*&gt; head;        // the shared head of a linked list

Link* nh = new Link(data, nullptr);    // make a link ready for insertion
Link* h = head.load();                 // read the shared head of the list

do {
    if (h-&gt;data &lt;= data) break;        // if so, insert elsewhere
    nh-&gt;next = h;                      // next element is the previous head
} while (!head.compare_exchange_weak(h, nh));    // write nh to head or to h
</pre></div>
</div>
<p>Trovare il bug. Sarebbe davvero difficile da trovare tramite i test. Si legga a proposito di «ABA problem».</p>
</section>
<section id="id1348">
<h5>Eccezione<a class="headerlink" href="#id1348" title="Link to this heading">¶</a></h5>
<p>Le <a class="reference internal" href="#???"><span class="xref myst">variabili atomiche</span></a> possono essere utilizzate in modo semplice e sicuro, purché si utilizzi il modello di memoria coerente sequenzialmente (memory_order_seq_cst), che è il default.</p>
</section>
<section id="id1349">
<h5>Nota<a class="headerlink" href="#id1349" title="Link to this heading">¶</a></h5>
<p>Meccanismi di concorrenza di livello superiore, come i <code class="docutils literal notranslate"><span class="pre">thread</span></code> e i <code class="docutils literal notranslate"><span class="pre">mutex</span></code> vengono implementati con la programmazione lock-free.</p>
<p><strong>Alternativa</strong>: Usare strutture dati lock-free implementate da altri come parti di qualche libreria.</p>
</section>
</section>
<section id="cp-101-distrust-your-hardware-compiler-combination">
<h4><a name="Rconc-distrust"></a>CP.101: Diffidare della combinazione hardware/compilatore<a class="headerlink" href="#cp-101-distrust-your-hardware-compiler-combination" title="Link to this heading">¶</a></h4>
<section id="id1350">
<h5>Motivo<a class="headerlink" href="#id1350" title="Link to this heading">¶</a></h5>
<p>Le interfacce hardware di basso livello utilizzate nella programmazione lock-free sono tra le più difficili da implementare correttamente e tra le aree in cui si verificano i problemi più subdoli sulla portabilità. Se si sta seguendo una programmazione lock-free per le prestazioni, si devono controllare le regressioni.</p>
</section>
<section id="id1351">
<h5>Nota<a class="headerlink" href="#id1351" title="Link to this heading">¶</a></h5>
<p>Il riordino delle istruzioni (statico e dinamico) ci rende difficile pensare in modo efficace a questo livello (specie se si usano modelli di memoria rilassati [relaxed memory models]). L’esperienza, i modelli (semi)formali e il [model checking] possono servire. Il test - spesso in misura estrema - è essenziale. «Non volare troppo vicino al sole».</p>
</section>
<section id="id1352">
<h5>Imposizione<a class="headerlink" href="#id1352" title="Link to this heading">¶</a></h5>
<p>Ci sono regole rigide per i test che coprono qualsiasi cambiamento nell’hardware, nel sistema operativo, nel compilatore e nelle librerie.</p>
</section>
</section>
<section id="cp-102-carefully-study-the-literature">
<h4><a name="Rconc-literature"></a>CP.102: Studiare attentamente la bibliografia<a class="headerlink" href="#cp-102-carefully-study-the-literature" title="Link to this heading">¶</a></h4>
<section id="id1353">
<h5>Motivo<a class="headerlink" href="#id1353" title="Link to this heading">¶</a></h5>
<p>Ad eccezione di quelli atomici e di alcuni altri pattern standard, la programmazione senza lock «lock-free» è veramente un argomento per soli esperti. Si deve diventare esperti prima di cimentarsi in codice lock-free utilizzabile da altri.</p>
</section>
<section id="references">
<h5>Riferimenti<a class="headerlink" href="#references" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Anthony Williams: C++ concurrency in action. Manning Publications.</p></li>
<li><p>Boehm, Adve, You Don’t Know Jack About Shared Variables or Memory Models , Communications of the ACM, Feb 2012.</p></li>
<li><p>Boehm, «Threads Basics», HPL TR 2009-259.</p></li>
<li><p>Adve, Boehm, «Memory Models: A Case for Rethinking Parallel Languages and Hardware», Communications of the ACM, August 2010.</p></li>
<li><p>Boehm, Adve, «Foundations of the C++ Concurrency Memory Model», PLDI 08.</p></li>
<li><p>Mark Batty, Scott Owens, Susmit Sarkar, Peter Sewell, and Tjark Weber, «Mathematizing C++ Concurrency», POPL 2011.</p></li>
<li><p>Damian Dechev, Peter Pirkelbauer, and Bjarne Stroustrup: Understanding and Effectively Preventing the ABA Problem in Descriptor-based Lock-free Designs. 13th IEEE Computer Society ISORC 2010 Symposium. May 2010.</p></li>
<li><p>Damian Dechev and Bjarne Stroustrup: Scalable Non-blocking Concurrent Objects for Mission Critical Code. ACM OOPSLA’09. October 2009</p></li>
<li><p>Damian Dechev, Peter Pirkelbauer, Nicolas Rouquette, and Bjarne Stroustrup: Semantically Enhanced Containers for Concurrent Real-Time Systems. Proc. 16th Annual IEEE International Conference and Workshop on the Engineering of Computer Based Systems (IEEE ECBS). April 2009.</p></li>
<li><p>Maurice Herlihy, Nir Shavit, Victor Luchangco, Michael Spear, «The Art of Multiprocessor Programming», 2nd ed. September 2020</p></li>
</ul>
</section>
</section>
<section id="cp-110-do-not-write-your-own-double-checked-locking-for-initialization">
<h4><a name="Rconc-double"></a>CP.110: Non scriversi il proprio «interblocco ricontrollato» [double-checked locking] per l’inizializzazione<a class="headerlink" href="#cp-110-do-not-write-your-own-double-checked-locking-for-initialization" title="Link to this heading">¶</a></h4>
<section id="id1354">
<h5>Motivo<a class="headerlink" href="#id1354" title="Link to this heading">¶</a></h5>
<p>Dal C++11, le variabili locali statiche vengono ora inizializzate in modo thread-safe. In combinazione con il modello RAII, le variabili locali statiche possono sostituire la necessità di scrivere il proprio blocco «double-checked» per l’inizializzazione. Anche con std::call_once si può raggiungere lo stesso scopo. Utilizzare le variabili locali statiche del C++11 o std::call_once anziché scriversi il proprio blocco «double-checked» per l’inizializzazione.</p>
</section>
<section id="id1355">
<h5>Esempio<a class="headerlink" href="#id1355" title="Link to this heading">¶</a></h5>
<p>Esempio con std::call_once.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    static std::once_flag my_once_flag;
    std::call_once(my_once_flag, []()
    {
        // do this only once
    });
    // ...
}
</pre></div>
</div>
<p>Esempio con le variabili locali «thread-safe» del C++11.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    // Assuming the compiler is compliant with C++11
    static My_class my_object; // Constructor called only once
    // ...
}

class My_class
{
public:
    My_class()
    {
        // do this only once
    }
};
</pre></div>
</div>
</section>
<section id="id1356">
<h5>Imposizione<a class="headerlink" href="#id1356" title="Link to this heading">¶</a></h5>
<p>??? È possibile rilevare l’idioma?</p>
</section>
</section>
<section id="cp-111-use-a-conventional-pattern-if-you-really-need-double-checked-locking">
<h4><a name="Rconc-double-pattern"></a>CP.111: Usare un pattern convenzionale se è veramente necessario il «double-checked locking»<a class="headerlink" href="#cp-111-use-a-conventional-pattern-if-you-really-need-double-checked-locking" title="Link to this heading">¶</a></h4>
<section id="id1357">
<h5>Motivo<a class="headerlink" href="#id1357" title="Link to this heading">¶</a></h5>
<p>Il «double-checked locking» è facile da rovinare. Se è davvero necessario scrivere il proprio «double-checked locking», nonostante le regole <a class="reference internal" href="#Rconc-double"><span class="xref myst">CP.110: Non scriversi il proprio «interblocco ricontrollato» [double-checked locking] per l’inizializzazione</span></a> e <a class="reference internal" href="#Rconc-lockfree"><span class="xref myst">CP.100: Non utilizzare la programmazione lock-free a meno che non sia assolutamente necessario</span></a>, farlo secondo un pattern convenzionale.</p>
<p>Gli usi del pattern «double-checked locking» che non sono in violazione della <a class="reference internal" href="#Rconc-double"><span class="xref myst">CP.110: Non scriversi il proprio «interblocco ricontrollato» [double-checked locking] per l’inizializzazione</span></a>, si hanno quando un’azione «non-thread-safe» è sia difficile [hard] che rara, ed esiste un test veloce «thread-safe» utilizzabile per garantire che l’azione non sia necessaria, ma non è utilizzabile per garantire il contrario.</p>
</section>
<section id="id1358">
<h5>Esempio, cattivo<a class="headerlink" href="#id1358" title="Link to this heading">¶</a></h5>
<p>L’uso di volatile non rende il primo controllo «thread-safe», si veda anche <a class="reference internal" href="#Rconc-volatile2"><span class="xref myst">CP.200: Usare <code class="docutils literal notranslate"><span class="pre">volatile</span></code> solo per comunicare con una memoria non-C++</span></a></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mutex action_mutex;
volatile bool action_needed;

if (action_needed) {
    std::lock_guard&lt;std::mutex&gt; lock(action_mutex);
    if (action_needed) {
        take_action();
        action_needed = false;
    }
}
</pre></div>
</div>
</section>
<section id="id1359">
<h5>Esempio, buono<a class="headerlink" href="#id1359" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mutex action_mutex;
atomic&lt;bool&gt; action_needed;

if (action_needed) {
    std::lock_guard&lt;std::mutex&gt; lock(action_mutex);
    if (action_needed) {
        take_action();
        action_needed = false;
    }
}
</pre></div>
</div>
<p>Un preciso ordine della memoria potrebbe essere d’aiuto dove il carico di acquisizione è più efficiente di quello sequenziale</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mutex action_mutex;
atomic&lt;bool&gt; action_needed;

if (action_needed.load(memory_order_acquire)) {
    lock_guard&lt;std::mutex&gt; lock(action_mutex);
    if (action_needed.load(memory_order_relaxed)) {
        take_action();
        action_needed.store(false, memory_order_release);
    }
}
</pre></div>
</div>
</section>
<section id="id1360">
<h5>Imposizione<a class="headerlink" href="#id1360" title="Link to this heading">¶</a></h5>
<p>??? È possibile rilevare l’idioma?</p>
</section>
</section>
</section>
<section id="cp-etc-etc-concurrency-rules">
<h3><a name="SScp-etc"></a>CP.etc: Ecc. regole della concorrenza<a class="headerlink" href="#cp-etc-etc-concurrency-rules" title="Link to this heading">¶</a></h3>
<p>Queste regole non sono facilmente categorizzabili:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rconc-volatile2"><span class="xref myst">CP.200: Usare <code class="docutils literal notranslate"><span class="pre">volatile</span></code> solo per comunicare con una memoria non-C++</span></a></p></li>
<li><p><a class="reference internal" href="#Rconc-signal"><span class="xref myst">CP.201: ??? Signals</span></a></p></li>
</ul>
<section id="cp-200-use-volatile-only-to-talk-to-non-c-memory">
<h4><a name="Rconc-volatile2"></a>CP.200: Usare <code class="docutils literal notranslate"><span class="pre">volatile</span></code> solo per comunicare con una memoria non-C++<a class="headerlink" href="#cp-200-use-volatile-only-to-talk-to-non-c-memory" title="Link to this heading">¶</a></h4>
<section id="id1361">
<h5>Motivo<a class="headerlink" href="#id1361" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">volatile</span></code> è usato per far riferimento a oggetti condivisi con un codice «non-C++» o con un hardware che non segue il modello di memoria del C++.</p>
</section>
<section id="id1362">
<h5>Esempio<a class="headerlink" href="#id1362" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const volatile long clock;
</pre></div>
</div>
<p>Descrive un registro aggiornato costantemente da un orologio interno. <code class="docutils literal notranslate"><span class="pre">clock</span></code> è <code class="docutils literal notranslate"><span class="pre">volatile</span></code> perché il suo valore cambierà senza alcuna azione da parte del programma C++ che lo usa. Per esempio, leggendo <code class="docutils literal notranslate"><span class="pre">clock</span></code> due volte si hanno spesso due valori diversi, quindi è opportuno che l’ottimizzatore non ottimizzi la seconda lettura in questo codice:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long t1 = clock;
// ... no use of clock here ...
long t2 = clock;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">clock</span></code> è <code class="docutils literal notranslate"><span class="pre">const</span></code> perché il programma non dovrebbe tentare di scrivere in <code class="docutils literal notranslate"><span class="pre">clock</span></code>.</p>
</section>
<section id="id1363">
<h5>Nota<a class="headerlink" href="#id1363" title="Link to this heading">¶</a></h5>
<p>A meno che non si stia scrivendo il codice a livello più basso per gestire direttamente l’hardware, si consideri <code class="docutils literal notranslate"><span class="pre">volatile</span></code> una funzionalità esoterica che è meglio evitare.</p>
</section>
<section id="id1364">
<h5>Esempio<a class="headerlink" href="#id1364" title="Link to this heading">¶</a></h5>
<p>Solitamente il codice C++ riceve come <code class="docutils literal notranslate"><span class="pre">volatile</span></code> la memoria posseduta altrove (hardware o un altro linguaggio):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int volatile* vi = get_hardware_memory_location();
    // note: we get a pointer to someone else&#39;s memory here
    // volatile says &quot;treat this with extra respect&quot;
</pre></div>
</div>
<p>A volte il codice C++ alloca memoria <code class="docutils literal notranslate"><span class="pre">volatile</span></code> e la condivide con «qualcun altro» (hardware o un altro linguaggio) per sfuggire deliberatamente ad un puntatore [escaping a pointer]:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static volatile long vl;
please_use_this(&amp;vl);   // escape a reference to this to &quot;elsewhere&quot; (not C++)
</pre></div>
</div>
</section>
<section id="id1365">
<h5>Esempio, cattivo<a class="headerlink" href="#id1365" title="Link to this heading">¶</a></h5>
<p>Le variabili locali <code class="docutils literal notranslate"><span class="pre">volatile</span></code> sono quasi sempre sbagliate – come si possono condividere con altri linguaggi o con l’hardware se sono temporanee? Lo stesso vale quasi altrettanto fortemente per i dati membri, per lo stesso motivo.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    volatile int i = 0; // bad, volatile local variable
    // etc.
}

class My_type {
    volatile int i = 0; // suspicious, volatile data member
    // etc.
};
</pre></div>
</div>
</section>
<section id="id1366">
<h5>Nota<a class="headerlink" href="#id1366" title="Link to this heading">¶</a></h5>
<p>In C++, diversamente da altri linguaggi, <code class="docutils literal notranslate"><span class="pre">volatile</span></code> non ha <a class="reference internal" href="#Rconc-volatile"><span class="xref myst">niente a che fare con la sincronizzazione</span></a>.</p>
</section>
<section id="id1367">
<h5>Imposizione<a class="headerlink" href="#id1367" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare <code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">T</span></code> locale e i dati membro; quasi certamente si intendeva usare, invece, <code class="docutils literal notranslate"><span class="pre">atomic&lt;T&gt;</span></code>.</p></li>
<li><p>???</p></li>
</ul>
</section>
</section>
<section id="cp-201-signals">
<h4><a name="Rconc-signal"></a>CP.201: ??? Signal<a class="headerlink" href="#cp-201-signals" title="Link to this heading">¶</a></h4>
<p>???Gestione dei signal di UNIX???. Potrebbe essere utile ricordare quando siano poco sicuri gli async-signal-safe, e come comunicare con un gestore di signal (forse è meglio «non farlo affatto»)</p>
</section>
</section>
</section>
<section id="e-error-handling">
<h2><a name="S-errors"></a>E: Gestione degli errori [Error handling]<a class="headerlink" href="#e-error-handling" title="Link to this heading">¶</a></h2>
<p>La gestione degli errori implica:</p>
<ul class="simple">
<li><p>Rilevare un errore</p></li>
<li><p>Trasmettere le informazioni su un errore a un codice per la sua gestione</p></li>
<li><p>Preservare uno stato valido del programma</p></li>
<li><p>Evitare perdite (leak) di risorse</p></li>
</ul>
<p>Non è possibile recuperare da tutti gli errori. Se il recupero da un errore non è possibile, è importante «uscire» rapidamente in un modo ben definito. Una strategia per la gestione degli errori deve essere semplice, altrimenti diventa fonte di errori anche peggiori.  Anche il codice per gestire gli errori se non testato, o eseguito raramente, è esso stesso una sorgenti di molti bug.</p>
<p>Le regole sono fatte per aiutare a evitare i diversi tipi di errori:</p>
<ul class="simple">
<li><p>Violazione del tipo (p.es., uso improprio delle <code class="docutils literal notranslate"><span class="pre">union</span></code> e dei cast)</p></li>
<li><p>Perdita (leak) delle risorse (compresi i “memory leak”)</p></li>
<li><p>Errori sui limiti [bound]</p></li>
<li><p>Errori del diclodi vita [lifetime] (ad es. accesso a un oggetto dopo che aver subito un <code class="docutils literal notranslate"><span class="pre">delete</span></code>)</p></li>
<li><p>Errori di complessità (errori logici dati da espressioni o idee eccessivamente complesse)</p></li>
<li><p>Errori di interfaccia (p.es., un valore inatteso passato ad un’interfaccia)</p></li>
</ul>
<p>Riepilogo delle regole sulla gestione degli errori [error-handling]:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Re-design"><span class="xref myst">E.1: Sviluppare una strategia di gestione degli errori nelle prime fasi di un progetto</span></a></p></li>
<li><p><a class="reference internal" href="#Re-throw"><span class="xref myst">E.2: Generare un’eccezione per segnalare che una funzioni non può eseguire il proprio compito</span></a></p></li>
<li><p><a class="reference internal" href="#Re-errors"><span class="xref myst">E.3: Usare le eccezioni solamente per la gestione degli errori</span></a></p></li>
<li><p><a class="reference internal" href="#Re-design-invariants"><span class="xref myst">E.4: Progettarsi la propria strategia di gestione degli errori basandosi sugli invarianti</span></a></p></li>
<li><p><a class="reference internal" href="#Re-invariant"><span class="xref myst">E.5: Consentire ad un costruttore di stabilire un invariante, e sollevare un errore se non può</span></a></p></li>
<li><p><a class="reference internal" href="#Re-raii"><span class="xref myst">E.6: Usare il RAII per evitare i leak</span></a></p></li>
<li><p><a class="reference internal" href="#Re-precondition"><span class="xref myst">E.7: Dichiarare le proprie pre-condizioni</span></a></p></li>
<li><p><a class="reference internal" href="#Re-postcondition"><span class="xref myst">E.8: Dichiarare le proprie pre-condizioni</span></a></p></li>
<li><p><a class="reference internal" href="#Re-noexcept"><span class="xref myst">E.12: Usare <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> uscendo da una funzione quando un <code class="docutils literal notranslate"><span class="pre">throw</span></code> (un’eccezione) è impossibile o inaccettabile</span></a></p></li>
<li><p><a class="reference internal" href="#Re-never-throw"><span class="xref myst">E.13: Mai sollevare eccezioni quando si è i diretti proprietari [owner] di un oggetto</span></a></p></li>
<li><p><a class="reference internal" href="#Re-exception-types"><span class="xref myst">E.14: Usare tipi appositamente progettati o [user-defined] come eccezioni (non i tipi [built-in])</span></a></p></li>
<li><p><a class="reference internal" href="#Re-exception-ref"><span class="xref myst">E.15: Eseguire il «throw» per valore, il «catch» di eccezioni da una gerarchia per riferimento</span></a></p></li>
<li><p><a class="reference internal" href="#Re-never-fail"><span class="xref myst">E.16: I distruttori, la de-allocazione, <code class="docutils literal notranslate"><span class="pre">swap</span></code> e la costruzione copia/spostamento dell’eccezione, non devono mai fallire</span></a></p></li>
<li><p><a class="reference internal" href="#Re-not-always"><span class="xref myst">E.17: Non cercare di catturare tutte le eccezioni da tutte le funzioni</span></a></p></li>
<li><p><a class="reference internal" href="#Re-catch"><span class="xref myst">E.18: Minimizzare l’uso di <code class="docutils literal notranslate"><span class="pre">try</span></code>/<code class="docutils literal notranslate"><span class="pre">catch</span></code> espliciti</span></a></p></li>
<li><p><a class="reference internal" href="#Re-finally"><span class="xref myst">E.19: Usare un oggetto <code class="docutils literal notranslate"><span class="pre">final_action</span></code> per la pulizia [cleanup] se non è disponibile un gestore delle risorse adatto</span></a></p></li>
<li><p><a class="reference internal" href="#Re-no-throw-raii"><span class="xref myst">E.25: Se non è possibile sollevare eccezioni, simulare il RAII per la gestione delle risorse</span></a></p></li>
<li><p><a class="reference internal" href="#Re-no-throw-crash"><span class="xref myst">E.26: Se non è possibile sollevare eccezioni, si prenda in considerazione un veloce fallimento</span></a></p></li>
<li><p><a class="reference internal" href="#Re-no-throw-codes"><span class="xref myst">E.27: Se non è possibile sollevare eccezioni, si usino sistematicamente i codici di errore</span></a></p></li>
<li><p><a class="reference internal" href="#Re-no-throw"><span class="xref myst">E.28: Evitare la gestione degli errori basata su uno stato globale (p.es. <code class="docutils literal notranslate"><span class="pre">errno</span></code>)</span></a></p></li>
<li><p><a class="reference internal" href="#Re-specifications"><span class="xref myst">E.30: Non utilizzare le specifiche delle eccezioni</span></a></p></li>
<li><p><a class="reference internal" href="#Re_catch"><span class="xref myst">E.31: Ordinare in modo appropriato le proprie istruzioni <code class="docutils literal notranslate"><span class="pre">catch</span></code></span></a></p></li>
</ul>
<section id="e-1-develop-an-error-handling-strategy-early-in-a-design">
<h3><a name="Re-design"></a>E.1: Sviluppare una strategia di gestione degli errori nelle prime fasi di un progetto<a class="headerlink" href="#e-1-develop-an-error-handling-strategy-early-in-a-design" title="Link to this heading">¶</a></h3>
<section id="id1368">
<h4>Motivo<a class="headerlink" href="#id1368" title="Link to this heading">¶</a></h4>
<p>Una strategia coerente e completa per la gestione degli errori e i leak delle risorse è difficile da aggiornare in un sistema.</p>
</section>
</section>
<section id="e-2-throw-an-exception-to-signal-that-a-function-can-t-perform-its-assigned-task">
<h3><a name="Re-throw"></a>E.2: Generare un’eccezione per segnalare che una funzioni non può eseguire il proprio compito<a class="headerlink" href="#e-2-throw-an-exception-to-signal-that-a-function-can-t-perform-its-assigned-task" title="Link to this heading">¶</a></h3>
<section id="id1369">
<h4>Motivo<a class="headerlink" href="#id1369" title="Link to this heading">¶</a></h4>
<p>Per rendere la gestione degli errori sistematica, robusta e non-ripetitiva.</p>
</section>
<section id="id1370">
<h4>Esempio<a class="headerlink" href="#id1370" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Foo {
    vector&lt;Thing&gt; v;
    File_handle f;
    string s;
};

void use()
{
    Foo bar { {Thing{1}, Thing{2}, Thing{monkey} }, {&quot;my_file&quot;, &quot;r&quot;}, &quot;Here we go!&quot;};
    // ...
}
</pre></div>
</div>
<p>Qui, i costruttori dei <code class="docutils literal notranslate"><span class="pre">vector</span></code> e delle <code class="docutils literal notranslate"><span class="pre">string</span></code> potrebbero non essere in grado di allocare memoria sufficiente per i loro elementi, il costruttore dei <code class="docutils literal notranslate"><span class="pre">vector</span></code> potrebbe non essere in grado di copiare i <code class="docutils literal notranslate"><span class="pre">Thing</span></code> nella sua lista di inizializzazione, e <code class="docutils literal notranslate"><span class="pre">File_handle</span></code> potrebbe non essere in grado di aprire il file richiesto. In ogni caso, generano un errore per gestire il chiamante di <code class="docutils literal notranslate"><span class="pre">use()</span></code>. Se <code class="docutils literal notranslate"><span class="pre">use()</span></code> è in grado di gestire il fallimento nel costruire <code class="docutils literal notranslate"><span class="pre">bar</span></code> può assumere il controllo usando <code class="docutils literal notranslate"><span class="pre">try</span></code>/<code class="docutils literal notranslate"><span class="pre">catch</span></code>. in entrambi i casi, il costruttore di <code class="docutils literal notranslate"><span class="pre">Foo</span></code> distrugge correttamente i membri prima di passare il controllo a chiunque abbia tentato di creare un <code class="docutils literal notranslate"><span class="pre">Foo</span></code>. Si noti che non esiste alcun valore ritorno che potrebbe contenere un codice di errore.</p>
<p>Il costruttore <code class="docutils literal notranslate"><span class="pre">File_handle</span></code> potrebbe essere definito in questo modo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>File_handle::File_handle(const string&amp; name, const string&amp; mode)
    : f{fopen(name.c_str(), mode.c_str())}
{
    if (!f)
        throw runtime_error{&quot;File_handle: could not open &quot; + name + &quot; as &quot; + mode};
}
</pre></div>
</div>
</section>
<section id="id1371">
<h4>Nota<a class="headerlink" href="#id1371" title="Link to this heading">¶</a></h4>
<p>Si dice spesso che le eccezioni siano destinate a segnalare eventi e fallimenti eccezionali. Tuttavia, è un po “circolare perché «cos’è eccezionale?» Esempi:</p>
<ul class="simple">
<li><p>Un prerequisito che non può essere soddisfatto</p></li>
<li><p>Un costruttore che non è in grado di costruire un oggetto (impossibile stabilire il proprio <a class="reference internal" href="#Rc-struct"><span class="xref myst">invariante</span></a> della classe)</p></li>
<li><p>Un errore [out-of-range] (p.es., <code class="docutils literal notranslate"><span class="pre">v[v.size()]</span> <span class="pre">=</span> <span class="pre">7</span></code>)</p></li>
<li><p>Impossibilità di acquisire una risorsa (p.es., la rete non è attiva)</p></li>
</ul>
<p>Al contrario, la conclusione di un normale ciclo non è eccezionale. A meno che il loop non fosse destinato a essere infinito, la terminazione è normale e prevista.</p>
</section>
<section id="id1372">
<h4>Nota<a class="headerlink" href="#id1372" title="Link to this heading">¶</a></h4>
<p>Non usare un <code class="docutils literal notranslate"><span class="pre">throw</span></code> come un semplice modo alternativo per tornare da una funzione.</p>
</section>
<section id="id1373">
<h4>Eccezione<a class="headerlink" href="#id1373" title="Link to this heading">¶</a></h4>
<p>Alcuni sistemi, come quelli fortemente real-time richiedono la garanzia che un’azione venga intrapresa entro un tempo costante massimo (solitamente breve) noto prima dell’avvio dell’esecuzione. Questi sistemi possono usare le eccezioni solo se c’è uno strumento di supporto che preveda con precisione il tempo massimo per riprendersi da un <code class="docutils literal notranslate"><span class="pre">throw</span></code>.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Re-raii"><span class="xref myst">RAII</span></a></p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Sd-noexcept"><span class="xref myst">discussione</span></a></p>
</section>
<section id="id1374">
<h4>Nota<a class="headerlink" href="#id1374" title="Link to this heading">¶</a></h4>
<p>Prima di decidere che non ci si può permettere o che non piace la gestione degli errori basata sulle eccezioni, si dia uno sguardo alle <a class="reference internal" href="#Re-no-throw-raii"><span class="xref myst">alternative</span></a>; queste hanno le loro complessità e i loro problemi. Inoltre, per quanto possibile, effettuare delle misure prima di fare affermazioni sull’efficienza.</p>
</section>
</section>
<section id="e-3-use-exceptions-for-error-handling-only">
<h3><a name="Re-errors"></a>E.3: Usare le eccezioni solamente per la gestione degli errori<a class="headerlink" href="#e-3-use-exceptions-for-error-handling-only" title="Link to this heading">¶</a></h3>
<section id="id1375">
<h4>Motivo<a class="headerlink" href="#id1375" title="Link to this heading">¶</a></h4>
<p>Per mantenere la gestione degli errori separata dal «codice ordinario.» le implementazioni del C++ tendono ad essere ottimizzate in base al presupposto che le eccezioni siano rare.</p>
</section>
<section id="id1376">
<h4>Esempio, da non fare<a class="headerlink" href="#id1376" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// don&#39;t: exception not used for error handling
int find_index(vector&lt;string&gt;&amp; vec, const string&amp; x)
{
    try {
        for (gsl::index i = 0; i &lt; vec.size(); ++i)
            if (vec[i] == x) throw i;  // found x
    }
    catch (int i) {
        return i;
    }
    return -1;   // not found
}
</pre></div>
</div>
<p>Questo è più complicato e molto probabilmente gira molto più lentamente dell’alternativa ovvia. Non c’è niente di eccezionale nel trovare un valore in un <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</section>
<section id="id1377">
<h4>Imposizione<a class="headerlink" href="#id1377" title="Link to this heading">¶</a></h4>
<p>Dovrebbe essere euristico. Cercare i valori «persi [leaked]» delle istruzioni <code class="docutils literal notranslate"><span class="pre">catch</span></code>.</p>
</section>
</section>
<section id="e-4-design-your-error-handling-strategy-around-invariants">
<h3><a name="Re-design-invariants"></a>E.4: Progettarsi la propria strategia di gestione degli errori basandosi sugli invarianti<a class="headerlink" href="#e-4-design-your-error-handling-strategy-around-invariants" title="Link to this heading">¶</a></h3>
<section id="id1378">
<h4>Motivo<a class="headerlink" href="#id1378" title="Link to this heading">¶</a></h4>
<p>Per usare un oggetto esso deve essere in uno stato valido (definito formalmente o informalmente da un invariante) e per recuperare da un errore ogni oggetto non distrutto deve essere in uno stato valido.</p>
</section>
<section id="id1379">
<h4>Nota<a class="headerlink" href="#id1379" title="Link to this heading">¶</a></h4>
<p>Un <a class="reference internal" href="#Rc-struct"><span class="xref myst">invariante</span></a>, è una condizione logica per i membri di un oggetto che un costruttore deve stabilire, affinché le funzioni membro pubbliche la possano assumere.</p>
</section>
<section id="id1380">
<h4>Imposizione<a class="headerlink" href="#id1380" title="Link to this heading">¶</a></h4>
<p>???</p>
</section>
</section>
<section id="e-5-let-a-constructor-establish-an-invariant-and-throw-if-it-cannot">
<h3><a name="Re-invariant"></a>E.5: Consentire ad un costruttore di stabilire un invariante, e sollevare un errore se non può<a class="headerlink" href="#e-5-let-a-constructor-establish-an-invariant-and-throw-if-it-cannot" title="Link to this heading">¶</a></h3>
<section id="id1381">
<h4>Motivo<a class="headerlink" href="#id1381" title="Link to this heading">¶</a></h4>
<p>Lasciare un oggetto senza il suo invariante stabilito vuol dire andare in cerca di guai. Non tutte le funzioni membro si possono chiamare.</p>
</section>
<section id="id1382">
<h4>Esempio<a class="headerlink" href="#id1382" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Vector {  // very simplified vector of doubles
    // if elem != nullptr then elem points to sz doubles
public:
    Vector() : elem{nullptr}, sz{0}{}
    Vector(int s) : elem{new double[s]}, sz{s} { /* initialize elements */ }
    ~Vector() { delete [] elem; }
    double&amp; operator[](int s) { return elem[s]; }
    // ...
private:
    owner&lt;double*&gt; elem;
    int sz;
};
</pre></div>
</div>
<p>L’invariante della classe - qui definito come commento - è stabilito dal suo costruttore. <code class="docutils literal notranslate"><span class="pre">new</span></code> solleva un errore se non può allocare la memoria richiesta. Gli operatori, in particolare l’operatore di indicizzazione, si basano sull’invariante.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Rc-throw"><span class="xref myst">Se un costruttore non è in grado di costruire un oggetto valido, generare un’eccezione</span></a></p>
</section>
<section id="id1383">
<h4>Imposizione<a class="headerlink" href="#id1383" title="Link to this heading">¶</a></h4>
<p>Segnalare le classi con <code class="docutils literal notranslate"><span class="pre">private</span></code> definito senza un costruttore (public, protected o private).</p>
</section>
</section>
<section id="e-6-use-raii-to-prevent-leaks">
<h3><a name="Re-raii"></a>E.6: Usare il RAII per evitare i leak<a class="headerlink" href="#e-6-use-raii-to-prevent-leaks" title="Link to this heading">¶</a></h3>
<section id="id1384">
<h4>Motivo<a class="headerlink" href="#id1384" title="Link to this heading">¶</a></h4>
<p>I leak sono generalmente inaccettabili. Il rilascio manuale delle risorse è soggetto a errori. Il RAII («Resource Acquisition Is Initialization») è il modo più semplice e sistematico per prevenire i leak.</p>
</section>
<section id="id1385">
<h4>Esempio<a class="headerlink" href="#id1385" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f1(int i)   // Bad: possible leak
{
    int* p = new int[12];
    // ...
    if (i &lt; 17) throw Bad{&quot;in f()&quot;, i};
    // ...
}
</pre></div>
</div>
<p>Si potrebbe rilasciare la risorsa prima di sollevare l’eccezione:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f2(int i)   // Clumsy and error-prone: explicit release
{
    int* p = new int[12];
    // ...
    if (i &lt; 17) {
        delete[] p;
        throw Bad{&quot;in f()&quot;, i};
    }
    // ...
}
</pre></div>
</div>
<p>Questo è prolisso. Nel codice più complesso con più possibili <code class="docutils literal notranslate"><span class="pre">throw</span></code> il rilascio esplicito diventa ripetitivo e soggetto ad errori.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f3(int i)   // OK: resource management done by a handle (but see below)
{
    auto p = make_unique&lt;int[]&gt;(12);
    // ...
    if (i &lt; 17) throw Bad{&quot;in f()&quot;, i};
    // ...
}
</pre></div>
</div>
<p>Si noti che questo funziona anche quando il <code class="docutils literal notranslate"><span class="pre">throw</span></code> è implicito perché avviene in una funzione chiamata:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f4(int i)   // OK: resource management done by a handle (but see below)
{
    auto p = make_unique&lt;int[]&gt;(12);
    // ...
    helper(i);   // might throw
    // ...
}
</pre></div>
</div>
<p>A meno che non sia davvero necessaria la semantica del puntatore, utilizzare un oggetto con risorsa locale:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f5(int i)   // OK: resource management done by local object
{
    vector&lt;int&gt; v(12);
    // ...
    helper(i);   // might throw
    // ...
}
</pre></div>
</div>
<p>È ancora più semplice e sicuro e spesso è più efficiente.</p>
</section>
<section id="id1386">
<h4>Nota<a class="headerlink" href="#id1386" title="Link to this heading">¶</a></h4>
<p>Se non c’è alcun gestore delle risorse ovvio e per qualche motivo non è possibile definire un appropriato oggetto/handle, come ultima risorsa, le azioni di ripulitura [cleanup] possono essere rappresentate da un oggetto <a class="reference internal" href="#Re-finally"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">final_action</span></code></span></a>.</p>
</section>
<section id="id1387">
<h4>Nota<a class="headerlink" href="#id1387" title="Link to this heading">¶</a></h4>
<p>Ma cosa si fa se si sta scrivendo un programma in cui non è possibile usare le eccezioni? Primo confutare quest’assunto; ci sono molti falsi miti contro le eccezioni. Si conoscono solo alcuni buoni motivi:</p>
<ul class="simple">
<li><p>Si è su un sistema talmente piccolo che il supporto delle eccezioni si prenderebbe gran parte dei 2K di memoria disponibile.</p></li>
<li><p>Si è su un sistema hard-real-time e non ci sono tool che ci garantiscano che un’eccezione venga gestita nel tempo richiesto.</p></li>
<li><p>Si è su un sistema con un sacco di codice pre-esistente che usa tantissimi puntatori difficili-da-capire (in particolare senza una strategia riconoscibile della proprietà [ownership]) quindi le eccezioni potrebbero causare leak.</p></li>
<li><p>L’implementazione dei meccanismi delle eccezioni C++ è irragionevolmente scarsa (lenta, richiede memoria, non funziona bene con le librerie linkate dinamicamente, ecc.). Ci si deve lamentare col proprio fornitore dell’implementazione; se nessuno si lamenta, non ci sarà nessun miglioramento.</p></li>
<li><p>Si verrà licenziati se sfiderà l’antica saggezza del proprio capo.</p></li>
</ul>
<p>Solo il primo, di questi motivi, è fondamentale, quindi laddove è possibile, usare le eccezioni per implementare il RAII, o progettarsi i propri oggetti per non fallire mai. Quando non si possono usare le eccezioni, simulare il RAII. Ovvero, controllare sistematicamente che gli oggetti sono ancora validi dopo la costruzione e che rilasceranno tutte le risorse nel distruttore. Una strategia consiste nell’aggiungere un’operazione <code class="docutils literal notranslate"><span class="pre">valid()</span></code> ad ogni handle delle risorse:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    vector&lt;string&gt; vs(100);   // not std::vector: valid() added
    if (!vs.valid()) {
        // handle error or exit
    }

    ifstream fs(&quot;foo&quot;);   // not std::ifstream: valid() added
    if (!fs.valid()) {
        // handle error or exit
    }

    // ...
} // destructors clean up as usual
</pre></div>
</div>
<p>Ovviamente, questo aumenta la dimensione del codice, non consente la propagazione implicita delle «eccezioni» (i controlli di <code class="docutils literal notranslate"><span class="pre">valid()</span></code>), e i controlli di <code class="docutils literal notranslate"><span class="pre">valid()</span></code> si possono dimenticare. Preferire l’uso delle eccezioni.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Re-noexcept"><span class="xref myst">Uso di <code class="docutils literal notranslate"><span class="pre">noexcept</span></code></span></a></p>
</section>
<section id="id1388">
<h4>Imposizione<a class="headerlink" href="#id1388" title="Link to this heading">¶</a></h4>
<p>???</p>
</section>
</section>
<section id="e-7-state-your-preconditions">
<h3><a name="Re-precondition"></a>E.7: Dichiarare le proprie pre-condizioni<a class="headerlink" href="#e-7-state-your-preconditions" title="Link to this heading">¶</a></h3>
<section id="id1389">
<h4>Motivo<a class="headerlink" href="#id1389" title="Link to this heading">¶</a></h4>
<p>Per evitare errori di interfaccia.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Ri-pre"><span class="xref myst">regola sulla pre-condizione</span></a></p>
</section>
</section>
<section id="e-8-state-your-postconditions">
<h3><a name="Re-postcondition"></a>E.8: Dichiarare le proprie post-condizioni<a class="headerlink" href="#e-8-state-your-postconditions" title="Link to this heading">¶</a></h3>
<section id="id1390">
<h4>Motivo<a class="headerlink" href="#id1390" title="Link to this heading">¶</a></h4>
<p>Per evitare errori di interfaccia.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Ri-post"><span class="xref myst">regola della post-condizione</span></a></p>
</section>
</section>
<section id="e-12-use-noexcept-when-exiting-a-function-because-of-a-throw-is-impossible-or-unacceptable">
<h3><a name="Re-noexcept"></a>E.12: Usare <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> uscendo da una funzione quando un <code class="docutils literal notranslate"><span class="pre">throw</span></code> (un’eccezione) è impossibile o inaccettabile<a class="headerlink" href="#e-12-use-noexcept-when-exiting-a-function-because-of-a-throw-is-impossible-or-unacceptable" title="Link to this heading">¶</a></h3>
<section id="id1391">
<h4>Motivo<a class="headerlink" href="#id1391" title="Link to this heading">¶</a></h4>
<p>Per rendere la gestione degli errori sistematica, solida ed efficiente.</p>
</section>
<section id="id1392">
<h4>Esempio<a class="headerlink" href="#id1392" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double compute(double d) noexcept
{
    return log(sqrt(d &lt;= 0 ? 1 : d));
}
</pre></div>
</div>
<p>Qui, si sa che <code class="docutils literal notranslate"><span class="pre">compute</span></code> non solleverà eccezioni perché è composta da operazioni che non generano errori. Affermando che <code class="docutils literal notranslate"><span class="pre">compute</span></code> è <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>, si informa compilatore e i lettori umani che si può semplificare la comprensione e la gestione di <code class="docutils literal notranslate"><span class="pre">compute</span></code>.</p>
</section>
<section id="id1393">
<h4>Nota<a class="headerlink" href="#id1393" title="Link to this heading">¶</a></h4>
<p>Molte funzioni della libreria standard sono <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> comprese tutte quelle «ereditate» dalla Libreria Standard del C.</p>
</section>
<section id="id1394">
<h4>Esempio<a class="headerlink" href="#id1394" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;double&gt; munge(const vector&lt;double&gt;&amp; v) noexcept
{
    vector&lt;double&gt; v2(v.size());
    // ... do something ...
}
</pre></div>
</div>
<p>Qui il <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> indica che non si è disposti o non si è in grado di gestire la situazione in cui non si può costruire il <code class="docutils literal notranslate"><span class="pre">vector</span></code> locale. Cioè, si considera l’esaurimento della memoria un grave errore di progettazione (al pari dei guasti hardware), quindi si è disposti a bloccare il programma se capita.</p>
</section>
<section id="id1395">
<h4>Nota<a class="headerlink" href="#id1395" title="Link to this heading">¶</a></h4>
<p>Non usare le tradizionali <a class="reference internal" href="#Re-specifications"><span class="xref myst">specifiche delle eccezioni [exception-specification]</span></a>.</p>
</section>
<section id="id1396">
<h4>Si veda anche<a class="headerlink" href="#id1396" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="#Sd-noexcept"><span class="xref myst">discussione</span></a>.</p>
</section>
</section>
<section id="e-13-never-throw-while-being-the-direct-owner-of-an-object">
<h3><a name="Re-never-throw"></a>E.13: Mai sollevare eccezioni quando si è i diretti proprietari [owner] di un oggetto<a class="headerlink" href="#e-13-never-throw-while-being-the-direct-owner-of-an-object" title="Link to this heading">¶</a></h3>
<section id="id1397">
<h4>Motivo<a class="headerlink" href="#id1397" title="Link to this heading">¶</a></h4>
<p>Ci sarebbe un leak.</p>
</section>
<section id="id1398">
<h4>Esempio<a class="headerlink" href="#id1398" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void leak(int x)   // don&#39;t: might leak
{
    auto p = new int{7};
    if (x &lt; 0) throw Get_me_out_of_here{};  // might leak *p
    // ...
    delete p;   // we might never get here
}
</pre></div>
</div>
<p>Un modo per evitare tali problemi è utilizzare i gestori delle risorse in modo coerente:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void no_leak(int x)
{
    auto p = make_unique&lt;int&gt;(7);
    if (x &lt; 0) throw Get_me_out_of_here{};  // will delete *p if necessary
    // ...
    // no need for delete p
}
</pre></div>
</div>
<p>Un’altra soluzione (spesso migliore) sarebbe quella di utilizzare una variabile locale per evitare l’uso esplicito di puntatori:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void no_leak_simplified(int x)
{
    vector&lt;int&gt; v(7);
    // ...
}
</pre></div>
</div>
</section>
<section id="id1399">
<h4>Nota<a class="headerlink" href="#id1399" title="Link to this heading">¶</a></h4>
<p>Se si ha una «cosa» locale che richiede la pulizia [cleanup], ma non è rappresentata da un oggetto con un distruttore, tale pulizia dev’essere fatta anche prima di un <code class="docutils literal notranslate"><span class="pre">throw</span></code>. A volte, <a class="reference internal" href="#Re-finally"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">finally()</span></code></span></a> può rendere questa sistematicamente pulizia un po” più gestibile.</p>
</section>
</section>
<section id="e-14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types">
<h3><a name="Re-exception-types"></a>E.14: Usare tipi appositamente progettati o [user-defined] come eccezioni (non i tipi [built-in])<a class="headerlink" href="#e-14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types" title="Link to this heading">¶</a></h3>
<section id="id1400">
<h4>Motivo<a class="headerlink" href="#id1400" title="Link to this heading">¶</a></h4>
<p>Un tipo definito dall’utente può trasmettere meglio le informazioni su un errore a un handler.  Le informazioni possono essere codificate nel tipo stesso ed è improbabile che il tipo si scontri con le eccezioni di altre persone.</p>
</section>
<section id="id1401">
<h4>Esempio<a class="headerlink" href="#id1401" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>throw 7; // bad

throw &quot;something bad&quot;;  // bad

throw std::exception{}; // bad - no info
</pre></div>
</div>
<p>Derivando da <code class="docutils literal notranslate"><span class="pre">std::exception</span></code> si ha la flessibilità di catturare l’eccezione specifica o gestirla in generale tramite <code class="docutils literal notranslate"><span class="pre">std::exception</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class MyException : public std::runtime_error
{
public:
    MyException(const string&amp; msg) : std::runtime_error{msg} {}
    // ...
};

// ...

throw MyException{&quot;something bad&quot;};  // good
</pre></div>
</div>
<p>Le eccezioni non devono essere derivate da <code class="docutils literal notranslate"><span class="pre">std::exception</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class MyCustomError final {};  // not derived from std::exception

// ...

throw MyCustomError{};  // good - handlers must catch this type (or ...)
</pre></div>
</div>
<p>I tipi della libreria derivati da <code class="docutils literal notranslate"><span class="pre">std::exception</span></code> si possono usare come eccezioni generiche se non è possibile aggiungere informazioni utili al punto di rilevamento:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>throw std::runtime_error(&quot;someting bad&quot;); // good

// ...

throw std::invalid_argument(&quot;i is not even&quot;); // good
</pre></div>
</div>
<p>Sono consentite anche le classi <code class="docutils literal notranslate"><span class="pre">enum</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum class alert {RED, YELLOW, GREEN};

throw alert::RED; // good
</pre></div>
</div>
</section>
<section id="id1402">
<h4>Imposizione<a class="headerlink" href="#id1402" title="Link to this heading">¶</a></h4>
<p>Cattura il <code class="docutils literal notranslate"><span class="pre">throw</span></code> dei tipi nativi e di <code class="docutils literal notranslate"><span class="pre">std::exception</span></code>.</p>
</section>
</section>
<section id="e-15-throw-by-value-catch-exceptions-from-a-hierarchy-by-reference">
<h3><a name="Re-exception-ref"></a>E.15: Eseguire il «throw» per valore, il «catch» di eccezioni da una gerarchia per riferimento<a class="headerlink" href="#e-15-throw-by-value-catch-exceptions-from-a-hierarchy-by-reference" title="Link to this heading">¶</a></h3>
<section id="id1403">
<h4>Motivo<a class="headerlink" href="#id1403" title="Link to this heading">¶</a></h4>
<p>Eseguendo il throw per valore (non per puntatore) e il catch per riferimento si impedisce la copia, specialmente lo slicing dei sotto-oggetti base.</p>
</section>
<section id="id1404">
<h4>Esempio; cattivo<a class="headerlink" href="#id1404" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    try {
        // ...
        throw new widget{}; // don&#39;t: throw by value not by raw pointer
        // ...
    }
    catch (base_class e) {  // don&#39;t: might slice
        // ...
    }
}
</pre></div>
</div>
<p>Usare, invece, un riferimento:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>catch (base_class&amp; e) { /* ... */ }
</pre></div>
</div>
<p>o - generalmente ancor meglio  - un riferimento <code class="docutils literal notranslate"><span class="pre">const</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>catch (const base_class&amp; e) { /* ... */ }
</pre></div>
</div>
<p>La maggior parte dei gestori non modificano la propria eccezione e in generale <a class="reference internal" href="#Res-const"><span class="xref myst">si consiglia l’uso di <code class="docutils literal notranslate"><span class="pre">const</span></code></span></a>.</p>
</section>
<section id="id1405">
<h4>Nota<a class="headerlink" href="#id1405" title="Link to this heading">¶</a></h4>
<p>Il catch per valore può essere appropriato per un tipo di valore piccolo come un valore <code class="docutils literal notranslate"><span class="pre">enum</span></code>.</p>
</section>
<section id="id1406">
<h4>Nota<a class="headerlink" href="#id1406" title="Link to this heading">¶</a></h4>
<p>Per rilanciare [rethrow] un’eccezione rilevata usare <code class="docutils literal notranslate"><span class="pre">throw;</span></code> non <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">e;</span></code>. L’uso di <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">e;</span></code> genererebbe una nuova copia di <code class="docutils literal notranslate"><span class="pre">e</span></code> («sliced» al tipo statico <code class="docutils literal notranslate"><span class="pre">std::exception</span></code>, quando l’eccezione viene catturata da <code class="docutils literal notranslate"><span class="pre">catch</span> <span class="pre">(const</span> <span class="pre">std::exception&amp;</span> <span class="pre">e)</span></code>) anziché rilanciare [rethrowing] l’eccezione originale di tipo <code class="docutils literal notranslate"><span class="pre">std::runtime_error</span></code>. (Ma si tengano in mente (But keep <a class="reference internal" href="#Re-not-always"><span class="xref myst">Non cercare di catturare tutte le eccezioni da tutte le funzioni</span></a> e <a class="reference internal" href="#Re-catch"><span class="xref myst">Minimizzare l’uso di <code class="docutils literal notranslate"><span class="pre">try</span></code>/<code class="docutils literal notranslate"><span class="pre">catch</span></code> espliciti</span></a>).</p>
</section>
<section id="id1407">
<h4>Imposizione<a class="headerlink" href="#id1407" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare il catch per valore di un tipo che ha una funzione virtuale.</p></li>
<li><p>Segnalare il throw di puntatori semplici.</p></li>
</ul>
</section>
</section>
<section id="e-16-destructors-deallocation-swap-and-exception-type-copy-move-construction-must-never-fail">
<h3><a name="Re-never-fail"></a>E.16: I distruttori, la de-allocazione, <code class="docutils literal notranslate"><span class="pre">swap</span></code> e la costruzione copia/spostamento dell’eccezione, non devono mai fallire<a class="headerlink" href="#e-16-destructors-deallocation-swap-and-exception-type-copy-move-construction-must-never-fail" title="Link to this heading">¶</a></h3>
<section id="id1408">
<h4>Motivo<a class="headerlink" href="#id1408" title="Link to this heading">¶</a></h4>
<p>Non sappiamo come scrivere programmi affidabili se un distruttore, uno swap, una deallocazione della memoria o un tentativo di copiare/spostare-costruire un oggetto eccezione, fallisce; cioè, se esce da un’eccezione o semplicemente non esegue l’azione richiesta.</p>
</section>
<section id="id1409">
<h4>Esempio, da non fare<a class="headerlink" href="#id1409" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Connection {
    // ...
public:
    ~Connection()   // Don&#39;t: very bad destructor
    {
        if (cannot_disconnect()) throw I_give_up{information};
        // ...
    }
};
</pre></div>
</div>
</section>
<section id="id1410">
<h4>Nota<a class="headerlink" href="#id1410" title="Link to this heading">¶</a></h4>
<p>Molti hanno provato a scrivere codice affidabile violando questa regola per esempio, come una connessione di rete che si «rifiuta di chiudersi». Per quanto ne sappiamo, nessuno ha trovato un modo generale per farlo. Occasionalmente, per esempi molto specifici, è possibile cavarsela impostando un certo stato per una successiva pulizia. Per esempio, si potrebbe mettere un socket che non vuole chiudersi in una lista dei «socket cattivi», per poi esaminare la lista con una regolare scansione dello stato del sistema. Ogni esempio visto a questo proposito è soggetto a errori, specializzato e spesso bacato.</p>
</section>
<section id="id1411">
<h4>Nota<a class="headerlink" href="#id1411" title="Link to this heading">¶</a></h4>
<p>La libreria standard presuppone che i distruttori, le funzioni di de-allocazione (p.es., <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete</span></code>) e <code class="docutils literal notranslate"><span class="pre">swap</span></code> non emettano errori [throw]. Se lo fanno, gli invarianti basilari della libreria standard vengono infranti.</p>
</section>
<section id="id1412">
<h4>Nota<a class="headerlink" href="#id1412" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Le funzioni di de-allocazione, compreso <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete</span></code>, devono essere <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>.</p></li>
<li><p>La funzione <code class="docutils literal notranslate"><span class="pre">swap</span></code> dev’essere <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>.</p></li>
<li><p>La maggior parte dei distruttori sono implicitamente <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> per default.</p></li>
<li><p>Inoltre, <a class="reference internal" href="#Rc-move-noexcept"><span class="xref myst">creare le operazioni di [move] come <code class="docutils literal notranslate"><span class="pre">noexcept</span></code></span></a>.</p></li>
<li><p>Se si scrive un tipo destinato ad essere utilizzato come tipo di un’eccezione, assicurarsi che il suo costruttore di copia non sia <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>. In generale non possiamo applicarlo meccanicamente, perché non sappiamo se un tipo deve essere utilizzato come tipo di un’eccezione.</p></li>
<li><p>Cercare di non eseguire il <code class="docutils literal notranslate"><span class="pre">throw</span></code> di un tipo il cui costruttore di copia non sia <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>. In generale non possiamo applicarlo meccanicamente, perché anche <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">std::string(...)</span></code> potrebbe “lanciare” [throw] ma in pratica non lo fa.</p></li>
</ul>
</section>
<section id="id1413">
<h4>Imposizione<a class="headerlink" href="#id1413" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Catturare i distruttori, le operazioni di de-allocazione e gli <code class="docutils literal notranslate"><span class="pre">swap</span></code> che eseguono <code class="docutils literal notranslate"><span class="pre">throw</span></code>.</p></li>
<li><p>Catturare tali operazioni che non sono <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>.</p></li>
</ul>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Sd-never-fail"><span class="xref myst">discussione</span></a></p>
</section>
</section>
<section id="e-17-don-t-try-to-catch-every-exception-in-every-function">
<h3><a name="Re-not-always"></a>E.17: Non cercare di catturare tutte le eccezioni da tutte le funzioni<a class="headerlink" href="#e-17-don-t-try-to-catch-every-exception-in-every-function" title="Link to this heading">¶</a></h3>
<section id="id1414">
<h4>Motivo<a class="headerlink" href="#id1414" title="Link to this heading">¶</a></h4>
<p>Catturare un’eccezione in una funzione che non esegue una significativa azione di recupero comporta complessità e spreco. Lasciare che un’eccezione si propaghi fino a raggiunger una funzione che la possa gestire. Lasciare che le azioni di pulizia [cleanup] sul percorso attraversato sia gestita dal <a class="reference internal" href="#Re-raii"><span class="xref myst">RAII</span></a>.</p>
</section>
<section id="id1415">
<h4>Esempio, da non fare<a class="headerlink" href="#id1415" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()   // bad
{
    try {
        // ...
    }
    catch (...) {
        // no action
        throw;   // propagate exception
    }
}
</pre></div>
</div>
</section>
<section id="id1416">
<h4>Imposizione<a class="headerlink" href="#id1416" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare i blocchi-try nidificati.</p></li>
<li><p>Segnalare i file di codice sorgente con un rapporto troppo alto di blocchi-try-blocks a funzioni. (??? Problema: definire «troppo alto»)</p></li>
</ul>
</section>
</section>
<section id="e-18-minimize-the-use-of-explicit-try-catch">
<h3><a name="Re-catch"></a>E.18: Minimizzare l’uso di <code class="docutils literal notranslate"><span class="pre">try</span></code>/<code class="docutils literal notranslate"><span class="pre">catch</span></code> espliciti<a class="headerlink" href="#e-18-minimize-the-use-of-explicit-try-catch" title="Link to this heading">¶</a></h3>
<section id="id1417">
<h4>Motivo<a class="headerlink" href="#id1417" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">try</span></code>/<code class="docutils literal notranslate"><span class="pre">catch</span></code> è prolisso e gli usi non banali sono soggetti a errori.  <code class="docutils literal notranslate"><span class="pre">try</span></code>/<code class="docutils literal notranslate"><span class="pre">catch</span></code> può essere un segno di una gestione delle risorse non sistematica e/o di basso livello oppure soggetto a errori.</p>
</section>
<section id="id1418">
<h4>Esempio, Cattivo<a class="headerlink" href="#id1418" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(zstring s)
{
    Gadget* p;
    try {
        p = new Gadget(s);
        // ...
        delete p;
    }
    catch (Gadget_construction_failure) {
        delete p;
        throw;
    }
}
</pre></div>
</div>
<p>Questo codice è disordinato. Potrebbe esserci un leak dal puntatore semplice nel blocco <code class="docutils literal notranslate"><span class="pre">try</span></code>. Non tutte le eccezioni vengono gestite. Il <code class="docutils literal notranslate"><span class="pre">deleting</span></code> di un oggetto di cui è fallita la costruzione è quasi certamente un errore. Meglio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f2(zstring s)
{
    Gadget g {s};
}
</pre></div>
</div>
</section>
<section id="id1419">
<h4>Alternative<a class="headerlink" href="#id1419" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Gestori delle risorse appropriati e <a class="reference internal" href="#Re-raii"><span class="xref myst">RAII</span></a></p></li>
<li><p><a class="reference internal" href="#Re-finally"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">finally</span></code></span></a></p></li>
</ul>
</section>
<section id="id1420">
<h4>Imposizione<a class="headerlink" href="#id1420" title="Link to this heading">¶</a></h4>
<p>??? difficile, necessita di una euristica</p>
</section>
</section>
<section id="e-19-use-a-final-action-object-to-express-cleanup-if-no-suitable-resource-handle-is-available">
<h3><a name="Re-finally"></a>E.19: Usare un oggetto <code class="docutils literal notranslate"><span class="pre">final_action</span></code> per la pulizia [cleanup] se non è disponibile un gestore delle risorse adatto<a class="headerlink" href="#e-19-use-a-final-action-object-to-express-cleanup-if-no-suitable-resource-handle-is-available" title="Link to this heading">¶</a></h3>
<section id="id1421">
<h4>Motivo<a class="headerlink" href="#id1421" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">finally</span></code> dalle <a class="reference internal" href="#gsl-guidelines-support-library"><span class="xref myst">GSL</span></a> è meno “verboso” e più difficile da sbagliare rispetto al <code class="docutils literal notranslate"><span class="pre">try</span></code>/<code class="docutils literal notranslate"><span class="pre">catch</span></code>.</p>
</section>
<section id="id1422">
<h4>Esempio<a class="headerlink" href="#id1422" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int n)
{
    void* p = malloc(n);
    auto _ = gsl::finally([p] { free(p); });
    // ...
}
</pre></div>
</div>
</section>
<section id="id1423">
<h4>Nota<a class="headerlink" href="#id1423" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">finally</span></code> non è disordinato come <code class="docutils literal notranslate"><span class="pre">try</span></code>/<code class="docutils literal notranslate"><span class="pre">catch</span></code>, ma resta una soluzione ad-hoc. Preferire <a class="reference internal" href="#Re-raii"><span class="xref myst">oggetti per la gestione delle risorse</span></a>. Considerare <code class="docutils literal notranslate"><span class="pre">finally</span></code> come ultima risorsa.</p>
</section>
<section id="id1424">
<h4>Nota<a class="headerlink" href="#id1424" title="Link to this heading">¶</a></h4>
<p>L’uso di <code class="docutils literal notranslate"><span class="pre">finally</span></code> è un’alternativa sistematica e ragionevolmente pulita rispetto alla vecchia tecnica <a class="reference internal" href="#Re-no-throw-codes"><span class="xref myst">tecnica <code class="docutils literal notranslate"><span class="pre">goto</span> <span class="pre">exit;</span></code></span></a> per gestire la pulizia [cleanup] dove la gestione delle risorse non è sistematica.</p>
</section>
<section id="id1425">
<h4>Imposizione<a class="headerlink" href="#id1425" title="Link to this heading">¶</a></h4>
<p>Euristica: Rilevare <code class="docutils literal notranslate"><span class="pre">goto</span> <span class="pre">exit;</span></code></p>
</section>
</section>
<section id="e-25-if-you-can-t-throw-exceptions-simulate-raii-for-resource-management">
<h3><a name="Re-no-throw-raii"></a>E.25: Se non è possibile sollevare eccezioni, simulare il RAII per la gestione delle risorse<a class="headerlink" href="#e-25-if-you-can-t-throw-exceptions-simulate-raii-for-resource-management" title="Link to this heading">¶</a></h3>
<section id="id1426">
<h4>Motivo<a class="headerlink" href="#id1426" title="Link to this heading">¶</a></h4>
<p>Anche senza eccezioni, il <a class="reference internal" href="#Re-raii"><span class="xref myst">RAII</span></a> è solitamente il modo migliore e più sistematico per gestire le risorse.</p>
</section>
<section id="id1427">
<h4>Nota<a class="headerlink" href="#id1427" title="Link to this heading">¶</a></h4>
<p>La gestione degli errori con le eccezioni è il solo modo completo e sistematico per gestire errori non-locali nel C++. In particolare, la segnalazione non-intrusiva del fallimento della costruzione di un oggetto richiede un’eccezione. Segnalare gli errori in modo che non si possano ignorare richiede le eccezioni. Se non si possono usare eccezioni, si dovrebbero simulare al meglio.</p>
<p>La paura delle eccezioni è ingiustificata. Se utilizzato per circostanze eccezionali in un codice che non sia disseminato di puntatori e di complicate strutture di controllo, la gestione delle eccezioni è quasi sempre conveniente (nel tempo e nello spazio) e quasi sempre porta a un codice migliore. Ciò, ovviamente, presuppone una buona implementazione dei meccanismi di gestione delle eccezioni, che non è disponibile su tutti i sistemi. Ci sono anche casi in cui i problemi sopra indicati non si applicano, ma le eccezioni non possono essere utilizzate per altri motivi. Alcuni sistemi di [hard-real-time]  sono un esempio: Un’operazione deve essere completata entro un tempo fisso sia con una risposta corretta che con un errore. In assenza di adeguati strumenti per la stima del tempo, è difficile da garantire questo per le eccezioni. Tali sistemi (p.es. software per il controllo aereo) generalmente vietano anche l’uso della memoria dinamica (heap).</p>
<p>Quindi, la principale linea-guida per la gestione degli errori è «usare le eccezioni e il <a class="reference internal" href="#Re-raii"><span class="xref myst">RAII</span></a>». Questa sezione tratta i casi in cui o non si dispone di un’implementazione efficiente delle eccezioni o si fa un ingarbugliato codice vecchio stile (p.es., tantissimi puntatori, proprietà [ownership] mal definita, e tantissimi gestori degli errori non sistematici basati sul test dei codici di errori) in cui non è possibile introdurre una gestione delle eccezioni semplice e sistematica.</p>
<p>Prima di condannare le eccezioni o lamentarsi troppo del loro costo, si prendano in considerazione esempi d’uso dei <a class="reference internal" href="#Re-no-throw-codes"><span class="xref myst">codici di errore</span></a>. Considerare il costo e la complessità dell’uso dei codici di errore. Se si è preoccupati delle prestazioni, misurare.</p>
</section>
<section id="id1428">
<h4>Esempio<a class="headerlink" href="#id1428" title="Link to this heading">¶</a></h4>
<p>Si supponga di aver voluto scrivere</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void func(zstring arg)
{
    Gadget g {arg};
    // ...
}
</pre></div>
</div>
<p>Se il <code class="docutils literal notranslate"><span class="pre">gadget</span></code> non è ben costruito, <code class="docutils literal notranslate"><span class="pre">func</span></code> esce con un’eccezione. Se non si possono generare eccezioni, si può simulare questo stile RAII della gestione delle risorse aggiungendo la funzione membro <code class="docutils literal notranslate"><span class="pre">valid()</span></code> a <code class="docutils literal notranslate"><span class="pre">Gadget</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>error_indicator func(zstring arg)
{
    Gadget g {arg};
    if (!g.valid()) return gadget_construction_error;
    // ...
    return 0;   // zero indicates &quot;good&quot;
}
</pre></div>
</div>
<p>Il problema è, ovviamente, che ora il chiamante deve ricordarsi di controllare il valore di ritorno. Per invogliare a farlo, si consideri l’aggiunta di un <code class="docutils literal notranslate"><span class="pre">[[nodiscard]]</span></code>.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Sd-???"><span class="xref myst">Discussione</span></a></p>
</section>
<section id="id1429">
<h4>Imposizione<a class="headerlink" href="#id1429" title="Link to this heading">¶</a></h4>
<p>Possibile (solo) per specifiche versioni di questa idea: p.es., test per i controlli sistematici di <code class="docutils literal notranslate"><span class="pre">valid()</span></code> dopo la costruzione del gestore delle risorse</p>
</section>
</section>
<section id="e-26-if-you-can-t-throw-exceptions-consider-failing-fast">
<h3><a name="Re-no-throw-crash"></a>E.26: Se non è possibile sollevare eccezioni, si prenda in considerazione un veloce fallimento<a class="headerlink" href="#e-26-if-you-can-t-throw-exceptions-consider-failing-fast" title="Link to this heading">¶</a></h3>
<section id="id1430">
<h4>Motivo<a class="headerlink" href="#id1430" title="Link to this heading">¶</a></h4>
<p>Se non si può recuperare per bene, si può almeno uscire prima di fare troppi ulteriori danni.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Re-no-throw-raii"><span class="xref myst">Simulare il RAII</span></a></p>
</section>
<section id="id1431">
<h4>Nota<a class="headerlink" href="#id1431" title="Link to this heading">¶</a></h4>
<p>Se non si può essere sistematici sulla gestione degli errori, si consideri il «crash» come risposta a tutti gli errori che non si possono gestire localmente. Cioè, se non è possibile riprendersi da un errore nel contesto della funzione che l’ha rilevato, si chiama <code class="docutils literal notranslate"><span class="pre">abort()</span></code>, <code class="docutils literal notranslate"><span class="pre">quick_exit()</span></code>, o una funzione simile che attiverà qualche tipo di riavvio del sistema.</p>
<p>Nei sistemi con tantissimi processi e/o molti computer, ci si deve comunque aspettare e gestire dei crash fatali, ad esempio i guasti hardware. In questi casi, «crashando» si sta semplicemente lasciando la gestione degli errori al successivo livello del sistema.</p>
</section>
<section id="id1432">
<h4>Esempio<a class="headerlink" href="#id1432" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int n)
{
    // ...
    p = static_cast&lt;X*&gt;(malloc(n * sizeof(X)));
    if (!p) abort();     // abort if memory is exhausted
    // ...
}
</pre></div>
</div>
<p>La maggior parte dei programmi non è comunque in grado di gestire adeguatamente l’esaurimento della memoria. Ciò equivale a</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int n)
{
    // ...
    p = new X[n];    // throw if memory is exhausted (by default, terminate)
    // ...
}
</pre></div>
</div>
<p>Solitamente, è bene loggare il motivo del «crash» prima di uscire.</p>
</section>
<section id="id1433">
<h4>Imposizione<a class="headerlink" href="#id1433" title="Link to this heading">¶</a></h4>
<p>Difficile</p>
</section>
</section>
<section id="e-27-if-you-can-t-throw-exceptions-use-error-codes-systematically">
<h3><a name="Re-no-throw-codes"></a>E.27: Se non è possibile sollevare eccezioni, si usino sistematicamente i codici di errore<a class="headerlink" href="#e-27-if-you-can-t-throw-exceptions-use-error-codes-systematically" title="Link to this heading">¶</a></h3>
<section id="id1434">
<h4>Motivo<a class="headerlink" href="#id1434" title="Link to this heading">¶</a></h4>
<p>L’uso sistematico di qualsiasi strategia per la gestione degli errori minimizza le possibilità di dimenticarsi di gestire un errore.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Re-no-throw-raii"><span class="xref myst">Simulare il RAII</span></a></p>
</section>
<section id="id1435">
<h4>Nota<a class="headerlink" href="#id1435" title="Link to this heading">¶</a></h4>
<p>Ci sono diversi problemi da affrontare:</p>
<ul class="simple">
<li><p>Come trasmettere l’indicazione di un errore dall’esterno di una funzione?</p></li>
<li><p>Come si rilasciano tutte le risorse da una funzione prima di uscire per un errore?</p></li>
<li><p>Cosa usare per indicare un errore?</p></li>
</ul>
<p>In generale, la restituzione di un indicatore di errore implica la restituzione di due valori: Il risultato e l’indicatore dell’errore. L’indicatore dell’errore può far parte dell’oggetto, p.es. un oggetto può avere un indicatore <code class="docutils literal notranslate"><span class="pre">valid()</span></code> o si può ritornare una coppia di valori.</p>
</section>
<section id="id1436">
<h4>Esempio<a class="headerlink" href="#id1436" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Gadget make_gadget(int n)
{
    // ...
}

void user()
{
    Gadget g = make_gadget(17);
    if (!g.valid()) {
            // error handling
    }
    // ...
}
</pre></div>
</div>
<p>Questo approccio è del tipo <a class="reference internal" href="#Re-no-throw-raii"><span class="xref myst">gestione delle risorse RAII simulata</span></a>. La funzione <code class="docutils literal notranslate"><span class="pre">valid()</span></code> potrebbe restituire un <code class="docutils literal notranslate"><span class="pre">error_indicator</span></code> (p.es. un membro di un’enumerazione <code class="docutils literal notranslate"><span class="pre">error_indicator</span></code>).</p>
</section>
<section id="id1437">
<h4>Esempio<a class="headerlink" href="#id1437" title="Link to this heading">¶</a></h4>
<p>Cosa succede se non si può o non si vuole modificare il tipo <code class="docutils literal notranslate"><span class="pre">Gadget</span></code>? In questo caso si deve ritornare una coppia di valori. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>std::pair&lt;Gadget, error_indicator&gt; make_gadget(int n)
{
    // ...
}

void user()
{
    auto r = make_gadget(17);
    if (!r.second) {
            // error handling
    }
    Gadget&amp; g = r.first;
    // ...
}
</pre></div>
</div>
<p>Come mostrato, <code class="docutils literal notranslate"><span class="pre">std::pair</span></code> è un possibile tipo di ritorno. Qualcuno preferisce un tipo specifico. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Gval make_gadget(int n)
{
    // ...
}

void user()
{
    auto r = make_gadget(17);
    if (!r.err) {
            // error handling
    }
    Gadget&amp; g = r.val;
    // ...
}
</pre></div>
</div>
<p>Uno dei motivi per preferire un tipo di ritorno specifico è quello di avere dei nomi per i suoi membri, piuttosto che i criptici <code class="docutils literal notranslate"><span class="pre">first</span></code> e <code class="docutils literal notranslate"><span class="pre">second</span></code> evitando confusione con altri utilizzi di <code class="docutils literal notranslate"><span class="pre">std::pair</span></code>.</p>
</section>
<section id="id1438">
<h4>Esempio<a class="headerlink" href="#id1438" title="Link to this heading">¶</a></h4>
<p>In generale, è necessario ripulire prima di uscire per un errore. Questo può risultare caotico:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>std::pair&lt;int, error_indicator&gt; user()
{
    Gadget g1 = make_gadget(17);
    if (!g1.valid()) {
        return {0, g1_error};
    }

    Gadget g2 = make_gadget(31);
    if (!g2.valid()) {
        cleanup(g1);
        return {0, g2_error};
    }

    // ...

    if (all_foobar(g1, g2)) {
        cleanup(g2);
        cleanup(g1);
        return {0, foobar_error};
    }

    // ...

    cleanup(g2);
    cleanup(g1);
    return {res, 0};
}
</pre></div>
</div>
<p>La simulazione del RAII può risultare complicata, specie nelle funzioni con più risorse e molteplici tipi di errori. Una tecnica non rara consiste nel raccogliere la pulizia alla fine della funzione per evitare ripetizioni (si noti che l’ulteriore scope attorno a <code class="docutils literal notranslate"><span class="pre">g2</span></code> non è desiderabile ma necessario per compilare la versione col <code class="docutils literal notranslate"><span class="pre">goto</span></code>):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>std::pair&lt;int, error_indicator&gt; user()
{
    error_indicator err = 0;
    int res = 0;

    Gadget g1 = make_gadget(17);
    if (!g1.valid()) {
        err = g1_error;
        goto g1_exit;
    }

    {
        Gadget g2 = make_gadget(31);
        if (!g2.valid()) {
            err = g2_error;
            goto g2_exit;
        }

        if (all_foobar(g1, g2)) {
            err = foobar_error;
            goto g2_exit;
        }

        // ...

    g2_exit:
        if (g2.valid()) cleanup(g2);
    }

g1_exit:
    if (g1.valid()) cleanup(g1);
    return {res, err};
}
</pre></div>
</div>
<p>Più grande è la funzione, più allettante diventa questa tecnica. <code class="docutils literal notranslate"><span class="pre">finally</span></code> può <a class="reference internal" href="#Re-finally"><span class="xref myst">semplificare un po”</span></a>. Inoltre, più grande è il programma, più diventa difficile diventa applicare sistematicamente una strategia di gestione degli errori basata su indicatori di errore.</p>
<p>Si deve <a class="reference internal" href="#Re-throw"><span class="xref myst">preferire la gestione degli errori basata sulle eccezioni</span></a> e si raccomanda di <a class="reference internal" href="#Rf-single"><span class="xref myst">fare funzioni brevi</span></a>.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Sd-???"><span class="xref myst">Discussione</span></a></p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Rf-out-multi"><span class="xref myst">Ritornare valori multipli</span></a></p>
</section>
<section id="id1439">
<h4>Imposizione<a class="headerlink" href="#id1439" title="Link to this heading">¶</a></h4>
<p>Difficile.</p>
</section>
</section>
<section id="e-28-avoid-error-handling-based-on-global-state-e-g-errno">
<h3><a name="Re-no-throw"></a>E.28: Evitare la gestione degli errori basata su uno stato globale (p.es. <code class="docutils literal notranslate"><span class="pre">errno</span></code>)<a class="headerlink" href="#e-28-avoid-error-handling-based-on-global-state-e-g-errno" title="Link to this heading">¶</a></h3>
<section id="id1440">
<h4>Motivo<a class="headerlink" href="#id1440" title="Link to this heading">¶</a></h4>
<p>Lo stato globale è difficile da gestire ed è facile che ci si dimentichi di controllarlo. Quando è stata l’ultima volta che si è testato il valore di ritorno di <code class="docutils literal notranslate"><span class="pre">printf()</span></code>?</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Re-no-throw-raii"><span class="xref myst">Simulare il RAII</span></a></p>
</section>
<section id="id1441">
<h4>Esempio, cattivo<a class="headerlink" href="#id1441" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int last_err;

void f(int n)
{
    // ...
    p = static_cast&lt;X*&gt;(malloc(n * sizeof(X)));
    if (!p) last_err = -1;     // error if memory is exhausted
    // ...
}
</pre></div>
</div>
</section>
<section id="id1442">
<h4>Nota<a class="headerlink" href="#id1442" title="Link to this heading">¶</a></h4>
<p>La gestione degli errori in stile C è basata sulla variabile globale <code class="docutils literal notranslate"><span class="pre">errno</span></code>, quindi è essenzialmente impossibile evitare completamente questo stile.</p>
</section>
<section id="id1443">
<h4>Imposizione<a class="headerlink" href="#id1443" title="Link to this heading">¶</a></h4>
<p>Difficile.</p>
</section>
</section>
<section id="e-30-don-t-use-exception-specifications">
<h3><a name="Re-specifications"></a>E.30: Non utilizzare le specifiche delle eccezioni<a class="headerlink" href="#e-30-don-t-use-exception-specifications" title="Link to this heading">¶</a></h3>
<section id="id1444">
<h4>Motivo<a class="headerlink" href="#id1444" title="Link to this heading">¶</a></h4>
<p>Le specifiche delle eccezioni [exception specification] indeboliscono la gestione degli errori, impongono un costo nel run-time, e sono state rimosse dallo standard del C++.</p>
</section>
<section id="id1445">
<h4>Esempio<a class="headerlink" href="#id1445" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int use(int arg)
    throw(X, Y)
{
    // ...
    auto x = f(arg);
    // ...
}
</pre></div>
</div>
<p>Se <code class="docutils literal notranslate"><span class="pre">f()</span></code> solleva un’eccezione diversa da <code class="docutils literal notranslate"><span class="pre">X</span></code> e da <code class="docutils literal notranslate"><span class="pre">Y</span></code> viene richiamato il gestore degli imprevisti, che per default termina. Questo va bene, ma mettiamo che si sia verificato che questo non avvenga e <code class="docutils literal notranslate"><span class="pre">f</span></code> viene modificato per sollevare una nuova eccezione <code class="docutils literal notranslate"><span class="pre">Z</span></code>, ci si ritrova con un crash tra le mani a meno di non cambiare <code class="docutils literal notranslate"><span class="pre">use()</span></code> (e ri-testare il tutto). Il problema è che <code class="docutils literal notranslate"><span class="pre">f()</span></code> potrebbe stare in una libreria di cui non si ha il controllo e la nuova eccezione è qualcosa con cui <code class="docutils literal notranslate"><span class="pre">use()</span></code> non può farci nulla o a cui non è in qualche modo interessata. Si può cambiare <code class="docutils literal notranslate"><span class="pre">use()</span></code> per passarle <code class="docutils literal notranslate"><span class="pre">Z</span></code>, ma probabilmente sarà necessario modificare i chiamanti di <code class="docutils literal notranslate"><span class="pre">use()</span></code>. E questo diventa subito ingestibile. In alternative, si può aggiungere un <code class="docutils literal notranslate"><span class="pre">try</span></code>-<code class="docutils literal notranslate"><span class="pre">catch</span></code> a <code class="docutils literal notranslate"><span class="pre">use()</span></code> per mappare <code class="docutils literal notranslate"><span class="pre">Z</span></code> in un’eccezione accettabile. Anche questo, diventa presto ingestibile. Si noti che le modifiche al set di eccezioni spesso avvengono al livello più basso di un sistema (p.es., a causa di modifiche ad una libreria di network o da qualche parte nel middleware), pertanto le modifiche «risalgono» per tutta la catena delle chiamate. In un codice di larghe dimensioni, ciò potrebbe significare che nessuno potrà aggiornarsi a una nuova versione di una libreria finché non viene siano modificati tutti gli utenti. Se <code class="docutils literal notranslate"><span class="pre">use()</span></code> fa parte di una libreria, potrebbe non essere possibile aggiornarla perché un cambiamento potrebbe implicare clienti sconosciuti.</p>
<p>La politica di far propagare le eccezioni fino a raggiungere una funzione potenzialmente in grado di gestirla si è dimostrata valida nel corso degli anni.</p>
</section>
<section id="id1446">
<h4>Nota<a class="headerlink" href="#id1446" title="Link to this heading">¶</a></h4>
<p>No. Non sarebbe stato meglio se le specifiche delle eccezioni sarebbero state imposte staticamente. Per esempio, si veda <a class="reference internal" href="#Stroustrup94"><span class="xref myst">Stroustrup94</span></a>.</p>
</section>
<section id="id1447">
<h4>Nota<a class="headerlink" href="#id1447" title="Link to this heading">¶</a></h4>
<p>Se non è possibile generare alcuna eccezione, si usa <a class="reference internal" href="#Re-noexcept"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">noexcept</span></code></span></a>.</p>
</section>
<section id="id1448">
<h4>Imposizione<a class="headerlink" href="#id1448" title="Link to this heading">¶</a></h4>
<p>Segnalare ogni specifica di eccezione [exception specification].</p>
</section>
</section>
<section id="e-31-properly-order-your-catch-clauses">
<h3><a name="Re_catch"></a>E.31: Ordinare in modo appropriato le proprie istruzioni <code class="docutils literal notranslate"><span class="pre">catch</span></code><a class="headerlink" href="#e-31-properly-order-your-catch-clauses" title="Link to this heading">¶</a></h3>
<section id="id1449">
<h4>Motivo<a class="headerlink" href="#id1449" title="Link to this heading">¶</a></h4>
<p>Le istruzioni <code class="docutils literal notranslate"><span class="pre">catch</span></code> vengono valutate nell’ordine con cui appaiono e un’istruzione può nasconderne altre.</p>
</section>
<section id="id1450">
<h4>Esempio, cattivo<a class="headerlink" href="#id1450" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    // ...
    try {
            // ...
    }
    catch (Base&amp; b) { /* ... */ }
    catch (Derived&amp; d) { /* ... */ }
    catch (...) { /* ... */ }
    catch (std::exception&amp; e) { /* ... */ }
}
</pre></div>
</div>
<p>Se &lt;<code class="docutils literal notranslate"><span class="pre">Derived</span></code> è derivato da <code class="docutils literal notranslate"><span class="pre">Base</span></code> il gestore <code class="docutils literal notranslate"><span class="pre">Derived</span></code> non verrà mai invocato. Il gestore «acchiappa tutto» garantisce che il gestore <code class="docutils literal notranslate"><span class="pre">std::exception</span></code> non sia mai invocato.</p>
</section>
<section id="id1451">
<h4>Imposizione<a class="headerlink" href="#id1451" title="Link to this heading">¶</a></h4>
<p>Segnalare tutti i «gestori nascosti».</p>
</section>
</section>
</section>
<section id="con-constants-and-immutability">
<h2><a name="S-const"></a>Con: Costanti e immutabilità<a class="headerlink" href="#con-constants-and-immutability" title="Link to this heading">¶</a></h2>
<p>Non può esserci una condizione di conflitto su una costante. È più facile ragionare su un programma quando molti degli oggetti non possono cambiare i loro valori. Le interfacce che promettono «nessuna modifica» degli oggetti passati come argomenti aumentano notevolmente la leggibilità.</p>
<p>Riepilogo delle regole sulle costanti:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rconst-immutable"><span class="xref myst">Con.1: Per default, creare oggetti immutabili</span></a></p></li>
<li><p><a class="reference internal" href="#Rconst-fct"><span class="xref myst">Con.2: Per default, creare le funzioni membro <code class="docutils literal notranslate"><span class="pre">const</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rconst-ref"><span class="xref myst">Con.3: By Per default, passare puntatori e riferimenti ai <code class="docutils literal notranslate"><span class="pre">const</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rconst-const"><span class="xref myst">Con.4: Utilizzare <code class="docutils literal notranslate"><span class="pre">const</span></code> per definire oggetti con valori che non cambiano dopo la costruzione</span></a></p></li>
<li><p><a class="reference internal" href="#Rconst-constexpr"><span class="xref myst">Con.5: Utilizzare <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> per i valori calcolabili durante la compilazione</span></a></p></li>
</ul>
<section id="con-1-by-default-make-objects-immutable">
<h3><a name="Rconst-immutable"></a>Con.1: Per default, creare oggetti immutabili<a class="headerlink" href="#con-1-by-default-make-objects-immutable" title="Link to this heading">¶</a></h3>
<section id="id1452">
<h4>Motivo<a class="headerlink" href="#id1452" title="Link to this heading">¶</a></h4>
<p>Gli oggetti immutabili sono più facili da gestire, quindi si creino oggetti non-<code class="docutils literal notranslate"><span class="pre">const</span></code> solo quando se ne deve cambiare il valore. Si previene una modifica del valore accidentale o difficile da notare .</p>
</section>
<section id="id1453">
<h4>Esempio<a class="headerlink" href="#id1453" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (const int i : c) cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;    // just reading: const

for (int i : c) cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;          // BAD: just reading
</pre></div>
</div>
</section>
<section id="id1454">
<h4>Eccezioni<a class="headerlink" href="#id1454" title="Link to this heading">¶</a></h4>
<p>Una variabile locale restituita per valore e che è più economica da spostare rispetto a copy non dovrebbe essere dichiarata <code class="docutils literal notranslate"><span class="pre">const</span></code> poiché potrebbe forzare una copia non necessaria.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>std::vector&lt;int&gt; f(int i)
{
    std::vector&lt;int&gt; v{ i, i, i };  // const not needed
    return v;
}
</pre></div>
</div>
<p>I parametri della funzione passati per valore vengono raramente cambiati, ma altrettanto raramente dichiarati <code class="docutils literal notranslate"><span class="pre">const</span></code>. Per evitare confusione ed un sacco di falsi positivi, non imporre questa regola ai parametri delle funzioni.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void g(const int i) { ... }  // pedantic
</pre></div>
</div>
<p>Si noti che un parametro della funzione è una variabile locale, quindi le sue modifiche sono locali.</p>
</section>
<section id="id1455">
<h4>Imposizione<a class="headerlink" href="#id1455" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare le variabili non-<code class="docutils literal notranslate"><span class="pre">const</span></code> che non sono state modificate (ad eccezione dei parametri per evitare molti falsi positivi
e le variabili locali restituite)</p></li>
</ul>
</section>
</section>
<section id="con-2-by-default-make-member-functions-const">
<h3><a name="Rconst-fct"></a>Con.2: Per default, creare le funzioni membro <code class="docutils literal notranslate"><span class="pre">const</span></code><a class="headerlink" href="#con-2-by-default-make-member-functions-const" title="Link to this heading">¶</a></h3>
<section id="id1456">
<h4>Motivo<a class="headerlink" href="#id1456" title="Link to this heading">¶</a></h4>
<p>Una funzione membro dovrebbe essere segnata come <code class="docutils literal notranslate"><span class="pre">const</span></code> a meno che non modifiche lo stato osservabile dell’oggetto. Ciò fornisce una dichiarazione più precisa dello scopo del progetto, una migliore leggibilità, più errori rilevati dal compilatore e talvolta maggiori possibilità di ottimizzazione.</p>
</section>
<section id="id1457">
<h4>Esempio, cattivo<a class="headerlink" href="#id1457" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Point {
    int x, y;
public:
    int getx() { return x; }    // BAD, should be const as it doesn&#39;t modify the object&#39;s state
    // ...
};

void f(const Point&amp; pt)
{
    int x = pt.getx();          // ERROR, doesn&#39;t compile because getx was not marked const
}
</pre></div>
</div>
</section>
<section id="id1458">
<h4>Nota<a class="headerlink" href="#id1458" title="Link to this heading">¶</a></h4>
<p>Non è intrinsecamente un male passare un puntatore o un riferimento come non-<code class="docutils literal notranslate"><span class="pre">const</span></code>, ma dovrebbe essere fatto solo quando si suppone che la funzione chiamata modifichi l’oggetto. Chi legge il codice deve presumere che una funzione che prende un «semplice» <code class="docutils literal notranslate"><span class="pre">T*</span></code> o <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>, modificherà l’oggetto a cui ci si riferisce. Se non lo fa per adesso, potrebbe farlo in seguito senza obbligare la ricompilazione.</p>
</section>
<section id="id1459">
<h4>Nota<a class="headerlink" href="#id1459" title="Link to this heading">¶</a></h4>
<p>Ci sono dei sorgenti/librerie che propongono funzioni che dichiarano un <code class="docutils literal notranslate"><span class="pre">T*</span></code> anche se quelle funzioni non modificano quel <code class="docutils literal notranslate"><span class="pre">T</span></code>. Questo è un problema per chi modernizza il codice. Si può</p>
<ul class="simple">
<li><p>aggiornare la libreria affinché abbia i <code class="docutils literal notranslate"><span class="pre">const</span></code> corretti; soluzione preferita per il lungo-termine</p></li>
<li><p>eseguire il «cast di  <code class="docutils literal notranslate"><span class="pre">const</span></code>»; <a class="reference internal" href="#Res-casts-const"><span class="xref myst">meglio evitare</span></a></p></li>
<li><p>fornire una funzione wrapper</p></li>
</ul>
<p>Esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int* p);   // old code: f() does not modify `*p`
void f(const int* p) { f(const_cast&lt;int*&gt;(p)); } // wrapper
</pre></div>
</div>
<p>Si noti che la soluzione del wrapper è una patch che si dovrebbe usare solo quando la dichiarazione di <code class="docutils literal notranslate"><span class="pre">f()</span></code> non può essere modificata, p.es. perché sta in una libreria che non può essere modificata.</p>
</section>
<section id="id1460">
<h4>Nota<a class="headerlink" href="#id1460" title="Link to this heading">¶</a></h4>
<p>Una funzione membro <code class="docutils literal notranslate"><span class="pre">const</span></code> può modificare il valore di un oggetto che sia <code class="docutils literal notranslate"><span class="pre">mutable</span></code> o a cui si acceda con un puntatore membro. Un uso comune è mantenere una cache anziché eseguire ripetutamente un calcolo complicato. Per esempio qui c’è una <code class="docutils literal notranslate"><span class="pre">Date</span></code> che mette in una cache (memoizza [!=memorizza]) la sua rappresentazione stringa per semplificarne i ripetuti usi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Date {
public:
    // ...
    const string&amp; string_ref() const
    {
        if (string_val == &quot;&quot;) compute_string_rep();
        return string_val;
    }
    // ...
private:
    void compute_string_rep() const;    // compute string representation and place it in string_val
    mutable string string_val;
    // ...
};
</pre></div>
</div>
<p>Un altro modo per dire che la proprietà <code class="docutils literal notranslate"><span class="pre">const</span></code> non è transitiva. È possibile per una funzione membro <code class="docutils literal notranslate"><span class="pre">const</span></code> modificare il valore di membri <code class="docutils literal notranslate"><span class="pre">mutable</span></code> e il valore di oggetti cui si accede tramite puntatori non-<code class="docutils literal notranslate"><span class="pre">const</span></code>. È compito della classe garantire che tale mutazione venga effettuata solo quando ha senso secondo la semantica (invarianti) che offre alla sua utenza.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Ri-pimpl"><span class="xref myst">Pimpl</span></a></p>
</section>
<section id="id1461">
<h4>Imposizione<a class="headerlink" href="#id1461" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare una funzione membro non contrassegnata con <code class="docutils literal notranslate"><span class="pre">const</span></code>, ma che non esegue un’operazione non-<code class="docutils literal notranslate"><span class="pre">const</span></code> su alcun dato membro.</p></li>
</ul>
</section>
</section>
<section id="con-3-by-default-pass-pointers-and-references-to-consts">
<h3><a name="Rconst-ref"></a>Con.3: Per default, passare puntatori e riferimenti ai <code class="docutils literal notranslate"><span class="pre">const</span></code><a class="headerlink" href="#con-3-by-default-pass-pointers-and-references-to-consts" title="Link to this heading">¶</a></h3>
<section id="id1462">
<h4>Motivo<a class="headerlink" href="#id1462" title="Link to this heading">¶</a></h4>
<p>Per evitare che una funzione chiamata cambi valore inaspettatamente.  È molto più facile gestire i programmi quando le funzioni chiamate non modificano lo stato.</p>
</section>
<section id="id1463">
<h4>Esempio<a class="headerlink" href="#id1463" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(char* p);        // does f modify *p? (assume it does)
void g(const char* p);  // g does not modify *p
</pre></div>
</div>
</section>
<section id="id1464">
<h4>Nota<a class="headerlink" href="#id1464" title="Link to this heading">¶</a></h4>
<p>Non è intrinsecamente un male passare un puntatore o un riferimento come non-<code class="docutils literal notranslate"><span class="pre">const</span></code>, ma dovrebbe essere fatto solo quando si suppone che la funzione chiamata modifichi l’oggetto.</p>
</section>
<section id="id1465">
<h4>Nota<a class="headerlink" href="#id1465" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="#Res-casts-const"><span class="xref myst">Non eseguire il cast da un <code class="docutils literal notranslate"><span class="pre">const</span></code></span></a>.</p>
</section>
<section id="id1466">
<h4>Imposizione<a class="headerlink" href="#id1466" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare una funzione che non modifica un oggetto passato per puntatore o riferimento non-<code class="docutils literal notranslate"><span class="pre">const</span></code></p></li>
<li><p>Segnalare una funzione che (utilizzando il cast) modifica un oggetto passato per puntatore o riferimento <code class="docutils literal notranslate"><span class="pre">const</span></code></p></li>
</ul>
</section>
</section>
<section id="con-4-use-const-to-define-objects-with-values-that-do-not-change-after-construction">
<h3><a name="Rconst-const"></a>Con.4: Utilizzare <code class="docutils literal notranslate"><span class="pre">const</span></code> per definire oggetti con valori che non cambiano dopo la costruzione<a class="headerlink" href="#con-4-use-const-to-define-objects-with-values-that-do-not-change-after-construction" title="Link to this heading">¶</a></h3>
<section id="id1467">
<h4>Motivo<a class="headerlink" href="#id1467" title="Link to this heading">¶</a></h4>
<p>Evitare sorprese dalla modifica inaspettata dei valori degli oggetti.</p>
</section>
<section id="id1468">
<h4>Esempio<a class="headerlink" href="#id1468" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    int x = 7;
    const int y = 9;

    for (;;) {
        // ...
    }
    // ...
}
</pre></div>
</div>
<p>Dato che <code class="docutils literal notranslate"><span class="pre">x</span></code> non è <code class="docutils literal notranslate"><span class="pre">const</span></code>, si deve presumere che venga modificato da qualche parte nel ciclo.</p>
</section>
<section id="id1469">
<h4>Imposizione<a class="headerlink" href="#id1469" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare le variabili non-<code class="docutils literal notranslate"><span class="pre">const</span></code> non modificate.</p></li>
</ul>
</section>
</section>
<section id="con-5-use-constexpr-for-values-that-can-be-computed-at-compile-time">
<h3><a name="Rconst-constexpr"></a>Con.5: Utilizzare <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> per i valori calcolabili durante la compilazione<a class="headerlink" href="#con-5-use-constexpr-for-values-that-can-be-computed-at-compile-time" title="Link to this heading">¶</a></h3>
<section id="id1470">
<h4>Motivo<a class="headerlink" href="#id1470" title="Link to this heading">¶</a></h4>
<p>Migliori prestazioni, miglior controllo in fase di compilazione, valutazione garantita durante la compilazione, nessuna possibilità di conflitti.</p>
</section>
<section id="id1471">
<h4>Esempio<a class="headerlink" href="#id1471" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double x = f(2);            // possible run-time evaluation
const double y = f(2);      // possible run-time evaluation
constexpr double z = f(2);  // error unless f(2) can be evaluated at compile time
</pre></div>
</div>
</section>
<section id="id1472">
<h4>Nota<a class="headerlink" href="#id1472" title="Link to this heading">¶</a></h4>
<p>Cfr. F.4.</p>
</section>
<section id="id1473">
<h4>Imposizione<a class="headerlink" href="#id1473" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare le condizioni <code class="docutils literal notranslate"><span class="pre">const</span></code> con inizializzatori di espressioni costanti.</p></li>
</ul>
</section>
</section>
</section>
<section id="t-templates-and-generic-programming">
<h2><a name="S-templates"></a>T: Template e programmazione generica<a class="headerlink" href="#t-templates-and-generic-programming" title="Link to this heading">¶</a></h2>
<p>La «programmazione generica» è quella che utilizza tipi e algoritmi parametrizzati dai tipi, dai valori e dagli algoritmi. Nel C++, la programmazione generica è supportata dal meccanismo dei <code class="docutils literal notranslate"><span class="pre">template</span></code> del linguaggio.</p>
<p>Gli argomenti delle funzioni generiche sono caratterizzati da un insieme di requisiti sui tipi degli argomenti e sui valori coinvolti. Nel C++, questi requisiti sono espressi da predicati di compilazione chiamati concetti [concept].</p>
<p>I template si possono usare anche per la meta-programmazione; vale a dire, programmi che compongono il codice in fase di compilazione.</p>
<p>Una nozione centrale nella programmazione generica sono i  «concetti»; vale a dire, i requisiti sugli argomenti dei template presenti come predicati in fase di compilazione. I «Concept» sono stati standardizzati nel C++20, sebbene siano stati resi disponibili per la prima volta, con una sintassi leggermente più vecchia, in GCC 6.1.</p>
<p>Riepilogo delle regole sui template:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rt-raise"><span class="xref myst">T.1: Utilizzare i template per elevare il livello di astrazione del codice</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-algo"><span class="xref myst">T.2: Utilizzare i template per esprimere gli algoritmi che si applicano a molti tipi di argomenti</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-cont"><span class="xref myst">T.3: Utilizzare i template per esprimere contenitori e [range]</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-expr"><span class="xref myst">T.4: Utilizzare i template per esprimere la gestione dell’albero sintattico</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-generic-oo"><span class="xref myst">T.5: Combinare la tecnica generica e la OO per amplificane i punti di forza, non i loro costi</span></a></p></li>
</ul>
<p>Riepilogo delle regole sull’uso dei concetti:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rt-concepts"><span class="xref myst">T.10: Specificare i concetti per tutti gli argomenti dei template</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-std-concepts"><span class="xref myst">T.11: Quando possibile utilizzare i concetti standard</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-auto"><span class="xref myst">T.12: Preferire i nomi dei concetti ad <code class="docutils literal notranslate"><span class="pre">auto</span></code> per le variabili locali</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-shorthand"><span class="xref myst">T.13: Preferire la notazione abbreviata per i concetti semplici, con un argomento di un solo tipo</span></a></p></li>
<li><p>???</p></li>
</ul>
<p>Riepilogo delle regole sulla definizione dei concetti:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rt-low"><span class="xref myst">T.20: Evitare «concetti» senza una semantica significativa</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-complete"><span class="xref myst">T.21: Richiedere un set completo di operazioni per un concetto</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-axiom"><span class="xref myst">T.22: Specificare gli assiomi per i concetti</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-refine"><span class="xref myst">T.23: Differenziare un concetto speciale dal suo caso più generale aggiungendo nuovi schemi di utilizzo</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-tag"><span class="xref myst">T.24: Usare classi tag o [trait] per differenziare i concetti che hanno solamente una semantica diversa</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-not"><span class="xref myst">T.25: Evitare i vincoli complementari</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-use"><span class="xref myst">T.26: Preferire la definizione dei concetti in termini di schemi d’uso anziché la semplice sintassi</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-???"><span class="xref myst">T.30: Usare con parsimonia la negazione del concetto (<code class="docutils literal notranslate"><span class="pre">!C&lt;T&gt;</span></code>) per esprimere piccole differenze</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-???"><span class="xref myst">T.31: Usare con parsimonia la disgiunzione del concetto (<code class="docutils literal notranslate"><span class="pre">C1&lt;T&gt;</span> <span class="pre">||</span> <span class="pre">C2&lt;T&gt;</span></code>) per esprimere le alternative</span></a></p></li>
<li><p>???</p></li>
</ul>
<p>Riepilogo delle regole sull’interfaccia dei template:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rt-fo"><span class="xref myst">T.40: Usare oggetti funzione per passare le operazioni agli algoritmi</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-essential"><span class="xref myst">T.41: Richiedere solo le proprietà essenziali nei concetti di un template</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-alias"><span class="xref myst">T.42: Usare gli alias dei template per semplificare la notazione e nascondere i dettagli implementativi</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-using"><span class="xref myst">T.43: Preferire <code class="docutils literal notranslate"><span class="pre">using</span></code> a <code class="docutils literal notranslate"><span class="pre">typedef</span></code> per definire gli alias</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-deduce"><span class="xref myst">T.44: Usare template di funzioni per dedurre i tipi degli argomenti della classe (dove fattibile)</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-regular"><span class="xref myst">T.46: Richiedere che gli argomenti template siano almeno semi-regolari</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-visible"><span class="xref myst">T.47: Evitare i template senza vincoli molto visibili con nomi comuni</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-concept-def"><span class="xref myst">T.48: Se il compilatore non supporta i concetti, simularli con <code class="docutils literal notranslate"><span class="pre">enable_if</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rt-erasure"><span class="xref myst">T.49: Dove possibile, evitare la [type-erasure]</span></a></p></li>
</ul>
<p>Riepilogo delle regole sulla definizione dei template:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rt-depend"><span class="xref myst">T.60: Minimizzare le dipendenze dal contesto di un template</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-scary"><span class="xref myst">T.61: Non sovra-parametrizzare i membri (SCARY)</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-nondependent"><span class="xref myst">T.62: Porre i membri della classe template non-dipendenti in una classe base non-template</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-specialization"><span class="xref myst">T.64: Usare la specializzazione per fornire implementazioni alternative di classi template</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-tag-dispatch"><span class="xref myst">T.65: Usare il [tag dispatch] per fornire implementazioni alternative delle funzioni</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-specialization2"><span class="xref myst">T.67: Usare la specializzazione per fornire implementazioni alternative per i tipi irregolari</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-cast"><span class="xref myst">T.68: Usare <code class="docutils literal notranslate"><span class="pre">{}</span></code> anziché <code class="docutils literal notranslate"><span class="pre">()</span></code> nei template per evitare ambiguità</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-customization"><span class="xref myst">T.69: All’interno di un template, non effettuare una chiamata di funzione non-membro non-qualificata a meno che non lo si intenda come un punto di personalizzazione</span></a></p></li>
</ul>
<p>Riepilogo delle regole sulla gerarchia dei template:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rt-hier"><span class="xref myst">T.80: Non rendere ingenuamente template una gerarchia di classi</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-array"><span class="xref myst">T.81: Non mischiare le gerarchie con gli array</span></a> // ??? da qualche parte nelle «gerarchie»</p></li>
<li><p><a class="reference internal" href="#Rt-linear"><span class="xref myst">T.82: Linearizzare una gerarchia quando le funzioni virtuali sono indesiderabili</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-virtual"><span class="xref myst">T.83: Non dichiarare virtuale una funzione membro template</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-abi"><span class="xref myst">T.84: Usare un nucleo implementativo non-template per fornire un’interfaccia ABI stabile</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-???"><span class="xref myst">T.??: ????</span></a></p></li>
</ul>
<p>Riepilogo delle regole sui template variadici:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rt-variadic"><span class="xref myst">T.100: Usare i template variadici quando c’è bisogno di una funzione che accetti un numero variabile di argomenti di vari tipi</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-variadic-pass"><span class="xref myst">T.101: ??? Come passare gli argomenti ad un template variadico ???</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-variadic-process"><span class="xref myst">T.102: ??? Come passare gli argomenti ad un template variadico ???</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-variadic-not"><span class="xref myst">T.103: Non usare i template variadici per liste di argomenti omogenei</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-???"><span class="xref myst">T.??: ????</span></a></p></li>
</ul>
<p>Riepilogo delle regole sulla meta-programmazione:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rt-metameta"><span class="xref myst">T.120: Usare la meta-programmazione template solo quando è veramente necessario</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-emulate"><span class="xref myst">T.121: Usare la meta-programmazione template soprattutto per emulare i concetti</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-tmp"><span class="xref myst">T.122: Usare i template (solitamente alias di template) per elaborare i tipi in fase di compilazione</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-fct"><span class="xref myst">T.123: Usare funzioni <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> per elaborare i valori in fase di compilazione</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-std-tmp"><span class="xref myst">T.124: Preferire l’uso delle funzioni TMP della libreria standard</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-lib"><span class="xref myst">T.125: Se c’è bisogno di andare oltre le funzioni TMP della libreria standard, usare una libreria esistente</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-???"><span class="xref myst">T.??: ????</span></a></p></li>
</ul>
<p>Riepilogo delle altre regole sui template:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rt-name"><span class="xref myst">T.140: Se un’operazione può essere riutilizzata, le si assegna un nome</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-lambda"><span class="xref myst">T.141: Usare una lambda anonima se si necessita di un semplice oggetto funzione in un solo posto</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-var"><span class="xref myst">T.142: Usare le variabili template per semplificare la notazione</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-non-generic"><span class="xref myst">T.143: Non scrivere involontariamente codice non-generico</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-specialize-function"><span class="xref myst">T.144: Non specializzare le funzioni template</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-check-class"><span class="xref myst">T.150: Verificare che a una classe corrisponda un concetto utilizzando <code class="docutils literal notranslate"><span class="pre">static_assert</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rt-???"><span class="xref myst">T.??: ????</span></a></p></li>
</ul>
<section id="t-gp-generic-programming">
<h3><a name="SS-GP"></a>T.gp: Programmazione generica<a class="headerlink" href="#t-gp-generic-programming" title="Link to this heading">¶</a></h3>
<p>La «programmazione generica» è quella che utilizza tipi e algoritmi parametrizzati dai tipi, dai valori e dagli algoritmi.</p>
<section id="t-1-use-templates-to-raise-the-level-of-abstraction-of-code">
<h4><a name="Rt-raise"></a>T.1: Utilizzare i template per elevare il livello di astrazione del codice<a class="headerlink" href="#t-1-use-templates-to-raise-the-level-of-abstraction-of-code" title="Link to this heading">¶</a></h4>
<section id="id1474">
<h5>Motivo<a class="headerlink" href="#id1474" title="Link to this heading">¶</a></h5>
<p>Generalità. Riutilizzo. Efficienza. Incoraggia la consistenza della definizione dei tipi utente.</p>
</section>
<section id="id1475">
<h5>Esempio, cattivo<a class="headerlink" href="#id1475" title="Link to this heading">¶</a></h5>
<p>Concettualmente, i seguenti requisiti sono sbagliati perché quello che si vuole di <code class="docutils literal notranslate"><span class="pre">T</span></code> sono più che i semplici concetti di bassissimo livello del «può essere incrementato» o «può essere aggiunto»:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
    requires Incrementable&lt;T&gt;
T sum1(vector&lt;T&gt;&amp; v, T s)
{
    for (auto x : v) s += x;
    return s;
}

template&lt;typename T&gt;
    requires Simple_number&lt;T&gt;
T sum2(vector&lt;T&gt;&amp; v, T s)
{
    for (auto x : v) s = s + x;
    return s;
}
</pre></div>
</div>
<p>Supponendo che <code class="docutils literal notranslate"><span class="pre">Incrementable</span></code> non supporti <code class="docutils literal notranslate"><span class="pre">+</span></code> e che <code class="docutils literal notranslate"><span class="pre">Simple_number</span></code> non supporti <code class="docutils literal notranslate"><span class="pre">+=</span></code>, si hanno degli implementatori troppo particolari di <code class="docutils literal notranslate"><span class="pre">sum1</span></code> e <code class="docutils literal notranslate"><span class="pre">sum2</span></code>. E, in questo caso, perdendo un’opportunità di generalizzazione.</p>
</section>
<section id="id1476">
<h5>Esempio<a class="headerlink" href="#id1476" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
    requires Arithmetic&lt;T&gt;
T sum(vector&lt;T&gt;&amp; v, T s)
{
    for (auto x : v) s += x;
    return s;
}
</pre></div>
</div>
<p>Assumendo che <code class="docutils literal notranslate"><span class="pre">Arithmetic</span></code> richieda sia <code class="docutils literal notranslate"><span class="pre">+</span></code> che <code class="docutils literal notranslate"><span class="pre">+=</span></code>, si vincola l’utente di <code class="docutils literal notranslate"><span class="pre">sum</span></code> a fornire un tipo completamente aritmetico. Questo non è un requisito minimo, ma fornisce all’implementatore degli algoritmi la libertà necessaria e garantisce che si possa usare qualsiasi tipo <code class="docutils literal notranslate"><span class="pre">Arithmetic</span></code> per un’ampia varietà di algoritmi.</p>
<p>Per ulteriore generalità e riusabilità, si potrebbe anche usare un più generale concetto di <code class="docutils literal notranslate"><span class="pre">Container</span></code> o di <code class="docutils literal notranslate"><span class="pre">Range</span></code> anziché affidarsi ad un solo contenitore, <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</section>
<section id="id1477">
<h5>Nota<a class="headerlink" href="#id1477" title="Link to this heading">¶</a></h5>
<p>Se si definisce un modello per avere solo e solamente le operazioni richieste per una particolare implementazione di un singolo algoritmo (p.es., si richiede solo <code class="docutils literal notranslate"><span class="pre">+=</span></code> anziché anche <code class="docutils literal notranslate"><span class="pre">=</span></code> e <code class="docutils literal notranslate"><span class="pre">+</span></code>), si hanno dei manutentori troppo vincolati. Lo scopo è quello di minimizzare i requisiti sugli argomenti template, ma i requisiti assolutamente minimali di un’implementazione raramente costituiscono un concetto significativo.</p>
</section>
<section id="id1478">
<h5>Nota<a class="headerlink" href="#id1478" title="Link to this heading">¶</a></h5>
<p>I template si possono usare per esprimere praticamente qualsiasi cosa (sono Turing equivalenti), ma lo scopo della programmazione generica (che si realizza con i template) è quello di generalizzare efficientemente operazioni e/o algoritmi per un insieme di tipi con proprietà semantiche simili.</p>
</section>
<section id="id1479">
<h5>Imposizione<a class="headerlink" href="#id1479" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare gli algoritmi con requisiti «eccessivamente semplici», come l’uso diretto di specifici operatori senza un concetto.</p></li>
<li><p>Non segnalare la definizione degli stessi concetti «eccessivamente semplici»; questi potrebbero semplicemente essere elementi costitutivi di concetti più utili.</p></li>
</ul>
</section>
</section>
<section id="t-2-use-templates-to-express-algorithms-that-apply-to-many-argument-types">
<h4><a name="Rt-algo"></a>T.2: Utilizzare i template per esprimere gli algoritmi che si applicano a molti tipi di argomenti<a class="headerlink" href="#t-2-use-templates-to-express-algorithms-that-apply-to-many-argument-types" title="Link to this heading">¶</a></h4>
<section id="id1480">
<h5>Motivo<a class="headerlink" href="#id1480" title="Link to this heading">¶</a></h5>
<p>Generalità. Minimizzare la quantità di codice sorgente. Interoperabilità. Riutilizzo.</p>
</section>
<section id="id1481">
<h5>Esempio<a class="headerlink" href="#id1481" title="Link to this heading">¶</a></h5>
<p>Questa è la base della STL. Un singolo algoritmo <code class="docutils literal notranslate"><span class="pre">find</span></code> funziona facilmente con qualsiasi tipo di serie in input:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename Iter, typename Val&gt;
    // requires Input_iterator&lt;Iter&gt;
    //       &amp;&amp; Equality_comparable&lt;Value_type&lt;Iter&gt;, Val&gt;
Iter find(Iter b, Iter e, Val v)
{
    // ...
}
</pre></div>
</div>
</section>
<section id="id1482">
<h5>Nota<a class="headerlink" href="#id1482" title="Link to this heading">¶</a></h5>
<p>Non usare un template a meno che non si abbia una reale necessità per più di un tipo di argomento template. Non essere eccessivamente concisi.</p>
</section>
<section id="id1483">
<h5>Imposizione<a class="headerlink" href="#id1483" title="Link to this heading">¶</a></h5>
<p>??? difficile, probabilmente necessita di un umano</p>
</section>
</section>
<section id="t-3-use-templates-to-express-containers-and-ranges">
<h4><a name="Rt-cont"></a>T.3: Utilizzare i template per esprimere contenitori e [range]<a class="headerlink" href="#t-3-use-templates-to-express-containers-and-ranges" title="Link to this heading">¶</a></h4>
<section id="id1484">
<h5>Motivo<a class="headerlink" href="#id1484" title="Link to this heading">¶</a></h5>
<p>I contenitori necessitano di un tipo per l’elemento, ed esprimerlo come un argomento template è generale, riutilizzabile e sicuro rispetto al tipo. Si evitano, inoltre, alternative fragili ed inefficienti. Convenzione: Questo è come fa la STL.</p>
</section>
<section id="id1485">
<h5>Esempio<a class="headerlink" href="#id1485" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
    // requires Regular&lt;T&gt;
class Vector {
    // ...
    T* elem;   // points to sz Ts
    int sz;
};

Vector&lt;double&gt; v(10);
v[7] = 9.9;
</pre></div>
</div>
</section>
<section id="id1486">
<h5>Esempio, cattivo<a class="headerlink" href="#id1486" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Container {
    // ...
    void* elem;   // points to size elements of some type
    int sz;
};

Container c(10, sizeof(double));
((double*) c.elem)[7] = 9.9;
</pre></div>
</div>
<p>Ciò non esprime direttamente l’intento del programmatore e nasconde la struttura del programma al sistema dei tipi e all’ottimizzatore.</p>
<p>Celando il <code class="docutils literal notranslate"><span class="pre">void*</span></code> dietro le macro semplicemente si nascondono i problemi e si introducono altre possibilità di confusione.</p>
<p><strong>Eccezioni</strong>: Se è necessaria un’interfaccia ABI stabile, potrebbe essere necessario fornire un’implementazione di base ed esprimere il template (type-safe)  in questi termini. Cfr. <a class="reference internal" href="#Rt-abi"><span class="xref myst">Base stabile</span></a>.</p>
</section>
<section id="id1487">
<h5>Imposizione<a class="headerlink" href="#id1487" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare gli utilizzi dei <code class="docutils literal notranslate"><span class="pre">void*</span></code> e dei cast al di fuori del codice di implementazione di basso livello</p></li>
</ul>
</section>
</section>
<section id="t-4-use-templates-to-express-syntax-tree-manipulation">
<h4><a name="Rt-expr"></a>T.4: Utilizzare i template per esprimere la gestione dell’albero sintattico<a class="headerlink" href="#t-4-use-templates-to-express-syntax-tree-manipulation" title="Link to this heading">¶</a></h4>
<section id="id1488">
<h5>Motivo<a class="headerlink" href="#id1488" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
<section id="id1489">
<h5>Esempio<a class="headerlink" href="#id1489" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
<p><strong>Eccezioni</strong>: ???</p>
</section>
</section>
<section id="t-5-combine-generic-and-oo-techniques-to-amplify-their-strengths-not-their-costs">
<h4><a name="Rt-generic-oo"></a>T.5: Combinare la tecnica generica e la OO per amplificane i punti di forza, non i loro costi<a class="headerlink" href="#t-5-combine-generic-and-oo-techniques-to-amplify-their-strengths-not-their-costs" title="Link to this heading">¶</a></h4>
<section id="id1490">
<h5>Motivo<a class="headerlink" href="#id1490" title="Link to this heading">¶</a></h5>
<p>Le tecniche di programmazione generica e OO sono complementari.</p>
</section>
<section id="id1491">
<h5>Esempio<a class="headerlink" href="#id1491" title="Link to this heading">¶</a></h5>
<p>La statica aiuta la dinamica: Usare il polimorfismo statico per implementare dinamicamente le interfacce polimorfiche.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Command {
    // pure virtual functions
};

// implementations
template&lt;/*...*/&gt;
class ConcreteCommand : public Command {
    // implement virtuals
};
</pre></div>
</div>
</section>
<section id="id1492">
<h5>Esempio<a class="headerlink" href="#id1492" title="Link to this heading">¶</a></h5>
<p>La dinamica aiuta la statica: Offre un’interfaccia generica, comoda e vincolata staticamente, ma internamente distribuisce dinamicamente, offrendo un layout uniforme dell’oggetto. Tra gli esempi c’è la cancellazione [erasure] del tipo come con il “deleter” del <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code> (ma <a class="reference internal" href="#Rt-erasure"><span class="xref myst">non abusare della cancellazione del tipo [type erasure]</span></a>).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;memory&gt;

class Object {
public:
    template&lt;typename T&gt;
    Object(T&amp;&amp; obj)
        : concept_(std::make_shared&lt;ConcreteCommand&lt;T&gt;&gt;(std::forward&lt;T&gt;(obj))) {}

    int get_id() const { return concept_-&gt;get_id(); }

private:
    struct Command {
        virtual ~Command() {}
        virtual int get_id() const = 0;
    };

    template&lt;typename T&gt;
    struct ConcreteCommand final : Command {
        ConcreteCommand(T&amp;&amp; obj) noexcept : object_(std::forward&lt;T&gt;(obj)) {}
        int get_id() const final { return object_.get_id(); }

    private:
        T object_;
    };

    std::shared_ptr&lt;Command&gt; concept_;
};

class Bar {
public:
    int get_id() const { return 1; }
};

struct Foo {
public:
    int get_id() const { return 2; }
};

Object o(Bar{});
Object o2(Foo{});
</pre></div>
</div>
</section>
<section id="id1493">
<h5>Nota<a class="headerlink" href="#id1493" title="Link to this heading">¶</a></h5>
<p>In una classe template, le funzioni non-virtuali vengono istanziate solo se vengono utilizzate – ma quelle virtuali vengono istanziate sempre. Questo può gonfiare la dimensione del codice, e potrebbe vincolare eccessivamente un tipo generico istanziando funzionalità che non saranno mai necessarie. È da evitare, anche se parti della libreria standard hanno commesso questo sbaglio.</p>
</section>
<section id="id1494">
<h5>Si veda anche<a class="headerlink" href="#id1494" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>rif ???</p></li>
<li><p>rif ???</p></li>
<li><p>rif ???</p></li>
</ul>
</section>
<section id="id1495">
<h5>Imposizione<a class="headerlink" href="#id1495" title="Link to this heading">¶</a></h5>
<p>Si vedano i riferimenti a regole più specifiche.</p>
</section>
</section>
</section>
<section id="t-concepts-concept-rules">
<h3><a name="SS-concepts"></a>T.concepts: Regole sui concetti<a class="headerlink" href="#t-concepts-concept-rules" title="Link to this heading">¶</a></h3>
<p>I concept è una struttura del C++20 per specificare i requisiti per gli argomenti template. Sono cruciali nel pensare alla programmazione generica e alla base di molto lavoro sulle future librerie C++ (standard e altre).</p>
<p>Questa sezione presuppone il supporto del concetto</p>
<p>Riepilogo delle regole sull’uso dei concetti:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rt-concepts"><span class="xref myst">T.10: Specificare i concetti per tutti gli argomenti dei template</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-std-concepts"><span class="xref myst">T.11: Quando possibile utilizzare i concetti standard</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-auto"><span class="xref myst">T.12: Preferire i nomi dei concetti ad <code class="docutils literal notranslate"><span class="pre">auto</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rt-shorthand"><span class="xref myst">T.13: Preferire la notazione abbreviata per i concetti semplici, con un argomento di un solo tipo</span></a></p></li>
<li><p>???</p></li>
</ul>
<p>Riepilogo delle regole sulla definizione dei concetti:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rt-low"><span class="xref myst">T.20: Evitare «concetti» senza una semantica significativa</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-complete"><span class="xref myst">T.21: Richiedere un set completo di operazioni per un concetto</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-axiom"><span class="xref myst">T.22: Specificare gli assiomi per i concetti</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-refine"><span class="xref myst">T.23: Differenziare un concetto speciale dal suo caso più generale aggiungendo nuovi schemi di utilizzo</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-tag"><span class="xref myst">T.24: Usare classi tag o [trait] per differenziare i concetti che hanno solamente una semantica diversa</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-not"><span class="xref myst">T.25: Evitare i vincoli complementari</span></a></p></li>
<li><p><a class="reference internal" href="#Rt-use"><span class="xref myst">T.26: Preferire la definizione dei concetti in termini di schemi d’uso anziché la semplice sintassi</span></a></p></li>
<li><p>???</p></li>
</ul>
</section>
<section id="t-con-use-concept-use">
<h3><a name="SS-concept-use"></a>T.con-use: Uso del concetto<a class="headerlink" href="#t-con-use-concept-use" title="Link to this heading">¶</a></h3>
<section id="t-10-specify-concepts-for-all-template-arguments">
<h4><a name="Rt-concepts"></a>T.10: Specificare i concetti per tutti gli argomenti dei template<a class="headerlink" href="#t-10-specify-concepts-for-all-template-arguments" title="Link to this heading">¶</a></h4>
<section id="id1496">
<h5>Motivo<a class="headerlink" href="#id1496" title="Link to this heading">¶</a></h5>
<p>Correttezza e leggibilità. Il significato supposto (sintattico e semantico) di un argomento template è fondamentale per l’interfaccia di un template. Un concetto migliora enormemente la documentazione e la gestione degli errori per il template. Lo specificare i concetti per gli argomenti template costituisce un potente strumento di progettazione.</p>
</section>
<section id="id1497">
<h5>Esempio<a class="headerlink" href="#id1497" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename Iter, typename Val&gt;
    requires input_iterator&lt;Iter&gt;
             &amp;&amp; equality_comparable_with&lt;iter_value_t&lt;Iter&gt;, Val&gt;
Iter find(Iter b, Iter e, Val v)
{
    // ...
}
</pre></div>
</div>
<p>o equivalentemente e più succintamente:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;input_iterator Iter, typename Val&gt;
    requires equality_comparable_with&lt;iter_value_t&lt;Iter&gt;, Val&gt;
Iter find(Iter b, Iter e, Val v)
{
    // ...
}
</pre></div>
</div>
</section>
<section id="id1498">
<h5>Nota<a class="headerlink" href="#id1498" title="Link to this heading">¶</a></h5>
<p>Il semplice <code class="docutils literal notranslate"><span class="pre">typename</span></code> (o <code class="docutils literal notranslate"><span class="pre">auto</span></code>) è il concetto meno vincolante. Dovrebbe essere usato solo raramente quando non si può supporre altro che «è un tipo». Ciò, generalmente, è necessario solo quando (come parte del codice di meta-programmazione dei template) si gestiscono alberi di espressioni pure, posponendo il controllo del tipo.</p>
<p><strong>Riferimenti</strong>: TC++PL4</p>
</section>
<section id="id1499">
<h5>Imposizione<a class="headerlink" href="#id1499" title="Link to this heading">¶</a></h5>
<p>Segnalare i tipi di argomenti template senza concetti</p>
</section>
</section>
<section id="t-11-whenever-possible-use-standard-concepts">
<h4><a name="Rt-std-concepts"></a>T.11: Quando possibile utilizzare i concetti standard<a class="headerlink" href="#t-11-whenever-possible-use-standard-concepts" title="Link to this heading">¶</a></h4>
<section id="id1500">
<h5>Motivo<a class="headerlink" href="#id1500" title="Link to this heading">¶</a></h5>
<p>I concept «standard» (quelli descritti nelle <a class="reference internal" href="#gsl-guidelines-support-library"><span class="xref myst">GSL</span></a> e nello stesso standard ISO) fanno risparmiare il lavoro di pensare ai propri concept, sono pensati meglio di quanto si possa riuscire a fare in proprio e migliorano l’interoperabilità.</p>
</section>
<section id="id1501">
<h5>Nota<a class="headerlink" href="#id1501" title="Link to this heading">¶</a></h5>
<p>A meno che non si stia creando una nuova libreria generica, la maggior parte dei concetti necessari sarà già stata definita dalla libreria standard.</p>
</section>
<section id="id1502">
<h5>Esempio<a class="headerlink" href="#id1502" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
    // don&#39;t define this: sortable is in &lt;iterator&gt;
concept Ordered_container = Sequence&lt;T&gt; &amp;&amp; Random_access&lt;Iterator&lt;T&gt;&gt; &amp;&amp; Ordered&lt;Value_type&lt;T&gt;&gt;;

void sort(Ordered_container auto&amp; s);
</pre></div>
</div>
<p>Questo <code class="docutils literal notranslate"><span class="pre">Ordered_container</span></code> è abbastanza plausibile, ma è molto simile al concept <code class="docutils literal notranslate"><span class="pre">sortable</span></code> nella libreria standard. È migliore? È  giusto? Riflette accuratamente i requisiti dello standard per <code class="docutils literal notranslate"><span class="pre">sort</span></code>? È meglio e più semplice usare semplicemente <code class="docutils literal notranslate"><span class="pre">sortable</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void sort(sortable auto&amp; s);   // better
</pre></div>
</div>
</section>
<section id="id1503">
<h5>Nota<a class="headerlink" href="#id1503" title="Link to this heading">¶</a></h5>
<p>L’insieme dei concetti «standard» si sta evolvendo nell’avvicinarsi ad uno standard ISO che includa i concetti.</p>
</section>
<section id="id1504">
<h5>Nota<a class="headerlink" href="#id1504" title="Link to this heading">¶</a></h5>
<p>Progettare un concetto utile è impegnativo.</p>
</section>
<section id="id1505">
<h5>Imposizione<a class="headerlink" href="#id1505" title="Link to this heading">¶</a></h5>
<p>Difficile.</p>
<ul class="simple">
<li><p>Cercare argomenti senza vincoli, template che usano concetti «insoliti»/non-standard, template che usano concetti «fatti in casa» senza assiomi.</p></li>
<li><p>Sviluppare un tool per scoprire i concetti (p.es., cfr. <a class="reference external" href="http://www.stroustrup.com/sle2010_webversion.pdf">un primo esperimento</a>).</p></li>
</ul>
</section>
</section>
<section id="t-12-prefer-concept-names-over-auto-for-local-variables">
<h4><a name="Rt-auto"></a>T.12: Preferire i nomi dei concetti ad <code class="docutils literal notranslate"><span class="pre">auto</span></code> per le variabili locali<a class="headerlink" href="#t-12-prefer-concept-names-over-auto-for-local-variables" title="Link to this heading">¶</a></h4>
<section id="id1506">
<h5>Motivo<a class="headerlink" href="#id1506" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">auto</span></code> è il concetto più debole. I nomi dei concetti convogliano più significato che il semplice <code class="docutils literal notranslate"><span class="pre">auto</span></code>.</p>
</section>
<section id="id1507">
<h5>Esempio<a class="headerlink" href="#id1507" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;string&gt; v{ &quot;abc&quot;, &quot;xyz&quot; };
auto&amp; x = v.front();        // bad
String auto&amp; s = v.front(); // good (String is a GSL concept)
</pre></div>
</div>
</section>
<section id="id1508">
<h5>Imposizione<a class="headerlink" href="#id1508" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>???</p></li>
</ul>
</section>
</section>
<section id="t-13-prefer-the-shorthand-notation-for-simple-single-type-argument-concepts">
<h4><a name="Rt-shorthand"></a>T.13: Preferire la notazione abbreviata per i concetti semplici, con un argomento di un solo tipo<a class="headerlink" href="#t-13-prefer-the-shorthand-notation-for-simple-single-type-argument-concepts" title="Link to this heading">¶</a></h4>
<section id="id1509">
<h5>Motivo<a class="headerlink" href="#id1509" title="Link to this heading">¶</a></h5>
<p>Leggibilità. Espressione diretta di un’idea.</p>
</section>
<section id="id1510">
<h5>Esempio<a class="headerlink" href="#id1510" title="Link to this heading">¶</a></h5>
<p>Per dire che «<code class="docutils literal notranslate"><span class="pre">T</span></code> è <code class="docutils literal notranslate"><span class="pre">sortable</span></code> [ordinabile]»:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;       // Correct but verbose: &quot;The parameter is
    requires sortable&lt;T&gt;   // of type T which is the name of a type
void sort(T&amp;);             // that is sortable&quot;

template&lt;sortable T&gt;       // Better: &quot;The parameter is of type T
void sort(T&amp;);             // which is Sortable&quot;

void sort(sortable auto&amp;); // Best: &quot;The parameter is Sortable&quot;
</pre></div>
</div>
<p>Le versioni più brevi si adattano meglio al nostro modo di parlare. Si noti che per molti template non è necessario usare la parola-chiave <code class="docutils literal notranslate"><span class="pre">template</span></code>.</p>
</section>
<section id="id1511">
<h5>Imposizione<a class="headerlink" href="#id1511" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Non fattibile a breve termine quando le persone convertono dalla notazione <code class="docutils literal notranslate"><span class="pre">&lt;typename</span> <span class="pre">T&gt;</span></code> e <code class="docutils literal notranslate"><span class="pre">&lt;class</span> <span class="pre">T&gt;</span></code>.</p></li>
<li><p>In seguito, le dichiarazioni che prima introducono un [typename] e poi lo vincolano con un concetto semplice, argomento-di-un-solo-tipo.</p></li>
</ul>
</section>
</section>
</section>
<section id="t-concepts-def-concept-definition-rules">
<h3><a name="SS-concepts-def"></a>T.concepts.def: Regole sulla definizione dei concetti<a class="headerlink" href="#t-concepts-def-concept-definition-rules" title="Link to this heading">¶</a></h3>
<p>Definire dei buoni concetti non è banale. I «concetti» hanno lo scopo di rappresentare concetti fondamentali in un dominio di applicazione (da cui il nome «concept»). Allo stesso modo, mettere insieme una serie di vincoli sintattici da utilizzare per gli argomenti di una classe o di un algoritmo non è ciò per cui i concetti sono stati progettati e non darà tutti i benefici del meccanismo.</p>
<p>Ovviamente, la definizione dei concept è più utile per il codice che può utilizzare un’implementazione (ad es. C++20 o successivo), ma la definizione dei concept è di per sé un’utile tecnica di progettazione e aiuta a rilevare gli errori concettuali e a ripulire i concetti (sic!) di un implementazione.</p>
<section id="t-20-avoid-concepts-without-meaningful-semantics">
<h4><a name="Rt-low"></a>T.20: Evitare «concetti» senza una semantica significativa<a class="headerlink" href="#t-20-avoid-concepts-without-meaningful-semantics" title="Link to this heading">¶</a></h4>
<section id="id1512">
<h5>Motivo<a class="headerlink" href="#id1512" title="Link to this heading">¶</a></h5>
<p>I concetti hanno lo scopo di esprimere nozioni semantiche, come in «un numero», «un intervallo [range]» di elementi, e «totalmente ordinato». Semplici vincoli, come  in «ha un operatore <code class="docutils literal notranslate"><span class="pre">+</span></code>» e «ha un operatore <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>» non possono essere specificati in modo significativo isolatamente e si dovrebbero usare solo come elementi costitutivi di concetti significativi, piuttosto che nel codice utente.</p>
</section>
<section id="id1513">
<h5>Esempio, cattivo<a class="headerlink" href="#id1513" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
// bad; insufficient
concept Addable = requires(T a, T b) { a + b; };

template&lt;Addable N&gt;
auto algo(const N&amp; a, const N&amp; b) // use two numbers
{
    // ...
    return a + b;
}

int x = 7;
int y = 9;
auto z = algo(x, y);   // z = 16

string xx = &quot;7&quot;;
string yy = &quot;9&quot;;
auto zz = algo(xx, yy);   // zz = &quot;79&quot;
</pre></div>
</div>
<p>Forse era prevista la concatenazione. Più probabilmente, è stato un incidente. Definire il meno in modo equivalente farebbe accettare un insieme di tipi notevolmente diversi. Questo <code class="docutils literal notranslate"><span class="pre">Addable</span></code> viola la regola matematica che supponga che l’addizione sia commutativa: <code class="docutils literal notranslate"><span class="pre">a+b</span> <span class="pre">==</span> <span class="pre">b+a</span></code>.</p>
</section>
<section id="id1514">
<h5>Nota<a class="headerlink" href="#id1514" title="Link to this heading">¶</a></h5>
<p>La capacità di specificare semantiche significative è una caratteristica distintiva di un vero concetto, al contrario di un vincolo sintattico.</p>
</section>
<section id="id1515">
<h5>Esempio<a class="headerlink" href="#id1515" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
// The operators +, -, *, and / for a number are assumed to follow the usual mathematical rules
concept Number = requires(T a, T b) { a + b; a - b; a * b; a / b; };

template&lt;Number N&gt;
auto algo(const N&amp; a, const N&amp; b)
{
    // ...
    return a + b;
}

int x = 7;
int y = 9;
auto z = algo(x, y);   // z = 16

string xx = &quot;7&quot;;
string yy = &quot;9&quot;;
auto zz = algo(xx, yy);   // error: string is not a Number
</pre></div>
</div>
</section>
<section id="id1516">
<h5>Nota<a class="headerlink" href="#id1516" title="Link to this heading">¶</a></h5>
<p>I concetti con più operazioni hanno una probabilità molto più bassa di abbinare accidentalmente un tipo rispetto a un concetto a singola-operazione.</p>
</section>
<section id="id1517">
<h5>Imposizione<a class="headerlink" href="#id1517" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare i <code class="docutils literal notranslate"><span class="pre">concept</span></code> a singola-operazione utilizzati al di fuori della definizione di altri <code class="docutils literal notranslate"><span class="pre">concept</span></code>.</p></li>
<li><p>Segnalare gli usi di <code class="docutils literal notranslate"><span class="pre">enable_if</span></code> che sembrano simulare <code class="docutils literal notranslate"><span class="pre">concept</span></code> mono-operazione.</p></li>
</ul>
</section>
</section>
<section id="t-21-require-a-complete-set-of-operations-for-a-concept">
<h4><a name="Rt-complete"></a>T.21: Richiedere un set completo di operazioni per un concetto<a class="headerlink" href="#t-21-require-a-complete-set-of-operations-for-a-concept" title="Link to this heading">¶</a></h4>
<section id="id1518">
<h5>Motivo<a class="headerlink" href="#id1518" title="Link to this heading">¶</a></h5>
<p>Facilità di comprensione. Migliorata interoperabilità. Aiuta gli implementatori e i manutentori.</p>
</section>
<section id="id1519">
<h5>Nota<a class="headerlink" href="#id1519" title="Link to this heading">¶</a></h5>
<p>Questa è una specifica variante della regola generale <a class="reference internal" href="#Rt-low"><span class="xref myst">un concetto deve avere un senso semantico</span></a>.</p>
</section>
<section id="id1520">
<h5>Esempio, cattivo<a class="headerlink" href="#id1520" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt; concept Subtractable = requires(T a, T b) { a - b; };
</pre></div>
</div>
<p>Questo non ha un senso semantico. C’è almeno bisogno di <code class="docutils literal notranslate"><span class="pre">+</span></code> per rendere <code class="docutils literal notranslate"><span class="pre">-</span></code> significativo e utile.</p>
<p>Esempi di set completi sono</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Aritmetica</span></code>: <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Comparabile</span></code>: <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code></p></li>
</ul>
</section>
<section id="id1521">
<h5>Nota<a class="headerlink" href="#id1521" title="Link to this heading">¶</a></h5>
<p>Questa regola si applica a prescindere dal fatto che si utilizzi il supporto diretto del linguaggio per i concetti. È una regola di progettazione generale che si applica anche ai non-template:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Minimal {
    // ...
};

bool operator==(const Minimal&amp;, const Minimal&amp;);
bool operator&lt;(const Minimal&amp;, const Minimal&amp;);

Minimal operator+(const Minimal&amp;, const Minimal&amp;);
// no other operators

void f(const Minimal&amp; x, const Minimal&amp; y)
{
    if (!(x == y)) { /* ... */ }    // OK
    if (x != y) { /* ... */ }       // surprise! error

    while (!(x &lt; y)) { /* ... */ }  // OK
    while (x &gt;= y) { /* ... */ }    // surprise! error

    x = x + y;          // OK
    x += y;             // surprise! error
}
</pre></div>
</div>
<p>Questo è il minimo, ma sorprende e vincola gli utenti. Potrebbe inoltre essere meno efficiente.</p>
<p>La regola supporta l’opinione secondo cui un concetto dovrebbe riflettere una serie (matematicamente) coerente di operazioni.</p>
</section>
<section id="id1522">
<h5>Esempio<a class="headerlink" href="#id1522" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Convenient {
    // ...
};

bool operator==(const Convenient&amp;, const Convenient&amp;);
bool operator&lt;(const Convenient&amp;, const Convenient&amp;);
// ... and the other comparison operators ...

Convenient operator+(const Convenient&amp;, const Convenient&amp;);
// ... and the other arithmetic operators ...

void f(const Convenient&amp; x, const Convenient&amp; y)
{
    if (!(x == y)) { /* ... */ }    // OK
    if (x != y) { /* ... */ }       // OK

    while (!(x &lt; y)) { /* ... */ }  // OK
    while (x &gt;= y) { /* ... */ }    // OK

    x = x + y;     // OK
    x += y;        // OK
}
</pre></div>
</div>
<p>Definire tutti gli operatori può essere fastidioso, ma non difficile. Idealmente, la regola dovrebbe essere supportata dal linguaggio fornendo operatori di confronto di default.</p>
</section>
<section id="id1523">
<h5>Imposizione<a class="headerlink" href="#id1523" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare le classi che supportano sottoinsiemi «strani» di un insieme di operatori, p.es., <code class="docutils literal notranslate"><span class="pre">==</span></code> ma non <code class="docutils literal notranslate"><span class="pre">!=</span></code> oppure <code class="docutils literal notranslate"><span class="pre">+</span></code> ma non <code class="docutils literal notranslate"><span class="pre">-</span></code>. Sì, <code class="docutils literal notranslate"><span class="pre">std::string</span></code> è «strana», ma è troppo tardi per cambiare.</p></li>
</ul>
</section>
</section>
<section id="t-22-specify-axioms-for-concepts">
<h4><a name="Rt-axiom"></a>T.22: Specificare gli assiomi per i concetti<a class="headerlink" href="#t-22-specify-axioms-for-concepts" title="Link to this heading">¶</a></h4>
<section id="id1524">
<h5>Motivo<a class="headerlink" href="#id1524" title="Link to this heading">¶</a></h5>
<p>Un concetto significativo/utile ha un significato semantico. Esprimere queste semantiche in modo informale, semi-formale o formale rende il concetto comprensibile ai lettori e lo sforzo di esprimerlo può intercettare errori concettuali. La specifica della semantica è un potente strumento di progettazione.</p>
</section>
<section id="id1525">
<h5>Esempio<a class="headerlink" href="#id1525" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
    // The operators +, -, *, and / for a number are assumed to follow the usual mathematical rules
    // axiom(T a, T b) { a + b == b + a; a - a == 0; a * (b + c) == a * b + a * c; /*...*/ }
    concept Number = requires(T a, T b) {
        { a + b } -&gt; convertible_to&lt;T&gt;;
        { a - b } -&gt; convertible_to&lt;T&gt;;
        { a * b } -&gt; convertible_to&lt;T&gt;;
        { a / b } -&gt; convertible_to&lt;T&gt;;
    };
</pre></div>
</div>
</section>
<section id="id1526">
<h5>Nota<a class="headerlink" href="#id1526" title="Link to this heading">¶</a></h5>
<p>Questo è un assioma in senso matematico: qualcosa che può essere assunto senza prove. In generale, gli assiomi non sono dimostrabili, e quando c’è una prova va spesso oltre le capacità di un compilatore. Un assioma potrebbe non essere generale, ma chi scrive il template potrebbe presumere che valga per tutti gli input effettivamente utilizzati (simile a una pre-condizione).</p>
</section>
<section id="id1527">
<h5>Nota<a class="headerlink" href="#id1527" title="Link to this heading">¶</a></h5>
<p>In questo contesto gli assiomi sono espressioni Booleane. Per gli esempi si veda <a class="reference internal" href="#S-references"><span class="xref myst">Palo Alto TR</span></a>. Attualmente, il C++ non supporta gli assiomi (nemmeno la TS ISO «Concepts»), quindi ci si dovrà accontentare a lungo dei commenti. Appena sarà disponibile il supporto del linguaggio, si potranno rimuovere le <code class="docutils literal notranslate"><span class="pre">//</span></code> davanti all’assioma</p>
</section>
<section id="id1528">
<h5>Nota<a class="headerlink" href="#id1528" title="Link to this heading">¶</a></h5>
<p>I  concetti GSL hanno una semantica ben definita; si veda la TR «Palo Alto» e la TS «Ranges».</p>
</section>
<section id="id1529">
<h5>Eccezione<a class="headerlink" href="#id1529" title="Link to this heading">¶</a></h5>
<p>Le prime versioni di un nuovo «concept» ancora in fase di sviluppo definiranno spesso semplici insiemi di vincoli senza una semantica ben specificata. Trovare una buona semantica può richiedere tempo e fatica. Un insieme incompleto di vincoli può essere ancora utilissimo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// balancer for a generic binary tree
template&lt;typename Node&gt; concept Balancer = requires(Node* p) {
    add_fixup(p);
    touch(p);
    detach(p);
};
</pre></div>
</div>
<p>Quindi un <code class="docutils literal notranslate"><span class="pre">Balancer</span></code> deve fornire almeno queste operazioni su un albero <code class="docutils literal notranslate"><span class="pre">Node</span></code>, ma non si è ancora pronti a specificare una semantica dettagliata perché un nuovo tipo di albero bilanciato potrebbe richiedere più operazioni e la semantica generale precisa per tutti i nodi è difficile da definire nelle prime fasi della progettazione.</p>
<p>Un «concept» incompleto o senza una semantica ben specificata può ancora essere utile. Per esempio, consente alcuni controlli durante la sperimentazione iniziale. Tuttavia, non si deve supporre che sia stabile. Ciascun nuovo caso d’uso potrebbe richiedere uno di questi concetti incompleti da migliorare.</p>
</section>
<section id="id1530">
<h5>Imposizione<a class="headerlink" href="#id1530" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Cercare la parola «axiom» [assioma] nei commenti per la definizione dei concept</p></li>
</ul>
</section>
</section>
<section id="t-23-differentiate-a-refined-concept-from-its-more-general-case-by-adding-new-use-patterns">
<h4><a name="Rt-refine"></a>T.23: Differenziare un concetto speciale dal suo caso più generale aggiungendo nuovi schemi di utilizzo.<a class="headerlink" href="#t-23-differentiate-a-refined-concept-from-its-more-general-case-by-adding-new-use-patterns" title="Link to this heading">¶</a></h4>
<section id="id1531">
<h5>Motivo<a class="headerlink" href="#id1531" title="Link to this heading">¶</a></h5>
<p>Altrimenti non possono essere distinti automaticamente dal compilatore.</p>
</section>
<section id="id1532">
<h5>Esempio<a class="headerlink" href="#id1532" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename I&gt;
// Note: input_iterator is defined in &lt;iterator&gt;
concept Input_iter = requires(I iter) { ++iter; };

template&lt;typename I&gt;
// Note: forward_iterator is defined in &lt;iterator&gt;
concept Fwd_iter = Input_iter&lt;I&gt; &amp;&amp; requires(I iter) { iter++; };
</pre></div>
</div>
<p>Il compilatore può determinare il perfezionamento in base all’insieme di operazioni richieste (qui, il suffisso <code class="docutils literal notranslate"><span class="pre">++</span></code>). Ciò riduce l’onere per gli implementatori di questi tipi poiché non necessitano di dichiarazioni speciali per «agganciarsi al concetto». Se due concetti hanno esattamente gli stessi requisiti, sono logicamente equivalenti (non c’è alcun aggiustamento).</p>
</section>
<section id="id1533">
<h5>Imposizione<a class="headerlink" href="#id1533" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare un concetto che ha esattamente gli stessi requisiti di un altro concetto già visto (nessuno dei due è più elaborato [refined]). Per chiarire le ambiguità, si veda <a class="reference internal" href="#Rt-tag"><span class="xref myst">T.24</span></a>.</p></li>
</ul>
</section>
</section>
<section id="t-24-use-tag-classes-or-traits-to-differentiate-concepts-that-differ-only-in-semantics">
<h4><a name="Rt-tag"></a>T.24: Usare classi tag o [trait] per differenziare i concetti che hanno solamente una semantica diversa.<a class="headerlink" href="#t-24-use-tag-classes-or-traits-to-differentiate-concepts-that-differ-only-in-semantics" title="Link to this heading">¶</a></h4>
<section id="id1534">
<h5>Motivo<a class="headerlink" href="#id1534" title="Link to this heading">¶</a></h5>
<p>Due concetti che richiedono la stessa sintassi ma hanno semantica diversa portano ad un’ambiguità a meno che il programmatore non li differenzi.</p>
</section>
<section id="id1535">
<h5>Esempio<a class="headerlink" href="#id1535" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename I&gt;    // iterator providing random access
// Note: random_access_iterator is defined in &lt;iterator&gt;
concept RA_iter = ...;

template&lt;typename I&gt;    // iterator providing random access to contiguous data
// Note: contiguous_iterator is defined in &lt;iterator&gt;
concept Contiguous_iter =
    RA_iter&lt;I&gt; &amp;&amp; is_contiguous_v&lt;I&gt;;  // using is_contiguous trait
</pre></div>
</div>
<p>Il programmatore (in una libreria) deve definire adeguatamente <code class="docutils literal notranslate"><span class="pre">is_contiguous</span></code> (un [trait]).</p>
<p>Avvolgere una classe [tag] in un concetto porta ad una semplice espressione di quest’idea:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename I&gt; concept Contiguous = is_contiguous_v&lt;I&gt;;

template&lt;typename I&gt;
concept Contiguous_iter = RA_iter&lt;I&gt; &amp;&amp; Contiguous&lt;I&gt;;
</pre></div>
</div>
<p>Il programmatore (in una libreria) deve definire adeguatamente <code class="docutils literal notranslate"><span class="pre">is_contiguous</span></code> (un [trait]).</p>
</section>
<section id="id1536">
<h5>Nota<a class="headerlink" href="#id1536" title="Link to this heading">¶</a></h5>
<p>I traits possono essere classi di traits o traits di tipi. Questi possono essere quelli definiti dall’utente o quelli della libreria standard. Preferire quelli della libreria standard.</p>
</section>
<section id="id1537">
<h5>Imposizione<a class="headerlink" href="#id1537" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Il compilatore segnala l’uso ambiguo di concetti identici.</p></li>
<li><p>Segnalare la definizione di concetti identici.</p></li>
</ul>
</section>
</section>
<section id="t-25-avoid-complementary-constraints">
<h4><a name="Rt-not"></a>T.25: Evitare i vincoli complementari<a class="headerlink" href="#t-25-avoid-complementary-constraints" title="Link to this heading">¶</a></h4>
<section id="id1538">
<h5>Motivo<a class="headerlink" href="#id1538" title="Link to this heading">¶</a></h5>
<p>Chiarezza. Manutenibilità. Le funzioni con requisiti complementari, espressi usando la negazione sono fragili.</p>
</section>
<section id="id1539">
<h5>Esempio<a class="headerlink" href="#id1539" title="Link to this heading">¶</a></h5>
<p>Inizialmente, le persone proveranno a definire funzioni con requisiti complementari:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
    requires !C&lt;T&gt;    // bad
void f();

template&lt;typename T&gt;
    requires C&lt;T&gt;
void f();
</pre></div>
</div>
<p>Questo è migliore:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;   // general template
    void f();

template&lt;typename T&gt;   // specialization by concept
    requires C&lt;T&gt;
void f();
</pre></div>
</div>
<p>Il compilatore sceglierà il modello non vincolato solo quando <code class="docutils literal notranslate"><span class="pre">C&lt;T&gt;</span></code> non è soddisfatto. Se non si vuole (o non si può) definire una versione non vincolata di <code class="docutils literal notranslate"><span class="pre">f()</span></code>, allora la si cancella.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
void f() = delete;
</pre></div>
</div>
<p>Il compilatore selezionerà l’overload, o emetterà l’errore appropriato.</p>
</section>
<section id="id1540">
<h5>Nota<a class="headerlink" href="#id1540" title="Link to this heading">¶</a></h5>
<p>I vincoli complementari sono purtroppo comuni nel codice di <code class="docutils literal notranslate"><span class="pre">enable_if</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
enable_if&lt;!C&lt;T&gt;, void&gt;   // bad
f();

template&lt;typename T&gt;
enable_if&lt;C&lt;T&gt;, void&gt;
f();
</pre></div>
</div>
</section>
<section id="id1541">
<h5>Nota<a class="headerlink" href="#id1541" title="Link to this heading">¶</a></h5>
<p>I requisiti complementari su un requisito sono talvolta (erroneamente) considerati gestibili. Tuttavia, per due o più requisiti, il numero di definizioni richieste può aumentare in modo esponenziale (2,4,8,16,…):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>C1&lt;T&gt; &amp;&amp; C2&lt;T&gt;
!C1&lt;T&gt; &amp;&amp; C2&lt;T&gt;
C1&lt;T&gt; &amp;&amp; !C2&lt;T&gt;
!C1&lt;T&gt; &amp;&amp; !C2&lt;T&gt;
</pre></div>
</div>
<p>Ora le opportunità di errori si moltiplicano.</p>
</section>
<section id="id1542">
<h5>Imposizione<a class="headerlink" href="#id1542" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare le coppie di funzioni con i vincoli <code class="docutils literal notranslate"><span class="pre">C&lt;T&gt;</span></code> e <code class="docutils literal notranslate"><span class="pre">!C&lt;T&gt;</span></code></p></li>
</ul>
</section>
</section>
<section id="t-26-prefer-to-define-concepts-in-terms-of-use-patterns-rather-than-simple-syntax">
<h4><a name="Rt-use"></a>T.26: Preferire la definizione dei concetti in termini di schemi d’uso anziché la semplice sintassi<a class="headerlink" href="#t-26-prefer-to-define-concepts-in-terms-of-use-patterns-rather-than-simple-syntax" title="Link to this heading">¶</a></h4>
<section id="id1543">
<h5>Motivo<a class="headerlink" href="#id1543" title="Link to this heading">¶</a></h5>
<p>La definizione è più leggibile e corrisponde direttamente a ciò che un utente deve scrivere. Le conversioni vengono prese in considerazione. Non si devono ricordare i nomi di tutti i [traits] del tipo.</p>
</section>
<section id="id1544">
<h5>Esempio<a class="headerlink" href="#id1544" title="Link to this heading">¶</a></h5>
<p>Si potrebbe essere tentati di definire un concetto <code class="docutils literal notranslate"><span class="pre">Equality</span></code> in questo modo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt; concept Equality = has_equal&lt;T&gt; &amp;&amp; has_not_equal&lt;T&gt;;
</pre></div>
</div>
<p>Ovviamente, sarebbe meglio e più facile usare solo lo standard <code class="docutils literal notranslate"><span class="pre">equality_comparable</span></code>, ma - solo a titolo di esempio - se si dovesse definire un concetto del genere, preferire:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt; concept Equality = requires(T a, T b) {
    { a == b } -&gt; std::convertible_to&lt;bool&gt;;
    { a != b } -&gt; std::convertible_to&lt;bool&gt;;
    // axiom { !(a == b) == (a != b) }
    // axiom { a = b; =&gt; a == b }  // =&gt; means &quot;implies&quot;
};
</pre></div>
</div>
<p>anziché definire due concetti insignificanti <code class="docutils literal notranslate"><span class="pre">has_equal</span></code> e <code class="docutils literal notranslate"><span class="pre">has_not_equal</span></code> solo come “helper” nella definizione di <code class="docutils literal notranslate"><span class="pre">Equality</span></code>. Per «insignificante» si intende che non si può specificare la semantica di <code class="docutils literal notranslate"><span class="pre">has_equal</span></code> isolatamente.</p>
</section>
<section id="id1545">
<h5>Imposizione<a class="headerlink" href="#id1545" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
</section>
<section id="template-interfaces">
<h3><a name="SS-temp-interface"></a> Interfacce template<a class="headerlink" href="#template-interfaces" title="Link to this heading">¶</a></h3>
<p>Nel corso degli anni, la programmazione con i template ha subito una debole distinzione tra l’interfaccia di un template e la sua implementazione. Prima dei concetti, tale distinzione non aveva un supporto linguistico diretto. Tuttavia, l’interfaccia per un template è un concetto critico - un contratto tra un utente e un implementatore - e dovrebbe essere progettata con cura.</p>
<section id="t-40-use-function-objects-to-pass-operations-to-algorithms">
<h4><a name="Rt-fo"></a>T.40: Usare oggetti funzione per passare le operazioni agli algoritmi<a class="headerlink" href="#t-40-use-function-objects-to-pass-operations-to-algorithms" title="Link to this heading">¶</a></h4>
<section id="id1546">
<h5>Motivo<a class="headerlink" href="#id1546" title="Link to this heading">¶</a></h5>
<p>Gli oggetti funzione possono trasportare più informazioni attraverso un’interfaccia anziché un «semplice» puntatore a una funzione. In generale, passare oggetti funzione ha prestazioni migliori che passare puntatori a funzioni.</p>
</section>
<section id="id1547">
<h5>Esempio<a class="headerlink" href="#id1547" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool greater(double x, double y) { return x &gt; y; }
sort(v, greater);                                    // pointer to function: potentially slow
sort(v, [](double x, double y) { return x &gt; y; });   // function object
sort(v, std::greater{});                             // function object

bool greater_than_7(double x) { return x &gt; 7; }
auto x = find_if(v, greater_than_7);                 // pointer to function: inflexible
auto y = find_if(v, [](double x) { return x &gt; 7; }); // function object: carries the needed data
auto z = find_if(v, Greater_than&lt;double&gt;(7));        // function object: carries the needed data
</pre></div>
</div>
<p>Ovviamente si possono generalizzare queste funzioni usando <code class="docutils literal notranslate"><span class="pre">auto</span></code> o i concept. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto y1 = find_if(v, [](totally_ordered auto x) { return x &gt; 7; }); // require an ordered type
auto z1 = find_if(v, [](auto x) { return x &gt; 7; });                 // hope that the type has a &gt;
</pre></div>
</div>
</section>
<section id="id1548">
<h5>Nota<a class="headerlink" href="#id1548" title="Link to this heading">¶</a></h5>
<p>Le lambda generano oggetti funzione.</p>
</section>
<section id="id1549">
<h5>Nota<a class="headerlink" href="#id1549" title="Link to this heading">¶</a></h5>
<p>L’argomento delle prestazioni dipende dalla tecnologia del compilatore e di quella dell’ottimizzatore.</p>
</section>
<section id="id1550">
<h5>Imposizione<a class="headerlink" href="#id1550" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare gli argomenti template puntatori a funzione.</p></li>
<li><p>Segnalare i puntatori a funzione passati come argomenti a un template (si rischiano falsi positivi).</p></li>
</ul>
</section>
</section>
<section id="t-41-require-only-essential-properties-in-a-template-s-concepts">
<h4><a name="Rt-essential"></a>T.41: Richiedere solo le proprietà essenziali nei concetti di un template<a class="headerlink" href="#t-41-require-only-essential-properties-in-a-template-s-concepts" title="Link to this heading">¶</a></h4>
<section id="id1551">
<h5>Motivo<a class="headerlink" href="#id1551" title="Link to this heading">¶</a></h5>
<p>Mantenere le interfacce semplici e stabili.</p>
</section>
<section id="id1552">
<h5>Esempio<a class="headerlink" href="#id1552" title="Link to this heading">¶</a></h5>
<p>Si consideri, un <code class="docutils literal notranslate"><span class="pre">sort</span></code> dotato di un semplice (molto semplificato) supporto per il debug:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void sort(sortable auto&amp; s)  // sort sequence s
{
    if (debug) cerr &lt;&lt; &quot;enter sort( &quot; &lt;&lt; s &lt;&lt;  &quot;)\n&quot;;
    // ...
    if (debug) cerr &lt;&lt; &quot;exit sort( &quot; &lt;&lt; s &lt;&lt;  &quot;)\n&quot;;
}
</pre></div>
</div>
<p>Questo dovrebbe essere riscritto in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;sortable S&gt;
    requires Streamable&lt;S&gt;
void sort(S&amp; s)  // sort sequence s
{
    if (debug) cerr &lt;&lt; &quot;enter sort( &quot; &lt;&lt; s &lt;&lt;  &quot;)\n&quot;;
    // ...
    if (debug) cerr &lt;&lt; &quot;exit sort( &quot; &lt;&lt; s &lt;&lt;  &quot;)\n&quot;;
}
</pre></div>
</div>
<p>Dopotutto, non esiste nulla in <code class="docutils literal notranslate"><span class="pre">sortable</span></code> che richiede il supporto di <code class="docutils literal notranslate"><span class="pre">iostream</span></code>. D’altra parte, nell’idea fondamentale dell’ordinamento non c’è nulla che dica qualcosa sul debug.</p>
</section>
<section id="id1553">
<h5>Nota<a class="headerlink" href="#id1553" title="Link to this heading">¶</a></h5>
<p>Se si chiede che ogni operazione utilizzata venga elencata tra i requisiti, l’interfaccia diventa instabile: Ogni volta che cambiano le strutture di debug, la raccolta dei dati utilizzati, il supporto dei test, la segnalazione degli errori, ecc., si dovrebbe cambiare il template e si dovrebbe ricompilare ogni utilizzo del template. Questo è poco gestibile e, in alcuni ambienti, impossibile.</p>
<p>Al contrario, se si utilizza un’operazione nell’implementazione che non è garantita dal controllo concettuale, si potrebbe ricevere un successivo errore di compilazione.</p>
<p>Non utilizzando il controllo del concetto per le proprietà di un argomento template che non è considerato essenziale, se ne ritarda il controllo fino al tempo dell’istanziazione. Questo, lo si considera un utile compromesso.</p>
<p>Si noti che anche l’utilizzo di nomi non locali e non dipendenti (come <code class="docutils literal notranslate"><span class="pre">debug</span></code> e <code class="docutils literal notranslate"><span class="pre">cerr</span></code>) introduce dipendenze dal contesto che possono portare a errori «misteriosi».</p>
</section>
<section id="id1554">
<h5>Nota<a class="headerlink" href="#id1554" title="Link to this heading">¶</a></h5>
<p>Può essere difficile decidere quali proprietà di un tipo sono essenziali e quali no.</p>
</section>
<section id="id1555">
<h5>Imposizione<a class="headerlink" href="#id1555" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="t-42-use-template-aliases-to-simplify-notation-and-hide-implementation-details">
<h4><a name="Rt-alias"></a>T.42: Usare gli alias dei template per semplificare la notazione e nascondere i dettagli implementativi<a class="headerlink" href="#t-42-use-template-aliases-to-simplify-notation-and-hide-implementation-details" title="Link to this heading">¶</a></h4>
<section id="id1556">
<h5>Motivo<a class="headerlink" href="#id1556" title="Link to this heading">¶</a></h5>
<p>Leggibilità migliorata. Occultamento dell’implementazione. Si noti che gli alias dei template sostituiscono molti usi dei [trait] per calcolare un tipo. Si possono anche usare per avvolgere [wrap] un [trait].</p>
</section>
<section id="id1557">
<h5>Esempio<a class="headerlink" href="#id1557" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T, size_t N&gt;
class Matrix {
    // ...
    using Iterator = typename std::vector&lt;T&gt;::iterator;
    // ...
};
</pre></div>
</div>
<p>Questo evita all’utente di <code class="docutils literal notranslate"><span class="pre">Matrix</span></code> il dover conoscere che gli elementi sono memorizzati in un <code class="docutils literal notranslate"><span class="pre">vector</span></code> ed evita anche che l’utente digiti ripetutamente <code class="docutils literal notranslate"><span class="pre">typename</span> <span class="pre">std::vector&lt;T&gt;::</span></code>.</p>
</section>
<section id="id1558">
<h5>Esempio<a class="headerlink" href="#id1558" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
void user(T&amp; c)
{
    // ...
    typename container_traits&lt;T&gt;::value_type x; // bad, verbose
    // ...
}

template&lt;typename T&gt;
using Value_type = typename container_traits&lt;T&gt;::value_type;
</pre></div>
</div>
<p>Ciò evita all’utente di <code class="docutils literal notranslate"><span class="pre">Value_type</span></code> il dover conoscere la tecnica usata per implementare i <code class="docutils literal notranslate"><span class="pre">value_type</span></code>s.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
void user2(T&amp; c)
{
    // ...
    Value_type&lt;T&gt; x;
    // ...
}
</pre></div>
</div>
</section>
<section id="id1559">
<h5>Nota<a class="headerlink" href="#id1559" title="Link to this heading">¶</a></h5>
<p>Un uso semplice e comune potrebbe essere espresso: «[Wrap traits]!»</p>
</section>
<section id="id1560">
<h5>Imposizione<a class="headerlink" href="#id1560" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare l’uso di <code class="docutils literal notranslate"><span class="pre">typename</span></code> come disambiguatore all’esterno delle dichiarazioni <code class="docutils literal notranslate"><span class="pre">using</span></code>.</p></li>
<li><p>???</p></li>
</ul>
</section>
</section>
<section id="t-43-prefer-using-over-typedef-for-defining-aliases">
<h4><a name="Rt-using"></a>T.43: Preferire <code class="docutils literal notranslate"><span class="pre">using</span></code> a <code class="docutils literal notranslate"><span class="pre">typedef</span></code> per definire gli alias<a class="headerlink" href="#t-43-prefer-using-over-typedef-for-defining-aliases" title="Link to this heading">¶</a></h4>
<section id="id1561">
<h5>Motivo<a class="headerlink" href="#id1561" title="Link to this heading">¶</a></h5>
<p>Leggibilità migliorata: Con <code class="docutils literal notranslate"><span class="pre">using</span></code>, il nuovo nome viene prima anziché essere incorporato da qualche parte in una dichiarazione. Generalità: <code class="docutils literal notranslate"><span class="pre">using</span></code> si può usare per gli alias dei template, mentre i <code class="docutils literal notranslate"><span class="pre">typedef</span></code> non possono facilmente essere template. Uniformità: <code class="docutils literal notranslate"><span class="pre">using</span></code> è sintatticamente simile ad <code class="docutils literal notranslate"><span class="pre">auto</span></code>.</p>
</section>
<section id="id1562">
<h5>Esempio<a class="headerlink" href="#id1562" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef int (*PFI)(int);   // OK, but convoluted

using PFI2 = int (*)(int);   // OK, preferred

template&lt;typename T&gt;
typedef int (*PFT)(T);      // error

template&lt;typename T&gt;
using PFT2 = int (*)(T);   // OK
</pre></div>
</div>
</section>
<section id="id1563">
<h5>Imposizione<a class="headerlink" href="#id1563" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare gli usi di <code class="docutils literal notranslate"><span class="pre">typedef</span></code>. Questo troverà molti «punti» :-(</p></li>
</ul>
</section>
</section>
<section id="t-44-use-function-templates-to-deduce-class-template-argument-types-where-feasible">
<h4><a name="Rt-deduce"></a>T.44: Usare template di funzioni per dedurre i tipi degli argomenti della classe (dove fattibile)<a class="headerlink" href="#t-44-use-function-templates-to-deduce-class-template-argument-types-where-feasible" title="Link to this heading">¶</a></h4>
<section id="id1564">
<h5>Motivo<a class="headerlink" href="#id1564" title="Link to this heading">¶</a></h5>
<p>Scrivere esplicitamente i tipi degli argomenti template può risultare noioso e inutilmente verboso.</p>
</section>
<section id="id1565">
<h5>Esempio<a class="headerlink" href="#id1565" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tuple&lt;int, string, double&gt; t1 = {1, &quot;Hamlet&quot;, 3.14};   // explicit type
auto t2 = make_tuple(1, &quot;Ophelia&quot;s, 3.14);         // better; deduced type
</pre></div>
</div>
<p>Si noti l’uso del suffisso <code class="docutils literal notranslate"><span class="pre">s</span></code> per assicurarsi che la stringa sia una <code class="docutils literal notranslate"><span class="pre">std::string</span></code>, anziché una stringa in stile C.</p>
</section>
<section id="id1566">
<h5>Nota<a class="headerlink" href="#id1566" title="Link to this heading">¶</a></h5>
<p>Dato che si può banalmente scrivere una funzione <code class="docutils literal notranslate"><span class="pre">make_T</span></code>, lo stesso potrebbe fare il compilatore. Pertanto, le funzioni <code class="docutils literal notranslate"><span class="pre">make_T</span></code> potrebbero, in futuro, diventare ridondanti.</p>
</section>
<section id="id1567">
<h5>Eccezione<a class="headerlink" href="#id1567" title="Link to this heading">¶</a></h5>
<p>A volte non c’è un buon modo per dedurre gli argomenti template e, a volte, si desidera specificare esplicitamente gli argomenti:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;double&gt; v = { 1, 2, 3, 7.9, 15.99 };
list&lt;Record*&gt; lst;
</pre></div>
</div>
</section>
<section id="id1568">
<h5>Nota<a class="headerlink" href="#id1568" title="Link to this heading">¶</a></h5>
<p>Si noti che il C++17 renderà ridondante questa regola consentendo agli argomenti del modello di essere dedotti direttamente dagli argomenti del costruttore: <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r1.html">Deduzione del parametro template per i costruttori (Rev. 3)</a>. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tuple t1 = {1, &quot;Hamlet&quot;s, 3.14}; // deduced: tuple&lt;int, string, double&gt;
</pre></div>
</div>
</section>
<section id="id1569">
<h5>Imposizione<a class="headerlink" href="#id1569" title="Link to this heading">¶</a></h5>
<p>Segnalare gli usi dove un tipo specializzato esplicitamente coincide con i tipi degli argomenti usati.</p>
</section>
</section>
<section id="t-46-require-template-arguments-to-be-at-least-semiregular">
<h4><a name="Rt-regular"></a>T.46: Richiedere che gli argomenti template siano almeno semi-regolari<a class="headerlink" href="#t-46-require-template-arguments-to-be-at-least-semiregular" title="Link to this heading">¶</a></h4>
<section id="id1570">
<h5>Motivo<a class="headerlink" href="#id1570" title="Link to this heading">¶</a></h5>
<p>Leggibilità. Prevenire sorprese ed errori. La maggior parte utilizza comunque questo supporto.</p>
</section>
<section id="id1571">
<h5>Esempio<a class="headerlink" href="#id1571" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {
public:
    explicit X(int);
    X(const X&amp;);            // copy
    X operator=(const X&amp;);
    X(X&amp;&amp;) noexcept;        // move
    X&amp; operator=(X&amp;&amp;) noexcept;
    ~X();
    // ... no more constructors ...
};

X x {1};              // fine
X y = x;              // fine
std::vector&lt;X&gt; v(10); // error: no default constructor
</pre></div>
</div>
</section>
<section id="id1572">
<h5>Nota<a class="headerlink" href="#id1572" title="Link to this heading">¶</a></h5>
<p>Semiregolare richiede il costruttore di default.</p>
</section>
<section id="id1573">
<h5>Imposizione<a class="headerlink" href="#id1573" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare i tipi usati come argomenti template che non siano almeno semi-regolari.</p></li>
</ul>
</section>
</section>
<section id="t-47-avoid-highly-visible-unconstrained-templates-with-common-names">
<h4><a name="Rt-visible"></a>T.47: Evitare i template senza vincoli molto visibili con nomi comuni<a class="headerlink" href="#t-47-avoid-highly-visible-unconstrained-templates-with-common-names" title="Link to this heading">¶</a></h4>
<section id="id1574">
<h5>Motivo<a class="headerlink" href="#id1574" title="Link to this heading">¶</a></h5>
<p>Un argomento template senza vincoli è una perfetta corrispondenza con qualsiasi cosa, quindi un tale template è preferibile a tipi più specifici che richiedono conversioni minori.  Ciò è particolarmente fastidioso/pericoloso quando si usa l’ADL (Argument-Dependent Lookup).  I nomi comuni rendono questo problema più probabile.</p>
</section>
<section id="id1575">
<h5>Esempio<a class="headerlink" href="#id1575" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>namespace Bad {
    struct S { int m; };
    template&lt;typename T1, typename T2&gt;
    bool operator==(T1, T2) { cout &lt;&lt; &quot;Bad\n&quot;; return true; }
}

namespace T0 {
    bool operator==(int, Bad::S) { cout &lt;&lt; &quot;T0\n&quot;; return true; }  // compare to int

    void test()
    {
        Bad::S bad{ 1 };
        vector&lt;int&gt; v(10);
        bool b = 1 == bad;
        bool b2 = v.size() == bad;
    }
}
</pre></div>
</div>
<p>Stampa <code class="docutils literal notranslate"><span class="pre">T0</span></code> e <code class="docutils literal notranslate"><span class="pre">Bad</span></code>.</p>
<p>Ora l”<code class="docutils literal notranslate"><span class="pre">==</span></code> in <code class="docutils literal notranslate"><span class="pre">Bad</span></code> è stato progettato per causare problemi, ma nel codice reale, sarebbe stato individuato il problema? Il problema è che <code class="docutils literal notranslate"><span class="pre">v.size()</span></code> restituisce un intero <code class="docutils literal notranslate"><span class="pre">unsigned</span></code> in modo che sia necessaria una conversione per chiamare il <code class="docutils literal notranslate"><span class="pre">==</span></code> locale; l”<code class="docutils literal notranslate"><span class="pre">==</span></code> in <code class="docutils literal notranslate"><span class="pre">Bad</span></code> non richiede alcuna conversione. I tipi realistici, come gli iteratori nella libreria standard si possono realizzare per mostrare simili tendenze anti-sociali.</p>
</section>
<section id="id1576">
<h5>Nota<a class="headerlink" href="#id1576" title="Link to this heading">¶</a></h5>
<p>Se un template senza vincoli è definito nello stesso namespace del tipo, tale template senza vincoli si può trovare per l’ADL (come avvenuto nell’esempio). Questo, è molto evidente.</p>
</section>
<section id="id1577">
<h5>Nota<a class="headerlink" href="#id1577" title="Link to this heading">¶</a></h5>
<p>Questa regola non dovrebbe essere necessaria, ma il comitato non può accettare di escludere template non vincolati da ADL.</p>
<p>Purtroppo questo porterà a molti falsi positivi; la libreria standard la viola ampiamente, inserendo molti template non vincolati  e tipi nel singolo namespace <code class="docutils literal notranslate"><span class="pre">std</span></code>.</p>
</section>
<section id="id1578">
<h5>Imposizione<a class="headerlink" href="#id1578" title="Link to this heading">¶</a></h5>
<p>Segnalare i template definiti in un namespace dove sono definiti anche i tipi concreti (forse non fattibile finché non si avranno i concetti).</p>
</section>
</section>
<section id="t-48-if-your-compiler-does-not-support-concepts-fake-them-with-enable-if">
<h4><a name="Rt-concept-def"></a>T.48: Se il compilatore non supporta i concetti, simularli con <code class="docutils literal notranslate"><span class="pre">enable_if</span></code><a class="headerlink" href="#t-48-if-your-compiler-does-not-support-concepts-fake-them-with-enable-if" title="Link to this heading">¶</a></h4>
<section id="id1579">
<h5>Motivo<a class="headerlink" href="#id1579" title="Link to this heading">¶</a></h5>
<p>Perché è il meglio che possiamo fare senza il supporto diretto del concetto. <code class="docutils literal notranslate"><span class="pre">enable_if</span></code> si può usare per definire condizionalmente le funzioni e per selezionare tra una serie di funzioni.</p>
</section>
<section id="id1580">
<h5>Esempio<a class="headerlink" href="#id1580" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
enable_if_t&lt;is_integral_v&lt;T&gt;&gt;
f(T v)
{
    // ...
}

// Equivalent to:
template&lt;Integral T&gt;
void f(T v)
{
    // ...
}
</pre></div>
</div>
</section>
<section id="id1581">
<h5>Nota<a class="headerlink" href="#id1581" title="Link to this heading">¶</a></h5>
<p>Attenzione ai <a class="reference internal" href="#Rt-not"><span class="xref myst">vincoli complementari [complementary constraints]</span></a>. Il falso [overloading] del concetto utilizzando <code class="docutils literal notranslate"><span class="pre">enable_if</span></code> a volte costringe ad usare questa tecnica di progettazione soggetta a errori.</p>
</section>
<section id="id1582">
<h5>Imposizione<a class="headerlink" href="#id1582" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="t-49-where-possible-avoid-type-erasure">
<h4><a name="Rt-erasure"></a>T.49: Dove possibile, evitare la [type-erasure]<a class="headerlink" href="#t-49-where-possible-avoid-type-erasure" title="Link to this heading">¶</a></h4>
<section id="id1583">
<h5>Motivo<a class="headerlink" href="#id1583" title="Link to this heading">¶</a></h5>
<p>La cancellazione del tipo [type erasure] comporta un ulteriore livello di indirezione nascondendo l’informazione sul tipo dietro una compilazione separata.</p>
</section>
<section id="id1584">
<h5>Esempio<a class="headerlink" href="#id1584" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
<p><strong>Eccezioni</strong>: La cancellazione del tipo [type erasure] è talvolta appropriata, come per <code class="docutils literal notranslate"><span class="pre">std::function</span></code>.</p>
</section>
<section id="id1585">
<h5>Imposizione<a class="headerlink" href="#id1585" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
<section id="id1586">
<h5>Nota<a class="headerlink" href="#id1586" title="Link to this heading">¶</a></h5>
</section>
</section>
</section>
<section id="t-def-template-definitions">
<h3><a name="SS-temp-def"></a>T.def: Definizioni dei template<a class="headerlink" href="#t-def-template-definitions" title="Link to this heading">¶</a></h3>
<p>Una definizione di un template (classe o funzione) può contenere del codice arbitrario, quindi per coprire questo argomento, ci vorrebbe una completa revisione delle tecniche di programmazione C++. Tuttavia, questa sezione si concentra su ciò che è specifico per l’implementazione del template. In particolare, si concentra sulla dipendenza di una definizione di template dal suo contesto.</p>
<section id="t-60-minimize-a-template-s-context-dependencies">
<h4><a name="Rt-depend"></a>T.60: Minimizzare le dipendenze dal contesto di un template<a class="headerlink" href="#t-60-minimize-a-template-s-context-dependencies" title="Link to this heading">¶</a></h4>
<section id="id1587">
<h5>Motivo<a class="headerlink" href="#id1587" title="Link to this heading">¶</a></h5>
<p>Facilita la comprensione. Riduce al minimo gli errori da dipendenze impreviste. Facilita la creazione di tool.</p>
</section>
<section id="id1588">
<h5>Esempio<a class="headerlink" href="#id1588" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename C&gt;
void sort(C&amp; c)
{
    std::sort(begin(c), end(c)); // necessary and useful dependency
}

template&lt;typename Iter&gt;
Iter algo(Iter first, Iter last)
{
    for (; first != last; ++first) {
        auto x = sqrt(*first); // potentially surprising dependency: which sqrt()?
        helper(first, x);      // potentially surprising dependency:
                               // helper is chosen based on first and x
        TT var = 7;            // potentially surprising dependency: which TT?
    }
}
</pre></div>
</div>
</section>
<section id="id1589">
<h5>Nota<a class="headerlink" href="#id1589" title="Link to this heading">¶</a></h5>
<p>I template solitamente appaiono nei file header quindi le loro dipendenze dal contesto sono più vulnerabili all’ordine degli <code class="docutils literal notranslate"><span class="pre">#include</span></code> che alle funzioni nei file <code class="docutils literal notranslate"><span class="pre">.cpp</span></code>.</p>
</section>
<section id="id1590">
<h5>Nota<a class="headerlink" href="#id1590" title="Link to this heading">¶</a></h5>
<p>Avere un template che opera solo sui suoi argomenti sarebbe un modo per ridurre il numero delle dipendenze al minimo, ma sarebbe generalmente ingestibile. Per esempio, gli algoritmi solitamente usano altri algoritmi ed invocano operazioni che non operano esclusivamente su argomenti. E non si cominci ad usare le macro!</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Rt-customization"><span class="xref myst">T.69</span></a></p>
</section>
<section id="id1591">
<h5>Imposizione<a class="headerlink" href="#id1591" title="Link to this heading">¶</a></h5>
<p>??? Difficile</p>
</section>
</section>
<section id="t-61-do-not-over-parameterize-members-scary">
<h4><a name="Rt-scary"></a>T.61: Non sovra-parametrizzare i membri (SCARY)<a class="headerlink" href="#t-61-do-not-over-parameterize-members-scary" title="Link to this heading">¶</a></h4>
<section id="id1592">
<h5>Motivo<a class="headerlink" href="#id1592" title="Link to this heading">¶</a></h5>
<p>Un membro che non dipende da un parametro template  non può essere utilizzato se non per uno specifico argomento template. Questo ne limita l’uso e in genere aumenta la dimensione del codice.</p>
</section>
<section id="id1593">
<h5>Esempio, cattivo<a class="headerlink" href="#id1593" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T, typename A = std::allocator&lt;T&gt;&gt;
    // requires Regular&lt;T&gt; &amp;&amp; Allocator&lt;A&gt;
class List {
public:
    struct Link {   // does not depend on A
        T elem;
        Link* pre;
        Link* suc;
    };

    using iterator = Link*;

    iterator first() const { return head; }

    // ...
private:
    Link* head;
};

List&lt;int&gt; lst1;
List&lt;int, My_allocator&gt; lst2;
</pre></div>
</div>
<p>Sembra abbastanza innocente, ma ora il <code class="docutils literal notranslate"><span class="pre">Link</span></code> dipende formalmente dall’allocatore (anche se non usa l’allocatore). Ciò impone istanze ridondanti che possono risultare sorprendentemente costose in alcuni scenari del mondo reale. In genere, la soluzione consiste nel rendere non locale quella che sarebbe stata una classe nidificata, con il proprio set minimo di parametri template.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
struct Link {
    T elem;
    Link* pre;
    Link* suc;
};

template&lt;typename T, typename A = std::allocator&lt;T&gt;&gt;
    // requires Regular&lt;T&gt; &amp;&amp; Allocator&lt;A&gt;
class List2 {
public:
    using iterator = Link&lt;T&gt;*;

    iterator first() const { return head; }

    // ...
private:
    Link&lt;T&gt;* head;
};

List2&lt;int&gt; lst1;
List2&lt;int, My_allocator&gt; lst2;
</pre></div>
</div>
<p>Alcuni hanno trovato l’idea che il <code class="docutils literal notranslate"><span class="pre">Link</span></code> non venga più nascosto nel terrificante elenco, quindi chiamiamo tale tecnica <a class="reference external" href="http://www.open-std.org/jtc1/sc22/WG21/docs/papers/2009/n2911.pdf">SCARY</a>. Da quel documento accademico: «L’acronimo SCARY descrive assegnazioni e inizializzazioni che Sembrano sbagliate (apparendo vincolate [Constrained] da parametri generici in conflitto), ma in realtà [Actually] funzionano con la giusta [Right] implementazione (non vincolata dal [bY] conflitto a causa di dipendenze minimizzate)».</p>
</section>
<section id="id1594">
<h5>Nota<a class="headerlink" href="#id1594" title="Link to this heading">¶</a></h5>
<p>Questo vale anche per le lambda che non dipendono da tutti i parametri template.</p>
</section>
<section id="id1595">
<h5>Imposizione<a class="headerlink" href="#id1595" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare i tipi membro che non dipendono da ogni parametro template</p></li>
<li><p>Segnalare le funzioni membro che non dipendono da ogni parametro template</p></li>
<li><p>Segnalare le lambda o le variabili template che non dipendono da ogni parametro template</p></li>
</ul>
</section>
</section>
<section id="t-62-place-non-dependent-class-template-members-in-a-non-templated-base-class">
<h4><a name="Rt-nondependent"></a>T.62: Porre i membri della classe template non-dipendenti in una classe base non-template<a class="headerlink" href="#t-62-place-non-dependent-class-template-members-in-a-non-templated-base-class" title="Link to this heading">¶</a></h4>
<section id="id1596">
<h5>Motivo<a class="headerlink" href="#id1596" title="Link to this heading">¶</a></h5>
<p>Consentire ai membri della classe base di essere utilizzati senza specificare gli argomenti template e senza istanziare il template.</p>
</section>
<section id="id1597">
<h5>Esempio<a class="headerlink" href="#id1597" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
class Foo {
public:
    enum { v1, v2 };
    // ...
};
</pre></div>
</div>
<p>???</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Foo_base {
    enum { v1, v2 };
    // ...
};

template&lt;typename T&gt;
class Foo : public Foo_base {
public:
    // ...
};
</pre></div>
</div>
</section>
<section id="id1598">
<h5>Nota<a class="headerlink" href="#id1598" title="Link to this heading">¶</a></h5>
<p>Una versione più generale di questa regola sarebbe «Se un membro template della classe dipende solo da N parametri template su M, lo si mette in una classe base con solo N parametri». Per N == 1, si ha una scelta di una classe base di una classe nello scope circostante come in <a class="reference internal" href="#Rt-scary"><span class="xref myst">T.61</span></a>.</p>
<p>??? E sulle costanti? staticità delle classi?</p>
</section>
<section id="id1599">
<h5>Imposizione<a class="headerlink" href="#id1599" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare ???</p></li>
</ul>
</section>
</section>
<section id="t-64-use-specialization-to-provide-alternative-implementations-of-class-templates">
<h4><a name="Rt-specialization"></a>T.64: Usare la specializzazione per fornire implementazioni alternative di classi template<a class="headerlink" href="#t-64-use-specialization-to-provide-alternative-implementations-of-class-templates" title="Link to this heading">¶</a></h4>
<section id="id1600">
<h5>Motivo<a class="headerlink" href="#id1600" title="Link to this heading">¶</a></h5>
<p>Un template definisce un’interfaccia generale. La specializzazione offre un potente meccanismo per fornire implementazioni alternative di tale interfaccia.</p>
</section>
<section id="id1601">
<h5>Esempio<a class="headerlink" href="#id1601" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>??? string specialization (==)

??? representation specialization ?
</pre></div>
</div>
</section>
<section id="id1602">
<h5>Nota<a class="headerlink" href="#id1602" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
<section id="id1603">
<h5>Imposizione<a class="headerlink" href="#id1603" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="t-65-use-tag-dispatch-to-provide-alternative-implementations-of-a-function">
<h4><a name="Rt-tag-dispatch"></a>T.65: Usare il [tag dispatch] per fornire implementazioni alternative delle funzioni<a class="headerlink" href="#t-65-use-tag-dispatch-to-provide-alternative-implementations-of-a-function" title="Link to this heading">¶</a></h4>
<section id="id1604">
<h5>Motivo<a class="headerlink" href="#id1604" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Un template definisce un’interfaccia generale.</p></li>
<li><p>Il [tag dispatch] consente di selezionare le implementazioni in base a specifiche proprietà di un tipo di un argomento.</p></li>
<li><p>Prestazione.</p></li>
</ul>
</section>
<section id="id1605">
<h5>Esempio<a class="headerlink" href="#id1605" title="Link to this heading">¶</a></h5>
<p>Questa è una versione semplificata di <code class="docutils literal notranslate"><span class="pre">std::copy</span></code> (viene ignorata la possibilità di sequenze non contigue)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct trivially_copyable_tag {};
struct non_trivially_copyable_tag {};

// T is not trivially copyable
template&lt;class T&gt; struct copy_trait { using tag = non_trivially_copyable_tag; };
// int is trivially copyable
template&lt;&gt; struct copy_trait&lt;int&gt; { using tag = trivially_copyable_tag; };

template&lt;class Iter&gt;
Out copy_helper(Iter first, Iter last, Iter out, trivially_copyable_tag)
{
    // use memmove
}

template&lt;class Iter&gt;
Out copy_helper(Iter first, Iter last, Iter out, non_trivially_copyable_tag)
{
    // use loop calling copy constructors
}

template&lt;class Iter&gt;
Out copy(Iter first, Iter last, Iter out)
{
    using tag_type = typename copy_trait&lt;std::iter_value_t&lt;Iter&gt;&gt;;
    return copy_helper(first, last, out, tag_type{})
}

void use(vector&lt;int&gt;&amp; vi, vector&lt;int&gt;&amp; vi2, vector&lt;string&gt;&amp; vs, vector&lt;string&gt;&amp; vs2)
{
    copy(vi.begin(), vi.end(), vi2.begin()); // uses memmove
    copy(vs.begin(), vs.end(), vs2.begin()); // uses a loop calling copy constructors
}
</pre></div>
</div>
<p>Questa è una tecnica generale e potente per la selezione dell’algoritmo in fase di compilazione.</p>
</section>
<section id="id1606">
<h5>Nota<a class="headerlink" href="#id1606" title="Link to this heading">¶</a></h5>
<p>Con i vincoli C++20, tali alternative possono essere distinte direttamente:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class Iter&gt;
    requires std::is_trivially_copyable_v&lt;std::iter_value_t&lt;Iter&gt;&gt;
Out copy_helper(In, first, In last, Out out)
{
    // use memmove
}

template&lt;class Iter&gt;
Out copy_helper(In, first, In last, Out out)
{
    // use loop calling copy constructors
}
</pre></div>
</div>
</section>
<section id="id1607">
<h5>Imposizione<a class="headerlink" href="#id1607" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="t-67-use-specialization-to-provide-alternative-implementations-for-irregular-types">
<h4><a name="Rt-specialization2"></a>T.67: Usare la specializzazione per fornire implementazioni alternative per i tipi irregolari<a class="headerlink" href="#t-67-use-specialization-to-provide-alternative-implementations-for-irregular-types" title="Link to this heading">¶</a></h4>
<section id="id1608">
<h5>Motivo<a class="headerlink" href="#id1608" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
<section id="id1609">
<h5>Esempio<a class="headerlink" href="#id1609" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1610">
<h5>Imposizione<a class="headerlink" href="#id1610" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="t-68-use-rather-than-within-templates-to-avoid-ambiguities">
<h4><a name="Rt-cast"></a>T.68: Usare <code class="docutils literal notranslate"><span class="pre">{}</span></code> anziché <code class="docutils literal notranslate"><span class="pre">()</span></code> nei template per evitare ambiguità<a class="headerlink" href="#t-68-use-rather-than-within-templates-to-avoid-ambiguities" title="Link to this heading">¶</a></h4>
<section id="id1611">
<h5>Motivo<a class="headerlink" href="#id1611" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">()</span></code> è vulnerabile alle ambiguità della grammatica.</p>
</section>
<section id="id1612">
<h5>Esempio<a class="headerlink" href="#id1612" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T, typename U&gt;
void f(T t, U u)
{
    T v1(T(u));    // mistake: oops, v1 is a function not a variable
    T v2{u};       // clear:   obviously a variable
    auto x = T(u); // unclear: construction or cast?
}

f(1, &quot;asdf&quot;); // bad: cast from const char* to int
</pre></div>
</div>
</section>
<section id="id1613">
<h5>Imposizione<a class="headerlink" href="#id1613" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>segnalare gli inizializzatori <code class="docutils literal notranslate"><span class="pre">()</span></code></p></li>
<li><p>segnalare i cast in stile funzione</p></li>
</ul>
</section>
</section>
<section id="t-69-inside-a-template-don-t-make-an-unqualified-non-member-function-call-unless-you-intend-it-to-be-a-customization-point">
<h4><a name="Rt-customization"></a>T.69: All’interno di un template, non effettuare una chiamata di funzione non-membro non-qualificata a meno che non lo si intenda come un punto di personalizzazione<a class="headerlink" href="#t-69-inside-a-template-don-t-make-an-unqualified-non-member-function-call-unless-you-intend-it-to-be-a-customization-point" title="Link to this heading">¶</a></h4>
<section id="id1614">
<h5>Motivo<a class="headerlink" href="#id1614" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Fornire solo la flessibilità prevista.</p></li>
<li><p>Evitare la vulnerabilità a cambiamenti accidentali dell’environment.</p></li>
</ul>
</section>
<section id="id1615">
<h5>Esempio<a class="headerlink" href="#id1615" title="Link to this heading">¶</a></h5>
<p>Ci sono tre modi principali per consentire al codice chiamante di personalizzare un template.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class T&gt;
    // Call a member function
void test1(T t)
{
    t.f();    // require T to provide f()
}

template&lt;class T&gt;
void test2(T t)
    // Call a non-member function without qualification
{
    f(t);     // require f(/*T*/) be available in caller&#39;s scope or in T&#39;s namespace
}

template&lt;class T&gt;
void test3(T t)
    // Invoke a &quot;trait&quot;
{
    test_traits&lt;T&gt;::f(t); // require customizing test_traits&lt;&gt;
                          // to get non-default functions/types
}
</pre></div>
</div>
<p>Un [trait] è solitamente un alias di un tipo per calcolare un tipo, una funzione <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> che calcola un valore, o un tradizionale template di [traits] per essere specializzato sul tipo dell’utente.</p>
</section>
<section id="id1616">
<h5>Nota<a class="headerlink" href="#id1616" title="Link to this heading">¶</a></h5>
<p>Se si intende chiamare la propria funzione <code class="docutils literal notranslate"><span class="pre">helper(t)</span></code> con un valore <code class="docutils literal notranslate"><span class="pre">t</span></code> che dipende da un tipo di parametro template, si mette in un namespace <code class="docutils literal notranslate"><span class="pre">::detail</span></code> e si qualifica la chiamata come <code class="docutils literal notranslate"><span class="pre">detail::helper(t);</span></code>. Una chiamata non qualificata diventa un punto di personalizzazione in cui ogni funzione <code class="docutils literal notranslate"><span class="pre">helper</span></code> si può chiamare nel namespace dei tipi <code class="docutils literal notranslate"><span class="pre">t</span></code>; ciò può provocare problemi come <a class="reference internal" href="#Rt-visible"><span class="xref myst">invocare involontariamente funzioni template non vincolate</span></a>.</p>
</section>
<section id="id1617">
<h5>Imposizione<a class="headerlink" href="#id1617" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>In un template, segnalare una chiamata non qualificata ad una funzione non-membro che passa una variabile di un tipo dipendente quando c’è una funzione non-membro con lo stesso nome nel namespace del template.</p></li>
</ul>
</section>
</section>
</section>
<section id="t-temp-hier-template-and-hierarchy-rules">
<h3><a name="SS-temp-hier"></a>T.temp-hier: Regole sulla gerarchia e i template:<a class="headerlink" href="#t-temp-hier-template-and-hierarchy-rules" title="Link to this heading">¶</a></h3>
<p>I template sono la spina dorsale del C++ per il supporto alla programmazione generica e la gerarchia di classi è la spina dorsale per il supporto della programmazione object-oriented. I due meccanismi del linguaggio si possono usare efficacemente in combinazione, ma è necessario evitare alcune insidie progettuali.</p>
<section id="t-80-do-not-naively-templatize-a-class-hierarchy">
<h4><a name="Rt-hier"></a>T.80: Non rendere ingenuamente template una gerarchia di classi<a class="headerlink" href="#t-80-do-not-naively-templatize-a-class-hierarchy" title="Link to this heading">¶</a></h4>
<section id="id1618">
<h5>Motivo<a class="headerlink" href="#id1618" title="Link to this heading">¶</a></h5>
<p>Rendere template una gerarchia di classi con molte funzioni, specialmente molte funzioni virtuali, può portare a codice inutile [code bloat].</p>
</section>
<section id="id1619">
<h5>Esempio, cattivo<a class="headerlink" href="#id1619" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
struct Container {         // an interface
    virtual T* get(int i);
    virtual T* first();
    virtual T* next();
    virtual void sort();
};

template&lt;typename T&gt;
class Vector : public Container&lt;T&gt; {
public:
    // ...
};

Vector&lt;int&gt; vi;
Vector&lt;string&gt; vs;
</pre></div>
</div>
<p>Probabilmente è una cattiva idea definire un <code class="docutils literal notranslate"><span class="pre">sort</span></code> come funzione membro di un container, ma non è inaudito ed è un buon esempio di cosa non fare.</p>
<p>Detto questo, il compilatore non può sapere se viene chiamato <code class="docutils literal notranslate"><span class="pre">vector&lt;int&gt;::sort()</span></code>, quindi deve generare del codice per esso. Lo stesso per <code class="docutils literal notranslate"><span class="pre">vector&lt;string&gt;::sort()</span></code>. A meno che queste due funzioni non vengano chiamate, questo è codice inutile [code bloat]. Si immagini cosa farebbe ad una gerarchia di classi con decine di classi derivate con molte istanze.</p>
</section>
<section id="id1620">
<h5>Nota<a class="headerlink" href="#id1620" title="Link to this heading">¶</a></h5>
<p>In molti casi si può fornire un’interfaccia stabile evitando di parametrizzare una base; cfr. <a class="reference internal" href="#Rt-abi"><span class="xref myst">«base stabile»</span></a> e <a class="reference internal" href="#Rt-generic-oo"><span class="xref myst">OO e GP</span></a></p>
</section>
<section id="id1621">
<h5>Imposizione<a class="headerlink" href="#id1621" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare le funzioni virtuali che dipendono da un argomento template. ??? Falsi positivi</p></li>
</ul>
</section>
</section>
<section id="t-81-do-not-mix-hierarchies-and-arrays">
<h4><a name="Rt-array"></a>T.81: Non mischiare le gerarchie con gli array<a class="headerlink" href="#t-81-do-not-mix-hierarchies-and-arrays" title="Link to this heading">¶</a></h4>
<section id="id1622">
<h5>Motivo<a class="headerlink" href="#id1622" title="Link to this heading">¶</a></h5>
<p>Un array di classi derivate può implicitamente «ridursi» ad un puntatore ad una classe base con risultati potenzialmente disastrosi.</p>
</section>
<section id="id1623">
<h5>Esempio<a class="headerlink" href="#id1623" title="Link to this heading">¶</a></h5>
<p>Si supponga che <code class="docutils literal notranslate"><span class="pre">Apple</span></code> e <code class="docutils literal notranslate"><span class="pre">Pear</span></code> siano due tipi di <code class="docutils literal notranslate"><span class="pre">Fruit</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void maul(Fruit* p)
{
    *p = Pear{};     // put a Pear into *p
    p[1] = Pear{};   // put a Pear into p[1]
}

Apple aa [] = { an_apple, another_apple };   // aa contains Apples (obviously!)

maul(aa);
Apple&amp; a0 = &amp;aa[0];   // a Pear?
Apple&amp; a1 = &amp;aa[1];   // a Pear?
</pre></div>
</div>
<p>Probabilmente, <code class="docutils literal notranslate"><span class="pre">aa[0]</span></code> sarà un oggetto <code class="docutils literal notranslate"><span class="pre">Pear</span></code> (senza usare un cast!). Se <code class="docutils literal notranslate"><span class="pre">sizeof(Apple)</span> <span class="pre">!=</span> <span class="pre">sizeof(Pear)</span></code> l’accesso a <code class="docutils literal notranslate"><span class="pre">aa[1]</span></code> non sarà allineato al giusto inizio di un oggetto nell’array. C’è una violazione del tipo e forse (probabilmente) una corruzione della memoria. Mai scrivere codice simile.</p>
<p>Si noti che <code class="docutils literal notranslate"><span class="pre">maul()</span></code> viola la <a class="reference internal" href="#Rf-ptr"><span class="xref myst">regola che <code class="docutils literal notranslate"><span class="pre">T*</span></code> punta ad un singolo oggetto</span></a>.</p>
<p><strong>Alternativa</strong>: Usare un contenitore appropriato (template):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void maul2(Fruit* p)
{
    *p = Pear{};   // put a Pear into *p
}

vector&lt;Apple&gt; va = { an_apple, another_apple };   // va contains Apples (obviously!)

maul2(va);       // error: cannot convert a vector&lt;Apple&gt; to a Fruit*
maul2(&amp;va[0]);   // you asked for it

Apple&amp; a0 = &amp;va[0];   // a Pear?
</pre></div>
</div>
<p>Si noti che l’assegnazione in <code class="docutils literal notranslate"><span class="pre">maul2()</span></code> viola la <a class="reference internal" href="#Res-slice"><span class="xref myst">regola del non provocare «slice»</span></a>.</p>
</section>
<section id="id1624">
<h5>Imposizione<a class="headerlink" href="#id1624" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Rilevare questo orrore!</p></li>
</ul>
</section>
</section>
<section id="t-82-linearize-a-hierarchy-when-virtual-functions-are-undesirable">
<h4><a name="Rt-linear"></a>T.82: Linearizzare una gerarchia quando le funzioni virtuali sono indesiderabili<a class="headerlink" href="#t-82-linearize-a-hierarchy-when-virtual-functions-are-undesirable" title="Link to this heading">¶</a></h4>
<section id="id1625">
<h5>Motivo<a class="headerlink" href="#id1625" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
<section id="id1626">
<h5>Esempio<a class="headerlink" href="#id1626" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1627">
<h5>Imposizione<a class="headerlink" href="#id1627" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="t-83-do-not-declare-a-member-function-template-virtual">
<h4><a name="Rt-virtual"></a>T.83: Non dichiarare virtuale una funzione membro template<a class="headerlink" href="#t-83-do-not-declare-a-member-function-template-virtual" title="Link to this heading">¶</a></h4>
<section id="id1628">
<h5>Motivo<a class="headerlink" href="#id1628" title="Link to this heading">¶</a></h5>
<p>Il C++ non lo supporta. Nel caso, non si potrebbe generare le tabelle virtuali [vtbl] fino al momento del link. E, in generale, le implementazioni devono occuparsi del link dinamico.</p>
</section>
<section id="id1629">
<h5>Esempio, da non fare<a class="headerlink" href="#id1629" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Shape {
    // ...
    template&lt;class T&gt;
    virtual bool intersect(T* p);   // error: template cannot be virtual
};
</pre></div>
</div>
</section>
<section id="id1630">
<h5>Nota<a class="headerlink" href="#id1630" title="Link to this heading">¶</a></h5>
<p>C’è bisogno di una regola perché le persone continuano a chiederlo</p>
</section>
<section id="id1631">
<h5>Alternativa<a class="headerlink" href="#id1631" title="Link to this heading">¶</a></h5>
<p>Double dispatch, visitors, calcolare quale funzione chiamare</p>
</section>
<section id="id1632">
<h5>Imposizione<a class="headerlink" href="#id1632" title="Link to this heading">¶</a></h5>
<p>Il compilatore lo gestisce.</p>
</section>
</section>
<section id="t-84-use-a-non-template-core-implementation-to-provide-an-abi-stable-interface">
<h4><a name="Rt-abi"></a>T.84: Usare un nucleo implementativo non-template per fornire un’interfaccia ABI stabile<a class="headerlink" href="#t-84-use-a-non-template-core-implementation-to-provide-an-abi-stable-interface" title="Link to this heading">¶</a></h4>
<section id="id1633">
<h5>Motivo<a class="headerlink" href="#id1633" title="Link to this heading">¶</a></h5>
<p>Migliora la stabilità del codice. Evitare il codice inutile [code bloat].</p>
</section>
<section id="id1634">
<h5>Esempio<a class="headerlink" href="#id1634" title="Link to this heading">¶</a></h5>
<p>Potrebbe essere una classe base:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Link_base {   // stable
    Link_base* suc;
    Link_base* pre;
};

template&lt;typename T&gt;   // templated wrapper to add type safety
struct Link : Link_base {
    T val;
};

struct List_base {
    Link_base* first;   // first element (if any)
    int sz;             // number of elements
    void add_front(Link_base* p);
    // ...
};

template&lt;typename T&gt;
class List : List_base {
public:
    void put_front(const T&amp; e) { add_front(new Link&lt;T&gt;{e}); }   // implicit cast to Link_base
    T&amp; front() { static_cast&lt;Link&lt;T&gt;*&gt;(first).val; }   // explicit cast back to Link&lt;T&gt;
    // ...
};

List&lt;int&gt; li;
List&lt;string&gt; ls;
</pre></div>
</div>
<p>Ora c’è solo una sola copia delle operazioni degli elementi, collegati e non, di un  elenco: <code class="docutils literal notranslate"><span class="pre">List</span></code>. Le classi <code class="docutils literal notranslate"><span class="pre">Link</span></code> e <code class="docutils literal notranslate"><span class="pre">List</span></code> non fanno altro che gestire il tipo.</p>
<p>Anziché usare un tipo «base» separato, un’altra tecnica comune consiste nello specializzare <code class="docutils literal notranslate"><span class="pre">void</span></code> o <code class="docutils literal notranslate"><span class="pre">void*</span></code> ed avere il template generale per <code class="docutils literal notranslate"><span class="pre">T</span></code> solo per i cast sicuri incapsulati da e per l’implementazione centrale di <code class="docutils literal notranslate"><span class="pre">void</span></code>.</p>
<p><strong>Alternativa</strong>: Usare un’implementazione <a class="reference internal" href="#Ri-pimpl"><span class="xref myst">Pimpl</span></a>.</p>
</section>
<section id="id1635">
<h5>Imposizione<a class="headerlink" href="#id1635" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
</section>
<section id="t-var-variadic-template-rules">
<h3><a name="SS-variadic"></a>T.var: Regole sui template variadici<a class="headerlink" href="#t-var-variadic-template-rules" title="Link to this heading">¶</a></h3>
<p>???</p>
<section id="t-100-use-variadic-templates-when-you-need-a-function-that-takes-a-variable-number-of-arguments-of-a-variety-of-types">
<h4><a name="Rt-variadic"></a>T.100: Usare i template variadici quando c’è bisogno di una funzione che accetti un numero variabile di argomenti di vari tipi<a class="headerlink" href="#t-100-use-variadic-templates-when-you-need-a-function-that-takes-a-variable-number-of-arguments-of-a-variety-of-types" title="Link to this heading">¶</a></h4>
<section id="id1636">
<h5>Motivo<a class="headerlink" href="#id1636" title="Link to this heading">¶</a></h5>
<p>Il template variadico è il meccanismo più generale, ed è sia efficiente che [type-safe]. Non usare i vararg del C.</p>
</section>
<section id="id1637">
<h5>Esempio<a class="headerlink" href="#id1637" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>??? printf
</pre></div>
</div>
</section>
<section id="id1638">
<h5>Imposizione<a class="headerlink" href="#id1638" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare gli usi di <code class="docutils literal notranslate"><span class="pre">va_arg</span></code> nel codice utente.</p></li>
</ul>
</section>
</section>
<section id="t-101-how-to-pass-arguments-to-a-variadic-template">
<h4><a name="Rt-variadic-pass"></a>T.101: ??? Come passare gli argomenti ad un template variadico ???<a class="headerlink" href="#t-101-how-to-pass-arguments-to-a-variadic-template" title="Link to this heading">¶</a></h4>
<section id="id1639">
<h5>Motivo<a class="headerlink" href="#id1639" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
<section id="id1640">
<h5>Esempio<a class="headerlink" href="#id1640" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>??? beware of move-only and reference arguments
</pre></div>
</div>
</section>
<section id="id1641">
<h5>Imposizione<a class="headerlink" href="#id1641" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="t-102-how-to-process-arguments-to-a-variadic-template">
<h4><a name="Rt-variadic-process"></a>T.102: Come processare gli argomenti in un template variadico<a class="headerlink" href="#t-102-how-to-process-arguments-to-a-variadic-template" title="Link to this heading">¶</a></h4>
<section id="id1642">
<h5>Motivo<a class="headerlink" href="#id1642" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
<section id="id1643">
<h5>Esempio<a class="headerlink" href="#id1643" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>??? forwarding, type checking, references
</pre></div>
</div>
</section>
<section id="id1644">
<h5>Imposizione<a class="headerlink" href="#id1644" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="t-103-don-t-use-variadic-templates-for-homogeneous-argument-lists">
<h4><a name="Rt-variadic-not"></a>T.103: Non usare i template variadici per liste di argomenti omogenei<a class="headerlink" href="#t-103-don-t-use-variadic-templates-for-homogeneous-argument-lists" title="Link to this heading">¶</a></h4>
<section id="id1645">
<h5>Motivo<a class="headerlink" href="#id1645" title="Link to this heading">¶</a></h5>
<p>Ci sono modi più precisi per indicare una sequenza omogenea, come <code class="docutils literal notranslate"><span class="pre">initializer_list</span></code>.</p>
</section>
<section id="id1646">
<h5>Esempio<a class="headerlink" href="#id1646" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1647">
<h5>Imposizione<a class="headerlink" href="#id1647" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
</section>
<section id="t-meta-template-metaprogramming-tmp">
<h3><a name="SS-meta"></a>T.meta: Meta-programmazione template (TMP)<a class="headerlink" href="#t-meta-template-metaprogramming-tmp" title="Link to this heading">¶</a></h3>
<p>I template forniscono un meccanismo generale per la programmazione in fase di compilazione.</p>
<p>La meta-programmazione è una programmazione dove almeno un input o un risultato è un tipo. I template durante la compilazione offrono una «tipizzazione dinamica» [duck typing] «Turing-equivalenti» (modulo memoria capacità). La sintassi e le tecniche necessarie sono piuttosto orrende.</p>
<section id="t-120-use-template-metaprogramming-only-when-you-really-need-to">
<h4><a name="Rt-metameta"></a>T.120: Usare la meta-programmazione template solo quando è veramente necessario<a class="headerlink" href="#t-120-use-template-metaprogramming-only-when-you-really-need-to" title="Link to this heading">¶</a></h4>
<section id="id1648">
<h5>Motivo<a class="headerlink" href="#id1648" title="Link to this heading">¶</a></h5>
<p>La meta-programmazione template è difficile da ottenere, rallenta la compilazione, ed è spesso difficilissima da manutenere. Tuttavia, ci sono esempi reali in cui la meta-programmazione template offre prestazioni migliori rispetto a qualsiasi altra alternativa a meno di usare il codice assembly ad un livello esperto. Ci sono anche esempi reali dove la meta-programmazione template esprime le idee fondamentali meglio del codice in esecuzione. Per esempio, se è necessario gestire l’AST ([Abstract Syntax Tree] durante la compilazione (p.es., per un opzionale operazione di riduzione [folding] di una matrice) potrebbe non esserci un altro modo in C++.</p>
</section>
<section id="id1649">
<h5>Esempio, cattivo<a class="headerlink" href="#id1649" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1650">
<h5>Esempio, cattivo<a class="headerlink" href="#id1650" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enable_if
</pre></div>
</div>
<p>Usare, invece, i concetti. Ma si veda <a class="reference internal" href="#Rt-emulate"><span class="xref myst">Come emulare i concetti se il linguaggio non lo supporta</span></a>.</p>
</section>
<section id="id1651">
<h5>Esempio<a class="headerlink" href="#id1651" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>??? good
</pre></div>
</div>
<p><strong>Alternativa</strong>: Se il risultato è un valore, anziché un tipo, usare una <a class="reference internal" href="#Rt-fct"><span class="xref myst">funzione <code class="docutils literal notranslate"><span class="pre">constexpr</span></code></span></a>.</p>
</section>
<section id="id1652">
<h5>Nota<a class="headerlink" href="#id1652" title="Link to this heading">¶</a></h5>
<p>Se si ritiene di dover nascondere la meta-programmazione dei template nelle macro, probabilmente si è andati oltre.</p>
</section>
</section>
<section id="t-121-use-template-metaprogramming-primarily-to-emulate-concepts">
<h4><a name="Rt-emulate"></a>T.121: Usare la meta-programmazione template soprattutto per emulare i concetti<a class="headerlink" href="#t-121-use-template-metaprogramming-primarily-to-emulate-concepts" title="Link to this heading">¶</a></h4>
<section id="id1653">
<h5>Motivo<a class="headerlink" href="#id1653" title="Link to this heading">¶</a></h5>
<p>Laddove non è disponibile il C++ 20, si devono emulare utilizzando TMP. I casi d’uso che richiedono i concetti (p.es. l’overloading basato sui concetti) sono tra gli utilizzi più comuni (e semplici) della TMP.</p>
</section>
<section id="id1654">
<h5>Esempio<a class="headerlink" href="#id1654" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename Iter&gt;
    /*requires*/ enable_if&lt;random_access_iterator&lt;Iter&gt;, void&gt;
advance(Iter p, int n) { p += n; }

template&lt;typename Iter&gt;
    /*requires*/ enable_if&lt;forward_iterator&lt;Iter&gt;, void&gt;
advance(Iter p, int n) { assert(n &gt;= 0); while (n--) ++p;}
</pre></div>
</div>
</section>
<section id="id1655">
<h5>Nota<a class="headerlink" href="#id1655" title="Link to this heading">¶</a></h5>
<p>Tale codice risulta molto più semplice usando i concetti:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void advance(random_access_iterator auto p, int n) { p += n; }

void advance(forward_iterator auto p, int n) { assert(n &gt;= 0); while (n--) ++p;}
</pre></div>
</div>
</section>
<section id="id1656">
<h5>Imposizione<a class="headerlink" href="#id1656" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="t-122-use-templates-usually-template-aliases-to-compute-types-at-compile-time">
<h4><a name="Rt-tmp"></a>T.122: Usare i template (solitamente alias di template) per elaborare i tipi in fase di compilazione<a class="headerlink" href="#t-122-use-templates-usually-template-aliases-to-compute-types-at-compile-time" title="Link to this heading">¶</a></h4>
<section id="id1657">
<h5>Motivo<a class="headerlink" href="#id1657" title="Link to this heading">¶</a></h5>
<p>La meta-programmazione template è l’unico modo ad essere supportato direttamente, ed è quasi il modo principale, per generare tipi in fase di compilazione.</p>
</section>
<section id="id1658">
<h5>Nota<a class="headerlink" href="#id1658" title="Link to this heading">¶</a></h5>
<p>Le tecniche «trait» sono per lo più sostituite dagli alias dei template per calcolare i tipi e dalle funzioni <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> per calcolare i valori.</p>
</section>
<section id="id1659">
<h5>Esempio<a class="headerlink" href="#id1659" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>??? big object / small object optimization
</pre></div>
</div>
</section>
<section id="id1660">
<h5>Imposizione<a class="headerlink" href="#id1660" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="t-123-use-constexpr-functions-to-compute-values-at-compile-time">
<h4><a name="Rt-fct"></a>T.123: Usare funzioni <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> per elaborare i valori in fase di compilazione<a class="headerlink" href="#t-123-use-constexpr-functions-to-compute-values-at-compile-time" title="Link to this heading">¶</a></h4>
<section id="id1661">
<h5>Motivo<a class="headerlink" href="#id1661" title="Link to this heading">¶</a></h5>
<p>Una funzione è il modo più ovvio e conveniente per esprimere il calcolo di un valore. Spesso una funzione <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> implica un minor tempo di compilazione rispetto alle alternative.</p>
</section>
<section id="id1662">
<h5>Nota<a class="headerlink" href="#id1662" title="Link to this heading">¶</a></h5>
<p>Le tecniche «trait» sono per lo più sostituite dagli alias dei template per calcolare i tipi e dalle funzioni <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> per calcolare i valori.</p>
</section>
<section id="id1663">
<h5>Esempio<a class="headerlink" href="#id1663" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt;
    // requires Number&lt;T&gt;
constexpr T pow(T v, int n)   // power/exponential
{
    T res = 1;
    while (n--) res *= v;
    return res;
}

constexpr auto f7 = pow(pi, 7);
</pre></div>
</div>
</section>
<section id="id1664">
<h5>Imposizione<a class="headerlink" href="#id1664" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare meta-programmi template che ottengono un valore. Questi dovrebbero essere sostituiti con funzioni <code class="docutils literal notranslate"><span class="pre">constexpr</span></code>.</p></li>
</ul>
</section>
</section>
<section id="t-124-prefer-to-use-standard-library-tmp-facilities">
<h4><a name="Rt-std-tmp"></a>T.124: Preferire l’uso delle funzioni TMP della libreria standard<a class="headerlink" href="#t-124-prefer-to-use-standard-library-tmp-facilities" title="Link to this heading">¶</a></h4>
<section id="id1665">
<h5>Motivo<a class="headerlink" href="#id1665" title="Link to this heading">¶</a></h5>
<p>Le funzionalità definite nello standard, come <code class="docutils literal notranslate"><span class="pre">conditional</span></code>, <code class="docutils literal notranslate"><span class="pre">enable_if</span></code> e <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, sono portabili e si può supporre che siano note.</p>
</section>
<section id="id1666">
<h5>Esempio<a class="headerlink" href="#id1666" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1667">
<h5>Imposizione<a class="headerlink" href="#id1667" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="t-125-if-you-need-to-go-beyond-the-standard-library-tmp-facilities-use-an-existing-library">
<h4><a name="Rt-lib"></a>T.125: Se c’è bisogno di andare oltre le funzioni TMP della libreria standard, usare una libreria esistente<a class="headerlink" href="#t-125-if-you-need-to-go-beyond-the-standard-library-tmp-facilities-use-an-existing-library" title="Link to this heading">¶</a></h4>
<section id="id1668">
<h5>Motivo<a class="headerlink" href="#id1668" title="Link to this heading">¶</a></h5>
<p>Ottenere servizi TMP non è facile e l’uso di una libreria ci rende parte (e si spera di supporto) di una comunità. Scrivere il proprio «supporto TMP avanzato» solo se è veramente necessario.</p>
</section>
<section id="id1669">
<h5>Esempio<a class="headerlink" href="#id1669" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1670">
<h5>Imposizione<a class="headerlink" href="#id1670" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
</section>
<section id="other-template-rules">
<h3><a name="SS-temp-other"></a>Altre regole sui template<a class="headerlink" href="#other-template-rules" title="Link to this heading">¶</a></h3>
<section id="t-140-if-an-operation-can-be-reused-give-it-a-name">
<h4><a name="Rt-name"></a>T.140: Se un’operazione può essere riutilizzata, le si assegna un nome<a class="headerlink" href="#t-140-if-an-operation-can-be-reused-give-it-a-name" title="Link to this heading">¶</a></h4>
<p>Cfr. <a class="reference internal" href="#Rf-name"><span class="xref myst">F.10</span></a></p>
</section>
<section id="t-141-use-an-unnamed-lambda-if-you-need-a-simple-function-object-in-one-place-only">
<h4><a name="Rt-lambda"></a>T.141: Usare una lambda anonima se si necessita di un semplice oggetto funzione in un solo posto<a class="headerlink" href="#t-141-use-an-unnamed-lambda-if-you-need-a-simple-function-object-in-one-place-only" title="Link to this heading">¶</a></h4>
<p>Cfr. <a class="reference internal" href="#Rf-lambda"><span class="xref myst">F.11</span></a></p>
</section>
<section id="t-142-use-template-variables-to-simplify-notation">
<h4><a name="Rt-var"></a>T.142?: Usare le variabili template per semplificare la notazione<a class="headerlink" href="#t-142-use-template-variables-to-simplify-notation" title="Link to this heading">¶</a></h4>
<section id="id1671">
<h5>Motivo<a class="headerlink" href="#id1671" title="Link to this heading">¶</a></h5>
<p>Leggibilità migliorata.</p>
</section>
<section id="id1672">
<h5>Esempio<a class="headerlink" href="#id1672" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1673">
<h5>Imposizione<a class="headerlink" href="#id1673" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="t-143-don-t-write-unintentionally-non-generic-code">
<h4><a name="Rt-non-generic"></a>T.143: Non scrivere involontariamente codice non-generico<a class="headerlink" href="#t-143-don-t-write-unintentionally-non-generic-code" title="Link to this heading">¶</a></h4>
<section id="id1674">
<h5>Motivo<a class="headerlink" href="#id1674" title="Link to this heading">¶</a></h5>
<p>Generalità. Riusabilità. Non dettagliare gratuitamente; usare le funzioni più generali a disposizione.</p>
</section>
<section id="id1675">
<h5>Esempio<a class="headerlink" href="#id1675" title="Link to this heading">¶</a></h5>
<p>Usare <code class="docutils literal notranslate"><span class="pre">!=</span></code> anziché <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> per confrontare iteratori; <code class="docutils literal notranslate"><span class="pre">!=</span></code> funziona per più oggetti perché non si basa sull’ordinamento.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (auto i = first; i &lt; last; ++i) {   // less generic
    // ...
}

for (auto i = first; i != last; ++i) {   // good; more generic
    // ...
}
</pre></div>
</div>
<p>Ovviamente, il range-<code class="docutils literal notranslate"><span class="pre">for</span></code> è ancora meglio in quanto fa quello che si vuole.</p>
</section>
<section id="id1676">
<h5>Esempio<a class="headerlink" href="#id1676" title="Link to this heading">¶</a></h5>
<p>Usare la classe meno-derivata che abbia le funzionalità richieste.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Base {
public:
    Bar f();
    Bar g();
};

class Derived1 : public Base {
public:
    Bar h();
};

class Derived2 : public Base {
public:
    Bar j();
};

// bad, unless there is a specific reason for limiting to Derived1 objects only
void my_func(Derived1&amp; param)
{
    use(param.f());
    use(param.g());
}

// good, uses only Base interface so only commit to that
void my_func(Base&amp; param)
{
    use(param.f());
    use(param.g());
}
</pre></div>
</div>
</section>
<section id="id1677">
<h5>Imposizione<a class="headerlink" href="#id1677" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare i confronti di iteratori con <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> anziché con <code class="docutils literal notranslate"><span class="pre">!=</span></code>.</p></li>
<li><p>Segnalare <code class="docutils literal notranslate"><span class="pre">x.size()</span> <span class="pre">==</span> <span class="pre">0</span></code> quando è disponibile <code class="docutils literal notranslate"><span class="pre">x.empty()</span></code> o <code class="docutils literal notranslate"><span class="pre">x.is_empty()</span></code>. Il controllare se vuoto, funziona per più contenitori rispetto a size(), perché alcuni contenitori non conoscono la propria dimensione [size] o sono concettualmente di dimensioni illimitate.</p></li>
<li><p>Segnalare le funzioni che prendono un puntatore o un riferimento a un tipo multi-derivato ma usano solo funzioni del tipo base.</p></li>
</ul>
</section>
</section>
<section id="t-144-don-t-specialize-function-templates">
<h4><a name="Rt-specialize-function"></a>T.144: Non specializzare le funzioni template<a class="headerlink" href="#t-144-don-t-specialize-function-templates" title="Link to this heading">¶</a></h4>
<section id="id1678">
<h5>Motivo<a class="headerlink" href="#id1678" title="Link to this heading">¶</a></h5>
<p>Non si può specializzare parzialmente una funzione template per le regole del linguaggio. Si può completamente specializzare una funzione template ma quasi certamente si vuole eseguire invece l’overload – perché le specializzazioni della funzione template non partecipano all’overloading, esse non agiscono come probabilmente si voleva. Raramente, si dovrebbe effettivamente specializzare delegando ad una classe template giustamente specializzata.</p>
</section>
<section id="id1679">
<h5>Esempio<a class="headerlink" href="#id1679" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
<p><strong>Eccezioni</strong>: Se c’è un motivo valido per specializzare una funzione template, basta scrivere una sola funzione template che delega ad una classe template, poi specializzare la classe template (inclusa la possibilità di scrivere specializzazioni parziali).</p>
</section>
<section id="id1680">
<h5>Imposizione<a class="headerlink" href="#id1680" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare tutte le specializzazioni di una funzione template. Usare l’overload, invece.</p></li>
</ul>
</section>
</section>
<section id="t-150-check-that-a-class-matches-a-concept-using-static-assert">
<h4><a name="Rt-check-class"></a>T.150: Verificare che a una classe corrisponda un concetto utilizzando <code class="docutils literal notranslate"><span class="pre">static_assert</span></code><a class="headerlink" href="#t-150-check-that-a-class-matches-a-concept-using-static-assert" title="Link to this heading">¶</a></h4>
<section id="id1681">
<h5>Motivo<a class="headerlink" href="#id1681" title="Link to this heading">¶</a></h5>
<p>Se si vuole che ad una classe corrisponda un concetto, una verifica a priori evita problemi agli utenti.</p>
</section>
<section id="id1682">
<h5>Esempio<a class="headerlink" href="#id1682" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {
public:
    X() = delete;
    X(const X&amp;) = default;
    X(X&amp;&amp;) = default;
    X&amp; operator=(const X&amp;) = default;
    // ...
};
</pre></div>
</div>
<p>Da qualche parte, forse in un file di implementazione, lasciare che sia il compilatore a verificare le proprietà desiderate di <code class="docutils literal notranslate"><span class="pre">X</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static_assert(Default_constructible&lt;X&gt;);    // error: X has no default constructor
static_assert(Copyable&lt;X&gt;);                 // error: we forgot to define X&#39;s move constructor
</pre></div>
</div>
</section>
<section id="id1683">
<h5>Imposizione<a class="headerlink" href="#id1683" title="Link to this heading">¶</a></h5>
<p>Non fattibile.</p>
</section>
</section>
</section>
</section>
<section id="cpl-c-style-programming">
<h2><a name="S-cpl"></a>CPL: Programmazione C-style<a class="headerlink" href="#cpl-c-style-programming" title="Link to this heading">¶</a></h2>
<p>C e C++ sono linguaggi strettamente correlati. Entrambi provengono dal «C Classico» del 1978 e da allora si sono evoluti in comitati ISO. Sono stati fatti molti tentativi per renderli compatibili, ma nessuno dei due è un sottoinsieme dell’altro.</p>
<p>Riepilogo delle regole sul C:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rcpl-C"><span class="xref myst">CPL.1: Preferire il C++ al C</span></a></p></li>
<li><p><a class="reference internal" href="#Rcpl-subset"><span class="xref myst">CPL.2: Se si deve usare il C, utilizzare il sotto-insieme comune al C e al C++, e compilare il codice C come C++</span></a></p></li>
<li><p><a class="reference internal" href="#Rcpl-interface"><span class="xref myst">CPL.3: Se si deve usare il C per le interfacce, usare il C++ nel codice chiamante utilizzando tali interfacce</span></a></p></li>
</ul>
<section id="cpl-1-prefer-c-to-c">
<h3><a name="Rcpl-C"></a>CPL.1: Preferire il C++ al C<a class="headerlink" href="#cpl-1-prefer-c-to-c" title="Link to this heading">¶</a></h3>
<section id="id1684">
<h4>Motivo<a class="headerlink" href="#id1684" title="Link to this heading">¶</a></h4>
<p>Il C++ offre un miglior controllo sui tipi e un maggior supporto notazionale. Fornisce un supporto migliore per la programmazione ad alto livello e spesso genera codice più veloce.</p>
</section>
<section id="id1685">
<h4>Esempio<a class="headerlink" href="#id1685" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char ch = 7;
void* pv = &amp;ch;
int* pi = pv;   // not C++
*pi = 999;      // overwrite sizeof(int) bytes near &amp;ch
</pre></div>
</div>
<p>Le regole per il cast implicito da e verso <code class="docutils literal notranslate"><span class="pre">void*</span></code> in C sono subdole e non forzate. In particolare, questo esempio viola una regola contro la conversione in un tipo con un allineamento più rigoroso.</p>
</section>
<section id="id1686">
<h4>Imposizione<a class="headerlink" href="#id1686" title="Link to this heading">¶</a></h4>
<p>Usare un compilatore C++.</p>
</section>
</section>
<section id="cpl-2-if-you-must-use-c-use-the-common-subset-of-c-and-c-and-compile-the-c-code-as-c">
<h3><a name="Rcpl-subset"></a>Se si deve usare il C, utilizzare il sotto-insieme comune al C e al C++, e compilare il codice C come C++<a class="headerlink" href="#cpl-2-if-you-must-use-c-use-the-common-subset-of-c-and-c-and-compile-the-c-code-as-c" title="Link to this heading">¶</a></h3>
<section id="id1687">
<h4>Motivo<a class="headerlink" href="#id1687" title="Link to this heading">¶</a></h4>
<p>Tale sottoinsieme può essere compilato sia con compilatori C che C++ e, quando compilato come C++, controlla meglio i tipi del «C puro».</p>
</section>
<section id="id1688">
<h4>Esempio<a class="headerlink" href="#id1688" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int* p1 = malloc(10 * sizeof(int));                      // not C++
int* p2 = static_cast&lt;int*&gt;(malloc(10 * sizeof(int)));   // not C, C-style C++
int* p3 = new int[10];                                   // not C
int* p4 = (int*) malloc(10 * sizeof(int));               // both C and C++
</pre></div>
</div>
</section>
<section id="id1689">
<h4>Imposizione<a class="headerlink" href="#id1689" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare se si usa una modalità di compilazione che compila il codice come C.</p>
<ul>
<li><p>Il compilatore C++ imporrà che il codice sia C++ sia valido a meno che non si utilizzino le opzioni per l’estensione all’uso del C.</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="cpl-3-if-you-must-use-c-for-interfaces-use-c-in-the-calling-code-using-such-interfaces">
<h3><a name="Rcpl-interface"></a>CPL.3: Se si deve usare il C per le interfacce, usare il C++ nel codice chiamante utilizzando tali interfacce<a class="headerlink" href="#cpl-3-if-you-must-use-c-for-interfaces-use-c-in-the-calling-code-using-such-interfaces" title="Link to this heading">¶</a></h3>
<section id="id1690">
<h4>Motivo<a class="headerlink" href="#id1690" title="Link to this heading">¶</a></h4>
<p>Il C++ è più espressivo del C ed offre un supporto migliore per molti tipi di programmazione.</p>
</section>
<section id="id1691">
<h4>Esempio<a class="headerlink" href="#id1691" title="Link to this heading">¶</a></h4>
<p>Ad esempio, per utilizzare una libreria C di terze parti o un’interfaccia di sistemi C, definire l’interfaccia a basso livello nel sottoinsieme comune al C e al C++ per un miglior controllo dei tipi. Quando possibile, incapsulare l’interfaccia di basso livello in un’interfaccia che segue le linee-guida del C++ (per migliorare astrazione, sicurezza della memoria e sicurezza delle risorse) ed usare questa interfaccia C++ nel codice C++.</p>
</section>
<section id="id1692">
<h4>Esempio<a class="headerlink" href="#id1692" title="Link to this heading">¶</a></h4>
<p>Si può chiamare il C dal C++:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// in C:
double sqrt(double);

// in C++:
extern &quot;C&quot; double sqrt(double);

sqrt(2);
</pre></div>
</div>
</section>
<section id="id1693">
<h4>Esempio<a class="headerlink" href="#id1693" title="Link to this heading">¶</a></h4>
<p>Si può chiamare il C++ dal C:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// in C:
X call_f(struct Y*, int);

// in C++:
extern &quot;C&quot; X call_f(Y* p, int i)
{
    return p-&gt;f(i);   // possibly a virtual function call
}
</pre></div>
</div>
</section>
<section id="id1694">
<h4>Imposizione<a class="headerlink" href="#id1694" title="Link to this heading">¶</a></h4>
<p>Nessuna necessaria</p>
</section>
</section>
</section>
<section id="sf-source-files">
<h2><a name="S-source"></a>SF: File sorgenti<a class="headerlink" href="#sf-source-files" title="Link to this heading">¶</a></h2>
<p>Distinguere tra dichiarazioni (usate come interfacce) e definizioni (usate come implementazioni). Utilizzare i file di intestazione [header] per rappresentare le interfacce ed enfatizzare la struttura logica.</p>
<p>Riepilogo delle regole sui file sorgenti:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rs-file-suffix"><span class="xref myst">SF.1: Usare un suffisso <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> per i file del codice e <code class="docutils literal notranslate"><span class="pre">.h</span></code> per i file delle interfacce nei propri progetti se non si sta già seguendo un’altra convenzione</span></a></p></li>
<li><p><a class="reference internal" href="#Rs-inline"><span class="xref myst">SF.2: Un file header non deve contenere definizioni di oggetti né definizioni di funzioni non inline</span></a></p></li>
<li><p><a class="reference internal" href="#Rs-declaration-header"><span class="xref myst">SF.3: Usare file header per tutte le dichiarazioni usate in più file sorgenti</span></a></p></li>
<li><p><a class="reference internal" href="#Rs-include-order"><span class="xref myst">SF.4: Includere i file header prima di altre dichiarazioni in un file</span></a></p></li>
<li><p><a class="reference internal" href="#Rs-consistency"><span class="xref myst">SF.5: Un file <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> deve includere file header che ne definiscono l’interfaccia</span></a></p></li>
<li><p><a class="reference internal" href="#Rs-using"><span class="xref myst">SF.6: Usare le direttive <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span></code> per la transizione, per le librerie di base (come la <code class="docutils literal notranslate"><span class="pre">std</span></code>), o (solamente) all’interno di uno scope locale</span></a></p></li>
<li><p><a class="reference internal" href="#Rs-using-directive"><span class="xref myst">SF.7: Non scrivere <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span></code> nello scope globale in un file header</span></a></p></li>
<li><p><a class="reference internal" href="#Rs-guards"><span class="xref myst">SF.8: Usare la protezione degli <code class="docutils literal notranslate"><span class="pre">#include</span></code> per tutti i file header</span></a></p></li>
<li><p><a class="reference internal" href="#Rs-cycles"><span class="xref myst">SF.9: Evitare le dipendenze cicliche tra i file sorgenti</span></a></p></li>
<li><p><a class="reference internal" href="#Rs-implicit"><span class="xref myst">SF.10: Evitare dipendenze da nomi inclusi [<code class="docutils literal notranslate"><span class="pre">#include</span></code>] implicitamente</span></a></p></li>
<li><p>[SF.11: I file header devono essere autonomi <a class="reference internal" href="#Rs-contained"><span class="xref myst">self-contained</span></a></p></li>
<li><p><a class="reference internal" href="#Rs-incform"><span class="xref myst">SF.12: Preferire la forma virgolettata di <code class="docutils literal notranslate"><span class="pre">#include</span></code> per i file relativi a quello principale e la forma con parentesi angolari negli altri casi</span></a></p></li>
<li><p><a class="reference internal" href="#Rs-portable-header-id"><span class="xref myst">SF.13: Usare identificatori portatili di header nelle istruzioni <code class="docutils literal notranslate"><span class="pre">#include</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rs-namespace"><span class="xref myst">SF.20: Usare i <code class="docutils literal notranslate"><span class="pre">namespace</span></code> per esprimere le strutture logiche</span></a></p></li>
<li><p><a class="reference internal" href="#Rs-unnamed"><span class="xref myst">SF.21: Non usare un namespace senza nome (anonimo) in un header</span></a></p></li>
<li><p><a class="reference internal" href="#Rs-unnamed2"><span class="xref myst">SF.22: Usare un namespace senza nome (anonimo) per tutte le entità interne/non-esportate</span></a></p></li>
</ul>
<section id="sf-1-use-a-cpp-suffix-for-code-files-and-h-for-interface-files-if-your-project-doesn-t-already-follow-another-convention">
<h3><a name="Rs-file-suffix"></a>SF.1: Usare un suffisso <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> per i file del codice e <code class="docutils literal notranslate"><span class="pre">.h</span></code> per i file delle interfacce nei propri progetti se non si sta già seguendo un’altra convenzione<a class="headerlink" href="#sf-1-use-a-cpp-suffix-for-code-files-and-h-for-interface-files-if-your-project-doesn-t-already-follow-another-convention" title="Link to this heading">¶</a></h3>
<p>Vedere <a class="reference internal" href="#Rl-file-suffix"><span class="xref myst">NL.27</span></a></p>
</section>
<section id="sf-2-a-header-file-must-not-contain-object-definitions-or-non-inline-function-definitions">
<h3><a name="Rs-inline"></a>SF.2: Un file header non deve contenere definizioni di oggetti né definizioni di funzioni non inline<a class="headerlink" href="#sf-2-a-header-file-must-not-contain-object-definitions-or-non-inline-function-definitions" title="Link to this heading">¶</a></h3>
<section id="id1695">
<h4>Motivo<a class="headerlink" href="#id1695" title="Link to this heading">¶</a></h4>
<p>L’inclusione di entità soggette alla regola della definizione-singola comporta errori del linker.</p>
</section>
<section id="id1696">
<h4>Esempio<a class="headerlink" href="#id1696" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// file.h:
namespace Foo {
    int x = 7;
    int xx() { return x+x; }
}

// file1.cpp:
#include &lt;file.h&gt;
// ... more ...

 // file2.cpp:
#include &lt;file.h&gt;
// ... more ...
</pre></div>
</div>
<p>Linkando <code class="docutils literal notranslate"><span class="pre">file1.cpp</span></code> e <code class="docutils literal notranslate"><span class="pre">file2.cpp</span></code> si otterranno due errori del linker.</p>
<p><strong>Formulazione alternativa</strong>: Un file header deve contenere solo:</p>
<ul class="simple">
<li><p>degli <code class="docutils literal notranslate"><span class="pre">#include</span></code> di altri file header (possibilmente con delle protezioni per gli include)</p></li>
<li><p>template</p></li>
<li><p>definizioni di classi</p></li>
<li><p>dichiarazioni di funzioni</p></li>
<li><p>dichiarazioni <code class="docutils literal notranslate"><span class="pre">extern</span></code></p></li>
<li><p>definizioni di funzioni <code class="docutils literal notranslate"><span class="pre">inline</span></code></p></li>
<li><p>definizioni <code class="docutils literal notranslate"><span class="pre">constexpr</span></code></p></li>
<li><p>definizioni <code class="docutils literal notranslate"><span class="pre">const</span></code></p></li>
<li><p>definizioni di alias <code class="docutils literal notranslate"><span class="pre">using</span></code></p></li>
<li><p>???</p></li>
</ul>
</section>
<section id="id1697">
<h4>Imposizione<a class="headerlink" href="#id1697" title="Link to this heading">¶</a></h4>
<p>Controllare l’elenco positivo precedente.</p>
</section>
</section>
<section id="sf-3-use-header-files-for-all-declarations-used-in-multiple-source-files">
<h3><a name="Rs-declaration-header"></a>SF.3: Usare file header per tutte le dichiarazioni usate in più file sorgenti<a class="headerlink" href="#sf-3-use-header-files-for-all-declarations-used-in-multiple-source-files" title="Link to this heading">¶</a></h3>
<section id="id1698">
<h4>Motivo<a class="headerlink" href="#id1698" title="Link to this heading">¶</a></h4>
<p>Manutenibilità. Leggibilità.</p>
</section>
<section id="id1699">
<h4>Esempio, cattivo<a class="headerlink" href="#id1699" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// bar.cpp:
void bar() { cout &lt;&lt; &quot;bar\n&quot;; }

// foo.cpp:
extern void bar();
void foo() { bar(); }
</pre></div>
</div>
<p>Un manutentore di <code class="docutils literal notranslate"><span class="pre">bar</span></code> non può trovare tutte le dichiarazioni di <code class="docutils literal notranslate"><span class="pre">bar</span></code> se se ne deve cambiare il tipo. L’utente di <code class="docutils literal notranslate"><span class="pre">bar</span></code> non può sapere se l’interfaccia usata è completa e corretta. Nel migliore dei casi, verranno dei messaggi di errore (in ritardo) dal linker.</p>
</section>
<section id="id1700">
<h4>Imposizione<a class="headerlink" href="#id1700" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare le dichiarazioni di entità in altri file sorgenti non inserite in un <code class="docutils literal notranslate"><span class="pre">.h</span></code>.</p></li>
</ul>
</section>
</section>
<section id="sf-4-include-header-files-before-other-declarations-in-a-file">
<h3><a name="Rs-include-order"></a>SF.4: Includere i file header prima di altre dichiarazioni in un file<a class="headerlink" href="#sf-4-include-header-files-before-other-declarations-in-a-file" title="Link to this heading">¶</a></h3>
<section id="id1701">
<h4>Motivo<a class="headerlink" href="#id1701" title="Link to this heading">¶</a></h4>
<p>Ridurre le dipendenze dal contesto ed aumentare la leggibilità.</p>
</section>
<section id="id1702">
<h4>Esempio<a class="headerlink" href="#id1702" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

// ... my code here ...
</pre></div>
</div>
</section>
<section id="id1703">
<h4>Esempio, cattivo<a class="headerlink" href="#id1703" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;vector&gt;

// ... my code here ...

#include &lt;algorithm&gt;
#include &lt;string&gt;
</pre></div>
</div>
</section>
<section id="id1704">
<h4>Nota<a class="headerlink" href="#id1704" title="Link to this heading">¶</a></h4>
<p>Questo vale sia per i file <code class="docutils literal notranslate"><span class="pre">.h</span></code> che i <code class="docutils literal notranslate"><span class="pre">.cpp</span></code>.</p>
</section>
<section id="id1705">
<h4>Nota<a class="headerlink" href="#id1705" title="Link to this heading">¶</a></h4>
<p>C’è una discussione per isolare il codice dalle dichiarazioni e le macro nei file header <code class="docutils literal notranslate"><span class="pre">#include</span></code>ndo degli header <em>dopo</em> il codice che si vuol proteggere (come nell’esempio etichettato come «bad»). Tuttavia</p>
<ul class="simple">
<li><p>questo funziona solo per un file (a un livello): Se si usa questa tecnica negli header inclusi con altri header la vulnerabilità riappare.</p></li>
<li><p>un namespace (un «namespace di implementazione») può proteggere da molte dipendenze dal contesto.</p></li>
<li><p>la totale protezione e flessibilità si ottiene con i moduli.</p></li>
</ul>
<p><strong>Si veda anche</strong>:</p>
<ul class="simple">
<li><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4592.pdf">Bozza di Lavoro, Estensioni al C++ per i Moduli</a></p></li>
<li><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0141r0.pdf">Modules, Componentization, and Transition</a></p></li>
</ul>
</section>
<section id="id1706">
<h4>Imposizione<a class="headerlink" href="#id1706" title="Link to this heading">¶</a></h4>
<p>Facile.</p>
</section>
</section>
<section id="sf-5-a-cpp-file-must-include-the-header-file-s-that-defines-its-interface">
<h3><a name="Rs-consistency"></a>SF.5: Un file <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> deve includere file header che ne definiscono l’interfaccia<a class="headerlink" href="#sf-5-a-cpp-file-must-include-the-header-file-s-that-defines-its-interface" title="Link to this heading">¶</a></h3>
<section id="id1707">
<h4>Motivo<a class="headerlink" href="#id1707" title="Link to this heading">¶</a></h4>
<p>Questo consente al compilatore di fare un controllo di coerenza in anticipo.</p>
</section>
<section id="id1708">
<h4>Esempio, cattivo<a class="headerlink" href="#id1708" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// foo.h:
void foo(int);
int bar(long);
int foobar(int);

// foo.cpp:
void foo(int) { /* ... */ }
int bar(double) { /* ... */ }
double foobar(int);
</pre></div>
</div>
<p>Gli errori non verranno rilevati fino al momento del link per un programma che chiama <code class="docutils literal notranslate"><span class="pre">bar</span></code> o <code class="docutils literal notranslate"><span class="pre">foobar</span></code>.</p>
</section>
<section id="id1709">
<h4>Esempio<a class="headerlink" href="#id1709" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// foo.h:
void foo(int);
int bar(long);
int foobar(int);

// foo.cpp:
#include &quot;foo.h&quot;

void foo(int) { /* ... */ }
int bar(double) { /* ... */ }
double foobar(int);   // error: wrong return type
</pre></div>
</div>
<p>L’errore sul tipo restituito per <code class="docutils literal notranslate"><span class="pre">foobar</span></code> ora viene intercettato immediatamente quando si compila <code class="docutils literal notranslate"><span class="pre">foo.cpp</span></code>. L’errore sul tipo dell’argomento per <code class="docutils literal notranslate"><span class="pre">bar</span></code> non può essere intercettato fino al momento del link perché c’è la possibilità dell’overloading, ma l’uso sistematico dei file <code class="docutils literal notranslate"><span class="pre">.h</span></code> aumenta la la probabilità venga rilevato prima dal programmatore.</p>
</section>
<section id="id1710">
<h4>Imposizione<a class="headerlink" href="#id1710" title="Link to this heading">¶</a></h4>
<p>???</p>
</section>
</section>
<section id="sf-6-use-using-namespace-directives-for-transition-for-foundation-libraries-such-as-std-or-within-a-local-scope-only">
<h3><a name="Rs-using"></a>SF.6: Usare le direttive <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span></code> per la transizione, per le librerie di base (come la <code class="docutils literal notranslate"><span class="pre">std</span></code>), o (solamente) all’interno di uno scope locale<a class="headerlink" href="#sf-6-use-using-namespace-directives-for-transition-for-foundation-libraries-such-as-std-or-within-a-local-scope-only" title="Link to this heading">¶</a></h3>
<section id="id1711">
<h4>Motivo<a class="headerlink" href="#id1711" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span></code> può portare a conflitti con i nomi, quindi dovrebbe essere usato con parsimonia.  Tuttavia, non è sempre possibile qualificare ogni nome da un namespace nel codice utente (p.es., durante la transizione) e talvolta un namespace è così fondamentale e prevalente nel codice, che una qualificazione coerente sarebbe prolissa e distraente.</p>
</section>
<section id="id1712">
<h4>Esempio<a class="headerlink" href="#id1712" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;algorithm&gt;

using namespace std;

// ...
</pre></div>
</div>
<p>Qui (ovviamente), la libreria standard viene utilizzata in modo pervasivo e apparentemente non ne vengono usate altre, quindi richiedere <code class="docutils literal notranslate"><span class="pre">std::</span></code> ovunque può portare a distrazioni.</p>
</section>
<section id="id1713">
<h4>Esempio<a class="headerlink" href="#id1713" title="Link to this heading">¶</a></h4>
<p>L’utilizzo di <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">std;</span></code> lascia il programmatore la possibilità di andare in conflitto con un nome dalla libreria standard</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;cmath&gt;
using namespace std;

int g(int x)
{
    int sqrt = 7;
    // ...
    return sqrt(x); // error
}
</pre></div>
</div>
<p>Tuttavia, questo non favorisce particolarmente una soluzione dei conflitti senza errori e quelli che usano <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">std</span></code> si suppone che sappiano di <code class="docutils literal notranslate"><span class="pre">std</span></code> e di questo rischio.</p>
</section>
<section id="id1714">
<h4>Nota<a class="headerlink" href="#id1714" title="Link to this heading">¶</a></h4>
<p>Un file <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> è una forma di scope locale. C’è poca differenza nelle probabilità di conflitti sui nomi tra un <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> di N-righe contenente <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">X</span></code>, una funzione di N-righe contenente <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">X</span></code>, e M funzioni ciascuna contenente un <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">X</span></code> con N righe di codice in totale.</p>
</section>
<section id="id1715">
<h4>Nota<a class="headerlink" href="#id1715" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="#Rs-using-directive"><span class="xref myst">Non scrivere <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span></code> nello scope globale in un file header</span></a>.</p>
</section>
</section>
<section id="sf-7-don-t-write-using-namespace-at-global-scope-in-a-header-file">
<h3><a name="Rs-using-directive"></a>SF.7: Non scrivere <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span></code> nello scope globale in un file header<a class="headerlink" href="#sf-7-don-t-write-using-namespace-at-global-scope-in-a-header-file" title="Link to this heading">¶</a></h3>
<section id="id1716">
<h4>Motivo<a class="headerlink" href="#id1716" title="Link to this heading">¶</a></h4>
<p>Facendolo si elimina la capacità di chi <code class="docutils literal notranslate"><span class="pre">#include</span></code> di chiarire efficacemente e usare alternative. Rende anche gli header inclusi [<code class="docutils literal notranslate"><span class="pre">#include</span></code>] dipendenti dall’ordine in quanto potrebbero avere un significato diverso se inclusi in un ordine diverso.</p>
</section>
<section id="id1717">
<h4>Esempio<a class="headerlink" href="#id1717" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// bad.h
#include &lt;iostream&gt;
using namespace std; // bad

// user.cpp
#include &quot;bad.h&quot;

bool copy(/*... some parameters ...*/);    // some function that happens to be named copy

int main()
{
    copy(/*...*/);    // now overloads local ::copy and std::copy, could be ambiguous
}
</pre></div>
</div>
</section>
<section id="id1718">
<h4>Nota<a class="headerlink" href="#id1718" title="Link to this heading">¶</a></h4>
<p>Un’eccezione è <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">std::literals;</span></code>. Questo è necessario per usare le stringhe letterali nei file header e date <a class="reference external" href="http://eel.is/c++draft/over.literal">le regole</a> - gli utenti sono tenuti a dare un nome ai propri UDL <code class="docutils literal notranslate"><span class="pre">operator&quot;&quot;_x</span></code> - non collideranno con la libreria standard.</p>
</section>
<section id="id1719">
<h4>Imposizione<a class="headerlink" href="#id1719" title="Link to this heading">¶</a></h4>
<p>Segnalare <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span></code> nello scope globale nel file header.</p>
</section>
</section>
<section id="sf-8-use-include-guards-for-all-header-files">
<h3><a name="Rs-guards"></a>SF.8: Usare la protezione degli <code class="docutils literal notranslate"><span class="pre">#include</span></code> per tutti i file header<a class="headerlink" href="#sf-8-use-include-guards-for-all-header-files" title="Link to this heading">¶</a></h3>
<section id="id1720">
<h4>Motivo<a class="headerlink" href="#id1720" title="Link to this heading">¶</a></h4>
<p>Per evitare che i file vengano inclusi [<code class="docutils literal notranslate"><span class="pre">#include</span></code>] più volte.</p>
<p>Per evitare le collisioni tra le protezioni degli include, non ci si limiti a dare un nome alla protezione dopo il nome del file. Assicurarsi di includere anche una chiave ed un buon differenziatore, come il nome della libreria o del componente di cui fa parte il file header.</p>
</section>
<section id="id1721">
<h4>Esempio<a class="headerlink" href="#id1721" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// file foobar.h:
#ifndef LIBRARY_FOOBAR_H
#define LIBRARY_FOOBAR_H
// ... declarations ...
#endif // LIBRARY_FOOBAR_H
</pre></div>
</div>
</section>
<section id="id1722">
<h4>Imposizione<a class="headerlink" href="#id1722" title="Link to this heading">¶</a></h4>
<p>Segnalare i <code class="docutils literal notranslate"><span class="pre">.h</span></code> senza le protezioni degli <code class="docutils literal notranslate"><span class="pre">#include</span></code>.</p>
</section>
<section id="id1723">
<h4>Nota<a class="headerlink" href="#id1723" title="Link to this heading">¶</a></h4>
<p>Alcune implementazioni offrono delle estensioni come <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">once</span></code> come alternative alle protezioni degli include. Questo non è standard e non è portabile.  Esso inietta la semantica del filesystem della macchina host nel proprio programma, oltre a legarsi ad un fornitore. La raccomandazione è quella di scrivere in C++ ISO: Cfr. <a class="reference internal" href="#Rp-Cplusplus"><span class="xref myst">regola P.2</span></a>.</p>
</section>
</section>
<section id="sf-9-avoid-cyclic-dependencies-among-source-files">
<h3><a name="Rs-cycles"></a>SF.9: Evitare le dipendenze cicliche tra i file sorgenti<a class="headerlink" href="#sf-9-avoid-cyclic-dependencies-among-source-files" title="Link to this heading">¶</a></h3>
<section id="id1724">
<h4>Motivo<a class="headerlink" href="#id1724" title="Link to this heading">¶</a></h4>
<p>La ciclicità complica la comprensione e rallenta la compilazione. Esse, inoltre, complicano la conversione per l’uso dei moduli supportati dal linguaggio (quando saranno disponibili).</p>
</section>
<section id="id1725">
<h4>Nota<a class="headerlink" href="#id1725" title="Link to this heading">¶</a></h4>
<p>Eliminare le ciclicità; non limitarsi ad interromperli con le protezioni degli <code class="docutils literal notranslate"><span class="pre">#include</span></code>.</p>
</section>
<section id="id1726">
<h4>Esempio, cattivo<a class="headerlink" href="#id1726" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// file1.h:
#include &quot;file2.h&quot;

// file2.h:
#include &quot;file3.h&quot;

// file3.h:
#include &quot;file1.h&quot;
</pre></div>
</div>
</section>
<section id="id1727">
<h4>Imposizione<a class="headerlink" href="#id1727" title="Link to this heading">¶</a></h4>
<p>Segnalare tutte le ciclicità.</p>
</section>
</section>
<section id="sf-10-avoid-dependencies-on-implicitly-included-names">
<h3><a name="Rs-implicit"></a>SF.10: Evitare dipendenze da nomi inclusi con <code class="docutils literal notranslate"><span class="pre">#include</span></code> implicitamente<a class="headerlink" href="#sf-10-avoid-dependencies-on-implicitly-included-names" title="Link to this heading">¶</a></h3>
<section id="id1728">
<h4>Motivo<a class="headerlink" href="#id1728" title="Link to this heading">¶</a></h4>
<p>Evitare sorprese. Evitare di dover modificare gli <code class="docutils literal notranslate"><span class="pre">#include</span></code> se si modifica l’header di un <code class="docutils literal notranslate"><span class="pre">#include</span></code>. Evitare di diventare accidentalmente dipendenti dai dettagli dell’implementazione e da entità logicamente separate incluse in un header.</p>
</section>
<section id="id1729">
<h4>Esempio, cattivo<a class="headerlink" href="#id1729" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;iostream&gt;
using namespace std;

void use()
{
    string s;
    cin &gt;&gt; s;               // fine
    getline(cin, s);        // error: getline() not defined
    if (s == &quot;surprise&quot;) {  // error == not defined
        // ...
    }
}
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&lt;iostream&gt;</span></code> espone la definizione di <code class="docutils literal notranslate"><span class="pre">std::string</span></code> («perché?» sembra un quiz divertente), ma non è necessario farlo, quindi include transitivamente tutto l’header di <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code>, da cui la nota domanda del principiante «perché <code class="docutils literal notranslate"><span class="pre">getline(cin,s);</span></code> non funziona?» o anche delle eventuali «<code class="docutils literal notranslate"><span class="pre">string</span></code>he non si possono confrontare con <code class="docutils literal notranslate"><span class="pre">==</span></code>»).</p>
<p>La soluzione è scrivere esplicitamente <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;string&gt;</span></code>:</p>
</section>
<section id="id1730">
<h4>Esempio, buono<a class="headerlink" href="#id1730" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

void use()
{
    string s;
    cin &gt;&gt; s;               // fine
    getline(cin, s);        // fine
    if (s == &quot;surprise&quot;) {  // fine
        // ...
    }
}
</pre></div>
</div>
</section>
<section id="id1731">
<h4>Nota<a class="headerlink" href="#id1731" title="Link to this heading">¶</a></h4>
<p>Alcuni header esistono precisamente per raggruppare un insieme di dichiarazioni coerenti provenienti da vari header. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// basic_std_lib.h:

#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;vector&gt;
</pre></div>
</div>
<p>ora un utente può ottenere questo insieme di dichiarazioni con un solo <code class="docutils literal notranslate"><span class="pre">#include</span></code></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &quot;basic_std_lib.h&quot;
</pre></div>
</div>
<p>Questa regola contro l’inclusione implicita non intende impedire questo tipo di deliberate aggregazioni.</p>
</section>
<section id="id1732">
<h4>Imposizione<a class="headerlink" href="#id1732" title="Link to this heading">¶</a></h4>
<p>Una imposizione richiederebbe la conoscenze di quello che in un header si vuole «esportare» agli utenti e quello che serve per l’implementazione. Nessuna soluzione davvero valida è possibile fino a quando non ci saranno i moduli.</p>
</section>
</section>
<section id="sf-11-header-files-should-be-self-contained">
<h3><a name="Rs-contained"></a>SF.11: I file header devono essere autonomi [self-contained]<a class="headerlink" href="#sf-11-header-files-should-be-self-contained" title="Link to this heading">¶</a></h3>
<section id="id1733">
<h4>Motivo<a class="headerlink" href="#id1733" title="Link to this heading">¶</a></h4>
<p>Usabilità, gli header dovrebbero essere semplici da usare e funzionare se inclusi da soli. Gli header dovrebbero incapsulare le funzionalità che forniscono. Evitare che i clienti di un header ne debbano gestire le dipendenze.</p>
</section>
<section id="id1734">
<h4>Esempio<a class="headerlink" href="#id1734" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &quot;helpers.h&quot;
// helpers.h depends on std::string and includes &lt;string&gt;
</pre></div>
</div>
</section>
<section id="id1735">
<h4>Nota<a class="headerlink" href="#id1735" title="Link to this heading">¶</a></h4>
<p>La mancata osservanza di ciò comporta errori difficili da diagnosticare per i clienti di un header.</p>
</section>
<section id="id1736">
<h4>Nota<a class="headerlink" href="#id1736" title="Link to this heading">¶</a></h4>
<p>Un header dovrebbe includere tutte le sue dipendenze. Prestare attenzione all’utilizzo dei path relativi poiché le implementazioni C++ differiscono sul loro significato.</p>
</section>
<section id="id1737">
<h4>Imposizione<a class="headerlink" href="#id1737" title="Link to this heading">¶</a></h4>
<p>Un test dovrebbe verificare che l’header stesso compili e che si compili anche un file cpp che includa il solo file header.</p>
</section>
</section>
<section id="sf-12-prefer-the-quoted-form-of-include-for-files-relative-to-the-including-file-and-the-angle-bracket-form-everywhere-else">
<h3><a name="Rs-incform"></a>SF.12: Preferire la forma virgolettata di <code class="docutils literal notranslate"><span class="pre">#include</span></code> per i file relativi a quello principale e la forma con parentesi angolari negli altri casi<a class="headerlink" href="#sf-12-prefer-the-quoted-form-of-include-for-files-relative-to-the-including-file-and-the-angle-bracket-form-everywhere-else" title="Link to this heading">¶</a></h3>
<section id="id1738">
<h4>Motivo<a class="headerlink" href="#id1738" title="Link to this heading">¶</a></h4>
<p>Lo <a class="reference external" href="http://eel.is/c++draft/cpp.include">standard</a> impone ai compilatori di implementare le due forme di sintassi per gli <code class="docutils literal notranslate"><span class="pre">#include</span></code> lasciando la scelta tra le parentesi angolari (<code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code>) e le virgolette (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>). I produttori se ne avvantaggiano usando algoritmi diversi di ricerca e metodi per indicare il percorso per l’include.</p>
<p>Tuttavia, il consiglio è quello di utilizzare la forma virgolettata per includere i file che esistono su un percorso relativo a quello contenente l’istruzione <code class="docutils literal notranslate"><span class="pre">#include</span></code> (all’interno dello stesso componente o progetto) e di usare la forma con le parentesi angolari in tutti gli altri casi, dove possibile. Ciò incoraggia ad essere chiari riguardo la posizione relativa del file rispetto a quelli che lo includono e agli scenari in cui si richiedono diversi algoritmi di ricerca. Questo rende subito comprensibile se un header viene incluso da un file locale o da un header di una libreria standard o anche da un percorso alternativo di ricerca (p.es. un header da un’altra libreria o da insieme comune di inclusione).</p>
</section>
<section id="id1739">
<h4>Esempio<a class="headerlink" href="#id1739" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// foo.cpp:
#include &lt;string&gt;                // From the standard library, requires the &lt;&gt; form
#include &lt;some_library/common.h&gt; // A file that is not locally relative, included from another library; use the &lt;&gt; form
#include &quot;foo.h&quot;                 // A file locally relative to foo.cpp in the same project, use the &quot;&quot; form
#include &quot;util/util.h&quot;           // A file locally relative to foo.cpp in the same project, use the &quot;&quot; form
#include &lt;component_b/bar.h&gt;     // A file in the same project located via a search path, use the &lt;&gt; form
</pre></div>
</div>
</section>
<section id="id1740">
<h4>Nota<a class="headerlink" href="#id1740" title="Link to this heading">¶</a></h4>
<p>La mancata osservanza di ciò porta ad una diagnostica difficoltosa degli errori a causa del prelievo del file sbagliato dovuto ad un’errata indicazione del percorso di quanto si include. Per esempio, in un tipico caso in cui l’algoritmo di ricerca di <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;&quot;</span></code> potrebbe cercare un file dapprima posizionato in un percorso locale relativo, poi utilizzare questa forma per far riferimento ad un file non localmente relativo potrebbe significare che se un file dovesse mai esistere nel percorso locale relativo (p.es. il file principale è stato spostato in una nuova posizione), verrà trovato prima del del file include precedente e l’insieme degli include risulteranno modificati in modo inaspettato.</p>
<p>I creatori delle librerie dovrebbero mettere i loro header in una cartella e fare in modo che i loro utenti li includano con un path relativo <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;some_library/common.h&gt;</span></code></p>
</section>
<section id="id1741">
<h4>Imposizione<a class="headerlink" href="#id1741" title="Link to this heading">¶</a></h4>
<p>Un test dovrebbe individuare se gli header referenziati tramite <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> possono invece essere referenziati con <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code>.</p>
</section>
</section>
<section id="sf-13-use-portable-header-identifiers-in-include-statements">
<h3><a name="Rs-portable-header-id"></a>SF.13: Usare identificatori portatili di header nelle istruzioni <code class="docutils literal notranslate"><span class="pre">#include</span></code><a class="headerlink" href="#sf-13-use-portable-header-identifiers-in-include-statements" title="Link to this heading">¶</a></h3>
<section id="id1742">
<h4>Motivo<a class="headerlink" href="#id1742" title="Link to this heading">¶</a></h4>
<p>Lo <a class="reference external" href="http://eel.is/c++draft/cpp.include">standard</a> non specifica come i compilatori individuano in modo univoco gli header da un identificatore in una direttiva <code class="docutils literal notranslate"><span class="pre">#include</span></code>, né specifica cosa costituisce l’unicità. Ad esempio, se l’implementazione considera gli identificatori con distinzione tra maiuscole e minuscole o se gli identificatori sono path del file system verso un file header e, in tal caso, come viene delimitato un path gerarchico del file system.</p>
<p>Per massimizzare la portabilità delle direttive <code class="docutils literal notranslate"><span class="pre">#include</span></code> tra compilatori, le linee guida sono:</p>
<ul class="simple">
<li><p>utilizzare la distinzione tra maiuscole e minuscole per l’identificatore dell’header, corrispondendo al modo in cui l’header è definita dallo standard, dalla specifica, dall’implementazione o dal file che fornisce l’header.</p></li>
<li><p>quando l’identificatore dell’header è un path gerarchico, utilizzare la barra <code class="docutils literal notranslate"><span class="pre">/</span></code> per delimitare i componenti del percorso poiché questo è il carattere di delimitazione più ampiamente accettato per i path.</p></li>
</ul>
</section>
<section id="id1743">
<h4>Esempio<a class="headerlink" href="#id1743" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// good examples
#include &lt;vector&gt;
#include &lt;string&gt;
#include &quot;util/util.h&quot;

// bad examples
#include &lt;VECTOR&gt;        // bad: the standard library defines a header identified as &lt;vector&gt;, not &lt;VECTOR&gt;
#include &lt;String&gt;        // bad: the standard library defines a header identified as &lt;string&gt;, not &lt;String&gt;
#include &quot;Util/Util.H&quot;   // bad: the header file exists on the file system as &quot;util/util.h&quot;
#include &quot;util\util.h&quot;   // bad: may not work if the implementation interprets `\u` as an escape sequence, or where &#39;\&#39; is not a valid path separator
</pre></div>
</div>
</section>
<section id="id1744">
<h4>Imposizione<a class="headerlink" href="#id1744" title="Link to this heading">¶</a></h4>
<p>È possibile applicare solo su implementazioni in cui gli identificatori di header fanno distinzione tra maiuscole e minuscole e che supportano solo <code class="docutils literal notranslate"><span class="pre">/</span></code> come delimitatore del path del file.</p>
</section>
</section>
<section id="sf-20-use-namespaces-to-express-logical-structure">
<h3><a name="Rs-namespace"></a>SF.20: Usare i <code class="docutils literal notranslate"><span class="pre">namespace</span></code> per esprimere le strutture logiche<a class="headerlink" href="#sf-20-use-namespaces-to-express-logical-structure" title="Link to this heading">¶</a></h3>
<section id="id1745">
<h4>Motivo<a class="headerlink" href="#id1745" title="Link to this heading">¶</a></h4>
<p>???</p>
</section>
<section id="id1746">
<h4>Esempio<a class="headerlink" href="#id1746" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1747">
<h4>Imposizione<a class="headerlink" href="#id1747" title="Link to this heading">¶</a></h4>
<p>???</p>
</section>
</section>
<section id="sf-21-don-t-use-an-unnamed-anonymous-namespace-in-a-header">
<h3><a name="Rs-unnamed"></a>SF.21: Non usare un namespace senza nome (anonimo) in un header<a class="headerlink" href="#sf-21-don-t-use-an-unnamed-anonymous-namespace-in-a-header" title="Link to this heading">¶</a></h3>
<section id="id1748">
<h4>Motivo<a class="headerlink" href="#id1748" title="Link to this heading">¶</a></h4>
<p>È quasi sempre un errore menzionare un namespace senza nome in un file header.</p>
</section>
<section id="id1749">
<h4>Esempio<a class="headerlink" href="#id1749" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// file foo.h:
namespace
{
    const double x = 1.234;  // bad

    double foo(double y)     // bad
    {
        return y + x;
    }
}

namespace Foo
{
    const double x = 1.234; // good

    inline double foo(double y)        // good
    {
        return y + x;
    }
}
</pre></div>
</div>
</section>
<section id="id1750">
<h4>Imposizione<a class="headerlink" href="#id1750" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare qualsiasi uso di un namespace anonimo in un file header.</p></li>
</ul>
</section>
</section>
<section id="sf-22-use-an-unnamed-anonymous-namespace-for-all-internal-non-exported-entities">
<h3><a name="Rs-unnamed2"></a>SF.22: Usare un namespace senza nome (anonimo) per tutte le entità interne/non-esportate<a class="headerlink" href="#sf-22-use-an-unnamed-anonymous-namespace-for-all-internal-non-exported-entities" title="Link to this heading">¶</a></h3>
<section id="id1751">
<h4>Motivo<a class="headerlink" href="#id1751" title="Link to this heading">¶</a></h4>
<p>Niente all’esterno può dipendere da un’entità in un namespace annidato senza nome. Considerare di mettere ogni definizione in un file sorgente dell’implementazione, in un namespace senza nome, a meno che non definisca un’entità «esterna/esportata».</p>
</section>
<section id="id1752">
<h4>Esempio; cattivo<a class="headerlink" href="#id1752" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int f();
int g();
static bool h();
int k();
</pre></div>
</div>
</section>
<section id="id1753">
<h4>Esempio; buono<a class="headerlink" href="#id1753" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>namespace {
    int f();
    bool h();
}
int g();
int k();
</pre></div>
</div>
</section>
<section id="id1754">
<h4>Esempio<a class="headerlink" href="#id1754" title="Link to this heading">¶</a></h4>
<p>Una classe API e i suoi membri non possono stare in un namespace anonimo; ma ogni classe «helper» o funzione definita in un file sorgente dell’implementazione deve stare nello scope di un namespace senza nome.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1755">
<h4>Imposizione<a class="headerlink" href="#id1755" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>???</p></li>
</ul>
</section>
</section>
</section>
<section id="sl-the-standard-library">
<h2><a name="S-stdlib"></a>SL: La Libreria Standard [Standard Library]<a class="headerlink" href="#sl-the-standard-library" title="Link to this heading">¶</a></h2>
<p>Usando il solo linguaggio, ogni attività risulta noiosa (in qualsiasi linguaggio). Utilizzando una libreria adatta ogni attività si semplifica.</p>
<p>La libreria standard è cresciuta gradualmente negli anni. La sua descrizione nello standard è ora più ampia di quella delle funzionalità del linguaggio. Quindi, probabilmente questa sezione delle linee-guida crescerà allo stesso modo uguagliando o superando tutto il resto.</p>
<p>&lt;&lt; ??? C’è bisogno di un altro livello nella numerazione delle regole??? &gt;&gt;</p>
<p>Riepilogo dei componenti della Libreria Standard C++:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#SS-con"><span class="xref myst">SL.con: Contenitori</span></a></p></li>
<li><p><a class="reference internal" href="#SS-string"><span class="xref myst">SL.str: Stringhe</span></a></p></li>
<li><p><a class="reference internal" href="#SS-io"><span class="xref myst">SL.io: Iostream</span></a></p></li>
<li><p><a class="reference internal" href="#SS-regex"><span class="xref myst">SL.regex: Regex</span></a></p></li>
<li><p><a class="reference internal" href="#SS-chrono"><span class="xref myst">SL.chrono: Time</span></a></p></li>
<li><p><a class="reference internal" href="#SS-clib"><span class="xref myst">SL.C: La Libreria Standard del C</span></a></p></li>
</ul>
<p>Riepilogo delle regole sulla libreria standard:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rsl-lib"><span class="xref myst">SL.1: Usare le librerie dove possibile</span></a></p></li>
<li><p><a class="reference internal" href="#Rsl-sl"><span class="xref myst">SL.2: Preferire la libreria standard ad altre librerie</span></a></p></li>
<li><p><a class="reference internal" href="#sl-std"><span class="xref myst">SL.3: Non aggiungere entità non-standard al namespace <code class="docutils literal notranslate"><span class="pre">std</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#sl-safe"><span class="xref myst">SL.4: Usare la libreria standard in modo sicuro per i tipi [type-safe]</span></a></p></li>
<li><p>???</p></li>
</ul>
<section id="sl-1-use-libraries-wherever-possible">
<h3><a name="Rsl-lib"></a>SL.1:  Usare le librerie dove possibile<a class="headerlink" href="#sl-1-use-libraries-wherever-possible" title="Link to this heading">¶</a></h3>
<section id="id1756">
<h4>Motivo<a class="headerlink" href="#id1756" title="Link to this heading">¶</a></h4>
<p>Si risparmia tempo. Non si re-inventa la ruota. Non si replica il lavoro di altri. Si approfitta del lavoro di altri quando apportano miglioramenti. Si aiutano altre persone quando si fanno dei miglioramenti.</p>
</section>
</section>
<section id="sl-2-prefer-the-standard-library-to-other-libraries">
<h3><a name="Rsl-sl"></a>SL.2: Preferire la libreria standard ad altre librerie<a class="headerlink" href="#sl-2-prefer-the-standard-library-to-other-libraries" title="Link to this heading">¶</a></h3>
<section id="id1757">
<h4>Motivo<a class="headerlink" href="#id1757" title="Link to this heading">¶</a></h4>
<p>Molte persone conoscono la libreria standard. È più probabile che sia stabile, ben mantenuta e ampiamente disponibile rispetto al proprio codice o alla maggior parte delle altre librerie.</p>
</section>
</section>
<section id="sl-3-do-not-add-non-standard-entities-to-namespace-std">
<h3><a name="sl-std"></a>SL.3: Non aggiungere entità non-standard al namespace <code class="docutils literal notranslate"><span class="pre">std</span></code><a class="headerlink" href="#sl-3-do-not-add-non-standard-entities-to-namespace-std" title="Link to this heading">¶</a></h3>
<section id="id1758">
<h4>Motivo<a class="headerlink" href="#id1758" title="Link to this heading">¶</a></h4>
<p>L’aggiunta a <code class="docutils literal notranslate"><span class="pre">std</span></code> potrebbe modificare il significato di codice conforme agli standard. Le aggiunte a <code class="docutils literal notranslate"><span class="pre">std</span></code> potrebbero creare conflitti con le future versioni dello standard.</p>
</section>
<section id="id1759">
<h4>Esempio<a class="headerlink" href="#id1759" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>namespace std { // BAD: violates standard

class My_vector {
    //     . . .
};

}

namespace Foo { // GOOD: user namespace is allowed

class My_vector {
    //     . . .
};

}
</pre></div>
</div>
</section>
<section id="id1760">
<h4>Imposizione<a class="headerlink" href="#id1760" title="Link to this heading">¶</a></h4>
<p>Possibile, ma disordinata e suscettibile di causare problemi con le piattaforme.</p>
</section>
</section>
<section id="sl-4-use-the-standard-library-in-a-type-safe-manner">
<h3><a name="sl-safe"></a>SL.4: Usare la libreria standard in modo sicuro per i tipi [type-safe]<a class="headerlink" href="#sl-4-use-the-standard-library-in-a-type-safe-manner" title="Link to this heading">¶</a></h3>
<section id="id1761">
<h4>Motivo<a class="headerlink" href="#id1761" title="Link to this heading">¶</a></h4>
<p>Perché, ovviamente, infrangere questa regola può portare a comportamenti indefiniti, corruzione della memoria e tutti i tipi di altri pessimi errori.</p>
</section>
<section id="id1762">
<h4>Nota<a class="headerlink" href="#id1762" title="Link to this heading">¶</a></h4>
<p>Questa è una meta-regola semi-filosofica, che necessita di molte regole concrete a supporto. È necessaria come un ombrello per regole più specifiche.</p>
<p>Riepilogo delle regole più specifiche:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sl-safe"><span class="xref myst">SL.4: Usare la libreria standard in modo sicuro per i tipi [type-safe]</span></a></p></li>
</ul>
</section>
</section>
<section id="sl-con-containers">
<h3><a name="SS-con"></a>SL.con: Contenitori<a class="headerlink" href="#sl-con-containers" title="Link to this heading">¶</a></h3>
<p>???</p>
<p>Riepilogo delle regole sui contenitori:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rsl-arrays"><span class="xref myst">SL.con.1: Preferire l’uso dell”<code class="docutils literal notranslate"><span class="pre">array</span></code> o del <code class="docutils literal notranslate"><span class="pre">vector</span></code> della STL anziché l’array del C</span></a></p></li>
<li><p><a class="reference internal" href="#Rsl-vector"><span class="xref myst">SL.con.2: Preferire l’uso del <code class="docutils literal notranslate"><span class="pre">vector</span></code> della STL di default a meno che non ci sia un motivo per usare un contenitore differente</span></a></p></li>
<li><p><a class="reference internal" href="#Rsl-bounds"><span class="xref myst">SL.con.3: Evitare gli errori sui limiti [bound]</span></a></p></li>
<li><p><a class="reference internal" href="#Rsl-copy"><span class="xref myst">SL.con.4: non usare <code class="docutils literal notranslate"><span class="pre">memset</span></code> o <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> per gli argomenti che non siano facilmente copiabili</span></a></p></li>
</ul>
<section id="sl-con-1-prefer-using-stl-array-or-vector-instead-of-a-c-array">
<h4><a name="Rsl-arrays"></a>SL.con.1: Preferire l’uso dell”<code class="docutils literal notranslate"><span class="pre">array</span></code> o del <code class="docutils literal notranslate"><span class="pre">vector</span></code> della STL anziché l’array del C<a class="headerlink" href="#sl-con-1-prefer-using-stl-array-or-vector-instead-of-a-c-array" title="Link to this heading">¶</a></h4>
<section id="id1763">
<h5>Motivo<a class="headerlink" href="#id1763" title="Link to this heading">¶</a></h5>
<p>Gli array del C sono meno sicuri e non hanno vantaggi rispetto ad <code class="docutils literal notranslate"><span class="pre">array</span></code> ed a <code class="docutils literal notranslate"><span class="pre">vector</span></code>. Per un array a lunghezza fissa, si usa <code class="docutils literal notranslate"><span class="pre">std::array</span></code>, che non degenera in un puntatore quando viene passato ad una funzione e conosce la propria dimensione. Inoltre, come un array nativo, uno <code class="docutils literal notranslate"><span class="pre">std::array</span></code> allocato sullo stack tiene i suoi elementi sullo stack. Per un array a lunghezza variabile, si usa <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>, che può inoltre modificare la sua dimensione e gestire l’allocazione della memoria.</p>
</section>
<section id="id1764">
<h5>Esempio<a class="headerlink" href="#id1764" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int v[SIZE];                        // BAD

std::array&lt;int, SIZE&gt; w;            // ok
</pre></div>
</div>
</section>
<section id="id1765">
<h5>Esempio<a class="headerlink" href="#id1765" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int* v = new int[initial_size];     // BAD, owning raw pointer
delete[] v;                         // BAD, manual delete

std::vector&lt;int&gt; w(initial_size);   // ok
</pre></div>
</div>
</section>
<section id="id1766">
<h5>Nota<a class="headerlink" href="#id1766" title="Link to this heading">¶</a></h5>
<p>Usare <code class="docutils literal notranslate"><span class="pre">gsl::span</span></code> per i riferimenti non proprietari in un contenitore [container].</p>
</section>
<section id="id1767">
<h5>Nota<a class="headerlink" href="#id1767" title="Link to this heading">¶</a></h5>
<p>Il confronto delle prestazioni tra un array a dimensione fissa allocato sullo stack rispetto ad un <code class="docutils literal notranslate"><span class="pre">vector</span></code> con gli elementi sull’heap [free store] è falsato. Si potrebbe anche confrontare uno <code class="docutils literal notranslate"><span class="pre">std::array</span></code> sullo stack rispetto all’accesso al risultato di un <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> tramite un puntatore. Per la maggior parte del codice, la differenza tra l’allocazione sullo stack e quella sull’heap [free-store] non importa, ma la praticità e la convenienza di <code class="docutils literal notranslate"><span class="pre">vector</span></code> sono importanti. Le persone che lavorano col codice per cui conta questa differenza sono abbastanza capaci di scegliere tra l”<code class="docutils literal notranslate"><span class="pre">array</span></code> e il <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</section>
<section id="id1768">
<h5>Imposizione<a class="headerlink" href="#id1768" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare la dichiarazione di un array C in una funzione o in una classe che dichiara anche un contenitore STL (per evitare un numero eccessivo di avvisi per il codice ereditato non-STL). Per risolvere: Modificare almeno l’array C in uno <code class="docutils literal notranslate"><span class="pre">std::array</span></code>.</p></li>
</ul>
</section>
</section>
<section id="sl-con-2-prefer-using-stl-vector-by-default-unless-you-have-a-reason-to-use-a-different-container">
<h4><a name="Rsl-vector"></a>SL.con.2: Preferire l’uso del <code class="docutils literal notranslate"><span class="pre">vector</span></code> della STL di default a meno che non ci sia un motivo per usare un contenitore differente<a class="headerlink" href="#sl-con-2-prefer-using-stl-vector-by-default-unless-you-have-a-reason-to-use-a-different-container" title="Link to this heading">¶</a></h4>
<section id="id1769">
<h5>Motivo<a class="headerlink" href="#id1769" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">vector</span></code> e <code class="docutils literal notranslate"><span class="pre">array</span></code> sono i soli contenitori standard che offrono i seguenti vantaggi:</p>
<ul class="simple">
<li><p>L’accesso più rapido per scopi generici (l’accesso random, compreso l’essere compatibile con la vettorizzazione [vectorization-friendly]);</p></li>
<li><p>il più veloce pattern di accesso di default (da-inizio-alla-fine o dalla-fine-all-inizio è compatibile col prefetcher [prefetcher-friendly]);</p></li>
<li><p>il più basso spreco di spazio (il layout contiguo ha zero come spazio superfluo per ogni elemento, che lo rende [cache-friendly]).</p></li>
</ul>
<p>Solitamente è necessario aggiungere e togliere elementi dal contenitore, quindi si usa <code class="docutils literal notranslate"><span class="pre">vector</span></code> per default; se non si ha bisogno di modificare la dimensione del contenitore, si usa <code class="docutils literal notranslate"><span class="pre">array</span></code>.</p>
<p>Anche quando altri contenitori sembrano più adatti, come la <code class="docutils literal notranslate"><span class="pre">map</span></code> per una velocità di ricerca O(log N) o una <code class="docutils literal notranslate"><span class="pre">list</span></code> per l’efficienza delle inserzioni nel mezzo, un <code class="docutils literal notranslate"><span class="pre">vector</span></code> funzionerà ancora meglio dei contenitori con una dimensione fino a pochi KB.</p>
</section>
<section id="id1770">
<h5>Nota<a class="headerlink" href="#id1770" title="Link to this heading">¶</a></h5>
<p>La <code class="docutils literal notranslate"><span class="pre">string</span></code> non dev’essere usata come contenitore per caratteri singoli. Una <code class="docutils literal notranslate"><span class="pre">string</span></code> è una stringa di testo; se si vuole un contenitore di caratteri, invece si usa <code class="docutils literal notranslate"><span class="pre">vector&lt;/*char_type*/&gt;</span></code> o <code class="docutils literal notranslate"><span class="pre">array&lt;/*char_type*/&gt;</span></code>.</p>
</section>
<section id="id1771">
<h5>Eccezioni<a class="headerlink" href="#id1771" title="Link to this heading">¶</a></h5>
<p>Se si ha una buona ragione per usare un altro contenitore, lo si usi. Per esempio:</p>
<ul class="simple">
<li><p>Se <code class="docutils literal notranslate"><span class="pre">vector</span></code> soddisfa le proprie esigenze ma non si ha la necessità che il contenitore sia variabile in ampiezza, usare, invece, <code class="docutils literal notranslate"><span class="pre">array</span></code>.</p></li>
<li><p>Se si vuole un contenitore per una ricerca in stile dizionario che garantisca ricerche O(K) o O(log N), con un contenitore più grande (più che qualche KB) e si dovranno eseguire frequenti inserimenti per cui la gestione dello spazio aggiuntivo [overhead] di un <code class="docutils literal notranslate"><span class="pre">vector</span></code> ordinato non è fattibile, tendere, invece, all’uso di <code class="docutils literal notranslate"><span class="pre">unordered_map</span></code> o <code class="docutils literal notranslate"><span class="pre">map</span></code> instead.</p></li>
</ul>
</section>
<section id="id1772">
<h5>Nota<a class="headerlink" href="#id1772" title="Link to this heading">¶</a></h5>
<p>Per inizializzare un vettore con un certo numero di elementi, usare l’inizializzazione <code class="docutils literal notranslate"><span class="pre">()</span></code>. Per inizializzare un vettore con una lista di elementi, usare l’inizializzazione <code class="docutils literal notranslate"><span class="pre">{}</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;int&gt; v1(20);  // v1 has 20 elements with the value 0 (vector&lt;int&gt;{})
vector&lt;int&gt; v2 {20}; // v2 has 1 element with the value 20
</pre></div>
</div>
<p><a class="reference internal" href="#Res-list"><span class="xref myst">Preferire la sintassi dell’inizializzatore {}</span></a>.</p>
</section>
<section id="id1773">
<h5>Imposizione<a class="headerlink" href="#id1773" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare un <code class="docutils literal notranslate"><span class="pre">vector</span></code> le cui dimensioni non cambiano mai dopo la sua costruzione (o perché è <code class="docutils literal notranslate"><span class="pre">const</span></code> o perché con esso non si chiama alcuna funzione non-<code class="docutils literal notranslate"><span class="pre">const</span></code>). Per risolvere: Usare, invece, un <code class="docutils literal notranslate"><span class="pre">array</span></code>.</p></li>
</ul>
</section>
</section>
<section id="sl-con-3-avoid-bounds-errors">
<h4><a name="Rsl-bounds"></a>SL.con.3: Evitare gli errori sui limiti [bound]<a class="headerlink" href="#sl-con-3-avoid-bounds-errors" title="Link to this heading">¶</a></h4>
<section id="id1774">
<h5>Motivo<a class="headerlink" href="#id1774" title="Link to this heading">¶</a></h5>
<p>Leggere o scrivere oltre un intervallo allocato di elementi solitamente porta a brutti errori, risultati sbagliati, crash e violazioni sulla sicurezza.</p>
</section>
<section id="id1775">
<h5>Nota<a class="headerlink" href="#id1775" title="Link to this heading">¶</a></h5>
<p>Le funzioni della libreria standard che si applicano a sequenze [range] di elementi hanno tutte (o potrebbero avere) uno spazio extra di sicurezza [bounds-safe overloads] che prende lo <code class="docutils literal notranslate"><span class="pre">span</span></code>. I tipi standard come <code class="docutils literal notranslate"><span class="pre">vector</span></code> si possono modificare per eseguire dei controlli sui limiti [bounds-check] sotto il profilo dei limiti (in modo compatibile, ad esempio aggiungendo i contratti [contract]), o usati con <code class="docutils literal notranslate"><span class="pre">at()</span></code>.</p>
<p>Idealmente, la garanzia di stare tra i limiti dovrebbe essere imposta staticamente. Per esempio:</p>
<ul class="simple">
<li><p>un range-<code class="docutils literal notranslate"><span class="pre">for</span></code> non può ciclare oltre i limiti del contenitore cui viene applicato</p></li>
<li><p>un <code class="docutils literal notranslate"><span class="pre">v.begin(),v.end()</span></code> viene determinato facilmente per stare sicuramente nei limiti</p></li>
</ul>
<p>Tali loop sono veloci come qualsiasi altro equivalente incontrollato/insicuro.</p>
<p>Spesso un semplice controllo preliminare può eliminare la necessità di verificare i singoli indici. Per esempio</p>
<ul class="simple">
<li><p>per <code class="docutils literal notranslate"><span class="pre">v.begin(),v.begin()+i</span></code> la <code class="docutils literal notranslate"><span class="pre">i</span></code> può essere facilmente controllata rispetto a <code class="docutils literal notranslate"><span class="pre">v.size()</span></code></p></li>
</ul>
<p>Questi cicli possono essere molto più veloci degli accessi agli elementi controllati singolarmente.</p>
</section>
<section id="id1776">
<h5>Esempio, cattivo<a class="headerlink" href="#id1776" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    array&lt;int, 10&gt; a, b;
    memset(a.data(), 0, 10);         // BAD, and contains a length error (length = 10 * sizeof(int))
    memcmp(a.data(), b.data(), 10);  // BAD, and contains a length error (length = 10 * sizeof(int))
}
</pre></div>
</div>
<p>Inoltre, <code class="docutils literal notranslate"><span class="pre">std::array&lt;&gt;::fill()</span></code> o <code class="docutils literal notranslate"><span class="pre">std::fill()</span></code> o anche un inizializzatore vuoto sono candidati migliori di <code class="docutils literal notranslate"><span class="pre">memset()</span></code>.</p>
</section>
<section id="id1777">
<h5>Esempio, buono<a class="headerlink" href="#id1777" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    array&lt;int, 10&gt; a, b, c{};       // c is initialized to zero
    a.fill(0);
    fill(b.begin(), b.end(), 0);    // std::fill()
    fill(b, 0);                     // std::ranges::fill()

    if ( a == b ) {
      // ...
    }
}
</pre></div>
</div>
</section>
<section id="id1778">
<h5>Esempio<a class="headerlink" href="#id1778" title="Link to this heading">¶</a></h5>
<p>Se il codice utilizza una libreria standard non modificata, ci sono ancora soluzioni alternative che consentono l’uso di <code class="docutils literal notranslate"><span class="pre">std::array</span></code> e di <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> in modo sicuro per i limiti. Il codice può chiamare la funzione membro <code class="docutils literal notranslate"><span class="pre">.at()</span></code> per ogni classe, che provocherà un’eccezione per <code class="docutils literal notranslate"><span class="pre">std::out_of_range</span></code>. In alternativa, il codice può chiamare la funzione libera <code class="docutils literal notranslate"><span class="pre">at()</span></code>, che darà una violazione [fail-fast] (o un’azione personalizzata) sui limiti.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(std::vector&lt;int&gt;&amp; v, std::array&lt;int, 12&gt; a, int i)
{
    v[0] = a[0];        // BAD
    v.at(0) = a[0];     // OK (alternative 1)
    at(v, 0) = a[0];    // OK (alternative 2)

    v.at(0) = a[i];     // BAD
    v.at(0) = a.at(i);  // OK (alternative 1)
    v.at(0) = at(a, i); // OK (alternative 2)
}
</pre></div>
</div>
</section>
<section id="id1779">
<h5>Imposizione<a class="headerlink" href="#id1779" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare un problema diagnostico per qualsiasi chiamata ad una funzione della libreria standard che non sia controllata per i limiti [bounds-checked]. ??? inserire un link ad un elenco di funzioni vietate</p></li>
</ul>
<p>Questa regola fa parte del <a class="reference internal" href="#SS-bounds"><span class="xref myst">profilo di sicurezza dei limiti</span></a>.</p>
</section>
</section>
<section id="sl-con-4-don-t-use-memset-or-memcpy-for-arguments-that-are-not-trivially-copyable">
<h4><a name="Rsl-copy"></a>SL.con.4: non usare <code class="docutils literal notranslate"><span class="pre">memset</span></code> o <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> per gli argomenti che non siano facilmente copiabili<a class="headerlink" href="#sl-con-4-don-t-use-memset-or-memcpy-for-arguments-that-are-not-trivially-copyable" title="Link to this heading">¶</a></h4>
<section id="id1780">
<h5>Motivo<a class="headerlink" href="#id1780" title="Link to this heading">¶</a></h5>
<p>In questo modo si ingarbuglia la semantica degli oggetti (p.es., sovrascrivendo un <code class="docutils literal notranslate"><span class="pre">vptr</span></code>).</p>
</section>
<section id="id1781">
<h5>Nota<a class="headerlink" href="#id1781" title="Link to this heading">¶</a></h5>
<p>Allo stesso modo per (w)memset, (w)memcpy, (w)memmove, e (w)memcmp</p>
</section>
<section id="id1782">
<h5>Esempio<a class="headerlink" href="#id1782" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct base {
    virtual void update() = 0;
};

struct derived : public base {
    void update() override {}
};


void f(derived&amp; a, derived&amp; b) // goodbye v-tables
{
    memset(&amp;a, 0, sizeof(derived));
    memcpy(&amp;a, &amp;b, sizeof(derived));
    memcmp(&amp;a, &amp;b, sizeof(derived));
}
</pre></div>
</div>
<p>Definire invece le funzioni di inizializzazione, copia e confronto di default appropriate</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void g(derived&amp; a, derived&amp; b)
{
    a = {};    // default initialize
    b = a;     // copy
    if (a == b) do_something(a, b);
}
</pre></div>
</div>
</section>
<section id="id1783">
<h5>Imposizione<a class="headerlink" href="#id1783" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare l’uso di quelle funzioni per i tipi non facilmente copiabili</p></li>
</ul>
<p><strong>TODO Note</strong>:</p>
<ul class="simple">
<li><p>L’impatto sulla libreria standard richiederà uno stretto coordinamento con il WG21, se non altro per garantire la compatibilità anche se non sarà mai standardizzata.</p></li>
<li><p>Si sta valutando la possibilità di specificare [bounds-safe overloads] per le funzioni stdlib (in particolare per la stdlib C) come <code class="docutils literal notranslate"><span class="pre">memcmp</span></code> e inserirle nelle GSL.</p></li>
<li><p>Per le funzioni e i tipi stdlib come <code class="docutils literal notranslate"><span class="pre">vector</span></code> che non sono completamente [bounds-checked], l’obiettivo è che tali funzioni siano [bounds-checked] quando vengono chiamate dal codice col [bounds profile] attivato e non controllate quando chiamate da codice ereditato, forse utilizzando i contratti (attualmente proposti da diversi membri del WG21).</p></li>
</ul>
</section>
</section>
</section>
<section id="sl-str-string">
<h3><a name="SS-string"></a>SL.str: String<a class="headerlink" href="#sl-str-string" title="Link to this heading">¶</a></h3>
<p>La gestione del testo è un enorme argomento. <code class="docutils literal notranslate"><span class="pre">std::string</span></code> non lo copre tutto. Questa sezione cerca principalmente di chiarire la relazione di <code class="docutils literal notranslate"><span class="pre">std::string</span></code> con <code class="docutils literal notranslate"><span class="pre">char*</span></code>, <code class="docutils literal notranslate"><span class="pre">zstring</span></code>, <code class="docutils literal notranslate"><span class="pre">string_view</span></code> e <code class="docutils literal notranslate"><span class="pre">gsl::span&lt;char&gt;</span></code>. Sulla questione importante dell’insieme dei caratteri non-ASCII e sulle codifiche (p.es., <code class="docutils literal notranslate"><span class="pre">wchar_t</span></code>, Unicode e UTF-8) se ne parlerà altrove.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#SS-regex"><span class="xref myst">espressioni regolari</span></a></p>
<p>Qui, si usa «sequenza di caratteri» o «stringa» per riferirsi ad una sequenza di caratteri che si intende leggere come testo (in qualche modo, forse). Non si considera ???</p>
<p>Sommario sulle stringhe:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rstr-string"><span class="xref myst">SL.str.1: Usare <code class="docutils literal notranslate"><span class="pre">std::string</span></code> per avere sequenze di caratteri</span></a></p></li>
<li><p><a class="reference internal" href="#Rstr-view"><span class="xref myst">SL.str.2: Usare <code class="docutils literal notranslate"><span class="pre">std::string_view</span></code> o <code class="docutils literal notranslate"><span class="pre">gsl::span&lt;char&gt;</span></code> per riferirsi alle sequenze di caratteri</span></a></p></li>
<li><p><a class="reference internal" href="#Rstr-zstring"><span class="xref myst">SL.str.3: Usare <code class="docutils literal notranslate"><span class="pre">zstring</span></code> o <code class="docutils literal notranslate"><span class="pre">czstring</span></code> per riferirsi a sequenze di caratteri in stile C, «zero-terminated»</span></a></p></li>
<li><p><a class="reference internal" href="#Rstr-char*"><span class="xref myst">SL.str.4: Usare <code class="docutils literal notranslate"><span class="pre">char*</span></code> per riferirsi ad un singolo carattere</span></a></p></li>
<li><p><a class="reference internal" href="#Rstr-byte"><span class="xref myst">SL.str.5: Usare <code class="docutils literal notranslate"><span class="pre">std::byte</span></code> per riferirsi ai valori dei byte che non necessariamente rappresentano caratteri</span></a></p></li>
<li><p><a class="reference internal" href="#Rstr-locale"><span class="xref myst">SL.str.10: Usare <code class="docutils literal notranslate"><span class="pre">std::string</span></code> quando c’è bisogno di eseguire operazioni sulle stringhe dipendenti dalla nazionalità</span></a></p></li>
<li><p><a class="reference internal" href="#Rstr-span"><span class="xref myst">SL.str.11: Usare <code class="docutils literal notranslate"><span class="pre">gsl::span&lt;char&gt;</span></code> arziché <code class="docutils literal notranslate"><span class="pre">std::string_view</span></code> quando si deve mutare una stringa</span></a></p></li>
<li><p><a class="reference internal" href="#Rstr-s"><span class="xref myst">SL.str.12: Usare il suffisso <code class="docutils literal notranslate"><span class="pre">s</span></code> per le stringhe letterali intese come <code class="docutils literal notranslate"><span class="pre">string</span></code> della libreria standard</span></a></p></li>
</ul>
<p><strong>Si veda anche</strong>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rf-range"><span class="xref myst">F.24 span</span></a></p></li>
<li><p><a class="reference internal" href="#Rf-zstring"><span class="xref myst">F.25 zstring</span></a></p></li>
</ul>
<section id="sl-str-1-use-std-string-to-own-character-sequences">
<h4><a name="Rstr-string"></a>SL.str.1: Usare <code class="docutils literal notranslate"><span class="pre">std::string</span></code> per avere sequenze di caratteri<a class="headerlink" href="#sl-str-1-use-std-string-to-own-character-sequences" title="Link to this heading">¶</a></h4>
<section id="id1784">
<h5>Motivo<a class="headerlink" href="#id1784" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">string</span></code> gestisce correttamente l’allocazione, la proprietà [ownership], la copia, la graduale espansione ed offre varie operazioni utili.</p>
</section>
<section id="id1785">
<h5>Esempio<a class="headerlink" href="#id1785" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;string&gt; read_until(const string&amp; terminator)
{
    vector&lt;string&gt; res;
    for (string s; cin &gt;&gt; s &amp;&amp; s != terminator; ) // read a word
        res.push_back(s);
    return res;
}
</pre></div>
</div>
<p>Si noti come <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> e <code class="docutils literal notranslate"><span class="pre">!=</span></code> siano disponibili per <code class="docutils literal notranslate"><span class="pre">string</span></code> (come esempio di operazioni utili) e che non ci sono esplicite allocazioni, de-allocazioni o controlli dei limiti [range check] (è la <code class="docutils literal notranslate"><span class="pre">string</span></code> che se ne occupa).</p>
<p>Nel C++17, si può usare <code class="docutils literal notranslate"><span class="pre">string_view</span></code> come argomento, anziché <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">string&amp;</span></code> per dare una maggiore flessibilità ai chiamanti:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;string&gt; read_until(string_view terminator)   // C++17
{
    vector&lt;string&gt; res;
    for (string s; cin &gt;&gt; s &amp;&amp; s != terminator; ) // read a word
        res.push_back(s);
    return res;
}
</pre></div>
</div>
</section>
<section id="id1786">
<h5>Esempio, cattivo<a class="headerlink" href="#id1786" title="Link to this heading">¶</a></h5>
<p>Non usare stringhe in stile C per le operazioni che richiedono una gestione non banale della memoria</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char* cat(const char* s1, const char* s2)   // beware!
    // return s1 + &#39;.&#39; + s2
{
    int l1 = strlen(s1);
    int l2 = strlen(s2);
    char* p = (char*) malloc(l1 + l2 + 2);
    strcpy(p, s1, l1);
    p[l1] = &#39;.&#39;;
    strcpy(p + l1 + 1, s2, l2);
    p[l1 + l2 + 1] = 0;
    return p;
}
</pre></div>
</div>
<p>Abbiamo capito bene? Il chiamante si ricorderà di eseguire il <code class="docutils literal notranslate"><span class="pre">free()</span></code> per il puntatore restituito? Questo codice supererà un test sulla sicurezza?</p>
</section>
<section id="id1787">
<h5>Nota<a class="headerlink" href="#id1787" title="Link to this heading">¶</a></h5>
<p>Non dare per scontato che <code class="docutils literal notranslate"><span class="pre">string</span></code> sia più lenta delle tecniche a basso livello senza fare delle misure e si ricordi che non in tutto il codice sono importanti le prestazioni. <a class="reference internal" href="#Rper-Knuth"><span class="xref myst">Non ottimizzare prematuramente</span></a></p>
</section>
<section id="id1788">
<h5>Imposizione<a class="headerlink" href="#id1788" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="sl-str-2-use-std-string-view-or-gsl-span-char-to-refer-to-character-sequences">
<h4><a name="Rstr-view"></a>SL.str.2: Usare <code class="docutils literal notranslate"><span class="pre">std::string_view</span></code> o <code class="docutils literal notranslate"><span class="pre">gsl::span&lt;char&gt;</span></code> per riferirsi alle sequenze di caratteri<a class="headerlink" href="#sl-str-2-use-std-string-view-or-gsl-span-char-to-refer-to-character-sequences" title="Link to this heading">¶</a></h4>
<section id="id1789">
<h5>Motivo<a class="headerlink" href="#id1789" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">std::string_view</span></code> e <code class="docutils literal notranslate"><span class="pre">gsl::span&lt;char&gt;</span></code> forniscono un accesso semplice e (potenzialmente) sicuro alle sequenze di caratteri indipendentemente da come queste siano allocate e memorizzate.</p>
</section>
<section id="id1790">
<h5>Esempio<a class="headerlink" href="#id1790" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;string&gt; read_until(string_view terminator);

void user(zstring p, const string&amp; s, string_view ss)
{
    auto v1 = read_until(p);
    auto v2 = read_until(s);
    auto v3 = read_until(ss);
    // ...
}
</pre></div>
</div>
</section>
<section id="id1791">
<h5>Nota<a class="headerlink" href="#id1791" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">std::string_view</span></code> (C++17) è a sola lettura.</p>
</section>
<section id="id1792">
<h5>Imposizione<a class="headerlink" href="#id1792" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="sl-str-3-use-zstring-or-czstring-to-refer-to-a-c-style-zero-terminated-sequence-of-characters">
<h4><a name="Rstr-zstring"></a>SL.str.3: Usare <code class="docutils literal notranslate"><span class="pre">zstring</span></code> o <code class="docutils literal notranslate"><span class="pre">czstring</span></code> per riferirsi a sequenze di caratteri in stile C, «zero-terminated»<a class="headerlink" href="#sl-str-3-use-zstring-or-czstring-to-refer-to-a-c-style-zero-terminated-sequence-of-characters" title="Link to this heading">¶</a></h4>
<section id="id1793">
<h5>Motivo<a class="headerlink" href="#id1793" title="Link to this heading">¶</a></h5>
<p>Leggibilità. Dichiarazione di intenti. Un semplice <code class="docutils literal notranslate"><span class="pre">char*</span></code> può essere un puntatore ad un solo carattere, un puntatore ad un array di caratteri, un puntatore ad una stringa C-style (zero-terminated), o anche ad un piccolo intero. Distinguere tra queste alternative evita incomprensioni e bug.</p>
</section>
<section id="id1794">
<h5>Esempio<a class="headerlink" href="#id1794" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f1(const char* s); // s is probably a string
</pre></div>
</div>
<p>Tutto quello che si sa è che si suppone essere o il nullptr o che punta ad almeno un carattere</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f1(zstring s);     // s is a C-style string or the nullptr
void f1(czstring s);    // s is a C-style string constant or the nullptr
void f1(std::byte* s);  // s is a pointer to a byte (C++17)
</pre></div>
</div>
</section>
<section id="id1795">
<h5>Nota<a class="headerlink" href="#id1795" title="Link to this heading">¶</a></h5>
<p>Non convertire una stringa C-style in <code class="docutils literal notranslate"><span class="pre">string</span></code> senza motivo.</p>
</section>
<section id="id1796">
<h5>Nota<a class="headerlink" href="#id1796" title="Link to this heading">¶</a></h5>
<p>Come ogni altro «puntatore semplice [plain]», una <code class="docutils literal notranslate"><span class="pre">zstring</span></code> non dovrebbe rappresentare la proprietà [ownership].</p>
</section>
<section id="id1797">
<h5>Nota<a class="headerlink" href="#id1797" title="Link to this heading">¶</a></h5>
<p>Ci sono miliardi di righe di codice C++ «in giro», la maggior parte usa <code class="docutils literal notranslate"><span class="pre">char*</span></code> e <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code> senza documentarne l’intenzione. Queste vengono usate in un’ampia varietà di modi, come per rappresentare la proprietà [ownership] e come puntatori generici alla memoria (invece di <code class="docutils literal notranslate"><span class="pre">void*</span></code>). È difficile distinguere questi usi, quindi questa linea-guida è difficile da seguire. Questa è una delle principali fonti di bug nei programmi C e C++, quindi vale la pena seguire queste linee-guida ove possibile.</p>
</section>
<section id="id1798">
<h5>Imposizione<a class="headerlink" href="#id1798" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare gli usi di <code class="docutils literal notranslate"><span class="pre">[]</span></code> su un <code class="docutils literal notranslate"><span class="pre">char*</span></code></p></li>
<li><p>Segnalare gli usi di <code class="docutils literal notranslate"><span class="pre">delete</span></code> su un <code class="docutils literal notranslate"><span class="pre">char*</span></code></p></li>
<li><p>Segnalare gli usi di <code class="docutils literal notranslate"><span class="pre">free()</span></code> su un <code class="docutils literal notranslate"><span class="pre">char*</span></code></p></li>
</ul>
</section>
</section>
<section id="sl-str-4-use-char-to-refer-to-a-single-character">
<h4><a name="Rstr-char*"></a>SL.str.4: Usare <code class="docutils literal notranslate"><span class="pre">char*</span></code> per riferirsi ad un singolo carattere<a class="headerlink" href="#sl-str-4-use-char-to-refer-to-a-single-character" title="Link to this heading">¶</a></h4>
<section id="id1799">
<h5>Motivo<a class="headerlink" href="#id1799" title="Link to this heading">¶</a></h5>
<p>La varietà degli usi di <code class="docutils literal notranslate"><span class="pre">char*</span></code> nel codice corrente è una delle principali fonti di errori.</p>
</section>
<section id="id1800">
<h5>Esempio, cattivo<a class="headerlink" href="#id1800" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char arr[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;};

void print(const char* p)
{
    cout &lt;&lt; p &lt;&lt; &#39;\n&#39;;
}

void use()
{
    print(arr);   // run-time error; potentially very bad
}
</pre></div>
</div>
<p>L’array <code class="docutils literal notranslate"><span class="pre">arr</span></code> non è una stringa C-style perché non è terminata con zero [zero-terminated].</p>
</section>
<section id="id1801">
<h5>Alternativa<a class="headerlink" href="#id1801" title="Link to this heading">¶</a></h5>
<p>Si vedano <a class="reference internal" href="#Rstr-zstring"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">zstring</span></code></span></a>, <a class="reference internal" href="#Rstr-string"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">string</span></code></span></a> e <a class="reference internal" href="#Rstr-view"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">string_view</span></code></span></a>.</p>
</section>
<section id="id1802">
<h5>Imposizione<a class="headerlink" href="#id1802" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p>Segnalare gli usi di <code class="docutils literal notranslate"><span class="pre">[]</span></code> su un <code class="docutils literal notranslate"><span class="pre">char*</span></code></p></li>
</ul>
</section>
</section>
<section id="sl-str-5-use-std-byte-to-refer-to-byte-values-that-do-not-necessarily-represent-characters">
<h4><a name="Rstr-byte"></a>SL.str.5: Usare <code class="docutils literal notranslate"><span class="pre">std::byte</span></code> per riferirsi ai valori dei byte che non necessariamente rappresentano caratteri<a class="headerlink" href="#sl-str-5-use-std-byte-to-refer-to-byte-values-that-do-not-necessarily-represent-characters" title="Link to this heading">¶</a></h4>
<section id="id1803">
<h5>Motivo<a class="headerlink" href="#id1803" title="Link to this heading">¶</a></h5>
<p>L’uso di <code class="docutils literal notranslate"><span class="pre">char*</span></code> per rappresentare un puntatore a qualcosa che non è necessariamente un carattere provoca confusione e disabilita preziose ottimizzazioni.</p>
</section>
<section id="id1804">
<h5>Esempio<a class="headerlink" href="#id1804" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1805">
<h5>Nota<a class="headerlink" href="#id1805" title="Link to this heading">¶</a></h5>
<p>C++17</p>
</section>
<section id="id1806">
<h5>Imposizione<a class="headerlink" href="#id1806" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="sl-str-10-use-std-string-when-you-need-to-perform-locale-sensitive-string-operations">
<h4><a name="Rstr-locale"></a>SL.str.10: Usare <code class="docutils literal notranslate"><span class="pre">std::string</span></code> quando c’è bisogno di eseguire operazioni sulle stringhe dipendenti dalla nazionalità<a class="headerlink" href="#sl-str-10-use-std-string-when-you-need-to-perform-locale-sensitive-string-operations" title="Link to this heading">¶</a></h4>
<section id="id1807">
<h5>Motivo<a class="headerlink" href="#id1807" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">std::string</span></code> supporta la funzionalità <a class="reference internal" href="#Rstr-locale"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">locale</span></code></span></a> della libreria standard</p>
</section>
<section id="id1808">
<h5>Esempio<a class="headerlink" href="#id1808" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1809">
<h5>Nota<a class="headerlink" href="#id1809" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
<section id="id1810">
<h5>Imposizione<a class="headerlink" href="#id1810" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="sl-str-11-use-gsl-span-char-rather-than-std-string-view-when-you-need-to-mutate-a-string">
<h4><a name="Rstr-span"></a>SL.str.11: Usare <code class="docutils literal notranslate"><span class="pre">gsl::span&lt;char&gt;</span></code> anziché <code class="docutils literal notranslate"><span class="pre">std::string_view</span></code> quando si deve mutare una stringa<a class="headerlink" href="#sl-str-11-use-gsl-span-char-rather-than-std-string-view-when-you-need-to-mutate-a-string" title="Link to this heading">¶</a></h4>
<section id="id1811">
<h5>Motivo<a class="headerlink" href="#id1811" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">std::string_view</span></code> è a sola lettura.</p>
</section>
<section id="id1812">
<h5>Esempio<a class="headerlink" href="#id1812" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
<section id="id1813">
<h5>Nota<a class="headerlink" href="#id1813" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
<section id="id1814">
<h5>Imposizione<a class="headerlink" href="#id1814" title="Link to this heading">¶</a></h5>
<p>Il compilatore segnalerà i tentativi di scrivere in una <code class="docutils literal notranslate"><span class="pre">string_view</span></code>.</p>
</section>
</section>
<section id="sl-str-12-use-the-s-suffix-for-string-literals-meant-to-be-standard-library-strings">
<h4><a name="Rstr-s"></a>SL.str.12: Usare il suffisso <code class="docutils literal notranslate"><span class="pre">s</span></code> per le stringhe letterali intese come <code class="docutils literal notranslate"><span class="pre">string</span></code> della libreria standard<a class="headerlink" href="#sl-str-12-use-the-s-suffix-for-string-literals-meant-to-be-standard-library-strings" title="Link to this heading">¶</a></h4>
<section id="id1815">
<h5>Motivo<a class="headerlink" href="#id1815" title="Link to this heading">¶</a></h5>
<p>L’espressione diretta di un’idea minimizza gli errori.</p>
</section>
<section id="id1816">
<h5>Esempio<a class="headerlink" href="#id1816" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto pp1 = make_pair(&quot;Tokyo&quot;, 9.00);         // {C-style string,double} intended?
pair&lt;string, double&gt; pp2 = {&quot;Tokyo&quot;, 9.00};  // a bit verbose
auto pp3 = make_pair(&quot;Tokyo&quot;s, 9.00);        // {std::string,double}    // C++14
pair pp4 = {&quot;Tokyo&quot;s, 9.00};                 // {std::string,double}    // C++17
</pre></div>
</div>
</section>
<section id="id1817">
<h5>Imposizione<a class="headerlink" href="#id1817" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
</section>
<section id="sl-io-iostream">
<h3><a name="SS-io"></a>SL.io: Iostream<a class="headerlink" href="#sl-io-iostream" title="Link to this heading">¶</a></h3>
<p>Le <code class="docutils literal notranslate"><span class="pre">iostream</span></code> costituiscono una libreria per lo streaming « type safe», espandibile, con I/O formattato e non. Supporta molteplici strategie di buffering (e estensibili dall’utente) e diverse localizzazioni. Si può utilizzare per l’I/O convenzionale, la lettura e la scrittura in memoria (flussi [stream] di stringhe) e per le estensioni definite dall’utente, come lo streaming attraverso la rete (l’ASIO [Audio Streaming Input Output]: non ancora standardizzato).</p>
<p>Riepilogo delle regole sull’iostream:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rio-low"><span class="xref myst">SL.io.1: Usare l’input a livello del carattere solo quando lo si deve fare</span></a></p></li>
<li><p><a class="reference internal" href="#Rio-validate"><span class="xref myst">SL.io.2: Quando si legge, considerare sempre l’input mal formattato</span></a></p></li>
<li><p><a class="reference internal" href="#Rio-streams"><span class="xref myst">SL.io.3: Preferire gli iostream per l’I/O</span></a></p></li>
<li><p><a class="reference internal" href="#Rio-sync"><span class="xref myst">SL.io.10: A meno che non si usi la famiglia delle funzioni <code class="docutils literal notranslate"><span class="pre">printf</span></code> chiamare <code class="docutils literal notranslate"><span class="pre">ios_base::sync_with_stdio(false)</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rio-endl"><span class="xref myst">SL.io.50: Evitare <code class="docutils literal notranslate"><span class="pre">endl</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#???"><span class="xref myst">???</span></a></p></li>
</ul>
<section id="sl-io-1-use-character-level-input-only-when-you-have-to">
<h4><a name="Rio-low"></a>SL.io.1: Usare l’input a livello del carattere solo quando lo si deve fare<a class="headerlink" href="#sl-io-1-use-character-level-input-only-when-you-have-to" title="Link to this heading">¶</a></h4>
<section id="id1818">
<h5>Motivo<a class="headerlink" href="#id1818" title="Link to this heading">¶</a></h5>
<p>A meno che non si abbia realmente a che fare con i singoli caratteri, l’uso dell’input a livello del carattere porta il codice ad essere soggetto a errori e a una composizione di caratteri in token, potenzialmente inefficiente.</p>
</section>
<section id="id1819">
<h5>Esempio<a class="headerlink" href="#id1819" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char c;
char buf[128];
int i = 0;
while (cin.get(c) &amp;&amp; !isspace(c) &amp;&amp; i &lt; 128)
    buf[i++] = c;
if (i == 128) {
    // ... handle too long string ....
}
</pre></div>
</div>
<p>Meglio (molto più semplice e forse più veloce):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>string s;
s.reserve(128);
cin &gt;&gt; s;
</pre></div>
</div>
<p>e il <code class="docutils literal notranslate"><span class="pre">reserve(128)</span></code> probabilmente non serve.</p>
</section>
<section id="id1820">
<h5>Imposizione<a class="headerlink" href="#id1820" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="sl-io-2-when-reading-always-consider-ill-formed-input">
<h4><a name="Rio-validate"></a>SL.io.2: Quando si legge, considerare sempre l’input mal formattato<a class="headerlink" href="#sl-io-2-when-reading-always-consider-ill-formed-input" title="Link to this heading">¶</a></h4>
<section id="id1821">
<h5>Motivo<a class="headerlink" href="#id1821" title="Link to this heading">¶</a></h5>
<p>Gli errori vengono gestiti meglio il prima possibile. Se l’input non è validato, ogni funzione dev’essere scritta per gestire dati errati (e questo non è pratico).</p>
</section>
<section id="id1822">
<h5>Esempio<a class="headerlink" href="#id1822" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1823">
<h5>Imposizione<a class="headerlink" href="#id1823" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="sl-io-3-prefer-iostreams-for-i-o">
<h4><a name="Rio-streams"></a>SL.io.3: Preferire gli <code class="docutils literal notranslate"><span class="pre">iostream</span></code> per l’I/O<a class="headerlink" href="#sl-io-3-prefer-iostreams-for-i-o" title="Link to this heading">¶</a></h4>
<section id="id1824">
<h5>Motivo<a class="headerlink" href="#id1824" title="Link to this heading">¶</a></h5>
<p>Gli <code class="docutils literal notranslate"><span class="pre">iostream</span></code> sono sicuri, flessibili ed espandibili.</p>
</section>
<section id="id1825">
<h5>Esempio<a class="headerlink" href="#id1825" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// write a complex number:
complex&lt;double&gt; z{ 3, 4 };
cout &lt;&lt; z &lt;&lt; &#39;\n&#39;;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">complex</span></code> è un tipo «user-defined» ed il sui I/O è definito senza modificare la libreria <code class="docutils literal notranslate"><span class="pre">iostream</span></code>.</p>
</section>
<section id="id1826">
<h5>Esempio<a class="headerlink" href="#id1826" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// read a file of complex numbers:
for (complex&lt;double&gt; z; cin &gt;&gt; z; )
    v.push_back(z);
</pre></div>
</div>
</section>
<section id="id1827">
<h5>Eccezione<a class="headerlink" href="#id1827" title="Link to this heading">¶</a></h5>
<p>??? prestazioni ???</p>
</section>
<section id="discussion-iostreams-vs-the-printf-family">
<h5>Discussione: Gli <code class="docutils literal notranslate"><span class="pre">iostream</span></code> rispetto alla famiglia dei <code class="docutils literal notranslate"><span class="pre">printf()</span></code><a class="headerlink" href="#discussion-iostreams-vs-the-printf-family" title="Link to this heading">¶</a></h5>
<p>Viene frequentemente (e spesso correttamente) sottolineato che la famiglia dei <code class="docutils literal notranslate"><span class="pre">printf()</span></code> ha due vantaggi rispetto agli <code class="docutils literal notranslate"><span class="pre">iostream</span></code>: flessibilità nella formattazione e prestazioni. Ciò deve essere soppesato con i vantaggi degli <code class="docutils literal notranslate"><span class="pre">iostream</span></code> sull’estensibilità nel gestire tipi definiti dall’utente, la resilienza alle violazioni della sicurezza, la gestione implicita della memoria e la gestione <code class="docutils literal notranslate"><span class="pre">locale</span></code> (nazionalità).</p>
<p>Se c’è bisogno di I/O performante, si può quasi sempre far meglio di <code class="docutils literal notranslate"><span class="pre">printf()</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">gets()</span></code>, <code class="docutils literal notranslate"><span class="pre">scanf()</span></code> using <code class="docutils literal notranslate"><span class="pre">%s</span></code>e <code class="docutils literal notranslate"><span class="pre">printf()</span></code> che usano <code class="docutils literal notranslate"><span class="pre">%s</span></code> sono rischi per la sicurezza (vulnerabile all”[overflow] e generalmente soggetti ad errori). Il C11 definisce delle «estensioni opzionali» che effettuano un controllo extra sui loro argomenti. Se presenti nella propria libreria C, <code class="docutils literal notranslate"><span class="pre">gets_s()</span></code>, <code class="docutils literal notranslate"><span class="pre">scanf_s()</span></code> e <code class="docutils literal notranslate"><span class="pre">printf_s()</span></code> potrebbero costituire delle valide alternative, ma restano non sicure riguardo al tipo.</p>
</section>
<section id="id1828">
<h5>Imposizione<a class="headerlink" href="#id1828" title="Link to this heading">¶</a></h5>
<p>Segnalare, opzionalmente, <code class="docutils literal notranslate"><span class="pre">&lt;cstdio&gt;</span></code> e <code class="docutils literal notranslate"><span class="pre">&lt;stdio.h&gt;</span></code>.</p>
</section>
</section>
<section id="sl-io-10-unless-you-use-printf-family-functions-call-ios-base-sync-with-stdio-false">
<h4><a name="Rio-sync"></a>SL.io.10: A meno che non si usi la famiglia delle funzioni <code class="docutils literal notranslate"><span class="pre">printf</span></code> chiamare <code class="docutils literal notranslate"><span class="pre">ios_base::sync_with_stdio(false)</span></code><a class="headerlink" href="#sl-io-10-unless-you-use-printf-family-functions-call-ios-base-sync-with-stdio-false" title="Link to this heading">¶</a></h4>
<section id="id1829">
<h5>Motivo<a class="headerlink" href="#id1829" title="Link to this heading">¶</a></h5>
<p>Sincronizzare l’I/O degli <code class="docutils literal notranslate"><span class="pre">iostream</span></code> col <code class="docutils literal notranslate"><span class="pre">printf-style</span></code> può risultare costoso. <code class="docutils literal notranslate"><span class="pre">cin</span></code> e <code class="docutils literal notranslate"><span class="pre">cout</span></code> sono per default sincronizzati con <code class="docutils literal notranslate"><span class="pre">printf</span></code>.</p>
</section>
<section id="id1830">
<h5>Esempio<a class="headerlink" href="#id1830" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int main()
{
    ios_base::sync_with_stdio(false);
    // ... use iostreams ...
}
</pre></div>
</div>
</section>
<section id="id1831">
<h5>Imposizione<a class="headerlink" href="#id1831" title="Link to this heading">¶</a></h5>
<p>???</p>
</section>
</section>
<section id="sl-io-50-avoid-endl">
<h4><a name="Rio-endl"></a>SL.io.50: Evitare <code class="docutils literal notranslate"><span class="pre">endl</span></code><a class="headerlink" href="#sl-io-50-avoid-endl" title="Link to this heading">¶</a></h4>
<section id="id1832">
<h5>Motivo<a class="headerlink" href="#id1832" title="Link to this heading">¶</a></h5>
<p>Il manipolatore <code class="docutils literal notranslate"><span class="pre">endl</span></code> è per lo più equivalente a <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> e <code class="docutils literal notranslate"><span class="pre">&quot;\n&quot;</span></code>; come viene comunemente usato, semplicemente rallenta l’output eseguendo dei <code class="docutils literal notranslate"><span class="pre">flush()</span></code> ridondanti. Questo rallentamento è significativo rispetto all’output in stile <code class="docutils literal notranslate"><span class="pre">printf</span></code>.</p>
</section>
<section id="id1833">
<h5>Esempio<a class="headerlink" href="#id1833" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;    // two output operations and a flush
cout &lt;&lt; &quot;Hello, World!\n&quot;;          // one output operation and no flush
</pre></div>
</div>
</section>
<section id="id1834">
<h5>Nota<a class="headerlink" href="#id1834" title="Link to this heading">¶</a></h5>
<p>Per l’interazione <code class="docutils literal notranslate"><span class="pre">cin</span></code>/<code class="docutils literal notranslate"><span class="pre">cout</span></code> (e le equivalenti), non c’è alcun motivo per eseguire il flush; viene fatto automaticamente. Durante la scrittura in un file, c’è raramente bisogno di eseguire il <code class="docutils literal notranslate"><span class="pre">flush</span></code>.</p>
</section>
<section id="id1835">
<h5>Nota<a class="headerlink" href="#id1835" title="Link to this heading">¶</a></h5>
<p>Per gli stream di stringhe (nello specifico <code class="docutils literal notranslate"><span class="pre">ostringstream</span></code>), l’inserimento di un <code class="docutils literal notranslate"><span class="pre">endl</span></code> è del tutto equivalente all’inserimento di un carattere <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>, ma anche in questo caso, <code class="docutils literal notranslate"><span class="pre">endl</span></code> potrebbe essere notevolmente più lento.</p>
<p><code class="docutils literal notranslate"><span class="pre">endl</span></code> <em>non</em> si occupa di produrre una sequenza di fine riga specifica della piattaforma (come <code class="docutils literal notranslate"><span class="pre">&quot;\r\n&quot;</span></code> su Windows). Quindi, per uno stream di stringhe, <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">&lt;&lt;</span> <span class="pre">endl</span></code> inserisce semplicemente un <em>singolo</em> carattere, <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>.</p>
</section>
<section id="id1836">
<h5>Nota<a class="headerlink" href="#id1836" title="Link to this heading">¶</a></h5>
<p>A parte il problema (occasionalmente importante) della performance, la scelta tra <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> e <code class="docutils literal notranslate"><span class="pre">endl</span></code> è quasi soltanto estetica.</p>
</section>
</section>
</section>
<section id="sl-regex-regex">
<h3><a name="SS-regex"></a>SL.regex: Regex<a class="headerlink" href="#sl-regex-regex" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">&lt;regex&gt;</span></code> è la libreria standard del C++ per le espressioni regolari. Supporta diverse convenzioni di modelli di espressioni regolari.</p>
</section>
<section id="sl-chrono-time">
<h3><a name="SS-chrono"></a>SL.chrono: Time<a class="headerlink" href="#sl-chrono-time" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">&lt;chrono&gt;</span></code> (definita nel namespace <code class="docutils literal notranslate"><span class="pre">std::chrono</span></code>) fornisce la nozione di <code class="docutils literal notranslate"><span class="pre">time_point</span></code> e <code class="docutils literal notranslate"><span class="pre">duration</span></code> [durata] oltre alle funzioni per l’output del tempo secondo le varie unità. Fornisce i clock per registrare i <code class="docutils literal notranslate"><span class="pre">time_points</span></code>.</p>
</section>
<section id="sl-c-the-c-standard-library">
<h3><a name="SS-clib"></a>SL.C: La Libreria Standard del C<a class="headerlink" href="#sl-c-the-c-standard-library" title="Link to this heading">¶</a></h3>
<p>???</p>
<p>Riepilogo delle regole sulla Libreria Standard del C:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rclib-jmp"><span class="xref myst">SL.C.1: Non usare setjmp/longjmp</span></a></p></li>
<li><p><a class="reference internal" href="#???"><span class="xref myst">???</span></a></p></li>
<li><p><a class="reference internal" href="#???"><span class="xref myst">???</span></a></p></li>
</ul>
<section id="sl-c-1-don-t-use-setjmp-longjmp">
<h4><a name="Rclib-jmp"></a>SL.C.1: Non usare setjmp/longjmp<a class="headerlink" href="#sl-c-1-don-t-use-setjmp-longjmp" title="Link to this heading">¶</a></h4>
<section id="id1837">
<h5>Motivo<a class="headerlink" href="#id1837" title="Link to this heading">¶</a></h5>
<p>un <code class="docutils literal notranslate"><span class="pre">longjmp</span></code> ignora i distruttori, invalidando tutta la gestione delle risorse basate sul RAII</p>
</section>
<section id="id1838">
<h5>Imposizione<a class="headerlink" href="#id1838" title="Link to this heading">¶</a></h5>
<p>Segnalare tutte le ricorrenze di <code class="docutils literal notranslate"><span class="pre">longjmp</span></code> e <code class="docutils literal notranslate"><span class="pre">setjmp</span></code></p>
</section>
</section>
</section>
</section>
<section id="a-architectural-ideas">
<h2><a name="S-A"></a>A: Idee architetturali<a class="headerlink" href="#a-architectural-ideas" title="Link to this heading">¶</a></h2>
<p>Questa sezione contiene idee sull’architettura a più alto livello e sulle librerie.</p>
<p>Riepilogo delle regole architetturali:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Ra-stable"><span class="xref myst">A.1: Separare il codice stabile da quello instabile</span></a></p></li>
<li><p><a class="reference internal" href="#Ra-lib"><span class="xref myst">A.2: Esprimere, in una libreria, le parti potenzialmente riutilizzabili</span></a></p></li>
<li><p><a class="reference internal" href="#Ra-dag"><span class="xref myst">A.4: Non ci dovrebbero essere ciclicità tra le librerie</span></a></p></li>
<li><p><a class="reference internal" href="#???"><span class="xref myst">???</span></a></p></li>
<li><p><a class="reference internal" href="#???"><span class="xref myst">???</span></a></p></li>
<li><p><a class="reference internal" href="#???"><span class="xref myst">???</span></a></p></li>
<li><p><a class="reference internal" href="#???"><span class="xref myst">???</span></a></p></li>
<li><p><a class="reference internal" href="#???"><span class="xref myst">???</span></a></p></li>
<li><p><a class="reference internal" href="#???"><span class="xref myst">???</span></a></p></li>
</ul>
<section id="a-1-separate-stable-code-from-less-stable-code">
<h3><a name="Ra-stable"></a>A.1: Separare il codice stabile da quello instabile<a class="headerlink" href="#a-1-separate-stable-code-from-less-stable-code" title="Link to this heading">¶</a></h3>
<p>L’isolamento del codice meno stabile ne facilita le unità di test, migliora l’interfaccia, il refactoring e l’eventuale [deprecation].</p>
</section>
<section id="a-2-express-potentially-reusable-parts-as-a-library">
<h3><a name="Ra-lib"></a>A.2: Esprimere, in una libreria, le parti potenzialmente riutilizzabili<a class="headerlink" href="#a-2-express-potentially-reusable-parts-as-a-library" title="Link to this heading">¶</a></h3>
<section id="id1839">
<h4>Motivo<a class="headerlink" href="#id1839" title="Link to this heading">¶</a></h4>
</section>
<section id="id1840">
<h4>Nota<a class="headerlink" href="#id1840" title="Link to this heading">¶</a></h4>
<p>Una libreria è una collezione di dichiarazioni e definizioni mantenute, documentate e raggruppate assieme. Una libreria può essere un set di header (una «header-only library») o un insieme di header più un insieme di file oggetto. È possibile linkare staticamente o dinamicamente una libreria con un programma, o si può <code class="docutils literal notranslate"><span class="pre">#include</span></code>re una libreria «header-only».</p>
</section>
</section>
<section id="a-4-there-should-be-no-cycles-among-libraries">
<h3><a name="Ra-dag"></a>A.4: Non ci dovrebbero essere ciclicità tra le librerie<a class="headerlink" href="#a-4-there-should-be-no-cycles-among-libraries" title="Link to this heading">¶</a></h3>
<section id="id1841">
<h4>Motivo<a class="headerlink" href="#id1841" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Una ciclicità complica il processo di compilazione.</p></li>
<li><p>Le ciclicità sono difficili da capire e potrebbero introdurre indeterminismo (comportamento non specificato).</p></li>
</ul>
</section>
<section id="id1842">
<h4>Nota<a class="headerlink" href="#id1842" title="Link to this heading">¶</a></h4>
<p>Una libreria può contenere riferimenti ciclici nella definizione dei propri componenti. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
<p>Tuttavia, una libreria non dovrebbe dipendere da un’altra che, a sua volta, dipende da essa.</p>
</section>
</section>
</section>
<section id="nr-non-rules-and-myths">
<h2><a name="S-not"></a>NR: Non-Regole e miti<a class="headerlink" href="#nr-non-rules-and-myths" title="Link to this heading">¶</a></h2>
<p>Questa sezione contiene regole e linee-guida che sono popolari altrove, ma che deliberatamente non si raccomandano. È ben noto che ci sono stati tempi e luoghi in cui queste regole avevano un senso, e a volte le abbiamo usate noi stessi. Tuttavia, nel contesto degli stili di programmazione che si raccomandano e si supportano con le linee-guida, queste «non regole» risulterebbero dannose.</p>
<p>Tuttora possono esserci contesti in cui le regole hanno senso. Per esempio, la mancanza di un adeguato supporto di tool può rendere inadeguate le eccezioni nei sistemi in tempo reale, ma non c’è da fidarsi ingenuamente della «saggezza popolare» (p.es., affermazioni non dimostrate sulla «efficienza»); questa «saggezza» potrebbe essere basata su informazioni vecchie di decenni e sperimentate con linguaggi dalle proprietà molto diverse da quelle del C++ (p.es., C o Java).</p>
<p>Gli argomenti positivi come alternative a queste non-regole sono indicate nelle regole proposte come «Alternative».</p>
<p>Riepilogo delle non-regole:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rnr-top"><span class="xref myst">NR.1: Non insistere sul fatto che tutte le dichiarazioni dovrebbero stare all’inizio di una funzione</span></a></p></li>
<li><p><a class="reference internal" href="#Rnr-single-return"><span class="xref myst">NR.2: Non insistere sul dover avere un’unica istruzione <code class="docutils literal notranslate"><span class="pre">return</span></code> in una funzione</span></a></p></li>
<li><p><a class="reference internal" href="#Rnr-no-exceptions"><span class="xref myst">NR.3: Non evitare le eccezioni</span></a></p></li>
<li><p><a class="reference internal" href="#Rnr-lots-of-files"><span class="xref myst">NR.4: Non insistere nel voler mettere ogni definizione di classe nel proprio file sorgente</span></a></p></li>
<li><p><a class="reference internal" href="#Rnr-two-phase-init"><span class="xref myst">NR.5: Non usare l’inizializzazione a due fasi [two-phase]</span></a></p></li>
<li><p><a class="reference internal" href="#Rnr-goto-exit"><span class="xref myst">NR.6: Non mettere tutte le operazioni di ripulitura alla fine di una funzione e il <code class="docutils literal notranslate"><span class="pre">goto</span> <span class="pre">exit</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rnr-protected-data"><span class="xref myst">NR.7: Non rendere tutti i dati membro come <code class="docutils literal notranslate"><span class="pre">protected</span></code></span></a></p></li>
<li><p>???</p></li>
</ul>
<section id="nr-1-don-t-insist-that-all-declarations-should-be-at-the-top-of-a-function">
<h3><a name="Rnr-top"></a>NR.1: Non insistere sul fatto che tutte le dichiarazioni dovrebbero stare all’inizio di una funzione<a class="headerlink" href="#nr-1-don-t-insist-that-all-declarations-should-be-at-the-top-of-a-function" title="Link to this heading">¶</a></h3>
<section id="id1843">
<h4>Motivo<a class="headerlink" href="#id1843" title="Link to this heading">¶</a></h4>
<p>La regola «tutte le dichiarazioni all’inizio» è un retaggio di vecchi linguaggi di programmazione che non consentivano l’inizializzazione di variabili e costanti dopo un’istruzione. Ciò porta a programmi più lunghi e più errori causati da variabili non inizializzate o inizializzate erroneamente.</p>
</section>
<section id="id1844">
<h4>Esempio, cattivo<a class="headerlink" href="#id1844" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int use(int x)
{
    int i;
    char c;
    double d;

    // ... some stuff ...

    if (x &lt; i) {
        // ...
        i = f(x, d);
    }
    if (i &lt; x) {
        // ...
        i = g(x, c);
    }
    return i;
}
</pre></div>
</div>
<p>Maggiore è la distanza tra la variabile non inizializzata e il suo utilizzo, maggiore è la probabilità di un bug. Fortunatamente, i compilatori rilevano molti errori «utilizzo prima dell’assegnazione». Purtroppo, i compilatori non possono rilevare tutti questi errori e, sfortunatamente, i bug non sono sempre così facili da individuare come in questo piccolo esempio.</p>
</section>
<section id="id1845">
<h4>Alternativa<a class="headerlink" href="#id1845" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#Res-always"><span class="xref myst">Inizializzare sempre un oggetto</span></a></p></li>
<li><p><a class="reference internal" href="#Res-introduce"><span class="xref myst">ES.21: Non introdurre una variabile (o una costante) prima che ne sia necessario l’uso</span></a></p></li>
</ul>
</section>
</section>
<section id="nr-2-don-t-insist-to-have-only-a-single-return-statement-in-a-function">
<h3><a name="Rnr-single-return"></a>NR.2: Non insistere sul dover avere un’unica istruzione <code class="docutils literal notranslate"><span class="pre">return</span></code> in una funzione<a class="headerlink" href="#nr-2-don-t-insist-to-have-only-a-single-return-statement-in-a-function" title="Link to this heading">¶</a></h3>
<section id="id1846">
<h4>Motivo<a class="headerlink" href="#id1846" title="Link to this heading">¶</a></h4>
<p>La regola del return-unico può portare a un codice inutilmente contorto e alla necessità di variabili di stato extra. In particolare, la regola del return-unico rende più difficile concentrare il controllo degli errori all’inizio di una funzione.</p>
</section>
<section id="id1847">
<h4>Esempio<a class="headerlink" href="#id1847" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class T&gt;
//  requires Number&lt;T&gt;
string sign(T x)
{
    if (x &lt; 0)
        return &quot;negative&quot;;
    if (x &gt; 0)
        return &quot;positive&quot;;
    return &quot;zero&quot;;
}
</pre></div>
</div>
<p>per usare un return unico si dovrebbe fare qualcosa del genere</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class T&gt;
//  requires Number&lt;T&gt;
string sign(T x)        // bad
{
    string res;
    if (x &lt; 0)
        res = &quot;negative&quot;;
    else if (x &gt; 0)
        res = &quot;positive&quot;;
    else
        res = &quot;zero&quot;;
    return res;
}
</pre></div>
</div>
<p>Questo è sia più lungo che probabilmente meno efficiente. Più grande e complicata è la funzione, più contorte sono le soluzioni alternative. Ovviamente molte funzioni semplici avranno naturalmente un solo <code class="docutils literal notranslate"><span class="pre">return</span></code> a causa della loro logica intrinseca più semplice.</p>
</section>
<section id="id1848">
<h4>Esempio<a class="headerlink" href="#id1848" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int index(const char* p)
{
    if (!p) return -1;  // error indicator: alternatively &quot;throw nullptr_error{}&quot;
    // ... do a lookup to find the index for p
    return i;
}
</pre></div>
</div>
<p>Se si applicasse la regola, si otterrebbe qualcosa di simile</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int index2(const char* p)
{
    int i;
    if (!p)
        i = -1;  // error indicator
    else {
        // ... do a lookup to find the index for p
    }
    return i;
}
</pre></div>
</div>
<p>Si noti che è stata (deliberatamente) violata la regola contro le variabili non inizializzate perché questo stile porta solitamente a farlo. Inoltre, questo stile è una tentazione per usare la non-regola <a class="reference internal" href="#Rnr-goto-exit"><span class="xref myst">goto exit</span></a>.</p>
</section>
<section id="id1849">
<h4>Alternativa<a class="headerlink" href="#id1849" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Tenere le funzioni brevi e semplici</p></li>
<li><p>Sentirsi liberi di usare più istruzioni <code class="docutils literal notranslate"><span class="pre">return</span></code> (e sollevare [throw] eccezioni).</p></li>
</ul>
</section>
</section>
<section id="nr-3-don-t-avoid-exceptions">
<h3><a name="Rnr-no-exceptions"></a>NR.3: Non evitare le eccezioni<a class="headerlink" href="#nr-3-don-t-avoid-exceptions" title="Link to this heading">¶</a></h3>
<section id="id1850">
<h4>Motivo<a class="headerlink" href="#id1850" title="Link to this heading">¶</a></h4>
<p>Sembrano esserci quattro principali ragioni per non usare le eccezioni:</p>
<ul class="simple">
<li><p>le eccezioni sono inefficienti</p></li>
<li><p>le eccezioni portano a leak e ad errori</p></li>
<li><p>La prestazione di un’eccezione non è prevedibile</p></li>
<li><p>il supporto a run-time della gestione delle eccezioni occupa troppo spazio</p></li>
</ul>
<p>Non è possibile risolvere questo problema assecondando tutti. Dopotutto, le discussioni sulle eccezioni vanno avanti da oltre 40 anni. Alcuni linguaggi non si possono usare senza le eccezioni, ma altri non le supportano. Ciò porta a delle consolidate tradizioni sull’uso e il non-uso delle eccezioni e ad accesi dibattiti.</p>
<p>Tuttavia, si può descrivere brevemente il motivo per cui si considerano le eccezioni l’alternativa migliore per la programmazione ad uso generale e nel contesto di queste linee-guida. Semplici argomenti a favore o contro spesso sono inconcludenti. Esistono applicazioni specializzate in cui le eccezioni possono essere inopportune (p.es., sistemi con un rigido real-time senza il supporto di stime affidabili dei costi della gestione degli errori).</p>
<p>Si considerino le principali obiezioni una per una</p>
<ul class="simple">
<li><p>Le eccezioni sono inefficienti: Rispetto a che? Durante il confronto, assicurarsi che venga gestita la stessa serie di errori e che siano gestiti in modo equivalente. In particolare, non confrontare un programma che termina immediatamente al primo errore con un programma che pulisce accuratamente le risorse prima di “loggare” un errore. Sì, alcuni sistemi hanno implementazioni di gestione delle eccezioni scadenti; a volte, tali implementazioni ci obbligano a utilizzare altri approcci per la gestione degli errori, ma questo non è un problema fondamentale per le eccezioni. Quando si utilizza un argomento di efficienza - in qualsiasi contesto - fare attenzione a disporre di dati validi che forniscano effettivamente informazioni sul problema in esame.</p></li>
<li><p>Le eccezioni portano a leak e ad errori. Non lo fanno. Se il programma è un ammasso di puntatori senza una strategia globale per la gestione delle risorse, c’è un problema, qualunque cosa si faccia. Se il sistema è costituito da un milione di righe di tale codice, probabilmente non si sarà in grado di usare le eccezioni, ma questo è un problema per un uso eccessivo e indisciplinato dei puntatori, piuttosto che con le eccezioni. A nostro avviso, c’è bisogno del RAII per rendere la gestione degli errori basata sulle eccezioni semplice e sicura – più semplice e più sicura delle alternative.</p></li>
<li><p>Le prestazioni delle eccezioni non sono prevedibili. Se ci si trova in un sistema fortemente real-time in cui è necessario garantire il completamento di un’attività in un determinato tempo, sono necessari dei tool per avallare queste necessità. Per quanto si sa, tali tool non sono disponibili (almeno non per la maggior parte dei programmatori).</p></li>
<li><p>Il supporto a run-time della gestione delle eccezioni occupa troppo spazio  Questo può accadere nel caso di piccoli sistemi (di solito quelli embedded). Tuttavia, prima di abbandonare le eccezioni, considerare quanto spazio richiederebbe una gestione coerente degli errori utilizzando i codici di errore e quanto costerebbe la mancata rilevazione di un errore.</p></li>
</ul>
<p>Molti, forse la maggior parte, dei problemi con le eccezioni derivano da esigenze storiche di interagire con un codice vecchio e disordinato.</p>
<p>Gli argomenti fondamentali per l’uso delle eccezioni sono</p>
<ul class="simple">
<li><p>Distinguono chiaramente tra un return con errore e un return senza</p></li>
<li><p>Non possono essere dimenticati o ignorati</p></li>
<li><p>Possono essere usati sistematicamente</p></li>
</ul>
<p>Da ricordare</p>
<ul class="simple">
<li><p>Le eccezioni servono per segnalare errori (nel C++; altri linguaggi le possono usare per altri usi).</p></li>
<li><p>Le eccezioni non riguardano errori che possono essere gestiti localmente.</p></li>
<li><p>Non cercare di catturare tutte le eccezioni in ogni funzione (è noioso, goffo e porta a un codice lento).</p></li>
<li><p>Le eccezioni non riguardano gli errori che richiedono la chiusura immediata di un modulo/sistema dopo un errore irrecuperabile.</p></li>
</ul>
</section>
<section id="id1851">
<h4>Esempio<a class="headerlink" href="#id1851" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1852">
<h4>Alternativa<a class="headerlink" href="#id1852" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#Re-raii"><span class="xref myst">RAII</span></a></p></li>
<li><p>Contratti/asserzioni: Usare <code class="docutils literal notranslate"><span class="pre">Expects</span></code> e <code class="docutils literal notranslate"><span class="pre">Ensures</span></code> del GSL (fino a quando non si avrà il supporto nel linguaggio per i contratti)</p></li>
</ul>
</section>
</section>
<section id="nr-4-don-t-insist-on-placing-each-class-definition-in-its-own-source-file">
<h3><a name="Rnr-lots-of-files"></a>NR.4: Non insistere nel voler mettere ogni definizione di classe nel proprio file sorgente<a class="headerlink" href="#nr-4-don-t-insist-on-placing-each-class-definition-in-its-own-source-file" title="Link to this heading">¶</a></h3>
<section id="id1853">
<h4>Motivo<a class="headerlink" href="#id1853" title="Link to this heading">¶</a></h4>
<p>Il numero di file che risulta nel collocare ciascuna classe nel proprio file è difficile da gestire e può rallentare la compilazione. Classi singole costituiscono raramente delle buone unità logiche da manutenere e distribuire.</p>
</section>
<section id="id1854">
<h4>Esempio<a class="headerlink" href="#id1854" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1855">
<h4>Alternativa<a class="headerlink" href="#id1855" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Usare i namespace contenenti insiemi di classi e funzioni logicamente correlati.</p></li>
</ul>
</section>
</section>
<section id="nr-5-don-t-use-two-phase-initialization">
<h3><a name="Rnr-two-phase-init"></a>NR.5: Non usare l’inizializzazione a due fasi [two-phase]<a class="headerlink" href="#nr-5-don-t-use-two-phase-initialization" title="Link to this heading">¶</a></h3>
<section id="id1856">
<h4>Motivo<a class="headerlink" href="#id1856" title="Link to this heading">¶</a></h4>
<p>Suddividere in due l’inizializzazione, porta a invarianti più deboli, codice più complicato (gestire oggetti semi-costruiti) e ad errori (quando non si gestiscono correttamente gli oggetti semi-costruiti in modo coerente).</p>
</section>
<section id="id1857">
<h4>Esempio, cattivo<a class="headerlink" href="#id1857" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Old conventional style: many problems

class Picture
{
    int mx;
    int my;
    int * data;
public:
    // main problem: constructor does not fully construct
    Picture(int x, int y)
    {
        mx = x;         // also bad: assignment in constructor body
                        // rather than in member initializer
        my = y;
        data = nullptr; // also bad: constant initialization in constructor
                        // rather than in member initializer
    }

    ~Picture()
    {
        Cleanup();
    }

    // ...

    // bad: two-phase initialization
    bool Init()
    {
        // invariant checks
        if (mx &lt;= 0 || my &lt;= 0) {
            return false;
        }
        if (data) {
            return false;
        }
        data = (int*) malloc(mx*my*sizeof(int));   // also bad: owning raw * and malloc
        return data != nullptr;
    }

    // also bad: no reason to make cleanup a separate function
    void Cleanup()
    {
        if (data) free(data);
        data = nullptr;
    }
};

Picture picture(100, 0); // not ready-to-use picture here
// this will fail..
if (!picture.Init()) {
    puts(&quot;Error, invalid picture&quot;);
}
// now have an invalid picture object instance.
</pre></div>
</div>
</section>
<section id="id1858">
<h4>Esempio, buono<a class="headerlink" href="#id1858" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Picture
{
    int mx;
    int my;
    vector&lt;int&gt; data;

    static int check_size(int size)
    {
        // invariant check
        Expects(size &gt; 0);
        return size;
    }

public:
    // even better would be a class for a 2D Size as one single parameter
    Picture(int x, int y)
        : mx(check_size(x))
        , my(check_size(y))
        // now we know x and y have a valid size
        , data(mx * my) // will throw std::bad_alloc on error
    {
        // picture is ready-to-use
    }

    // compiler generated dtor does the job. (also see C.21)

    // ...
};

Picture picture1(100, 100);
// picture1 is ready-to-use here...

// not a valid size for y,
// default contract violation behavior will call std::terminate then
Picture picture2(100, 0);
// not reach here...
</pre></div>
</div>
</section>
<section id="id1859">
<h4>Alternativa<a class="headerlink" href="#id1859" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Stabilire sempre un invariante della classe in un costruttore.</p></li>
<li><p>Non definire un oggetto prima che sia necessario.</p></li>
</ul>
</section>
</section>
<section id="nr-6-don-t-place-all-cleanup-actions-at-the-end-of-a-function-and-goto-exit">
<h3><a name="Rnr-goto-exit"></a>NR.6: Non mettere tutte le operazioni di ripulitura alla fine di una funzione e il <code class="docutils literal notranslate"><span class="pre">goto</span> <span class="pre">exit</span></code><a class="headerlink" href="#nr-6-don-t-place-all-cleanup-actions-at-the-end-of-a-function-and-goto-exit" title="Link to this heading">¶</a></h3>
<section id="id1860">
<h4>Motivo<a class="headerlink" href="#id1860" title="Link to this heading">¶</a></h4>
<p>Il <code class="docutils literal notranslate"><span class="pre">goto</span></code> è soggetto a errori. Questa è una tecnica pre-eccezioni per le risorse [RAII-like] e la gestione degli errori.</p>
</section>
<section id="id1861">
<h4>Esempio, cattivo<a class="headerlink" href="#id1861" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void do_something(int n)
{
    if (n &lt; 100) goto exit;
    // ...
    int* p = (int*) malloc(n);
    // ...
    if (some_error) goto_exit;
    // ...
exit:
    free(p);
}
</pre></div>
</div>
<p>e si trovi il bug.</p>
</section>
<section id="id1862">
<h4>Alternativa<a class="headerlink" href="#id1862" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Usare le eccezioni e il <a class="reference internal" href="#Re-raii"><span class="xref myst">RAII</span></a></p></li>
<li><p>per le risorse non-RAII, usare <a class="reference internal" href="#Re-finally"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">finally</span></code></span></a>.</p></li>
</ul>
</section>
</section>
<section id="nr-7-don-t-make-all-data-members-protected">
<h3><a name="Rnr-protected-data"></a>NR.7: Non rendere tutti i dati membro come <code class="docutils literal notranslate"><span class="pre">protected</span></code><a class="headerlink" href="#nr-7-don-t-make-all-data-members-protected" title="Link to this heading">¶</a></h3>
<section id="id1863">
<h4>Motivo<a class="headerlink" href="#id1863" title="Link to this heading">¶</a></h4>
<p>I dati <code class="docutils literal notranslate"><span class="pre">protected</span></code> sono fonte di errori. I dati <code class="docutils literal notranslate"><span class="pre">protected</span></code> possono essere modificati da una gran quantità di codice in vari punti. I dati <code class="docutils literal notranslate"><span class="pre">protected</span></code> sono l’equivalente dei dati globali nelle gerarchie di classi.</p>
</section>
<section id="id1864">
<h4>Esempio<a class="headerlink" href="#id1864" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>???
</pre></div>
</div>
</section>
<section id="id1865">
<h4>Alternativa<a class="headerlink" href="#id1865" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p><a class="reference internal" href="#Rh-protected"><span class="xref myst">Rendere i dati membro <code class="docutils literal notranslate"><span class="pre">public</span></code> o (preferibilmente) <code class="docutils literal notranslate"><span class="pre">private</span></code></span></a></p></li>
</ul>
</section>
</section>
</section>
<section id="rf-references">
<h2><a name="S-references"></a>RF: Riferimenti<a class="headerlink" href="#rf-references" title="Link to this heading">¶</a></h2>
<p>Sono stati scritti molti standard di codifica, regole e linee-guida per il C++, specie per usi specifici del C++. Molti</p>
<ul class="simple">
<li><p>si concentrano su argomenti a basso libello, come l’ortografia e gli identificatori</p></li>
<li><p>sono scritti da principianti del C++</p></li>
<li><p>cercano principalmente di «impedire ai programmatori di fare cose insolite»</p></li>
<li><p>mirano alla portabilità tra più compilatori (alcuni hanno 10 anni)</p></li>
<li><p>sono scritti per preservare decenni di vecchio codice</p></li>
<li><p>mirano ad un singolo dominio applicativo</p></li>
<li><p>sono decisamente controproducenti</p></li>
<li><p>vengono ignorati (devono essere ignorati dai programmatori per fare un buon lavoro)</p></li>
</ul>
<p>Un cattivo standard di codifica è peggio che non avere alcuno standard. Tuttavia, una serie di giuste linee-guida è molto meglio di nessuno standard: «La disciplina è liberatrice [Form is liberating]».</p>
<p>Perché non si può semplicemente avere un linguaggio consenta  tutto ciò si vuole e non ci permetta di tutto ciò che non si vuole («un linguaggio perfetto»)? Fondamentalmente, perché i linguaggi a prezzi accessibili (e i tool accessori) servono anche a persone con esigenze diverse dalle proprie e soddisfano più esigenze di quelle che odierne. Inoltre, le esigenze cambiano col tempo ed è necessario un linguaggio «general-purpose» per potersi adattare. Un linguaggio che sia perfetto oggi potrebbe diventare restrittivo un domani.</p>
<p>Le linee-guida adattano l’utilizzo del linguaggio a specifiche necessità. Pertanto, non può esistere un unico stile di codifica per tutti. C’è da prevedere che diverse organizzazioni forniscano delle aggiunte, in genere con più restrizioni e regole di stile più rigide.</p>
<p>Sezioni sui riferimenti:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#SS-rules"><span class="xref myst">RF.rules: Regole di codifica</span></a></p></li>
<li><p><a class="reference internal" href="#SS-books"><span class="xref myst">RF.books: Libri con linee-guida sulla codifica</span></a></p></li>
<li><p><a class="reference internal" href="#SS-Cplusplus"><span class="xref myst">RF.C++: Programmazione C++ (C++11/C++14/C++17)</span></a></p></li>
<li><p><a class="reference internal" href="#SS-web"><span class="xref myst">RF.web: Siti web</span></a></p></li>
<li><p><a class="reference internal" href="#SS-vid"><span class="xref myst">RS.video: Video sul «C++ moderno»</span></a></p></li>
<li><p><a class="reference internal" href="#SS-man"><span class="xref myst">RF.man: Manuali</span></a></p></li>
<li><p><a class="reference internal" href="#SS-core"><span class="xref myst">RF.core: Materiali sulle «Core Guidelines»</span></a></p></li>
</ul>
<section id="rf-rules-coding-rules">
<h3><a name="SS-rules"></a>RF.rules: Regole di codifica<a class="headerlink" href="#rf-rules-coding-rules" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://web.archive.org/web/20220629085753/https://www.autosar.org/fileadmin/user_upload/standards/adaptive/17-03/AUTOSAR_RS_CPP14Guidelines.pdf">Linee-guida AUTOSAR [AUTomotive Open System Architecture] per l’uso del linguaggio C++14 per sistemi critici e sicuri v17.10</a></p></li>
<li><p><a class="reference external" href="http://www.boost.org/development/requirements.html">Requisiti e linee-guida della libreria Boost</a>. ???.</p></li>
<li><p><a class="reference external" href="https://github.com/bloomberg/bde/wiki/CodingStandards.pdf">Bloomberg: BDE C++ Coding</a>. Pone una forte enfasi sull’organizzazione e il layout del codice.</p></li>
<li><p>Facebook: ???</p></li>
<li><p><a class="reference external" href="https://gcc.gnu.org/codingconventions.html">GCC Coding Conventions</a>. C++03 e (ragionevolmente) un po” datate.</p></li>
<li><p><a class="reference external" href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a>. Orientato al C++17 e (anche) al codice più vecchio. Qui, gli esperti di Google, stanno collaborando attivamente per contribuire a migliorare queste Linee-guida e, si spera, per unire gli sforzi in modo che queste possano costituire un moderno insieme comune che potrebbero anche raccomandare.</p></li>
<li><p><a class="reference external" href="http://www.stroustrup.com/JSF-AV-rules.pdf">JSF++: JOINT STRIKE FIGHTER AIR VEHICLE C++ CODING STANDARDS</a>. Documento Numero 2RDU00001 Rev C. Dicembre 2005. Per il software per il controllo di aerei. Per lo «hard-real-time». Questo vuol dire che è necessariamente molto restrittivo («se il programma fallisce qualcuno muore»). Ad esempio, non potrebbe avvenire nessuna allocazione o de-allocazione della memoria dopo il decollo dell’aereo (non è consentito nessun [overflow] della memoria né una sua frammentazione). Non è possibile utilizzare alcuna eccezione (perché non c’è alcun tool a disposizione che ne garantisca l’esecuzione subito, in un tempo prestabilito). Le librerie usate sono state approvate per applicazioni «mission critical». Non deve sorprendere che ci sia qualche somiglianza con queste linee-guida perché Bjarne Stroustrup è stato uno degli autori della JSF++. Raccomandata, ma si noti che ha un focus molto specifico.</p></li>
<li><p><a class="reference external" href="https://misra.org.uk/product/misra-cpp2023/">MISRA C++:2023 Guidelines for the use C++17 in critical systems</a>.</p></li>
<li><p><a class="reference external" href="https://firefox-source-docs.mozilla.org/code-quality/coding-style/using_cxx_in_firefox_code.html">Utilizzo del C++ nel Codice di Mozilla</a>. Come indica il nome, si pone lo scopo della portabilità tra molti (vecchi) compilatori. In quanto tale, è restrittivo.</p></li>
<li><p><a class="reference external" href="http://geosoft.no/development/cppstyle.html">Geosoft.no: C++ Programming Style Guidelines</a>.
???.</p></li>
<li><p><a class="reference external" href="http://www.possibility.com/Cpp/CppCodingStandard.html">Possibility.com: C++ Coding Standard</a>.
???.</p></li>
<li><p><a class="reference external" href="https://wiki.sei.cmu.edu/confluence/x/Wnw-BQ">SEI CERT: Secure C++ Coding Standard</a>. Un set di regole ben fatto (con esempi e razionali) per il codice [security-sensitive]. Molte delle regole si applicano in generale.</p></li>
<li><p><a class="reference external" href="http://www.codingstandard.com/">High Integrity C++ Coding Standard</a>.</p></li>
<li><p><a class="reference external" href="http://llvm.org/docs/CodingStandards.html">llvm</a>. Abbastanza breve, basato sul C++14 e (non irragionevolmente) adattato al suo dominio.</p></li>
<li><p>???</p></li>
</ul>
</section>
<section id="rf-books-books-with-coding-guidelines">
<h3><a name="SS-books"></a>RF.books: Libri con linee-guida sulla codifica<a class="headerlink" href="#rf-books-books-with-coding-guidelines" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><a class="reference internal" href="#Meyers96"><span class="xref myst">Meyers96</span></a> Scott Meyers: <em>More Effective C++</em>. Addison-Wesley 1996.</p></li>
<li><p><a class="reference internal" href="#Meyers97"><span class="xref myst">Meyers97</span></a> Scott Meyers: <em>Effective C++, Second Edition</em>. Addison-Wesley 1997.</p></li>
<li><p><a class="reference internal" href="#Meyers01"><span class="xref myst">Meyers01</span></a> Scott Meyers: <em>Effective STL</em>. Addison-Wesley 2001.</p></li>
<li><p><a class="reference internal" href="#Meyers05"><span class="xref myst">Meyers05</span></a> Scott Meyers: <em>Effective C++, Third Edition</em>. Addison-Wesley 2005.</p></li>
<li><p><a class="reference internal" href="#Meyers15"><span class="xref myst">Meyers15</span></a> Scott Meyers: <em>Effective Modern C++</em>. O’Reilly 2015.</p></li>
<li><p><a class="reference internal" href="#SuttAlex05"><span class="xref myst">SuttAlex05</span></a> Sutter and Alexandrescu: <em>C++ Coding Standards</em>. Addison-Wesley 2005. Più un insieme di meta-regole che un set di regole. Pre-C++11.</p></li>
<li><p><a class="reference internal" href="#Stroustrup05"><span class="xref myst">Stroustrup05</span></a> Bjarne Stroustrup: <a class="reference external" href="http://www.stroustrup.com/SELLrationale.pdf">A rationale for semantically enhanced library languages</a>.
LCSD05. October 2005.</p></li>
<li><p><a class="reference internal" href="#Stroustrup05"><span class="xref myst">Stroustrup14</span></a> Stroustrup: <a class="reference external" href="http://www.stroustrup.com/Tour.html">A Tour of C++</a>. Addison Wesley 2014. Ogni capitolo termina con una sezione di consigli composta da una serie di raccomandazioni.</p></li>
<li><p><a class="reference internal" href="#Stroustrup13"><span class="xref myst">Stroustrup13</span></a> Stroustrup: <a class="reference external" href="http://www.stroustrup.com/4th.html">The C++ Programming Language (4th Edition)</a>. Addison Wesley 2013. Ogni capitolo termina con una sezione di consigli composta da una serie di raccomandazioni.</p></li>
<li><p>Stroustrup: <a class="reference external" href="http://www.stroustrup.com/Programming/PPP-style.pdf">Style Guide</a> for <a class="reference external" href="http://www.stroustrup.com/programming.html">Programming: Principles and Practice using C++</a>. Principalmente regole sui nomi e sul layout a basso livello Principalmente uno strumento didattico.</p></li>
</ul>
</section>
<section id="rf-c-c-programming-c-11-c-14">
<h3><a name="SS-Cplusplus"></a>RF.C++: C++ Programming (C++11/C++14)<a class="headerlink" href="#rf-c-c-programming-c-11-c-14" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="http://www.stroustrup.com/4th.html">TC++PL4</a>: Una descrizione completa del linguaggio C++ e delle librerie standard per programmatori esperti.</p></li>
<li><p><a class="reference external" href="http://www.stroustrup.com/Tour.html">Tour++</a>: Una panoramica sul linguaggio C++ e sulle librerie standard per programmatori esperti.</p></li>
<li><p><a class="reference external" href="http://www.stroustrup.com/programming.html">Programming: Principles and Practice using C++</a>: Un libro di testo per principianti o quasi.</p></li>
</ul>
</section>
<section id="rf-web-websites">
<h3><a name="SS-web"></a>RF.web: Siti web<a class="headerlink" href="#rf-web-websites" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://isocpp.org">isocpp.org</a></p></li>
<li><p><a class="reference external" href="http://www.stroustrup.com">Il sito di Bjarne Stroustrup</a></p></li>
<li><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/">WG21</a></p></li>
<li><p><a class="reference external" href="http://www.boost.org">Boost</a><a name="Boost"></a></p></li>
<li><p><a class="reference external" href="https://opensource.adobe.com/">Adobe open source</a></p></li>
<li><p><a class="reference external" href="http://pocoproject.org/">Librerie Poco</a></p></li>
<li><p>Sutter’s Mill?</p></li>
<li><p>???</p></li>
</ul>
</section>
<section id="rs-video-videos-about-modern-c">
<h3><a name="SS-vid"></a>RS.video: Video sul «C++ moderno»<a class="headerlink" href="#rs-video-videos-about-modern-c" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>Bjarne Stroustrup: <a class="reference external" href="http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style">C++11 Style</a>. 2012.</p></li>
<li><p>Bjarne Stroustrup: <a class="reference external" href="http://channel9.msdn.com/Events/GoingNative/2013/Opening-Keynote-Bjarne-Stroustrup">The Essence of C++: With Examples in C++84, C++98, C++11, and C++14</a>. 2013</p></li>
<li><p>Tutti gli interventi dal <a class="reference external" href="https://isocpp.org/blog/2014/11/cppcon-videos-c9">CppCon “14</a></p></li>
<li><p>Bjarne Stroustrup: <a class="reference external" href="https://www.youtube.com/watch?v=86xWVb4XIyE">The essence of C++</a> at the University of Edinburgh. 2014.</p></li>
<li><p>Bjarne Stroustrup: <a class="reference external" href="https://www.youtube.com/watch?v=_wzc7a3McOs">The Evolution of C++ Past, Present and Future</a>. CppCon 2016 [keynote].</p></li>
<li><p>Bjarne Stroustrup: <a class="reference external" href="https://www.youtube.com/watch?v=nesCaocNjtQ">Make Simple Tasks Simple!</a>. CppCon 2014 [keynote].</p></li>
<li><p>Bjarne Stroustrup: <a class="reference external" href="https://www.youtube.com/watch?v=1OEu9C51K2A">Writing Good C++14</a>. CppCon 2015 [keynote] sulle «Core Guidelines».</p></li>
<li><p>Herb Sutter: <a class="reference external" href="https://www.youtube.com/watch?v=hEx5DNLWGgA">Writing Good C++14… By Default</a>. CppCon 2015 [keynote] sulle «Core Guidelines».</p></li>
<li><p>CppCon 15</p></li>
<li><p>??? C++ Prossimo</p></li>
<li><p>??? Meeting sul C++</p></li>
<li><p>??? altro ???</p></li>
</ul>
</section>
<section id="rf-man-manuals">
<h3><a name="SS-man"></a>RF.man: Manuali<a class="headerlink" href="#rf-man-manuals" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>ISO C++ Standard C++11.</p></li>
<li><p>ISO C++ Standard C++14.</p></li>
<li><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf">ISO C++ Standard C++17</a>. Bozza del Comitato [Committee Draft].</p></li>
<li><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf">Palo Alto «Concepts» TR</a>.</p></li>
<li><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf">ISO C++ Concepts TS</a>.</p></li>
<li><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf">WG21 Ranges report</a>. Bozza [draft].</p></li>
</ul>
</section>
<section id="rf-core-core-guidelines-materials">
<h3><a name="SS-core"></a>RF.core: Materiali sulle «Core Guidelines»<a class="headerlink" href="#rf-core-core-guidelines-materials" title="Link to this heading">¶</a></h3>
<p>Questa sezione contiene materiali che sono stati utili per presentare le «core guidelines» e le idee su cui si basano:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/tree/master/docs">La nostra directory dei documenti</a></p></li>
<li><p>Stroustrup, Sutter, and Dos Reis: <a class="reference external" href="http://www.stroustrup.com/resource-model.pdf">A brief introduction to C++”s model for type- and resource-safety</a>. Un documento don moltissimi esempi.</p></li>
<li><p>Sergey Zubkov: <a class="reference external" href="https://www.youtube.com/watch?v=DyLwdl_6vmU">a Core Guidelines talk</a> and here are the <a class="reference external" href="http://2017.cppconf.ru/talks/sergey-zubkov">slides</a>. In Russo. 2017.</p></li>
<li><p>Neil MacIntosh: <a class="reference external" href="https://www.youtube.com/watch?v=_GhNnCuaEjo">The Guideline Support Library: One Year Later</a>. CppCon 2016.</p></li>
<li><p>Bjarne Stroustrup: <a class="reference external" href="https://www.youtube.com/watch?v=1OEu9C51K2A">Writing Good C++14</a>. CppCon 2015 [keynote].</p></li>
<li><p>Herb Sutter: <a class="reference external" href="https://www.youtube.com/watch?v=hEx5DNLWGgA">Writing Good C++14… By Default</a>. CppCon 2015 [keynote].</p></li>
<li><p>Peter Sommerlad: <a class="reference external" href="https://www.youtube.com/watch?v=fQ926v4ZzAM">C++ Core Guidelines - Modernize your C++ Code Base</a>. ACCU 2017.</p></li>
<li><p>Bjarne Stroustrup: <a class="reference external" href="https://www.youtube.com/watch?v=01zI9kV4h8c">No Littering!</a>. Bay Area ACCU 2016. Da un’idea del livello ambito dalle  «Core Guidelines».</p></li>
</ul>
<p>Si noti che sono disponibili le slide per le presentazioni al CppCon (i link con i video postati).</p>
<p>Sono benvenuti altri contributi a questo elenco.</p>
</section>
<section id="acknowledgements">
<h3><a name="SS-ack"></a>Ringraziamenti<a class="headerlink" href="#acknowledgements" title="Link to this heading">¶</a></h3>
<p>Grazie alle molte persone che hanno contribuito con regole, suggerimenti, supportando le informazioni, con riferimenti, ecc.:</p>
<ul class="simple">
<li><p>Peter Juhl</p></li>
<li><p>Neil MacIntosh</p></li>
<li><p>Axel Naumann</p></li>
<li><p>Andrew Pardoe</p></li>
<li><p>Gabriel Dos Reis</p></li>
<li><p>Zhuang, Jiangang (Jeff)</p></li>
<li><p>Sergey Zubkov</p></li>
</ul>
<p>e si veda l’elenco dei contributori su github.</p>
</section>
</section>
<section id="pro-profiles">
<h2><a name="S-profile"></a>Pro: Profili<a class="headerlink" href="#pro-profiles" title="Link to this heading">¶</a></h2>
<p>Idealmente, si seguirebbero tutte le linee guida. Questo porterebbe a un codice più pulito, più regolare, meno soggetto a errori e spesso il più veloce. Sfortunatamente, ciò è generalmente impossibile perché si deve adattare il proprio codice ad altro codice di grandi dimensioni e utilizzare le librerie esistenti. Spesso, tale codice è stato scritto per decenni e non segue queste linee-guida. Si deve puntare ad una <a class="reference internal" href="#S-modernizing"><span class="xref myst">graduale adozione</span></a>.</p>
<p>Qualunque strategia di adozione graduale si adotti, si deve essere in grado di applicare una serie di linee-guida correlate per affrontare prima una serie di problemi e rimandare il resto a dopo. Un’idea simile di «linee-guida correlate» diventa importante quando alcune delle linee-guida, ma non tutte, vengono considerate rilevanti per una base di codice o se una serie di linee-guida specializzate deve essere applicata ad un’area applicativa specializzata. Un tale insieme di linee-guida correlate definisce un «profilo». Lo scopo di queste linee-guida di essere coerenti in modo che aiutino a raggiungere uno specifico obiettivo, come «assenza di errori sui limiti [range]» o «sicurezza dei tipi statici». Ciascun profilo viene progettato per eliminare una classe di errori. L’imposizione di regole «casuali», prese singolarmente, risulta più nocivo per il codice anziché un netto miglioramento.</p>
<p>Un «profilo» è un sotto-insieme di regole deterministiche e portabilmente imponibili (cioè restrizioni) progettate per ottenere una specifica garanzia. «Deterministico» significa che richiedono solo analisi locali e potrebbero essere implementate in un compilatore (sebbene non debbano per forza esserlo). «Portabilmente imponibili» significa che sono come le regole del linguaggio, quindi i programmatori possono contare su diversi strumenti applicativi che danno la stessa risposta per lo stesso codice.</p>
<p>Il codice scritto per essere privo di «warning» utilizzando uno di questi profili del linguaggio è considerato essere conforme a quel profilo. Il codice conforme è considerato essere sicuro per costituzione secondo le proprietà della sicurezza designate da quel profilo. Il codice conforme non sarà la causa principale di errori per quelle proprietà, sebbene questi errori potrebbero essere introdotti in un programma da altro codice, librerie e dall’ambiente esterno. Un profilo potrebbe anche aggiungere ulteriori tipi di librerie per essere facilmente conformi e incoraggiare il codice corretto.</p>
<p>Riepilogo dei profili:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#SS-type"><span class="xref myst">Pro.type: Sicurezza del tipo [Type safety]</span></a></p></li>
<li><p><a class="reference internal" href="#SS-bounds"><span class="xref myst">Pro.bounds: Sicurezza dei limiti [Bounds safety]</span></a></p></li>
<li><p><a class="reference internal" href="#SS-lifetime"><span class="xref myst">Pro.lifetime: Sicurezza del ciclo di vita [Lifetime safety]</span></a></p></li>
</ul>
<p>In futuro, si prevede di definire molti più profili e di aggiungere più controlli ai profili esistenti. Tra i candidati ci sono:</p>
<ul class="simple">
<li><p>[narrowing] aritmetico promozioni/conversioni (probabilmente come parte di un profilo separato su un’aritmetica sicura [safe-arithmetic])</p></li>
<li><p>cast aritmetici da virgola mobile negativi a interi senza segno (idem)</p></li>
<li><p>comportamento indefinito selezionato: Si parte con l’elenco UB di Gabriel Dos Reis, sviluppato per il gruppo di studio del WG21</p></li>
<li><p>comportamento indeterminato selezionato: Soluzione dei problemi di portabilità.</p></li>
<li><p>violazioni di <code class="docutils literal notranslate"><span class="pre">const</span></code>: Già eseguite per lo più dai compilatori, ma si possono intercettare i cast inappropriati e il sotto-utilizzo di <code class="docutils literal notranslate"><span class="pre">const</span></code>.</p></li>
</ul>
<p>L’abilitazione di un profilo è definita dall’implementazione; in genere, è impostato nello strumento di analisi utilizzato.</p>
<p>Per sopprimere l’applicazione di un controllo del profilo, inserire un’annotazione <code class="docutils literal notranslate"><span class="pre">suppress</span></code> in un contratto del linguaggio. Per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[[suppress(&quot;bounds&quot;)]] char* raw_find(char* p, int n, char x)    // find x in p[0]..p[n - 1]
{
    // ...
}
</pre></div>
</div>
<p>Ora <code class="docutils literal notranslate"><span class="pre">raw_find()</span></code> può mischiare la memoria al suo contenuto interno. Ovviamente, la soppressione dovrebbe essere rarissima.</p>
<section id="pro-safety-type-safety-profile">
<h3><a name="SS-type"></a>Pro.safety: Profilo [Type-safety]<a class="headerlink" href="#pro-safety-type-safety-profile" title="Link to this heading">¶</a></h3>
<p>Questo profilo semplifica la scrittura di codice che utilizzi correttamente i tipi ed eviti la confusione accidentale dei tipi. Lo fa concentrandosi sulla rimozione delle fonti primarie delle violazioni sui tipi, inclusi gli usi non sicuri di cast e unioni.</p>
<p>Per questa sezione, la sicurezza del tipo è definita come la proprietà che una variabile non venga usata in un modo che non rispetti le regole del tipo della sua definizione. La memoria a cui si accede come ad un tipo <code class="docutils literal notranslate"><span class="pre">T</span></code> non deve essere una memoria valida che effettivamente contenga un oggetto di un tipo non correlato <code class="docutils literal notranslate"><span class="pre">U</span></code>. Si noti che la sicurezza deve essere completa se combinata anche con la <a class="reference internal" href="#SS-bounds"><span class="xref myst">Bounds safety</span></a> e la <a class="reference internal" href="#SS-lifetime"><span class="xref myst">Lifetime safety</span></a>.</p>
<p>Un’implementazione di questo profilo deve riconoscere i seguenti schemi nel codice sorgente come non conformi ed emettere una diagnostica.</p>
<p>Riepilogo del profilo sulla sicurezza dei tipi [type safety]:</p>
<ul class="simple">
<li><p><a name="Pro-type-avoidcasts"></a>Type.1: <a class="reference internal" href="#Res-casts"><span class="xref myst">Evitare i cast</span></a>:</p>
<ol class="arabic simple">
<li><p><a name="Pro-type-reinterpretcast"></a>Non usare <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code>; Una versione rigorosa di <a class="reference internal" href="#Res-casts"><span class="xref myst">Evitare i cast</span></a> e <a class="reference internal" href="#Res-casts-named"><span class="xref myst">preferire i cast nominati</span></a>.</p></li>
<li><p><a name="Pro-type-arithmeticcast"></a>Non usare <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> per i tipi aritmetici; Una versione rigorosa di <a class="reference internal" href="#Res-casts"><span class="xref myst">Evitare i cast</span></a> e <a class="reference internal" href="#Res-casts-named"><span class="xref myst">preferire i cast nominati</span></a>.</p></li>
<li><p><a name="Pro-type-identitycast"></a>Non eseguire il cast tra tipi puntatori in cui il tipo di origine e quello di destinazione è lo stesso; Una versione rigorosa di <a class="reference internal" href="#Res-casts"><span class="xref myst">Evitare i cast</span></a>.</p></li>
<li><p><a name="Pro-type-implicitpointercast"></a>Non eseguire il cast tra tipi puntatori quando la conversione potrebbe essere implicita; Una versione rigorosa di <a class="reference internal" href="#Res-casts"><span class="xref myst">Evitare i cast</span></a>.</p></li>
</ol>
</li>
<li><p><a name="Pro-type-downcast"></a>Type.2: Non usare <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> per il [downcast]: <a class="reference internal" href="#Rh-dynamic_cast"><span class="xref myst">Usare, invece, <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code></span></a>.</p></li>
<li><p><a name="Pro-type-constcast"></a>Type.3: Non usare <code class="docutils literal notranslate"><span class="pre">const_cast</span></code> per eliminare il <code class="docutils literal notranslate"><span class="pre">const</span></code> (cioè mai): <a class="reference internal" href="#Res-casts-const"><span class="xref myst">Non eliminare const</span></a>.</p></li>
<li><p><a name="Pro-type-cstylecast"></a>Type.4: Non usare cast <code class="docutils literal notranslate"><span class="pre">(T)expression</span></code> in stile C o quelli funzionali <code class="docutils literal notranslate"><span class="pre">T(expression)</span></code>: Preferire la <a class="reference internal" href="#Res-construct"><span class="xref myst">costruzione</span></a> i <a class="reference internal" href="#Res-casts-named"><span class="xref myst">named casts</span></a> oppure <code class="docutils literal notranslate"><span class="pre">T{expression}</span></code>.</p></li>
<li><p><a name="Pro-type-init"></a>Type.5: Non usare una variabile prima che sia stata inizializzata: <a class="reference internal" href="#Res-always"><span class="xref myst">inizializzare sempre</span></a>.</p></li>
<li><p><a name="Pro-type-memberinit"></a>Type.6: Inizializzare sempre un dato membro: <a class="reference internal" href="#Res-always"><span class="xref myst">inizializzare sempre</span></a>, possibilmente utilizzando <a class="reference internal" href="#Rc-default0"><span class="xref myst">costruttori di default</span></a> o <a class="reference internal" href="#Rc-in-class-initializer"><span class="xref myst">inizializzatori membro di default</span></a>.</p></li>
<li><p><a name="Pro-type-union"></a>Type.7: Evitare le semplici [naked] union: <a class="reference internal" href="#Ru-naked"><span class="xref myst">Usare, invece, <code class="docutils literal notranslate"><span class="pre">variant</span></code></span></a>.</p></li>
<li><p><a name="Pro-type-varargs"></a>Type.8: Evitare i vararg: <a class="reference internal" href="#F-varargs"><span class="xref myst">Non usare gli argomenti <code class="docutils literal notranslate"><span class="pre">va_arg</span></code></span></a>.</p></li>
</ul>
<section id="impact">
<h4>Impatto<a class="headerlink" href="#impact" title="Link to this heading">¶</a></h4>
<p>Col profilo «type-safety» si può essere sicuri che ogni operazione venga applicata ad un oggetto valido. Si potrebbe generare un’eccezione per indicare errori che non possono essere rilevati staticamente (al momento della compilazione). Si noti che questo «type-safety» può essere completo solo se c’è anche il <a class="reference internal" href="#SS-bounds"><span class="xref myst">Bounds safety</span></a> e il <a class="reference internal" href="#SS-lifetime"><span class="xref myst">Lifetime safety</span></a>. Senza tali garanzie, è possibile accedere a una parte della memoria indipendentemente da quale oggetto, oggetti o parti di oggetti vi siano memorizzati.</p>
</section>
</section>
<section id="pro-bounds-bounds-safety-profile">
<h3><a name="SS-bounds"></a>Pro.bounds: Profilo [Bounds safety]<a class="headerlink" href="#pro-bounds-bounds-safety-profile" title="Link to this heading">¶</a></h3>
<p>Questo profilo semplifica la scrittura di codice che operi entro i limiti dei blocchi di memoria allocati. Lo fa concentrandosi sulla rimozione delle principali fonti di violazioni dei limiti: l’aritmetica del puntatore e l’indicizzazione degli array. Una delle caratteristiche principali di questo profilo è quella di limitare i puntatori a far riferimento solo a singoli oggetti, non ad array.</p>
<p>Si definisce la sicurezza dei limiti [bounds-safety] come la proprietà che un programma non utilizzi un oggetto per accedere alla memoria al di fuori dell’intervallo assegnato per l’oggetto stesso. La «bounds safety» è completa solo se combinata con la <a class="reference internal" href="#SS-type"><span class="xref myst">Type safety</span></a> e la <a class="reference internal" href="#SS-lifetime"><span class="xref myst">Lifetime safety</span></a>, che riguardano altre operazioni non sicure che permettono delle violazioni dei limiti.</p>
<p>Riepilogo del profilo [bounds safety]:</p>
<ul class="simple">
<li><p><a name="Pro-bounds-arithmetic"></a>Bounds.1: Non usare l’aritmetica dei puntatori. Utilizzare, invece, <code class="docutils literal notranslate"><span class="pre">span</span></code>: <a class="reference internal" href="#Ri-array"><span class="xref myst">Passare puntatori (solo) a singoli oggetti</span></a> e <a class="reference internal" href="#Res-ptr"><span class="xref myst">Semplificare l’aritmetica dei puntatori</span></a>.</p></li>
<li><p><a name="Pro-bounds-arrayindex"></a>Bounds.2: Indicizzare gli array solo con espressioni costanti: <a class="reference internal" href="#Ri-array"><span class="xref myst">Passare puntatori (solo) a singoli oggetti</span></a> e <a class="reference internal" href="#Res-ptr"><span class="xref myst">Semplificare l’aritmetica dei puntatori</span></a>.</p></li>
<li><p><a name="Pro-bounds-decay"></a>Bounds.3: Nessun decadimento da-array-a-puntatore: <a class="reference internal" href="#Ri-array"><span class="xref myst">Passare puntatori (solo) a singoli oggetti</span></a> e <a class="reference internal" href="#Res-ptr"><span class="xref myst">Semplificare l’aritmetica dei puntatori</span></a>.</p></li>
<li><p><a name="Pro-bounds-stdlib"></a>Bounds.4: Non utilizzare funzioni e tipi della libreria standard che non siano [bounds-checked]: <a class="reference internal" href="#Rsl-bounds"><span class="xref myst">Usare la libreria standard in modo [type-safe]</span></a>.</p></li>
</ul>
<section id="id1866">
<h4>Impatto<a class="headerlink" href="#id1866" title="Link to this heading">¶</a></h4>
<p>La sicurezza dei limiti implica che l’accesso a un oggetto - soprattutto array - non acceda oltre la memoria allocata per l’oggetto. Questo elimina una grande categoria di errori insidiosi e difficili da trovare, inclusi i famosi (infami) errori di «buffer overflow». Ciò chiude le falle nella sicurezza così come un’importante fonte di corruzione della memoria (quando si scrive oltre i limiti). Anche se un accesso oltre i limiti è «solo in lettura», può portare a violazioni degli invarianti (quando ciò a cui si accede non del tipo previsto) e a «misteriosi valori».</p>
</section>
</section>
<section id="pro-lifetime-lifetime-safety-profile">
<h3><a name="SS-lifetime"></a>Pro.lifetime: Profilo sulla sicurezza del ciclo-di-vita [lifetime]<a class="headerlink" href="#pro-lifetime-lifetime-safety-profile" title="Link to this heading">¶</a></h3>
<p>L’accesso tramite un puntatore che non punta a nulla è una delle principali fonti di errori, ed è molto difficile da evitare in molti stili di programmazione C e C++ tradizionali. Per esempio, un puntatore potrebbe essere non inizializzato, il <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>, puntare oltre i limiti di un array o a un oggetto cancellato.</p>
<p><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetime.pdf">Consultare le attuali specifiche di progettazione qui.</a></p>
<p>Riepilogo del profilo [lifetime safety]:</p>
<ul class="simple">
<li><p><a name="Pro-lifetime-invalid-deref"></a>Lifetime.1: Non de-referenziare un puntatore probabilmente non valido: <a class="reference internal" href="#Res-deref"><span class="xref myst">rilevare e evitare</span></a>.</p></li>
</ul>
<section id="id1867">
<h4>Impatto<a class="headerlink" href="#id1867" title="Link to this heading">¶</a></h4>
<p>Una volta imposto completamente attraverso una combinazione di regole di stile, analisi statica e supporto della libreria, questo profilo</p>
<ul class="simple">
<li><p>elimina una delle principali fonti di pessimi errori in C++</p></li>
<li><p>elimina un’importante fonte di potenziali violazioni della sicurezza</p></li>
<li><p>migliora le prestazioni eliminando i controlli ridondanti e «paranoici»</p></li>
<li><p>aumenta la fiducia nella correttezza del codice</p></li>
<li><p>evita comportamenti indefiniti imponendo una regola chiave del linguaggio C++</p></li>
</ul>
</section>
</section>
</section>
<section id="gsl-guidelines-support-library">
<h2><a name="S-gsl"></a>GSL: Libreria di supporto alle linee-guida [Guidelines support library]<a class="headerlink" href="#gsl-guidelines-support-library" title="Link to this heading">¶</a></h2>
<p>La GSL è una piccola libreria di funzionalità progettate per supportare questo insieme di linee-guida. Senza queste funzionalità, le linee-guida dovrebbero essere molto più restrittive sui dettagli del linguaggio.</p>
<p>La libreria di supporto alle «Core Guidelines» è definita nel namespace <code class="docutils literal notranslate"><span class="pre">gsl</span></code> e i nomi potrebbero essere alias per la libreria standard e di altri nomi ben noti di librerie. L’utilizzo (in fase di compilazione) del riferimento indiretto [indirection] tramite il namespace <code class="docutils literal notranslate"><span class="pre">gsl</span></code> consente la sperimentazione e varianti locali delle funzionalità di supporto.</p>
<p>La GSL è «header only», e si può trovare in <a class="reference external" href="https://github.com/Microsoft/GSL">GSL: Guidelines support library</a>. Le funzionalità della libreria di supporto sono progettate per essere estremamente leggere ([zero-overhead]) in modo da non imporre alcun «overhead» rispetto alle normali alternative. Ove fosse desiderabile, possono essere «munite» di ulteriori funzionalità (p.es., dei controlli) per attività come il debug.</p>
<p>Queste «Guidelines» usano tipi dallo standard (p.es., C++17) altre a quelli dalla GSL. Per esempio, si ipotizza un tipo <code class="docutils literal notranslate"><span class="pre">variant</span></code>, ma questo non è attualmente nella GSL. Alla fine, si usa <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0088r3.html">quello proposto nel C++17</a>.</p>
<p>Alcuni dei tipi della GSL elencati in seguito potrebbero non essere supportati nella libreria utilizzata per motivi tecnici quali le limitazioni delle attuali versioni del C++. Pertanto, consultare la documentazione GSL per ulteriori informazioni.</p>
<p>Per ogni tipo di GSL di seguito ne indichiamo un invariante. Tale invariante vale fintanto che il codice utente cambia solo lo stato di un oggetto GSL utilizzando le funzioni membro/free fornite dal tipo (ovvero, il codice utente non ignora l’interfaccia del tipo per modificare il valore/bit dell’oggetto violando qualsiasi altra regola delle Guidelines).</p>
<p>Riepilogo dei componenti della GSL:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#SS-views"><span class="xref myst">GSL.view: Viste</span></a></p></li>
<li><p><a class="reference internal" href="#SS-ownership"><span class="xref myst">GSL.owner: Puntatori proprietari</span></a></p></li>
<li><p><a class="reference internal" href="#SS-assertions"><span class="xref myst">GSL.assert: Asserzioni</span></a></p></li>
<li><p><a class="reference internal" href="#SS-utilities"><span class="xref myst">GSL.util: Utilities</span></a></p></li>
<li><p><a class="reference internal" href="#SS-gsl-concepts"><span class="xref myst">GSL.concept: Concetti</span></a></p></li>
</ul>
<p>È pianificata una specifica semi-formale delle GSL per un «ISO C++ standard style».</p>
<p>Si fa affidamento sulla Libreria Standard C++ ISO e si spera che parti della GSL vengano assorbite nella libreria standard.</p>
<section id="gsl-view-views">
<h3><a name="SS-views"></a>GSL.view: Viste<a class="headerlink" href="#gsl-view-views" title="Link to this heading">¶</a></h3>
<p>Questi tipi consentono all’utente di distinguere tra puntatori proprietari e non proprietari e tra puntatori a un singolo oggetto e puntatori al primo elemento di una sequenza.</p>
<p>Queste «viste» non sono mai proprietarie.</p>
<p>I riferimenti non sono mai proprietari (cfr. <a class="reference internal" href="#Rr-ref"><span class="xref myst">R.4</span></a>). Nota: I riferimenti hanno molte opportunità di sopravvivere agli oggetti cui si riferiscono (restituendo una variabile locale per riferimento, mantenendo un riferimento ad un elemento di un vettore che ha subito un <code class="docutils literal notranslate"><span class="pre">push_back</span></code>, un [binding] a <code class="docutils literal notranslate"><span class="pre">std::max(x,</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">1)</span></code>, ecc.). Il profilo «Lifetime safety» punta a risolvere tali problemi, ma anche così <code class="docutils literal notranslate"><span class="pre">owner&lt;T&amp;&gt;</span></code> non ha senso e se ne scoraggia l’uso.</p>
<p>I nomi sono principalmente nello stile della libreria standard ISO (minuscole e underscore):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T*</span></code>      // Il <code class="docutils literal notranslate"><span class="pre">T*</span></code> non è proprietario, potrebbe essere nullo; si presume che punti ad un singolo elemento.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>      // Il <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> non è proprietario e non può mai essere un «riferimento nullo»; i riferimenti sono sempre dimensionati [bound] agli oggetti.</p></li>
</ul>
<p>La notazione del «raw-pointer» (p.es. <code class="docutils literal notranslate"><span class="pre">int*</span></code>) si suppone che abbia il suo significato più comune; vale a dire, un puntatore punta ad un oggetto, ma non lo possiede. I proprietari devono essere convertiti in gestori [handle] delle risorse (p.es., <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> o <code class="docutils literal notranslate"><span class="pre">vector&lt;T&gt;</span></code>) o contrassegnati come <code class="docutils literal notranslate"><span class="pre">owner&lt;T*&gt;</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">owner&lt;T*&gt;</span></code>   // un <code class="docutils literal notranslate"><span class="pre">T*</span></code> che possiede l’oggetto puntato/riferito; potrebbe essere <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">owner</span></code> è usato per contrassegnare i puntatori proprietari nel codice che non può essere aggiornato per utilizzare gli handle appropriati delle risorse. Tra i motivi ci sono:</p>
<ul class="simple">
<li><p>Costo della conversione.</p></li>
<li><p>Il puntatore è usato con un ABI.</p></li>
<li><p>Il puntatore è parte dell’implementazione di un gestore di risorsa.</p></li>
</ul>
<p>Un <code class="docutils literal notranslate"><span class="pre">owner&lt;T&gt;</span></code> differisce da un gestore di risorsa per una <code class="docutils literal notranslate"><span class="pre">T</span></code> ma richiede comunque un esplicito <code class="docutils literal notranslate"><span class="pre">delete</span></code>.</p>
<p>Un <code class="docutils literal notranslate"><span class="pre">owner&lt;T&gt;</span></code> si suppone faccia riferimento ad un oggetto nel «free store» (heap).</p>
<p>Se qualcosa si suppone che non possa essere <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>, lo si affermi così:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">not_null&lt;T&gt;</span></code>   // <code class="docutils literal notranslate"><span class="pre">T</span></code> è solitamente il tipo del puntatore (p.es., <code class="docutils literal notranslate"><span class="pre">not_null&lt;int*&gt;</span></code> o <code class="docutils literal notranslate"><span class="pre">not_null&lt;owner&lt;Foo*&gt;&gt;</span></code>) che non dev’essere <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>. <code class="docutils literal notranslate"><span class="pre">T</span></code> può essere un qualunque tipo per cui ha senso <code class="docutils literal notranslate"><span class="pre">==nullptr</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">span&lt;T&gt;</span></code>       // <code class="docutils literal notranslate"><span class="pre">[p:p+n)</span></code>, costruttore da <code class="docutils literal notranslate"><span class="pre">{p,</span> <span class="pre">q}</span></code> and <code class="docutils literal notranslate"><span class="pre">{p,</span> <span class="pre">n}</span></code>; <code class="docutils literal notranslate"><span class="pre">T</span></code> è il tipo del puntatore</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">span_p&lt;T&gt;</span></code>     // <code class="docutils literal notranslate"><span class="pre">{p,</span> <span class="pre">predicate}</span></code> <code class="docutils literal notranslate"><span class="pre">[p:q)</span></code> dove <code class="docutils literal notranslate"><span class="pre">q</span></code> è il primo elemento per cui <code class="docutils literal notranslate"><span class="pre">predicate(*p)</span></code> è vero</p></li>
</ul>
<p>Uno <code class="docutils literal notranslate"><span class="pre">span&lt;T&gt;</span></code> si riferisce a zero o più <code class="docutils literal notranslate"><span class="pre">T</span></code> mutabili a meno che <code class="docutils literal notranslate"><span class="pre">T</span></code> sia un tipo <code class="docutils literal notranslate"><span class="pre">const</span></code>. Per default, tutti gli accessi agli elementi dello span, in particolare tramite <code class="docutils literal notranslate"><span class="pre">operator[]</span></code>, sono sicuramente bounds-checked.</p>
<blockquote>
<div><p>Nota: Lo <code class="docutils literal notranslate"><span class="pre">span</span></code> di GSL (inizialmente chiamato <code class="docutils literal notranslate"><span class="pre">array_view</span></code>) è stato proposto per l’inclusione nella libreria standard C++, ed è stato adottato (con modifiche al nome e all’interfaccia) tranne che <code class="docutils literal notranslate"><span class="pre">std::span</span></code> non prevede il controllo dei limiti. Pertanto GSL ha cambiato il nome e l’interfaccia di <code class="docutils literal notranslate"><span class="pre">span</span></code> per tener traccia di <code class="docutils literal notranslate"><span class="pre">std::span</span></code> e dovrebbe essere esattamente lo stesso di <code class="docutils literal notranslate"><span class="pre">std::span</span></code>, e l’unica differenza dovrebbe essere che <code class="docutils literal notranslate"><span class="pre">span</span></code> di GSL è completamente bounds-safe per default. Se la sicurezza dei limiti [bounds-safety] potrebbe influire sulla sua interfaccia, allora quelle proposte di modifica dovrebbero essere riportate tramite il comitato ISO C++ per mantenere l’interfaccia <code class="docutils literal notranslate"><span class="pre">gsl::span</span></code> compatibile con <code class="docutils literal notranslate"><span class="pre">std::span</span></code>. Se una futura evoluzione di <code class="docutils literal notranslate"><span class="pre">std::span</span></code> aggiunge il controllo dei limiti, <code class="docutils literal notranslate"><span class="pre">gsl::span</span></code> potrà essere rimossa.</p>
</div></blockquote>
<p>«L’aritmetica del puntatore» viene fatta meglio negli <code class="docutils literal notranslate"><span class="pre">span</span></code>. Un <code class="docutils literal notranslate"><span class="pre">char*</span></code> che punta a più di un <code class="docutils literal notranslate"><span class="pre">char</span></code> ma non è una stringa «C-style» (p.es., un puntatore in un buffer di input) deve essere rappresentato da uno <code class="docutils literal notranslate"><span class="pre">span</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">zstring</span></code>    // un <code class="docutils literal notranslate"><span class="pre">char*</span></code> che si suppone essere una stringa «C-style»; ovvero, una sequenza di <code class="docutils literal notranslate"><span class="pre">char</span></code> o un <code class="docutils literal notranslate"><span class="pre">nullptr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">czstring</span></code>   // un <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code> che si suppone essere una stringa «C-style»; ovvero, una sequenza di <code class="docutils literal notranslate"><span class="pre">const</span></code> <code class="docutils literal notranslate"><span class="pre">char</span></code> o un <code class="docutils literal notranslate"><span class="pre">nullptr</span></code></p></li>
</ul>
<p>Logicamente, questi ultimi due alias non sono necessari, ma non siamo sempre logici e rendono esplicita la distinzione tra un puntatore a un <code class="docutils literal notranslate"><span class="pre">char</span></code> e un esplicito puntatore a una stringa «C-style». Una sequenza di caratteri che non si suppone sia terminata con zero dovrebbe essere una <code class="docutils literal notranslate"><span class="pre">span&lt;char&gt;</span></code>, o se ciò è impossibile a causa dell’ABI, un <code class="docutils literal notranslate"><span class="pre">char*</span></code>, anziché una <code class="docutils literal notranslate"><span class="pre">zstring</span></code>.</p>
<p>Usare <code class="docutils literal notranslate"><span class="pre">not_null&lt;zstring&gt;</span></code> per stringhe «C-style» che non possono essere <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>. ??? C’è bisogno di un nome per <code class="docutils literal notranslate"><span class="pre">not_null&lt;zstring&gt;</span></code>? o la sua bruttezza già lo distingue?</p>
</section>
<section id="gsl-owner-ownership-pointers">
<h3><a name="SS-ownership"></a>GSL.owner: Puntatori proprietari<a class="headerlink" href="#gsl-owner-ownership-pointers" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;T&gt;</span></code>     // proprietà unica: <code class="docutils literal notranslate"><span class="pre">std::unique_ptr&lt;T&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shared_ptr&lt;T&gt;</span></code>     // proprietà condivisa: <code class="docutils literal notranslate"><span class="pre">std::shared_ptr&lt;T&gt;</span></code> (un puntatore conteggiato)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stack_array&lt;T&gt;</span></code>    // Un array allocato sullo stack. Il numero di elementi è determinato in fase di costruzione e fissato per il seguito. Gli elementi sono mutabili a meno che <code class="docutils literal notranslate"><span class="pre">T</span></code> non sia un tipo <code class="docutils literal notranslate"><span class="pre">const</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dyn_array&lt;T&gt;</span></code>      // ??? necessario ??? Un array allocato sull’heap. Il numero di elementi è determinato in fase di costruzione e fissato per il seguito. Gli elementi sono mutabili a meno che <code class="docutils literal notranslate"><span class="pre">T</span></code> non sia un tipo <code class="docutils literal notranslate"><span class="pre">const</span></code>. Fondamentalmente uno <code class="docutils literal notranslate"><span class="pre">span</span></code> che alloca e possiede i suoi elementi.</p></li>
</ul>
</section>
<section id="gsl-assert-assertions">
<h3><a name="SS-assertions"></a>GSL.assert: Asserzioni<a class="headerlink" href="#gsl-assert-assertions" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Expects</span></code>     // asserzione di precondizione. Attualmente posto nel corpo delle funzioni. In seguito, dovrebbe essere spostato nelle dichiarazioni.               // <code class="docutils literal notranslate"><span class="pre">Expects(p)</span></code> termina  il programma a meno che <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">==</span> <span class="pre">true</span></code>               // <code class="docutils literal notranslate"><span class="pre">Expects</span></code> è sotto il controllo di alcune opzioni (imposizione, messaggio di errore, alternative all’uscita del programma)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Ensures</span></code>     // asserzione di post-condizione. Attualmente posto nel corpo delle funzioni. In seguito, dovrebbe essere spostato nelle dichiarazioni.</p></li>
</ul>
<p>Attualmente queste asserzioni sono macro (che schifo!) e devono apparire (solamente) nelle definizioni delle funzioni in attesa delle decisioni del comitato sullo standard a proposito della sintassi dei contratti e delle asserzioni. Si veda  <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf">the contract proposal</a>; che usa la sintassi degli attributi, per esempio, <code class="docutils literal notranslate"><span class="pre">Expects(p)</span></code> diventerà <code class="docutils literal notranslate"><span class="pre">[[expects:</span> <span class="pre">p]]</span></code>.</p>
</section>
<section id="gsl-util-utilities">
<h3><a name="SS-utilities"></a>GSL.util: Utilità<a class="headerlink" href="#gsl-util-utilities" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">finally</span></code>        // <code class="docutils literal notranslate"><span class="pre">finally(f)</span></code> crea una <code class="docutils literal notranslate"><span class="pre">final_action{f}</span></code> con un distruttore che invoca <code class="docutils literal notranslate"><span class="pre">f</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">narrow_cast</span></code>    // <code class="docutils literal notranslate"><span class="pre">narrow_cast&lt;T&gt;(x)</span></code> è <code class="docutils literal notranslate"><span class="pre">static_cast&lt;T&gt;(x)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">narrow</span></code>         // <code class="docutils literal notranslate"><span class="pre">narrow&lt;T&gt;(x)</span></code> è <code class="docutils literal notranslate"><span class="pre">static_cast&lt;T&gt;(x)</span></code> se <code class="docutils literal notranslate"><span class="pre">static_cast&lt;T&gt;(x)</span> <span class="pre">==</span> <span class="pre">x</span></code> senza alcun passaggio signed/unsigned  [signedness], o genera un  <code class="docutils literal notranslate"><span class="pre">narrowing_error</span></code> (p.es., <code class="docutils literal notranslate"><span class="pre">narrow&lt;unsigned&gt;(-42)</span></code> solleva un errore)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[[implicit]]</span></code>   // «Marker» da mettere sui costruttori ad argomento singolo per crearli espressamente non-espliciti.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">move_owner</span></code>     // <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">move_owner(q)</span></code> significa  <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">q</span></code> but ???</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">joining_thread</span></code> // una versione in stile RAII di <code class="docutils literal notranslate"><span class="pre">std::thread</span></code> che esegue il join.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>          // un tipo da usare per indicizzare tutti i contenitori e gli array (al momento un alias di <code class="docutils literal notranslate"><span class="pre">ptrdiff_t</span></code>)</p></li>
</ul>
</section>
<section id="gsl-concept-concepts">
<h3><a name="SS-gsl-concepts"></a>GSL.concept: Concetti<a class="headerlink" href="#gsl-concept-concepts" title="Link to this heading">¶</a></h3>
<p>Questi concetti (tipi predicati) sono presi in prestito da «Andrew Sutton’s Origin library, the Range proposal, and the ISO WG21 Palo Alto TR». Molti di loro sono molto simili a ciò che è diventato parte dello standard ISO C++ in C++20.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">String</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Number</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Range</span></code>              // in C++20, <code class="docutils literal notranslate"><span class="pre">std::ranges::range</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Sortable</span></code>           // in C++20, <code class="docutils literal notranslate"><span class="pre">std::sortable</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EqualityComparable</span></code> // in C++20, <code class="docutils literal notranslate"><span class="pre">std::equality_comparable</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Convertible</span></code>        // in C++20, <code class="docutils literal notranslate"><span class="pre">std::convertible_to</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Common</span></code>             // in C++20, <code class="docutils literal notranslate"><span class="pre">std::common_with</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Integral</span></code>           // in C++20, <code class="docutils literal notranslate"><span class="pre">std::integral</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SignedIntegral</span></code>     // in C++20, <code class="docutils literal notranslate"><span class="pre">std::signed_integral</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SemiRegular</span></code>        // in C++20, <code class="docutils literal notranslate"><span class="pre">std::semiregular</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Regular</span></code>            // in C++20, <code class="docutils literal notranslate"><span class="pre">std::regular</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TotallyOrdered</span></code>     // in C++20, <code class="docutils literal notranslate"><span class="pre">std::totally_ordered</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Function</span></code>           // in C++20, <code class="docutils literal notranslate"><span class="pre">std::invocable</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RegularFunction</span></code>    // in C++20, <code class="docutils literal notranslate"><span class="pre">std::regular_invocable</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Predicate</span></code>          // in C++20, <code class="docutils literal notranslate"><span class="pre">std::predicate</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Relation</span></code>           // in C++20, <code class="docutils literal notranslate"><span class="pre">std::relation</span></code></p></li>
<li><p>…</p></li>
</ul>
<section id="gsl-ptr-smart-pointer-concepts">
<h4><a name="SS-gsl-smartptrconcepts"></a>GSL.ptr: I concetti di puntatori smart [smart pointer]<a class="headerlink" href="#gsl-ptr-smart-pointer-concepts" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Pointer</span></code>  // Un tipo con <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, e costruzione di default (la costruzione di default si suppone essere un insieme di singoli valori «null»)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Unique_pointer</span></code>  // Un tipo che corrisponde a <code class="docutils literal notranslate"><span class="pre">Pointer</span></code>, si può spostare [movable] e non è copiabile</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Shared_pointer</span></code>   // Un tipo che corrisponde a <code class="docutils literal notranslate"><span class="pre">Pointer</span></code>, ed è copiabile</p></li>
</ul>
</section>
</section>
</section>
<section id="nl-naming-and-layout-suggestions">
<h2><a name="S-naming"></a>NL: Suggerimenti per la nomenclatura e il layout<a class="headerlink" href="#nl-naming-and-layout-suggestions" title="Link to this heading">¶</a></h2>
<p>Una nomenclatura e un layout coerenti sono utili. Se non altro perché riducono questioni come «il mio stile è migliore del tuo». Tuttavia, ci sono molti, molti e diversi stili in giro e le persone vi sono affezionate (pro e contro). Inoltre, la maggior parte dei progetti del mondo reale include codice proveniente da molte fonti, quindi spesso è impossibile standardizzare un solo stile per tutto il codice. Dopo molte richieste di assistenza da parte di utenti, presentiamo una serie di regole che utilizzabili se non si ha di meglio, ma il vero obiettivo è la coerenza, piuttosto che una determinata serie di regole. Gli IDE e i tool possono aiutare (ma anche ostacolare).</p>
<p>Regole sulla nomenclatura e il layout:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Rl-comments"><span class="xref myst">NL.1: Non scrivere nei commenti ciò che è chiaramente affermato nel codice</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-comments-intent"><span class="xref myst">NL.2: Nei commenti dichiarare le intenzioni</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-comments-crisp"><span class="xref myst">NL.3: Rendere i commenti all’essenziale</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-indent"><span class="xref myst">NL.4: Mantenere uno stile coerente di indentazione</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-name-type"><span class="xref myst">NL.5: Evitare di codificare il tipo nei nomi</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-name-length"><span class="xref myst">NL.7: La lunghezza del nome deve essere proporzionale all’ampiezza del suo scope</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-name"><span class="xref myst">NL.8: Usare uno stile coerente per i nomi</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-all-caps"><span class="xref myst">NL.9: Usare <code class="docutils literal notranslate"><span class="pre">TUTTO_IN_MAIUSCOLO</span></code> solo per i nomi delle macro</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-camel"><span class="xref myst">NL.10: Preferire i nomi in <code class="docutils literal notranslate"><span class="pre">underscore_style</span></code> names</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-literals"><span class="xref myst">NL.11: Rendere leggibili i letterali</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-space"><span class="xref myst">NL.15: Usare gli spazi con parsimonia</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-order"><span class="xref myst">NL.16: Usare un ordine convenzionale per la dichiarazione dei membri di una classe</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-knr"><span class="xref myst">NL.17: Usare il layout derivato dal K&amp;R</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-ptr"><span class="xref myst">NL.18: Usare il layout dei dichiaratori in stile C++</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-misread"><span class="xref myst">NL.19: Evitare nomi facilmente travisabili</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-stmt"><span class="xref myst">NL.20: Non mettere due istruzioni sulla stessa riga</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-dcl"><span class="xref myst">NL.21: Dichiarare un (solo) nome per ogni dichiarazione</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-void"><span class="xref myst">NL.25: Non usare <code class="docutils literal notranslate"><span class="pre">void</span></code> come tipo di un argomento</span></a></p></li>
<li><p><a class="reference internal" href="#Rl-const"><span class="xref myst">NL.26: Usare la notazione convenzionale <code class="docutils literal notranslate"><span class="pre">const</span></code></span></a></p></li>
<li><p><a class="reference internal" href="#Rl-file-suffix"><span class="xref myst">NL.27: Usare un suffisso <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> per il file del codice e <code class="docutils literal notranslate"><span class="pre">.h</span></code> per quelli dell’interfaccia</span></a></p></li>
</ul>
<p>La maggior parte di queste regole sono estetiche e i programmatori hanno forti opinioni. Gli IDE tendono inoltre ad avere impostazioni predefinite e una gamma di alternative. Queste regole imposte di default a meno che non si abbiano motivi per fare diversamente.</p>
<p>Abbiamo osservato che la nomenclatura e il layout sono così personali e/o arbitrari che non si dovrebbe cercare di «legiferare» su di essi. Non si sta «legiferando» (si veda il paragrafo precedente). Tuttavia, ci sono state molte richieste per un insieme di convenzioni per la nomenclatura e il layout da utilizzare quando non ci sono vincoli esterni.</p>
<p>Le regole più specifiche e dettagliate sono più facili da applicare.</p>
<p>Queste regole somigliano fortemente alle raccomandazioni nella <a class="reference external" href="http://www.stroustrup.com/Programming/PPP-style.pdf">PPP Style Guide</a> scritta a supporto di <a class="reference external" href="http://www.stroustrup.com/programming.html">Programming: Principles and Practice using C++</a> di Stroustrup.</p>
<section id="nl-1-don-t-say-in-comments-what-can-be-clearly-stated-in-code">
<h3><a name="Rl-comments"></a>NL.1: Non scrivere nei commenti ciò che è chiaramente affermato nel codice<a class="headerlink" href="#nl-1-don-t-say-in-comments-what-can-be-clearly-stated-in-code" title="Link to this heading">¶</a></h3>
<section id="id1868">
<h4>Motivo<a class="headerlink" href="#id1868" title="Link to this heading">¶</a></h4>
<p>I compilatori non leggono i commenti. I commenti sono meno precisi del codice. I commenti vengono aggiornati quando si modifica il codice.</p>
</section>
<section id="id1869">
<h4>Esempio, cattivo<a class="headerlink" href="#id1869" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto x = m * v1 + vv;   // multiply m with v1 and add the result to vv
</pre></div>
</div>
</section>
<section id="id1870">
<h4>Imposizione<a class="headerlink" href="#id1870" title="Link to this heading">¶</a></h4>
<p>Creare un programma di AI che interpreti il testo umano e verifichi se ciò che si è detto si potrebbe esprimere meglio in C++.</p>
</section>
</section>
<section id="nl-2-state-intent-in-comments">
<h3><a name="Rl-comments-intent"></a>NL.2: Nei commenti dichiarare le intenzioni<a class="headerlink" href="#nl-2-state-intent-in-comments" title="Link to this heading">¶</a></h3>
<section id="id1871">
<h4>Motivo<a class="headerlink" href="#id1871" title="Link to this heading">¶</a></h4>
<p>Il codice dice ciò che viene fatto non ciò che si vorrebbe fosse fatto. Spesso l’intenzione può essere espressa in modo più chiaro e conciso dell’implementazione.</p>
</section>
<section id="id1872">
<h4>Esempio<a class="headerlink" href="#id1872" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void stable_sort(Sortable&amp; c)
    // sort c in the order determined by &lt;, keep equal elements (as defined by ==) in
    // their original relative order
{
    // ... quite a few lines of non-trivial code ...
}
</pre></div>
</div>
</section>
<section id="id1873">
<h4>Nota<a class="headerlink" href="#id1873" title="Link to this heading">¶</a></h4>
<p>Se il commento e il codice non coincidono, è probabile che siano entrambi sbagliati.</p>
</section>
</section>
<section id="nl-3-keep-comments-crisp">
<h3><a name="Rl-comments-crisp"></a>NL.3: Rendere i commenti all’essenziale<a class="headerlink" href="#nl-3-keep-comments-crisp" title="Link to this heading">¶</a></h3>
<section id="id1874">
<h4>Motivo<a class="headerlink" href="#id1874" title="Link to this heading">¶</a></h4>
<p>La verbosità rallenta la comprensione e rende il codice più difficile da leggere sparpagliandolo nel file di origine.</p>
</section>
<section id="id1875">
<h4>Nota<a class="headerlink" href="#id1875" title="Link to this heading">¶</a></h4>
<p>Usare un inglese chiaro. Si potrebbe scrivere in un ottimo danese, ma molti programmatori non lo capirebbero; i manutentori del codice potrebbero non essere danesi. Evitare il gergo degli SMS e porre attenzione alla grammatica, la punteggiature e le maiuscole. Si punti alla professionalità, non ad essere alla «moda».</p>
</section>
<section id="id1876">
<h4>Imposizione<a class="headerlink" href="#id1876" title="Link to this heading">¶</a></h4>
<p>non possibile.</p>
</section>
</section>
<section id="nl-4-maintain-a-consistent-indentation-style">
<h3><a name="Rl-indent"></a>NL.4: Mantenere uno stile coerente di indentazione<a class="headerlink" href="#nl-4-maintain-a-consistent-indentation-style" title="Link to this heading">¶</a></h3>
<section id="id1877">
<h4>Motivo<a class="headerlink" href="#id1877" title="Link to this heading">¶</a></h4>
<p>Leggibilità. Evitare «errori stupidi».</p>
</section>
<section id="id1878">
<h4>Esempio, cattivo<a class="headerlink" href="#id1878" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int i;
for (i = 0; i &lt; max; ++i); // bug waiting to happen
if (i == j)
    return i;
</pre></div>
</div>
</section>
<section id="id1879">
<h4>Nota<a class="headerlink" href="#id1879" title="Link to this heading">¶</a></h4>
<p>Solitamente è una buona idea indentare sempre l’istruzione dopo <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(...)</span></code>, <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">(...)</span></code> e <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">(...)</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (i &lt; 0) error(&quot;negative argument&quot;);

if (i &lt; 0)
    error(&quot;negative argument&quot;);
</pre></div>
</div>
</section>
<section id="id1880">
<h4>Imposizione<a class="headerlink" href="#id1880" title="Link to this heading">¶</a></h4>
<p>Usare un tool.</p>
</section>
</section>
<section id="nl-5-avoid-encoding-type-information-in-names">
<h3><a name="Rl-name-type"></a>NL.5: Evitare di codificare il tipo nei nomi<a class="headerlink" href="#nl-5-avoid-encoding-type-information-in-names" title="Link to this heading">¶</a></h3>
<section id="rationale">
<h4>Motivazione<a class="headerlink" href="#rationale" title="Link to this heading">¶</a></h4>
<p>Se i nomi rispecchiano i tipi anziché le funzionalità, diventa difficile cambiare i tipi utilizzati per fornire quella funzionalità. Inoltre, se il tipo di una variabile viene modificato, anche il codice che lo utilizza dovrà essere modificato. Ridurre al minimo le conversioni involontarie.</p>
</section>
<section id="id1881">
<h4>Esempio, cattivo<a class="headerlink" href="#id1881" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void print_int(int i);
void print_string(const char*);

print_int(1);          // repetitive, manual type matching
print_string(&quot;xyzzy&quot;); // repetitive, manual type matching
</pre></div>
</div>
</section>
<section id="id1882">
<h4>Esempio, buono<a class="headerlink" href="#id1882" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void print(int i);
void print(string_view);    // also works on any string-like sequence

print(1);              // clear, automatic type matching
print(&quot;xyzzy&quot;);        // clear, automatic type matching
</pre></div>
</div>
</section>
<section id="id1883">
<h4>Nota<a class="headerlink" href="#id1883" title="Link to this heading">¶</a></h4>
<p>I nomi con i tipi codificati sono prolissi e criptici.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>printS  // print a std::string
prints  // print a C-style string
printi  // print an int
</pre></div>
</div>
<p>L’esigenza di tecniche come la notazione ungherese per codificare un tipo è stata necessaria nei linguaggi non tipizzati, ma risulta generalmente inutile e molto dannosa in un linguaggio fortemente tipizzato come il C++, perché le annotazioni non vengono aggiornate (i commenti sono come le verruche: marciscono) e interferiscono con il buon uso del linguaggio (utilizzare, invece, lo stesso nome e risolvere con l”[overload]).</p>
</section>
<section id="id1884">
<h4>Nota<a class="headerlink" href="#id1884" title="Link to this heading">¶</a></h4>
<p>Certi stili usano prefissi molto generali (non specifici del tipo) per denotare l’uso generale di una variabile.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto p = new User();
auto p = make_unique&lt;User&gt;();
// note: &quot;p&quot; is not being used to say &quot;raw pointer to type User,&quot;
//       just generally to say &quot;this is an indirection&quot;

auto cntHits = calc_total_of_hits(/*...*/);
// note: &quot;cnt&quot; is not being used to encode a type,
//       just generally to say &quot;this is a count of something&quot;
</pre></div>
</div>
<p>Ciò non è dannoso e non rientra in questa linea-guida poiché non codifica il tipo.</p>
</section>
<section id="id1885">
<h4>Nota<a class="headerlink" href="#id1885" title="Link to this heading">¶</a></h4>
<p>Certi stili distinguono tra variabili membro, locali e globali.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct S {
    int m_;
    S(int m) : m_{abs(m)} { }
};
</pre></div>
</div>
<p>Ciò non è dannoso e non rientra in questa linea-guida poiché non codifica il tipo.</p>
</section>
<section id="id1886">
<h4>Nota<a class="headerlink" href="#id1886" title="Link to this heading">¶</a></h4>
<p>Come il C++, alcuni stili fanno distinzione tra i tipi e i non tipi. Per esempio, mettendo in maiuscolo i nomi dei tipi ma non i nomi delle funzioni e delle variabili.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typename&lt;typename T&gt;
class HashTable {   // maps string to T
    // ...
};

HashTable&lt;int&gt; index;
</pre></div>
</div>
<p>Ciò non è dannoso e non rientra in questa linea-guida poiché non codifica il tipo.</p>
</section>
</section>
<section id="nl-7-make-the-length-of-a-name-roughly-proportional-to-the-length-of-its-scope">
<h3><a name="Rl-name-length"></a>NL.7: La lunghezza del nome deve essere proporzionale all’ampiezza del suo scope<a class="headerlink" href="#nl-7-make-the-length-of-a-name-roughly-proportional-to-the-length-of-its-scope" title="Link to this heading">¶</a></h3>
<p><strong>Motivazione</strong>: Più grande è lo scope maggiori è la possibilità di confusione o di un conflitto involontario dei nomi.</p>
<section id="id1887">
<h4>Esempio<a class="headerlink" href="#id1887" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>double sqrt(double x);   // return the square root of x; x must be non-negative

int length(const char* p);  // return the number of characters in a zero-terminated C-style string

int length_of_string(const char zero_terminated_array_of_char[])    // bad: verbose

int g;      // bad: global variable with a cryptic name

int open;   // bad: global variable with a short, popular name
</pre></div>
</div>
<p>Usare <code class="docutils literal notranslate"><span class="pre">p</span></code> per un puntatore e <code class="docutils literal notranslate"><span class="pre">x</span></code> per una variabile in virgola mobile è una convenzione e non confonde in uno scope limitato.</p>
</section>
<section id="id1888">
<h4>Imposizione<a class="headerlink" href="#id1888" title="Link to this heading">¶</a></h4>
<p>???</p>
</section>
</section>
<section id="nl-8-use-a-consistent-naming-style">
<h3><a name="Rl-name"></a>NL.8: Mantenere uno stile coerente di indentazione<a class="headerlink" href="#nl-8-use-a-consistent-naming-style" title="Link to this heading">¶</a></h3>
<p><strong>Motivazione</strong>: La coerenza nella denominazione e nello stile della nomenclatura aumentano la leggibilità.</p>
<section id="id1889">
<h4>Nota<a class="headerlink" href="#id1889" title="Link to this heading">¶</a></h4>
<p>Esistono molti stili e quando si utilizzano più librerie, non è possibile seguire tutte le diverse convenzioni. Scegliere uno «stile proprio», ma lasciare le librerie «importate» col loro stile originale.</p>
</section>
<section id="id1890">
<h4>Esempio<a class="headerlink" href="#id1890" title="Link to this heading">¶</a></h4>
<p>Lo standard ISO, usa solo minuscole e numeri, le parole sono separate con gli [underscore]:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vector</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">my_map</span></code></p></li>
</ul>
<p>Evitare nomi di identificatori che contengono doppi caratteri di sottolineatura <code class="docutils literal notranslate"><span class="pre">__</span></code> o che iniziano con un carattere di sottolineatura seguito da una lettera maiuscola (ad esempio, <code class="docutils literal notranslate"><span class="pre">_Throws</span></code>). Tali identificatori sono riservati per l’implementazione del C++.</p>
</section>
<section id="id1891">
<h4>Esempio<a class="headerlink" href="#id1891" title="Link to this heading">¶</a></h4>
<p><a class="reference external" href="http://www.stroustrup.com/Programming/PPP-style.pdf">Stroustrup</a>: Lo Standard ISO, ma con le maiuscole usate per i propri tipi e i propri concetti:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vector</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">My_map</span></code></p></li>
</ul>
</section>
<section id="id1892">
<h4>Esempio<a class="headerlink" href="#id1892" title="Link to this heading">¶</a></h4>
<p>CamelCase: mette in maiuscolo l’iniziale di ogni parola in un identificatore multi-parole:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vector</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MyMap</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">myMap</span></code></p></li>
</ul>
<p>Alcune convenzioni mettono in maiuscolo la prima lettera, altre non lo fanno.</p>
</section>
<section id="id1893">
<h4>Nota<a class="headerlink" href="#id1893" title="Link to this heading">¶</a></h4>
<p>Cercare di essere coerenti con l’uso di acronimi e sulle lunghezze degli identificatori:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int mtbf {12};
int mean_time_between_failures {12}; // make up your mind
</pre></div>
</div>
</section>
<section id="id1894">
<h4>Imposizione<a class="headerlink" href="#id1894" title="Link to this heading">¶</a></h4>
<p>Sarebbe possibile eccetto che per l’uso di librerie con diverse convenzioni.</p>
</section>
</section>
<section id="nl-9-use-all-caps-for-macro-names-only">
<h3><a name="Rl-all-caps"></a>NL.9: Usare il <code class="docutils literal notranslate"><span class="pre">TUTTO_IN_MAIUSCOLO</span></code> solo per i nomi delle macro<a class="headerlink" href="#nl-9-use-all-caps-for-macro-names-only" title="Link to this heading">¶</a></h3>
<section id="id1895">
<h4>Motivo<a class="headerlink" href="#id1895" title="Link to this heading">¶</a></h4>
<p>Per evitare di confondere le macro con nomi che obbediscono alle regole sullo scope e sul tipo.</p>
</section>
<section id="id1896">
<h4>Esempio<a class="headerlink" href="#id1896" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f()
{
    const int SIZE{1000};  // Bad, use &#39;size&#39; instead
    int v[SIZE];
}
</pre></div>
</div>
</section>
<section id="id1897">
<h4>Nota<a class="headerlink" href="#id1897" title="Link to this heading">¶</a></h4>
<p>In particolare, questo evita di confondere le macro con costanti simboliche non macro (vedere anche <a class="reference internal" href="#Renum-caps"><span class="xref myst">Enum.5: Non usare <code class="docutils literal notranslate"><span class="pre">TUTTO_IN_MAIUSCOLO</span></code> per gli enumeratori</span></a>)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum bad { BAD, WORSE, HORRIBLE }; // BAD
</pre></div>
</div>
</section>
<section id="id1898">
<h4>Imposizione<a class="headerlink" href="#id1898" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare le macro con lettere minuscole</p></li>
<li><p>Segnalare le non-macro <code class="docutils literal notranslate"><span class="pre">TUTTE_IN_MAIUSCOLO</span></code></p></li>
</ul>
</section>
</section>
<section id="nl-10-prefer-underscore-style-names">
<h3><a name="Rl-camel"></a>NL.10: Preferire i nomi in <code class="docutils literal notranslate"><span class="pre">underscore_style</span></code><a class="headerlink" href="#nl-10-prefer-underscore-style-names" title="Link to this heading">¶</a></h3>
<section id="id1899">
<h4>Motivo<a class="headerlink" href="#id1899" title="Link to this heading">¶</a></h4>
<p>L’utilizzo degli underscore per separare le parti dei nomi è lo stile originale del C e del C++ ed è usato nella Libreria Standard del C++.</p>
</section>
<section id="id1900">
<h4>Nota<a class="headerlink" href="#id1900" title="Link to this heading">¶</a></h4>
<p>Questa è regola è un default valido solo se si può scegliere. Spesso, non si può scegliere e si deve seguire, per <a class="reference internal" href="#Rl-name"><span class="xref myst">coerenza</span></a>, uno stile prestabilito. La necessità di coerenza batte il gusto personale.</p>
<p>Questa è una raccomandazione per <a class="reference internal" href="#S-naming"><span class="xref myst">quando non si hanno vincoli o idee migliori</span></a>. Questa regola è stata aggiunta dopo molte richieste di regolamentazione.</p>
</section>
<section id="id1901">
<h4>Esempio<a class="headerlink" href="#id1901" title="Link to this heading">¶</a></h4>
<p><a class="reference external" href="http://www.stroustrup.com/Programming/PPP-style.pdf">Stroustrup</a>: Lo Standard ISO, ma con le maiuscole usate per i propri tipi e i propri concetti:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vector</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">My_map</span></code></p></li>
</ul>
</section>
<section id="id1902">
<h4>Imposizione<a class="headerlink" href="#id1902" title="Link to this heading">¶</a></h4>
<p>Impossibile.</p>
</section>
</section>
<section id="nl-11-make-literals-readable">
<h3><a name="Rl-literals"></a>NL.11: Rendere leggibili i letterali<a class="headerlink" href="#nl-11-make-literals-readable" title="Link to this heading">¶</a></h3>
<section id="id1903">
<h4>Motivo<a class="headerlink" href="#id1903" title="Link to this heading">¶</a></h4>
<p>Leggibilità.</p>
</section>
<section id="id1904">
<h4>Esempio<a class="headerlink" href="#id1904" title="Link to this heading">¶</a></h4>
<p>Usare i separatori dei decimali per evitare lunghe stringhe di numeri</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto c = 299&#39;792&#39;458; // m/s2
auto q2 = 0b0000&#39;1111&#39;0000&#39;0000;
auto ss_number = 123&#39;456&#39;7890;
</pre></div>
</div>
</section>
<section id="id1905">
<h4>Esempio<a class="headerlink" href="#id1905" title="Link to this heading">¶</a></h4>
<p>Usare suffissi letterali dove è necessario chiarire</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto hello = &quot;Hello!&quot;s; // a std::string
auto world = &quot;world&quot;;   // a C-style string
auto interval = 100ms;  // using &lt;chrono&gt;
</pre></div>
</div>
</section>
<section id="id1906">
<h4>Nota<a class="headerlink" href="#id1906" title="Link to this heading">¶</a></h4>
<p>I letterali non devono essere sparpagliati per tutto il codice come <a class="reference internal" href="#Res-magic"><span class="xref myst">«costanti magiche»</span></a>, ma è comunque una buona idea renderli leggibili dove sono definiti. È facile sbagliare con una lunga stringa di interi.</p>
</section>
<section id="id1907">
<h4>Imposizione<a class="headerlink" href="#id1907" title="Link to this heading">¶</a></h4>
<p>Segnalare le lunghe sequenze di cifre. Il problema è definire «lunghe»; forse 7.</p>
</section>
</section>
<section id="nl-15-use-spaces-sparingly">
<h3><a name="Rl-space"></a>NL.15: Usare gli spazi con parsimonia<a class="headerlink" href="#nl-15-use-spaces-sparingly" title="Link to this heading">¶</a></h3>
<section id="id1908">
<h4>Motivo<a class="headerlink" href="#id1908" title="Link to this heading">¶</a></h4>
<p>Troppi spazi ingrossano il testo e distraggono.</p>
</section>
<section id="id1909">
<h4>Esempio, cattivo<a class="headerlink" href="#id1909" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt; map &gt;

int main(int argc, char * argv [ ])
{
    // ...
}
</pre></div>
</div>
</section>
<section id="id1910">
<h4>Esempio<a class="headerlink" href="#id1910" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;map&gt;

int main(int argc, char* argv[])
{
    // ...
}
</pre></div>
</div>
</section>
<section id="id1911">
<h4>Nota<a class="headerlink" href="#id1911" title="Link to this heading">¶</a></h4>
<p>Alcuni IDE hanno le proprie opinioni e aggiungono spazi inopportuni.</p>
<p>Questa è una raccomandazione per <a class="reference internal" href="#S-naming"><span class="xref myst">quando non si hanno vincoli o idee migliori</span></a>. Questa regola è stata aggiunta dopo molte richieste di regolamentazione.</p>
</section>
<section id="id1912">
<h4>Nota<a class="headerlink" href="#id1912" title="Link to this heading">¶</a></h4>
<p>Sono ben accetti gli spazi ben posizionati come un aiuto significativo alla leggibilità. Non esagerare.</p>
</section>
</section>
<section id="nl-16-use-a-conventional-class-member-declaration-order">
<h3><a name="Rl-order"></a>NL.16: Usare un ordine convenzionale per la dichiarazione dei membri di una classe<a class="headerlink" href="#nl-16-use-a-conventional-class-member-declaration-order" title="Link to this heading">¶</a></h3>
<section id="id1913">
<h4>Motivo<a class="headerlink" href="#id1913" title="Link to this heading">¶</a></h4>
<p>Un ordine convenzionale dei membri migliora la leggibilità.</p>
<p>Quando si dichiara una classe, utilizzare il seguente ordine</p>
<ul class="simple">
<li><p>tipi: classi, enum e alias (<code class="docutils literal notranslate"><span class="pre">using</span></code>)</p></li>
<li><p>costruttori, assegnazioni, distruttori</p></li>
<li><p>funzioni</p></li>
<li><p>dati</p></li>
</ul>
<p>Usare <code class="docutils literal notranslate"><span class="pre">public</span></code> prima di <code class="docutils literal notranslate"><span class="pre">protected</span></code> prima di <code class="docutils literal notranslate"><span class="pre">private</span></code>.</p>
<p>Questa è una raccomandazione per <a class="reference internal" href="#S-naming"><span class="xref myst">quando non si hanno vincoli o idee migliori</span></a>. Questa regola è stata aggiunta dopo molte richieste di regolamentazione.</p>
</section>
<section id="id1914">
<h4>Esempio<a class="headerlink" href="#id1914" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {
public:
    // interface
protected:
    // unchecked function for use by derived class implementations
private:
    // implementation details
};
</pre></div>
</div>
</section>
<section id="id1915">
<h4>Esempio<a class="headerlink" href="#id1915" title="Link to this heading">¶</a></h4>
<p>A volte, l’ordine di default dei membri va in conflitto col desiderio di separare l’interfaccia pubblica dai dettagli implementativi. In questi casi, i tipi e le funzioni private si possono inserire con dati privati.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {
public:
    // interface
protected:
    // unchecked function for use by derived class implementations
private:
    // implementation details (types, functions, and data)
};
</pre></div>
</div>
</section>
<section id="id1916">
<h4>Esempio, cattivo<a class="headerlink" href="#id1916" title="Link to this heading">¶</a></h4>
<p>Evitare blocchi multipli di dichiarazioni di un tipo accesso (p.es., <code class="docutils literal notranslate"><span class="pre">public</span></code>) sparpagliati tra i blocchi di dichiarazioni con accessi diversi (p.es. <code class="docutils literal notranslate"><span class="pre">private</span></code>).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {   // bad
public:
    void f();
public:
    int g();
    // ...
};
</pre></div>
</div>
<p>L’utilizzo di macro per dichiarare gruppi di membri spesso porta alla violazione di eventuali regole di ordinamento. Tuttavia, l’utilizzo di macro nasconde comunque ciò che viene espresso.</p>
</section>
<section id="id1917">
<h4>Imposizione<a class="headerlink" href="#id1917" title="Link to this heading">¶</a></h4>
<p>Segnalare le discrepanze dall’ordinamento suggerito. Ci sarà un sacco di vecchio codice che non segue questa regola.</p>
</section>
</section>
<section id="nl-17-use-k-r-derived-layout">
<h3><a name="Rl-knr"></a>NL.17: Usare il layout derivato dal K&amp;R<a class="headerlink" href="#nl-17-use-k-r-derived-layout" title="Link to this heading">¶</a></h3>
<section id="id1918">
<h4>Motivo<a class="headerlink" href="#id1918" title="Link to this heading">¶</a></h4>
<p>Questo è il layout originale del C e del C++. Conserva bene la spaziatura verticale. Distingue bene i diversi costrutti del linguaggio (come le funzioni e le classi).</p>
</section>
<section id="id1919">
<h4>Nota<a class="headerlink" href="#id1919" title="Link to this heading">¶</a></h4>
<p>Nel contesto del C++, questo stile viene spesso chiamato «Stroustrup».</p>
<p>Questa è una raccomandazione per <a class="reference internal" href="#S-naming"><span class="xref myst">quando non si hanno vincoli o idee migliori</span></a>. Questa regola è stata aggiunta dopo molte richieste di regolamentazione.</p>
</section>
<section id="id1920">
<h4>Esempio<a class="headerlink" href="#id1920" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct Cable {
    int x;
    // ...
};

double foo(int x)
{
    if (0 &lt; x) {
        // ...
    }

    switch (x) {
    case 0:
        // ...
        break;
    case amazing:
        // ...
        break;
    default:
        // ...
        break;
    }

    if (0 &lt; x)
        ++x;

    if (x &lt; 0)
        something();
    else
        something_else();

    return some_value;
}
</pre></div>
</div>
<p>Si noti lo spazio tra l”<code class="docutils literal notranslate"><span class="pre">if</span></code> e la <code class="docutils literal notranslate"><span class="pre">(</span></code></p>
</section>
<section id="id1921">
<h4>Nota<a class="headerlink" href="#id1921" title="Link to this heading">¶</a></h4>
<p>Usare righe diverse per ciascuna istruzione, le graffe di un <code class="docutils literal notranslate"><span class="pre">if</span></code>, e il body di un <code class="docutils literal notranslate"><span class="pre">for</span></code>.</p>
</section>
<section id="id1922">
<h4>Nota<a class="headerlink" href="#id1922" title="Link to this heading">¶</a></h4>
<p>La <code class="docutils literal notranslate"><span class="pre">{</span></code> di una <code class="docutils literal notranslate"><span class="pre">class</span></code> e o di una <code class="docutils literal notranslate"><span class="pre">struct</span></code>, <em>non</em> sta su una riga a sé, ma la <code class="docutils literal notranslate"><span class="pre">{</span></code> per una funzione, sì.</p>
</section>
<section id="id1923">
<h4>Nota<a class="headerlink" href="#id1923" title="Link to this heading">¶</a></h4>
<p>Iniziali in maiuscolo per i nomi dei tipi [user-defined] per distinguerli dai tipi della libreria standard.</p>
</section>
<section id="id1924">
<h4>Nota<a class="headerlink" href="#id1924" title="Link to this heading">¶</a></h4>
<p>Non mettere le iniziali delle funzioni in maiuscolo.</p>
</section>
<section id="id1925">
<h4>Imposizione<a class="headerlink" href="#id1925" title="Link to this heading">¶</a></h4>
<p>Se si desidera un’imposizione, si usi un IDE per riformattare.</p>
</section>
</section>
<section id="nl-18-use-c-style-declarator-layout">
<h3><a name="Rl-ptr"></a>NL.18: Usare il layout dei dichiaratori in stile C++<a class="headerlink" href="#nl-18-use-c-style-declarator-layout" title="Link to this heading">¶</a></h3>
<section id="id1926">
<h4>Motivo<a class="headerlink" href="#id1926" title="Link to this heading">¶</a></h4>
<p>Il layout in stile C enfatizza l’uso in espressioni e grammatica, mentre quello in stile C++ porta l’attenzione sui tipi. L’uso negli argomenti delle espressioni non vale per i riferimenti.</p>
</section>
<section id="id1927">
<h4>Esempio<a class="headerlink" href="#id1927" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>T&amp; operator[](size_t);   // OK
T &amp;operator[](size_t);   // just strange
T &amp; operator[](size_t);   // undecided
</pre></div>
</div>
</section>
<section id="id1928">
<h4>Nota<a class="headerlink" href="#id1928" title="Link to this heading">¶</a></h4>
<p>Questa è una raccomandazione per <a class="reference internal" href="#S-naming"><span class="xref myst">quando non si hanno vincoli o idee migliori</span></a>. Questa regola è stata aggiunta dopo molte richieste di regolamentazione.</p>
</section>
<section id="id1929">
<h4>Imposizione<a class="headerlink" href="#id1929" title="Link to this heading">¶</a></h4>
<p>Impossibile di fronte alla storia.</p>
</section>
</section>
<section id="nl-19-avoid-names-that-are-easily-misread">
<h3><a name="Rl-misread"></a>NL.19: Evitare nomi facilmente travisabili<a class="headerlink" href="#nl-19-avoid-names-that-are-easily-misread" title="Link to this heading">¶</a></h3>
<section id="id1930">
<h4>Motivo<a class="headerlink" href="#id1930" title="Link to this heading">¶</a></h4>
<p>Leggibilità. Non tutti hanno schermi e stampanti che rendono facile distinguere tutti i caratteri. Si confondono facilmente le parole scritte in modo simile e leggermente errate.</p>
</section>
<section id="id1931">
<h4>Esempio<a class="headerlink" href="#id1931" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int oO01lL = 6; // bad

int splunk = 7;
int splonk = 8; // bad: splunk and splonk are easily confused
</pre></div>
</div>
</section>
<section id="id1932">
<h4>Imposizione<a class="headerlink" href="#id1932" title="Link to this heading">¶</a></h4>
<p>???</p>
</section>
</section>
<section id="nl-20-don-t-place-two-statements-on-the-same-line">
<h3><a name="Rl-stmt"></a>NL.20: Non mettere due istruzioni sulla stessa riga<a class="headerlink" href="#nl-20-don-t-place-two-statements-on-the-same-line" title="Link to this heading">¶</a></h3>
<section id="id1933">
<h4>Motivo<a class="headerlink" href="#id1933" title="Link to this heading">¶</a></h4>
<p>Leggibilità. È davvero facile non vedere un’istruzione quando ce ne sono diverse in una riga.</p>
</section>
<section id="id1934">
<h4>Esempio<a class="headerlink" href="#id1934" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int x = 7; char* p = 29;    // don&#39;t
int x = 7; f(x);  ++x;      // don&#39;t
</pre></div>
</div>
</section>
<section id="id1935">
<h4>Imposizione<a class="headerlink" href="#id1935" title="Link to this heading">¶</a></h4>
<p>Facile.</p>
</section>
</section>
<section id="nl-21-declare-one-name-only-per-declaration">
<h3><a name="Rl-dcl"></a>NL.21: Dichiarare un (solo) nome per ogni dichiarazione<a class="headerlink" href="#nl-21-declare-one-name-only-per-declaration" title="Link to this heading">¶</a></h3>
<section id="id1936">
<h4>Motivo<a class="headerlink" href="#id1936" title="Link to this heading">¶</a></h4>
<p>Leggibilità. Ridurre al minimo la confusione con la sintassi del dichiaratore.</p>
</section>
<section id="id1937">
<h4>Nota<a class="headerlink" href="#id1937" title="Link to this heading">¶</a></h4>
<p>Per i dettagli si veda <a class="reference internal" href="#Res-name-one"><span class="xref myst">ES.10</span></a>.</p>
</section>
</section>
<section id="nl-25-don-t-use-void-as-an-argument-type">
<h3><a name="Rl-void"></a>NL.25: Non usare <code class="docutils literal notranslate"><span class="pre">void</span></code> come tipo di un argomento<a class="headerlink" href="#nl-25-don-t-use-void-as-an-argument-type" title="Link to this heading">¶</a></h3>
<section id="id1938">
<h4>Motivo<a class="headerlink" href="#id1938" title="Link to this heading">¶</a></h4>
<p>È prolisso ed è necessario solo dove conta la compatibilità col C.</p>
</section>
<section id="id1939">
<h4>Esempio<a class="headerlink" href="#id1939" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(void);   // bad

void g();       // better
</pre></div>
</div>
</section>
<section id="id1940">
<h4>Nota<a class="headerlink" href="#id1940" title="Link to this heading">¶</a></h4>
<p>Anche Dennis Ritchie ritenne che <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">f(void)</span></code> fosse un abominio. Si poteva giustificare questo abominio in C quando i prototipi delle funzioni erano rari quindi vietare questo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int f();
f(1, 2, &quot;weird but valid C89&quot;);   // hope that f() is defined int f(a, b, c) char* c; { /* ... */ }
</pre></div>
</div>
<p>avrebbe causato problemi maggiori, ma non nel 21° secolo e in C++.</p>
</section>
</section>
<section id="nl-26-use-conventional-const-notation">
<h3><a name="Rl-const"></a>NL.26: Usare la notazione convenzionale <code class="docutils literal notranslate"><span class="pre">const</span></code><a class="headerlink" href="#nl-26-use-conventional-const-notation" title="Link to this heading">¶</a></h3>
<section id="id1941">
<h4>Motivo<a class="headerlink" href="#id1941" title="Link to this heading">¶</a></h4>
<p>La notazione convenzionale è più familiare a molti programmatori. Coerente in tantissimo codice esistente.</p>
</section>
<section id="id1942">
<h4>Esempio<a class="headerlink" href="#id1942" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const int x = 7;    // OK
int const y = 9;    // bad

const int *const p = nullptr;   // OK, constant pointer to constant int
int const *const p = nullptr;   // bad, constant pointer to constant int
</pre></div>
</div>
</section>
<section id="id1943">
<h4>Nota<a class="headerlink" href="#id1943" title="Link to this heading">¶</a></h4>
<p>Sappiamo bene che si potrebbero dire che gli esempi «cattivi» sono più logici di quelli contrassegnati con «OK», ma questi confondono più gente, specialmente i principianti che si affidano al materiale didattico fatto con uno stile OK molto più comune e convenzionale.</p>
<p>Come sempre, si ricordi che l’obiettivo di queste regole di denominazione e layout è la coerenza e che l’estetica varia enormemente.</p>
<p>Questa è una raccomandazione per <a class="reference internal" href="#S-naming"><span class="xref myst">quando non si hanno vincoli o idee migliori</span></a>. Questa regola è stata aggiunta dopo molte richieste di regolamentazione.</p>
</section>
<section id="id1944">
<h4>Imposizione<a class="headerlink" href="#id1944" title="Link to this heading">¶</a></h4>
<p>Segnalare l’utilizzo di <code class="docutils literal notranslate"><span class="pre">const</span></code> come suffisso di un tipo.</p>
</section>
</section>
<section id="nl-27-use-a-cpp-suffix-for-code-files-and-h-for-interface-files">
<h3><a name="Rl-file-suffix"></a>NL.27: Usare un suffisso <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> per il file del codice e <code class="docutils literal notranslate"><span class="pre">.h</span></code> per quelli dell’interfaccia<a class="headerlink" href="#nl-27-use-a-cpp-suffix-for-code-files-and-h-for-interface-files" title="Link to this heading">¶</a></h3>
<section id="id1945">
<h4>Motivo<a class="headerlink" href="#id1945" title="Link to this heading">¶</a></h4>
<p>È una convenzione di vecchia data. Ma la coerenza è più importante, quindi se il progetto utilizza qualcos’altro, lo si segua.</p>
</section>
<section id="id1946">
<h4>Nota<a class="headerlink" href="#id1946" title="Link to this heading">¶</a></h4>
<p>Questa convenzione riflette un modello di uso comune: Gli header vengono molto spesso condivisi col C per compilare sia come C++ che C, che tipicamente usa <code class="docutils literal notranslate"><span class="pre">.h</span></code>, ed è più facile dare un nome a tutti gli header <code class="docutils literal notranslate"><span class="pre">.h</span></code> anziché avere diverse estensioni solo per quegli header che si intendono usare col C. D’altra parte, i file delle di implementazione vengono raramente condivisi col C e quindi dovrebbero generalmente essere distinti dai file <code class="docutils literal notranslate"><span class="pre">.c</span></code>, quindi normalmente è meglio dare un nome a tutti i file C++ dell’implementazione con qualcos’altro (come <code class="docutils literal notranslate"><span class="pre">.cpp</span></code>).</p>
<p>I nomi specifici <code class="docutils literal notranslate"><span class="pre">.h</span></code> e <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> non sono richiesti (solo raccomandati per default) e si utilizzano ampiamente altri nomi. Esempi sono <code class="docutils literal notranslate"><span class="pre">.hh</span></code>, <code class="docutils literal notranslate"><span class="pre">.C</span></code> e <code class="docutils literal notranslate"><span class="pre">.cxx</span></code>. Usare questi nomi in modo equivalente. In questo documento, ci si riferisce a <code class="docutils literal notranslate"><span class="pre">.h</span></code> e <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> come abbreviazioni per file header e file di implementazione, anche se l’effettiva estensione potrebbe essere diversa.</p>
<p>L’IDE utilizzato (se se ne usa uno) potrebbe essere più restrittivo sui suffissi.</p>
</section>
<section id="id1947">
<h4>Esempio<a class="headerlink" href="#id1947" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// foo.h:
extern int a;   // a declaration
extern void foo();

// foo.cpp:
int a;   // a definition
void foo() { ++a; }
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">foo.h</span></code> fornisce l’interfaccia a <code class="docutils literal notranslate"><span class="pre">foo.cpp</span></code>. Sarà meglio evitare le variabili globali.</p>
</section>
<section id="id1948">
<h4>Esempio, cattivo<a class="headerlink" href="#id1948" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// foo.h:
int a;   // a definition
void foo() { ++a; }
</pre></div>
</div>
<p>Scrivendo <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;foo.h&gt;</span></code> due volte in un programma, si ottiene un errore di due violazioni regola-della-definizione-singola.</p>
</section>
<section id="id1949">
<h4>Imposizione<a class="headerlink" href="#id1949" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Segnalare nomi di file non-convenzionali.</p></li>
<li><p>Controllare che <code class="docutils literal notranslate"><span class="pre">.h</span></code> e <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> (ed equivalenti) seguano le regole seguenti.</p></li>
</ul>
</section>
</section>
</section>
<section id="faq-answers-to-frequently-asked-questions">
<h2><a name="S-faq"></a>FAQ: Risposte a domande frequenti<a class="headerlink" href="#faq-answers-to-frequently-asked-questions" title="Link to this heading">¶</a></h2>
<p>Questa sezione risponde alle domande più frequenti su queste linee-guida.</p>
<section id="faq-1-what-do-these-guidelines-aim-to-achieve">
<h3><a name="Faq-aims"></a>FAQ.1: Quali sono gli obiettivi di queste linee-guida?<a class="headerlink" href="#faq-1-what-do-these-guidelines-aim-to-achieve" title="Link to this heading">¶</a></h3>
<p>Vedere l”<a href="#S-abstract">inizio pagina</a>. Questo è un progetto open source per manutenere delle linee-guida moderne e autorevoli per la scrittura di codice C++ con l’attuale C++ Standard. Le linee-guida sono progettate per essere moderne, applicabili alle macchine quando possibile e aperte a contributi e ai «fork» in modo che le organizzazioni possano facilmente incorporarle tra le proprie linee-guida aziendali di codifica.</p>
</section>
<section id="faq-2-when-and-where-was-this-work-first-announced">
<h3><a name="Faq-announced"></a>FAQ.2: Quando e dove è stato annunciato questo lavoro per la prima volta?<a class="headerlink" href="#faq-2-when-and-where-was-this-work-first-announced" title="Link to this heading">¶</a></h3>
<p>Fu annunciato da <a class="reference external" href="https://isocpp.org/blog/2015/09/stroustrup-cppcon15-keynote">Bjarne Stroustrup nel suo discorso di apertura del CppCon 2015, «Writing Good C++14»</a>. Si veda anche <a class="reference external" href="https://isocpp.org/blog/2015/09/bjarne-stroustrup-announces-cpp-core-guidelines">il post del blog isocpp.org allegato</a>, e per la motivazione  del tipo e le linee-guida sulla sicurezza della memoria, si veda <a class="reference external" href="https://isocpp.org/blog/2015/09/sutter-cppcon15-day2plenary">l’intervento di Herb Sutter al CppCon 2015, «Writing Good C++14 … Per Default»</a>.</p>
</section>
<section id="faq-3-who-are-the-authors-and-maintainers-of-these-guidelines">
<h3><a name="Faq-maintainers"></a>FAQ.3: Chi sono gli autori e i manutentori di queste linee-guida?<a class="headerlink" href="#faq-3-who-are-the-authors-and-maintainers-of-these-guidelines" title="Link to this heading">¶</a></h3>
<p>Gli autori e manutentori iniziali sono Bjarne Stroustrup e Herb Sutter e le linee-guida finora sono state sviluppate col contributo di esperti del CERN, di Microsoft, di Morgan Stanley e di diverse altre organizzazioni. Al momento del loro rilascio, le linee-guida sono in uno stato «0.6» e i contributi sono ben accetti. Come ha detto Stroustrup nel suo annuncio: «Abbiamo bisogno di aiuto!»</p>
</section>
<section id="faq-4-how-can-i-contribute">
<h3><a name="Faq-contribute"></a>FAQ.4: Come si può contribuire?<a class="headerlink" href="#faq-4-how-can-i-contribute" title="Link to this heading">¶</a></h3>
<p>Leggere <a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a>. Si apprezza l’aiuto volontario!</p>
</section>
<section id="faq-5-how-can-i-become-an-editor-maintainer">
<h3><a name="Faq-maintainer"></a>FAQ.5: Come si diventa editore/manutentore?<a class="headerlink" href="#faq-5-how-can-i-become-an-editor-maintainer" title="Link to this heading">¶</a></h3>
<p>Innanzitutto contribuendo tantissimo e col riconoscimento della coerente qualità dei propri contributi. Leggere <a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a>. Si apprezza l’aiuto volontario!</p>
</section>
<section id="faq-6-have-these-guidelines-been-approved-by-the-iso-c-standards-committee-do-they-represent-the-consensus-of-the-committee">
<h3><a name="Faq-iso"></a>FAQ.6:  Queste linee guida sono state approvate dal comitato si standardizzazione ISO C++? Hanno il consenso del comitato?<a class="headerlink" href="#faq-6-have-these-guidelines-been-approved-by-the-iso-c-standards-committee-do-they-represent-the-consensus-of-the-committee" title="Link to this heading">¶</a></h3>
<p>No. Queste linee-guida sono al di fuori dello standard. Esse hanno lo scopo di servire lo standard ed essere mantenute come linee-guida correnti su come utilizzare efficacemente il C++ Standard. L’obiettivo è quello di mantenerle in sintonia con lo standard man mano che il comitato lo evolve.</p>
</section>
<section id="faq-7-if-these-guidelines-are-not-approved-by-the-committee-why-are-they-under-github-com-isocpp">
<h3><a name="Faq-isocpp"></a>FAQ.7: Se queste linee guida non sono approvate dal comitato, perché stanno in <code class="docutils literal notranslate"><span class="pre">github.com/isocpp</span></code>?<a class="headerlink" href="#faq-7-if-these-guidelines-are-not-approved-by-the-committee-why-are-they-under-github-com-isocpp" title="Link to this heading">¶</a></h3>
<p>Perché <code class="docutils literal notranslate"><span class="pre">isocpp</span></code> è lo «Standard C++ Foundation»; i repository del comitato stanno sotto <a class="reference external" href="https://github.com/cplusplus">github.com/<em>cplusplus</em></a>. Alcune organizzazioni neutrali devono possedere il copyright e la licenza per chiarire che questo non è dominato da nessuna persona o fornitore. L’ente naturale è la Fondazione, che esiste per promuovere l’uso e la comprensione aggiornata del C++ Standard moderno e il lavoro del comitato. Questo segue lo stesso schema che isocpp.org ha fatto per le <a class="reference external" href="https://isocpp.org/faq">C++ FAQ</a>, che iniziarono col lavoro di Bjarne Stroustrup, Marshall Cline, e Herb Sutter e che hanno contribuito allo stesso progetto “open”.</p>
</section>
<section id="faq-8-will-there-be-a-c-98-version-of-these-guidelines-a-c-11-version">
<h3><a name="Faq-cpp98"></a>FAQ.8: Ci sarà una versione per il C++98 di queste Linee-guida? una versione per il C++11?<a class="headerlink" href="#faq-8-will-there-be-a-c-98-version-of-these-guidelines-a-c-11-version" title="Link to this heading">¶</a></h3>
<p>No. Queste linee guida riguardano come utilizzare al meglio il C++ standard moderno e come scrivere codice supponendo che si disponga di un moderno compilatore conforme.</p>
</section>
<section id="faq-9-do-these-guidelines-propose-new-language-features">
<h3><a name="Faq-language-extensions"></a>FAQ.9: Queste linee guida propongono nuove funzionalità del linguaggio?<a class="headerlink" href="#faq-9-do-these-guidelines-propose-new-language-features" title="Link to this heading">¶</a></h3>
<p>No. Queste linee guida riguardano l’uso ottimale del  C++ standard moderno e si limitano a consigliare solo queste funzionalità.</p>
</section>
<section id="faq-10-what-version-of-markdown-do-these-guidelines-use">
<h3><a name="Faq-markdown"></a>FAQ.10: Quale versione di Markdown utilizzano queste linee-guida?<a class="headerlink" href="#faq-10-what-version-of-markdown-do-these-guidelines-use" title="Link to this heading">¶</a></h3>
<p>Questi standard di codifica sono scritti usando <a class="reference external" href="http://commonmark.org">CommonMark</a>, e <code class="docutils literal notranslate"><span class="pre">&lt;a&gt;</span></code> “ancore” HTML.</p>
<p>Si stanno prendendo in considerazione le seguenti estensioni da <a class="reference external" href="https://help.github.com/articles/github-flavored-markdown/">GitHub Flavored Markdown (GFM)</a>:</p>
<ul class="simple">
<li><p>blocchi di codice incorniciato (l’uso coerente dell’indentazione anziché le cornici è oggetto di discussione)</p></li>
<li><p>tabelle (ancora nessuna, ma ce ne sarà bisogno e questo sarà un’estensione della GFM)</p></li>
</ul>
<p>Evitare altri tag HTML ed altre estensioni.</p>
<p>Nota: Non si è ancora coerenti con questo stile.</p>
</section>
<section id="faq-50-what-is-the-gsl-guidelines-support-library">
<h3><a name="Faq-gsl"></a>FAQ.50: Che cos’è la GSL (libreria di supporto alle linee-guida [guidelines support library])?<a class="headerlink" href="#faq-50-what-is-the-gsl-guidelines-support-library" title="Link to this heading">¶</a></h3>
<p>La GSL è un piccolo insieme di tipi e alias descritti in queste linee-guida. Al momento della stesura di questo documento, le specifiche qui contenute sono troppo scarse; si prevede di aggiungere una specifica d’interfaccia in stile WG21 per garantire che le diverse applicazioni vadano d’accordo e di proporla come contributo per un’eventuale standardizzazione, soggetto come sempre a qualunque cosa il comitato decida di accettare/migliorare/modificare/rifiutare.</p>
</section>
<section id="faq-51-is-github-com-microsoft-gsl-the-gsl">
<h3><a name="Faq-msgsl"></a>FAQ.51: <a class="reference external" href="https://github.com/Microsoft/GSL">github.com/Microsoft/GSL</a> è la GSL?<a class="headerlink" href="#faq-51-is-github-com-microsoft-gsl-the-gsl" title="Link to this heading">¶</a></h3>
<p>No. Questa è solo una prima implementazione fornita da Microsoft. Altre implementazioni da parte di altri fornitori sono incoraggiate, così come «fork» e contributi a quella implementazione. Dopo una settimana dalla prima pubblicazione, ne esiste già almeno un’implementazione open-source GPLv3. C’è in programma la produzione di una specifica di interfaccia in stile WG21 per garantire che le diverse applicazioni vadano d’accordo.</p>
</section>
<section id="faq-52-why-not-supply-an-actual-gsl-implementation-in-with-these-guidelines">
<h3><a name="Faq-gsl-implementation"></a>FAQ.52: Perché non fornire una reale implementazione della GSL in/con queste linee-guida?<a class="headerlink" href="#faq-52-why-not-supply-an-actual-gsl-implementation-in-with-these-guidelines" title="Link to this heading">¶</a></h3>
<p>C’è una certa riluttanza nel “benedire” una particolare implementazione perché non si vuol far credere che ce ne sia una sola reprimendo inavvertitamente altre implementazioni. E se queste linee guida includessero un’implementazione, chiunque le avesse fornite potrebbe essere erroneamente considerato eccessivamente influente. Si preferisce seguire il consolidato approccio del comitato, ovvero specificare interfacce, non implementazioni. Contemporaneamente, però, si vuole almeno un’implementazione a disposizione; si spera che ce ne siano molte.</p>
</section>
<section id="faq-53-why-weren-t-the-gsl-types-proposed-through-boost">
<h3><a name="Faq-boost"></a>FAQ.53: Perché i tipi GSL non sono stati proposti tramite Boost?<a class="headerlink" href="#faq-53-why-weren-t-the-gsl-types-proposed-through-boost" title="Link to this heading">¶</a></h3>
<p>Perché si vogliono usare immediatamente e perché sono provvisori in quanto verranno eliminati appena esisteranno dei tipi che soddisfino gli stessi bisogni nella libreria standard.</p>
</section>
<section id="faq-54-has-the-gsl-guidelines-support-library-been-approved-by-the-iso-c-standards-committee">
<h3><a name="Faq-gsl-iso"></a>FAQ.54: La GSL (libreria di supporto delle linee guida) è stata approvata dal comitato ISO dello standard del C++?<a class="headerlink" href="#faq-54-has-the-gsl-guidelines-support-library-been-approved-by-the-iso-c-standards-committee" title="Link to this heading">¶</a></h3>
<p>No. La GSL esiste solo per fornire alcuni tipi e alias che attualmente non sono presenti nella libreria standard. Se il comitato decide sulle versioni standardizzate (di questi o di altri tipi che soddisfano le stessa necessità), si possono rimuovere dalla GSL.</p>
</section>
<section id="faq-55-if-you-re-using-the-standard-types-where-available-why-is-the-gsl-span-char-different-from-the-string-view-in-the-library-fundamentals-1-technical-specification-and-c-17-working-paper-why-not-just-use-the-committee-approved-string-view">
<h3><a name="Faq-gsl-string-view"></a>FAQ.55: Se si stanno usando i tipi standard quando sono disponibili, perché la <code class="docutils literal notranslate"><span class="pre">span&lt;char&gt;</span></code> della GSL è diversa dalla <code class="docutils literal notranslate"><span class="pre">string_view</span></code> del [Library Fundamentals 1 Technical Specification and C++17 Working Paper]? Perché non usare semplicemente la <code class="docutils literal notranslate"><span class="pre">string_view</span></code> approvata dal comitato?<a class="headerlink" href="#faq-55-if-you-re-using-the-standard-types-where-available-why-is-the-gsl-span-char-different-from-the-string-view-in-the-library-fundamentals-1-technical-specification-and-c-17-working-paper-why-not-just-use-the-committee-approved-string-view" title="Link to this heading">¶</a></h3>
<p>L’opinione sulla tassonomia delle viste per la Libreria Standard C++ è stato che «view» significa «read-only», e «span» indica «read/write». Se c’è bisogno solamente di visualizzare a sola lettura dei caratteri che non richiede il controllo dei limiti [bounds-checking] e si sta utilizzando il C++17, si usa <code class="docutils literal notranslate"><span class="pre">std::string_view</span></code>. Altrimenti, se c’è bisogno di una visualizzazione per leggere e scrivere che non richieda il controllo dei limiti [bounds-checking] e si usa il C++20, si usa <code class="docutils literal notranslate"><span class="pre">std::span&lt;char&gt;</span></code>. Altrimenti si usa <code class="docutils literal notranslate"><span class="pre">gsl::span&lt;char&gt;</span></code>.</p>
</section>
<section id="faq-56-is-owner-the-same-as-the-proposed-observer-ptr">
<h3><a name="Faq-gsl-owner"></a>FAQ.56: L”<code class="docutils literal notranslate"><span class="pre">owner</span></code> [proprietario] è lo stesso <code class="docutils literal notranslate"><span class="pre">observer_ptr</span></code> proposto?<a class="headerlink" href="#faq-56-is-owner-the-same-as-the-proposed-observer-ptr" title="Link to this heading">¶</a></h3>
<p>No. L”<code class="docutils literal notranslate"><span class="pre">owner</span></code> possiede, è un alias e si può applicare a qualsiasi tipo di indirezione. Lo scopo principale di <code class="docutils literal notranslate"><span class="pre">observer_ptr</span></code> è quello di indicare un puntatore <em>non</em>-proprietario.</p>
</section>
<section id="faq-57-is-stack-array-the-same-as-the-standard-array">
<h3><a name="Faq-gsl-stack-array"></a>FAQ.57: Lo <code class="docutils literal notranslate"><span class="pre">stack_array</span></code> è lo stesso <code class="docutils literal notranslate"><span class="pre">array</span></code> standard?<a class="headerlink" href="#faq-57-is-stack-array-the-same-as-the-standard-array" title="Link to this heading">¶</a></h3>
<p>No. <code class="docutils literal notranslate"><span class="pre">stack_array</span></code> è garantito che che sia allocato sullo stack. Sebbene uno <code class="docutils literal notranslate"><span class="pre">std::array</span></code> contenga il suo carico [storage] direttamente in se stesso, l’oggetto <code class="docutils literal notranslate"><span class="pre">array</span></code> può essere posto ovunque, anche nell’heap.</p>
</section>
<section id="faq-58-is-dyn-array-the-same-as-vector-or-the-proposed-dynarray">
<h3><a name="Faq-gsl-dyn-array"></a>FAQ.58: Il <code class="docutils literal notranslate"><span class="pre">dyn_array</span></code> è lo stesso di <code class="docutils literal notranslate"><span class="pre">vector</span></code> o del <code class="docutils literal notranslate"><span class="pre">dynarray</span></code> proposto?<a class="headerlink" href="#faq-58-is-dyn-array-the-same-as-vector-or-the-proposed-dynarray" title="Link to this heading">¶</a></h3>
<p>No. <code class="docutils literal notranslate"><span class="pre">dyn_array</span></code> non è ridimensionabile ed è un modo sicuro per far riferimento ad un array di dimensioni fisse allocato sull’heap. A differenza di <code class="docutils literal notranslate"><span class="pre">vector</span></code>, è destinato a sostituire array-<code class="docutils literal notranslate"><span class="pre">new[]</span></code>. A differenza del <code class="docutils literal notranslate"><span class="pre">dynarray</span></code> che è stato proposto al comitato, questo non anticipa la magia del compilatore/linguaggio ad allocarlo in qualche modo sullo stack quando è membro di un oggetto allocato sullo stack; si riferisce semplicemente ad un array «dinamico» o basato sull’heap.</p>
</section>
<section id="faq-59-is-expects-the-same-as-assert">
<h3><a name="Faq-gsl-expects"></a>FAQ.59: <code class="docutils literal notranslate"><span class="pre">Expects</span></code> è lo stesso di <code class="docutils literal notranslate"><span class="pre">assert</span></code>?<a class="headerlink" href="#faq-59-is-expects-the-same-as-assert" title="Link to this heading">¶</a></h3>
<p>No. È un segnaposto a supporto del linguaggio per le precondizioni del contratto.</p>
</section>
<section id="faq-60-is-ensures-the-same-as-assert">
<h3><a name="Faq-gsl-ensures"></a>FAQ.60: <code class="docutils literal notranslate"><span class="pre">Ensures</span></code> è lo stesso di <code class="docutils literal notranslate"><span class="pre">assert</span></code>?<a class="headerlink" href="#faq-60-is-ensures-the-same-as-assert" title="Link to this heading">¶</a></h3>
<p>No. È un segnaposto per il supporto linguistico per i post-condizioni del contratto.</p>
</section>
</section>
<section id="appendix-a-libraries">
<h2><a name="S-libraries"></a>Appendice A: Librerie<a class="headerlink" href="#appendix-a-libraries" title="Link to this heading">¶</a></h2>
<p>Questa sezione elenca le librerie consigliate e ne raccomanda esplicitamente qualcuna.</p>
<p>??? Adatto per la guida generale? Probabilmente no ???</p>
</section>
<section id="appendix-b-modernizing-code">
<h2><a name="S-modernizing"></a>Appendice B: Modernizzazione del codice<a class="headerlink" href="#appendix-b-modernizing-code" title="Link to this heading">¶</a></h2>
<p>Idealmente, si obbedisce a tutte le regole in tutto il codice. Realisticamente, si deve gestire tantissimo codice vecchio:</p>
<ul class="simple">
<li><p>codice scritto prima che le linee-guida fossero formulate e conosciute</p></li>
<li><p>librerie scritte con standard vecchi/diversi</p></li>
<li><p>codice scritto con «insoliti» vincoli</p></li>
<li><p>codice che semplicemente non si è riusciti a modernizzare</p></li>
</ul>
<p>Se si hanno milioni di righe di nuovo codice, l’impulso di «cambiare tutto in una volta» è solitamente poco realistico. Pertanto, c’è bisogno di un modo per modernizzare gradualmente il codice.</p>
<p>L’aggiornamento del codice più vecchio con uno stile moderno può risultare un compito scoraggiante. Spesso, il codice vecchio è sia disordinato (difficile da capire) che correttamente funzionante (per come è stato usato finora). Solitamente, il programmatore originale non c’è più e i casi di test sono incompleti. Il fatto che il codice sia disordinato aumenta notevolmente la fatica necessaria per fare qualsiasi modifica col rischio di introdurre degli errori. Spesso, il vecchio codice disordinato gira lentamente senza motivo perché richiede compilatori datati e non può sfruttare l’hardware più moderno. In molti casi, sarebbe opportuno il supporto di strumenti «modernizzatori» automatici per fare la maggior parte del lavoro di aggiornamento.</p>
<p>Lo scopo della modernizzazione del codice è quello di semplificare aggiungendo nuove funzionalità, facilitarne la manutenzione e migliorarne le prestazioni (throughput o latenza) utilizzando meglio l’hardware moderno. Rendere il codice «bello» o «seguire lo stile moderno» non sono di per sé buoni motivi per cambiare. Ci sono dei rischi impliciti per ogni modifica e costi impliciti (compreso il costo delle opportunità perse) nell’avere un codice obsoleto. La riduzione del costo dev’essere maggiore del rischio.</p>
<p>Ma come fare?</p>
<p>Non esiste un approccio alla modernizzazione del codice. Il modo migliore per farlo dipende dal codice, dalla pressione per gli aggiornamenti, l’esperienza degli sviluppatori e dagli strumenti a disposizione. Ecco alcune idee (molto generali):</p>
<ul class="simple">
<li><p>L’ideale è «aggiornare semplicemente tutto». Questo offre il massimo beneficio nel tempo minimo. Nella maggior parte dei casi, è anche impossibile.</p></li>
<li><p>Si potrebbe convertire il codice per ogni modulo, ma qualsiasi regola che riguarda le interfacce (specie le ABI), come <a class="reference internal" href="#SS-views"><span class="xref myst">l’uso di <code class="docutils literal notranslate"><span class="pre">span</span></code></span></a>, non può essere fatto per ogni modulo, uno per volta.</p></li>
<li><p>Si potrebbe convertire il codice partendo «dal basso» con le regole che si stimano possano offrire maggiori benefici e/o meno problemi.</p></li>
<li><p>Si potrebbe iniziare concentrandosi sulle interfacce, p.es., assicurandosi di non perdere alcuna risorsa e che nessun puntatore venga usato in modo improprio. Si tratterebbe di una serie di modifiche in tutto il codice, ma che probabilmente apporterebbe notevoli vantaggi. Successivamente, si potrà gradualmente modernizzare il codice nascosto dietro quelle interfacce senza modificare il resto.</p></li>
</ul>
<p>Qualunque cosa si scelga di fare, si noti che i vantaggi maggiori derivano dalla massima conformità alle linee-guida. Le linee-guida non sono un insieme casuale di regole slegate tra cui sceglierne casualmente qualcuna, aspettandosi qualche miglioria.</p>
<p>Ci piacerebbe molto conoscere l’esperienza e gli strumenti utilizzati. La modernizzazione potrebbe essere molto più veloce, più semplice e sicura se supportata da tool per l’analisi o anche per la trasformazione.</p>
</section>
<section id="appendix-c-discussion">
<h2><a name="S-discussion"></a>Appendice C: Discussione<a class="headerlink" href="#appendix-c-discussion" title="Link to this heading">¶</a></h2>
<p>Questa sezione contiene materiale supplementare sulle regole e sui gruppi di regole. In particolare, qui vengono presentate ulteriori motivazioni, esempi più estesi e le discussioni sulle alternative.</p>
<section id="discussion-define-and-initialize-data-members-in-the-order-of-member-declaration">
<h3><a name="Sd-order"></a>Discussione: Definire e inizializzare i dati membro secondo l’ordine di dichiarazione dei membri<a class="headerlink" href="#discussion-define-and-initialize-data-members-in-the-order-of-member-declaration" title="Link to this heading">¶</a></h3>
<p>I dati membri vengono sempre inizializzati nell’ordine in cui sono dichiarati nella definizione della classe, quindi si devono scrivere in quell’ordine nell’elenco di inizializzazione del costruttore. Scriverle con un ordine diverso rende semplicemente il codice confuso perché non verrà eseguito nell’ordine visto e questo potrebbe rendere arduo la ricerca di bug dipendenti dall’ordine.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Employee {
    string email, first, last;
public:
    Employee(const char* firstName, const char* lastName);
    // ...
};

Employee::Employee(const char* firstName, const char* lastName)
  : first(firstName),
    last(lastName),
    // BAD: first and last not yet constructed
    email(first + &quot;.&quot; + last + &quot;@acme.com&quot;)
{}
</pre></div>
</div>
<p>In questo esempio, <code class="docutils literal notranslate"><span class="pre">email</span></code> verrà costruita prima di <code class="docutils literal notranslate"><span class="pre">first</span></code> e di <code class="docutils literal notranslate"><span class="pre">last</span></code> perché è dichiarata per prima. Questo vuol dire che il suo costruttore tenterà di usare <code class="docutils literal notranslate"><span class="pre">first</span></code> e <code class="docutils literal notranslate"><span class="pre">last</span></code> troppo presto – non solo prima che siano impostate con i loro valori, ma addirittura prima che vengano costruite.</p>
<p>Se la definizione della classe e il body del costruttore stanno in file separati, con l’andare del tempo l’influenza che ha l’ordine della dichiarazione dei dati membro sulla correttezza del costruttore sarà sempre più difficile da individuare.</p>
<p><strong>Riferimenti</strong>:</p>
<p><a class="reference internal" href="#Cline99"><span class="xref myst">[Cline99]</span></a> §22.03-11, <a class="reference internal" href="#Dewhurst03"><span class="xref myst">[Dewhurst03]</span></a> §52-53, <a class="reference internal" href="#Koenig97"><span class="xref myst">[Koenig97]</span></a> §4, <a class="reference internal" href="#Lakos96"><span class="xref myst">[Lakos96]</span></a> §10.3.5, <a class="reference internal" href="#Meyers97"><span class="xref myst">[Meyers97]</span></a> §13, <a class="reference internal" href="#Murray93"><span class="xref myst">[Murray93]</span></a> §2.1.3, <a class="reference internal" href="#Sutter00"><span class="xref myst">[Sutter00]</span></a> §47</p>
</section>
<section id="discussion-use-of-and-as-initializers">
<h3><a name="Sd-init"></a>Discussione: Uso di <code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">{}</span></code> e <code class="docutils literal notranslate"><span class="pre">()</span></code> come inizializzatori<a class="headerlink" href="#discussion-use-of-and-as-initializers" title="Link to this heading">¶</a></h3>
<p>???</p>
</section>
<section id="discussion-use-a-factory-function-if-you-need-virtual-behavior-during-initialization">
<h3><a name="Sd-factory"></a>Discussione: Usare una funzione factory se c’è bisogno di un «comportamento virtuale» durante l’inizializzazione<a class="headerlink" href="#discussion-use-a-factory-function-if-you-need-virtual-behavior-during-initialization" title="Link to this heading">¶</a></h3>
<p>Se il proprio progetto richiede un [dispatch] virtuale in un costruttore o in un distruttore della classe derivata per funzioni come <code class="docutils literal notranslate"><span class="pre">f</span></code> e <code class="docutils literal notranslate"><span class="pre">g</span></code>, c’è bisogno di altre tecniche, come un post-costruttore – una funzione membro separata che il chiamante deve invocare per completare l’inizializzazione, che possa chiamare tranquillamente <code class="docutils literal notranslate"><span class="pre">f</span></code> e <code class="docutils literal notranslate"><span class="pre">g</span></code> perché è il normale funzionamento delle chiamate virtuali a funzioni membro. Alcune di queste tecniche sono mostrate nei Riferimenti. Ecco un elenco non esaustivo delle possibilità:</p>
<ul class="simple">
<li><p><em>Scaricabarile/rimandabile:</em> Basta documentare che il codice deve chiamare la funzione di post-inizializzazione subito dopo la costruzione di un oggetto.</p></li>
<li><p><em>Post-inizializzazione rimandata:</em> Lo si fa durante la prima chiamata ad una funzione membro. Un flag booleano nella classe base dirà se è già avvenuta la post-costruzione.</p></li>
<li><p><em>Usare la semantica della classe base virtuale:</em> Le regole del linguaggio impongono il costruttore della classe più derivata decida quale costruttore base verrà invocato; lo si può sfruttare a proprio vantaggio. (Cfr. <a class="reference internal" href="#Taligent94"><span class="xref myst">[Taligent94]</span></a>.)</p></li>
<li><p><em>Usare una funzione “factory”:</em> In questo modo si può facilmente forzare un’invocazione obbligatoria di una funzione di post-costruzione.</p></li>
</ul>
<p>Questo è un esempio dell’ultima opzione:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class B {
public:
    B()
    {
        /* ... */
        f(); // BAD: C.82: Don&#39;t call virtual functions in constructors and destructors
        /* ... */
    }

    virtual void f() = 0;
};

class B {
protected:
    class Token {};

public:
    // constructor needs to be public so that make_shared can access it.
    // protected access level is gained by requiring a Token.
    explicit B(Token) { /* ... */ }  // create an imperfectly initialized object
    virtual void f() = 0;

    template&lt;class T&gt;
    static shared_ptr&lt;T&gt; create()    // interface for creating shared objects
    {
        auto p = make_shared&lt;T&gt;(typename T::Token{});
        p-&gt;post_initialize();
        return p;
    }

protected:
    virtual void post_initialize()   // called right after construction
        { /* ... */ f(); /* ... */ } // GOOD: virtual dispatch is safe
    }
};


class D : public B {                 // some derived class
protected:
    class Token {};

public:
    // constructor needs to be public so that make_shared can access it.
    // protected access level is gained by requiring a Token.
    explicit D(Token) : B{ B::Token{} } {}
    void f() override { /* ...  */ };

protected:
    template&lt;class T&gt;
    friend shared_ptr&lt;T&gt; B::create();
};

shared_ptr&lt;D&gt; p = D::create&lt;D&gt;();    // creating a D object
</pre></div>
</div>
<p>Questo progetto richiede il seguente disciplinare:</p>
<ul class="simple">
<li><p>Le classi derivate come la <code class="docutils literal notranslate"><span class="pre">D</span></code> non devono esporre un costruttore richiamabile pubblico. Altrimenti, gli utilizzatori di <code class="docutils literal notranslate"><span class="pre">D</span></code> potrebbero creare oggetti <code class="docutils literal notranslate"><span class="pre">D</span></code> che non richiamino <code class="docutils literal notranslate"><span class="pre">post_initialize</span></code>.</p></li>
<li><p>L’allocazione è limitata all”<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new</span></code>. Tuttavia <code class="docutils literal notranslate"><span class="pre">B</span></code> può sovrascrivere [override] <code class="docutils literal notranslate"><span class="pre">new</span></code> (si vedano i Punti 45 e 46 in <a class="reference internal" href="#SuttAlex05"><span class="xref myst">SuttAlex05</span></a>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">D</span></code> deve definire un costruttore con gli stessi parametri selezionati da <code class="docutils literal notranslate"><span class="pre">B</span></code>. La definizione di vari [overload] di <code class="docutils literal notranslate"><span class="pre">create</span></code> può, tuttavia, attenuare questo problema; e gli [overload] possono anche essere template con i tipi degli argomenti.</p></li>
</ul>
<p>Se i precedenti requisiti sono soddisfatti, il progetto assicura che <code class="docutils literal notranslate"><span class="pre">post_initialize</span></code> sia stata chiamata per ogni oggetto derivato da <code class="docutils literal notranslate"><span class="pre">B</span></code>. <code class="docutils literal notranslate"><span class="pre">post_initialize</span></code> non deve essere virtuale; può tuttavia invocare liberamente funzioni virtuali.</p>
<p>In sintesi, nessuna tecnica di post-costruzione è perfetta. Le tecniche peggiori evitano tutto il problema richiedendo semplicemente al chiamante di invocare manualmente il post-costruttore. Anche i migliori richiedono una diversa sintassi per costruire oggetti (facile da controllare in fase di compilazione) e/o la cooperazione degli autori di classi derivate (impossibile da controllare in fase di compilazione).</p>
<p><strong>Riferimenti</strong>: <a class="reference internal" href="#Alexandrescu01"><span class="xref myst">[Alexandrescu01]</span></a> §3, <a class="reference internal" href="#Boost"><span class="xref myst">[Boost]</span></a>, <a class="reference internal" href="#Dewhurst03"><span class="xref myst">[Dewhurst03]</span></a> §75, <a class="reference internal" href="#Meyers97"><span class="xref myst">[Meyers97]</span></a> §46, <a class="reference internal" href="#Stroustrup00"><span class="xref myst">[Stroustrup00]</span></a> §15.4.3, <a class="reference internal" href="#Taligent94"><span class="xref myst">[Taligent94]</span></a></p>
</section>
<section id="discussion-make-base-class-destructors-public-and-virtual-or-protected-and-non-virtual">
<h3><a name="Sd-dtor"></a>Discussione: Rendere pubblici e virtuali i distruttori della classe base, o protected e non-virtual<a class="headerlink" href="#discussion-make-base-class-destructors-public-and-virtual-or-protected-and-non-virtual" title="Link to this heading">¶</a></h3>
<p>La distruzione dovrebbe avere un comportamento virtuale? Cioè, dovrebbe essere consentita la distruzione tramite un puntatore a una classe <code class="docutils literal notranslate"><span class="pre">base</span></code>? Se sì, allora il distruttore della <code class="docutils literal notranslate"><span class="pre">base</span></code> deve essere pubblico per poter essere richiamabile e virtuale altrimenti chiamandolo si ottiene un comportamento indefinito. Se no, dovrebbe essere protected in modo che solo le classi derivate lo possano invocare nei loro distruttori, e non-virtuale perché non necessita di un comportamento virtuale.</p>
<section id="id1950">
<h4>Esempio<a class="headerlink" href="#id1950" title="Link to this heading">¶</a></h4>
<p>Il caso comune per una classe base è che si vogliono avere classi derivate pubblicamente e quindi il codice chiamante è quasi sicuro che usi qualcosa di simile a <code class="docutils literal notranslate"><span class="pre">shared_ptr&lt;base&gt;</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Base {
public:
    ~Base();                   // BAD, not virtual
    virtual ~Base();           // GOOD
    // ...
};

class Derived : public Base { /* ... */ };

{
    unique_ptr&lt;Base&gt; pb = make_unique&lt;Derived&gt;();
    // ...
} // ~pb invokes correct destructor only when ~Base is virtual
</pre></div>
</div>
<p>In casi più rari, come le classi di sistema [policy], la classe viene usata come classe base per comodità, non per avere un comportamento polimorfico. Si raccomanda che tali distruttori siano protected e non-virtual:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class My_policy {
public:
    virtual ~My_policy();      // BAD, public and virtual
protected:
    ~My_policy();              // GOOD
    // ...
};

template&lt;class Policy&gt;
class customizable : Policy { /* ... */ }; // note: private inheritance
</pre></div>
</div>
</section>
<section id="id1951">
<h4>Nota<a class="headerlink" href="#id1951" title="Link to this heading">¶</a></h4>
<p>Questa semplice linea-guida illustra un problema sottile e riguarda gli usi moderni dell’ereditarietà e dei principi di progettazione object-oriented .</p>
<p>Per una classe base <code class="docutils literal notranslate"><span class="pre">Base</span></code>, il codice chiamante potrebbe tentare di distruggere gli oggetti derivati tramite i puntatori a <code class="docutils literal notranslate"><span class="pre">Base</span></code>, come quando si usa un <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;Base&gt;</span></code>. Se il distruttore di <code class="docutils literal notranslate"><span class="pre">Base</span></code> è pubblico e non virtuale (il default), può essere accidentalmente chiamato su un puntatore che in effetti punta a un oggetto derivato, nel qual caso il comportamento della tentata cancellazione è indefinito. Questo stato di cose ha portato gli standard di codifica più vecchi a imporre un requisito generale secondo cui tutti i distruttori della classe base devono essere virtuali. Questo è eccessivo (anche se è capita spesso); invece, la regola dovrebbe essere quella di rendere virtuali i distruttori della classe base se e solo se sono pubblici.</p>
<p>Scrivere una classe base vuol dire definire un’astrazione (si vedano i punti dal 35 al 37). Si rammenti che per ogni funzione membro che contribuisce a questa astrazione, si deve decidere:</p>
<ul class="simple">
<li><p>Se deve comportarsi virtualmente o meno.</p></li>
<li><p>Se dev’essere pubblicamente disponibile a tutti i chiamanti tramite un puntatore a <code class="docutils literal notranslate"><span class="pre">Base</span></code> o altrimenti essere un dettaglio implementativo interno nascosto.</p></li>
</ul>
<p>Come descritto al punto 39, per una normale funzione membro, la scelta è tra il consentirle di essere chiamata tramite un puntatore a <code class="docutils literal notranslate"><span class="pre">Base</span></code> non-virtualmente (ma forse con un comportamento virtuale se essa invoca funzioni virtuali, come nei pattern «NVI» (Non-Virtual Interface) e il «Template Method»), virtualmente, o niente affatto. Il pattern NVI è una tecnica per evitare le funzioni virtuali pubbliche.</p>
<p>La distruzione può essere vista semplicemente come un’altra operazione, anche se con una semantica speciale che rende pericolose o sbagliate le chiamate non-virtual. Per un distruttore di una classe base, quindi, la scelta è tra il consentirgli di essere chiamato tramite un puntatore a <code class="docutils literal notranslate"><span class="pre">Base</span></code> virtualmente o per niente; il «non-virtualmente» non è un’opzione. Quindi, un distruttore di una classe base è virtuale se può essere chiamato (cioè è pubblico) altrimenti è non-virtual.</p>
<p>Si noti che il pattern NVI non può essere applicato al distruttore perché i costruttori e i distruttori non possono effettuare chiamate virtuali [deep]. (Si vedano i Punti 39 e 55.)</p>
<p>Corollario: Quando si scrive una classe base, scrivere sempre esplicitamente un distruttore, poiché quello generato in modo implicito è pubblico e non-virtual. Si può sempre usare <code class="docutils literal notranslate"><span class="pre">=default</span></code> per l’implementazione se va bene il body di default e si sta solo scrivendo la funzione per darle la giusta visibilità e virtualità.</p>
</section>
<section id="id1952">
<h4>Eccezione<a class="headerlink" href="#id1952" title="Link to this heading">¶</a></h4>
<p>Alcune architetture di componenti (p.es., COM e CORBA) non usano un meccanismo standard per la cancellazione e adottano protocolli diversi per l’eliminazione degli oggetti. Seguire i pattern e gli idiomi locali, adattando questa linea-guida nel modo appropriato.</p>
<p>Si consideri anche questo caso raro:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">B</span></code> è sia una classe base che una classe concreta che può essere istanziata da sola, e quindi il distruttore deve essere pubblico per gli oggetti di <code class="docutils literal notranslate"><span class="pre">B</span></code> per essere creati e distrutti.</p></li>
<li><p>Eppure <code class="docutils literal notranslate"><span class="pre">B</span></code> non ha funzioni virtuali e non è pensata per essere usata polimorficamente, e quindi anche se il distruttore è pubblico non deve essere necessariamente virtuale.</p></li>
</ul>
<p>Quindi, anche se il distruttore deve essere pubblico, può esserci una grande pressione per non renderlo virtuale, poiché come prima funzione virtuale si avrebbe l”[overhead] del tipo a run-time, quando la funzionalità aggiunta non dovrebbe mai essere necessaria.</p>
<p>In questo raro caso, è possibile rendere pubblico e non-virtual il distruttore ma documentare chiaramente che gli oggetti ulteriormente derivati non devono essere usati polimorficamente come <code class="docutils literal notranslate"><span class="pre">B</span></code>. Questo è ciò che è stato fatto con <code class="docutils literal notranslate"><span class="pre">std::unary_function</span></code>.</p>
<p>In generale, tuttavia, evitare le classi di base concrete (cfr. Punto 35). Per esempio, la <code class="docutils literal notranslate"><span class="pre">unary_function</span></code> è un bundle-of-typedefs che non è mai stato concepito per essere istanziato da solo. Non ha davvero senso dargli un distruttore pubblico; un progetto migliore sarebbe quello di seguire il consiglio di questo punto e dargli un distruttore non-virtual protected.</p>
<p><strong>Riferimenti</strong>: <a class="reference internal" href="#SuttAlex05"><span class="xref myst">[SuttAlex05]</span></a> Item 50, <a class="reference internal" href="#Cargill92"><span class="xref myst">[Cargill92]</span></a> pp. 77-79, 207, <a class="reference internal" href="#Cline99"><span class="xref myst">[Cline99]</span></a> §21.06, 21.12-13, <a class="reference internal" href="#Henricson97"><span class="xref myst">[Henricson97]</span></a> pp. 110-114, <a class="reference internal" href="#Koenig97"><span class="xref myst">[Koenig97]</span></a> Chapters 4, 11, <a class="reference internal" href="#Meyers97"><span class="xref myst">[Meyers97]</span></a> §14, <a class="reference internal" href="#Stroustrup00"><span class="xref myst">[Stroustrup00]</span></a> §12.4.2, <a class="reference internal" href="#Sutter02"><span class="xref myst">[Sutter02]</span></a> §27, <a class="reference internal" href="#Sutter04"><span class="xref myst">[Sutter04]</span></a> §18</p>
</section>
</section>
<section id="discussion-usage-of-noexcept">
<h3><a name="Sd-noexcept"></a>Discussione: Uso di noexcept<a class="headerlink" href="#discussion-usage-of-noexcept" title="Link to this heading">¶</a></h3>
<p>???</p>
</section>
<section id="discussion-destructors-deallocation-and-swap-must-never-fail">
<h3><a name="Sd-never-fail"></a>Discussione: Distruttori, de-allocazione, e swap non devono mai fallire<a class="headerlink" href="#discussion-destructors-deallocation-and-swap-must-never-fail" title="Link to this heading">¶</a></h3>
<p>Non consentire mai la segnalazione di un errore da un distruttore, da una funzione di deallocazione di risorse (p.es., <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete</span></code>), o da una  funzione <code class="docutils literal notranslate"><span class="pre">swap</span></code> tramite <code class="docutils literal notranslate"><span class="pre">throw</span></code>. È quasi impossibile scrivere un codice utile se queste operazioni possono fallire e anche se qualcosa va storto non ha quasi senso riprovare. In particolare, i tipi i cui distruttori possono generare un’eccezione sono severamente vietati dall’uso con la Libreria Standard C++. La maggior parte dei distruttori ora sono implicitamente <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> per default.</p>
<section id="id1953">
<h4>Esempio<a class="headerlink" href="#id1953" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Nefarious {
public:
    Nefarious() { /* code that could throw */ }    // ok
    ~Nefarious() { /* code that could throw */ }   // BAD, should not throw
    // ...
};
</pre></div>
</div>
<ol class="arabic">
<li><p>Gli oggetti <code class="docutils literal notranslate"><span class="pre">Nefarious</span></code> sono difficili da usare in sicurezza anche come variabili locali:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> void test(string&amp; s)
 {
     Nefarious n;          // trouble brewing
     string copy = s;      // copy the string
 } // destroy copy and then n
</pre></div>
</div>
<p>Qui, la copia di <code class="docutils literal notranslate"><span class="pre">s</span></code> potrebbe generare un errore [throw], e se va in errore anche il distruttore di <code class="docutils literal notranslate"><span class="pre">n</span></code> il programma terminerà tramite <code class="docutils literal notranslate"><span class="pre">std::terminate</span></code> perché non possono essere propagate due eccezioni contemporaneamente.</p>
</li>
<li><p>Anche le classi basi o con membri <code class="docutils literal notranslate"><span class="pre">Nefarious</span></code> sono difficili da usare in sicurezza, perché i loro distruttori devono invocare il distruttore di <code class="docutils literal notranslate"><span class="pre">Nefarious</span></code> restando al loro volta avvelenati dal suo comportamento:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> class Innocent_bystander {
     Nefarious member;     // oops, poisons the enclosing class&#39;s destructor
     // ...
 };

 void test(string&amp; s)
 {
     Innocent_bystander i;  // more trouble brewing
     string copy2 = s;      // copy the string
 } // destroy copy and then i
</pre></div>
</div>
<p>Qui, se la costruzione di <code class="docutils literal notranslate"><span class="pre">copy2</span></code> genera un errore [throws], si pone lo stesso problema perché ora anche il distruttore di <code class="docutils literal notranslate"><span class="pre">i</span></code> può generare un errore [throw] e se lo farà verrà invocato <code class="docutils literal notranslate"><span class="pre">std::terminate</span></code>.</p>
</li>
<li><p>Non è possibile creare in modo affidabile oggetti <code class="docutils literal notranslate"><span class="pre">Nefarious</span></code> globali o statici:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> static Nefarious n;       // oops, any destructor exception can&#39;t be caught
</pre></div>
</div>
</li>
<li><p>Non è possibile creare in modo affidabile array di <code class="docutils literal notranslate"><span class="pre">Nefarious</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> void test()
 {
     std::array&lt;Nefarious, 10&gt; arr; // this line can std::terminate()
 }
</pre></div>
</div>
<p>Il comportamento delle matrici è indefinito in presenza di distruttori che lanciano eccezioni [throw] perché non esiste un comportamento di rollback ragionevole che si possa escogitare. Basti pensare: Quale codice può generare il compilatore per costruire un <code class="docutils literal notranslate"><span class="pre">arr</span></code> dove, se il costruttore del quarto oggetto va in [throw], il codice deve arrendersi e nella sua modalità di pulizia cerca di chiamare i distruttori degli oggetti già costruiti … e uno o più di tali distruttori va in [throw]? Non esiste una risposta soddisfacente.</p>
</li>
<li><p>Si possono usare gli oggetti <code class="docutils literal notranslate"><span class="pre">Nefarious</span></code> nei contenitori standard:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> std::vector&lt;Nefarious&gt; vec(10);   // this line can std::terminate()
</pre></div>
</div>
<p>La libreria standard proibisce l’esecuzione del [throw] in tutti i distruttori che usa. Non si possono memorizzare oggetti <code class="docutils literal notranslate"><span class="pre">Nefarious</span></code> nei contenitori standard o usarli con qualsiasi altra parte della libreria standard.</p>
</li>
</ol>
</section>
<section id="id1954">
<h4>Nota<a class="headerlink" href="#id1954" title="Link to this heading">¶</a></h4>
<p>Queste sono funzioni chiave che non devono fallire perché sono necessarie per le due operazioni principali nella programmazione transazionale: eseguire il ripristino del lavoro se si verificano problemi durante l’elaborazione e «committare» il lavoro se tutto è ok. Se non è possibile tornare indietro in modo sicuro utilizzando le operazioni «no-fail», è impossibile implementare il rollback «no-fail». Se non è possibile eseguire il commit sicuro dei cambiamenti di stato utilizzando un’operazione «no-fail» (in particolare, ma non solo, <code class="docutils literal notranslate"><span class="pre">swap</span></code>), è impossibile implementare il commit «no-fail».</p>
<p>Si tengano presenti i seguenti consigli e requisiti trovati nel C++ Standard:</p>
<blockquote>
<div><p>Se un distruttore viene chiamato durante lo svolgimento [unwinding] dello stack esce con un’eccezione, viene chiamato terminate (15.5.1). Quindi i distruttori dovrebbero generalmente catturare le eccezioni e non lasciarle propagare al di fuori del distruttore. –<a class="reference internal" href="#Cplusplus03"><span class="xref myst">[C++03]</span></a> §15.2(3)</p>
<p>Nessuna operazione del distruttore definita nella Libreria Standard C++ (compreso il distruttore di qualsiasi tipo utilizzato per creare un’istanza di un template della libreria standard) genererà un’eccezione. –<a class="reference internal" href="#Cplusplus03"><span class="xref myst">[C++03]</span></a> §17.4.4.8(3)</p>
</div></blockquote>
<p>Le funzioni di de-allocazione, compresi in particolare gli «overload» di <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete</span></code> e di <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete[]</span></code>, rientrano nella stessa categoria, poiché anch’esse vengono utilizzate durante la pulizia in generale e durante la gestione delle eccezioni in particolare, per eseguire il «rollback» del lavoro parziale che deve essere annullato. Oltre ai distruttori e alle funzioni di de-allocazione, le comuni tecniche [error-safety] si basano anche su operazioni <code class="docutils literal notranslate"><span class="pre">swap</span></code> che non falliscono mai – in questo caso, non perché vengono utilizzate per implementare un «rollback» garantito, ma perché vengono utilizzate per implementare un «commit» garantito. Ad esempio, ecco un’implementazione idiomatica dell”<code class="docutils literal notranslate"><span class="pre">operator=</span></code> per un tipo <code class="docutils literal notranslate"><span class="pre">T</span></code> che esegue la costruzione copia seguita da una chiamata «no-fail» a <code class="docutils literal notranslate"><span class="pre">swap</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>T&amp; T::operator=(const T&amp; other)
{
    auto temp = other;
    swap(temp);
    return *this;
}
</pre></div>
</div>
<p>(Si veda anche l’Item 56. ???)</p>
<p>Fortunatamente, quando si rilascia una risorsa, il margine di errore è decisamente più piccolo. Se si utilizzano le eccezioni come meccanismo di segnalazione degli errori, assicurarsi che tali funzioni gestiscano tutte le eccezioni e gli altri errori che la loro elaborazione interna potrebbe generare. (Per le eccezioni, semplicemente si racchiude tutto ciò che è sensibile in un blocco <code class="docutils literal notranslate"><span class="pre">try/catch(...)</span></code>). Questo è particolarmente importante perché un distruttore potrebbe essere chiamato in una situazione di crisi, come il fallimento nell’allocare una risorsa di sistema (p.es., memoria, file, lock, porte, finestre o altri oggetti).</p>
<p>Quando si utilizzano le eccezioni come meccanismo di gestione degli errori, documentare sempre questo comportamento dichiarando queste funzioni <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>. (Si veda il Punto 75.)</p>
<p><strong>Riferimenti</strong>: <a class="reference internal" href="#SuttAlex05"><span class="xref myst">[SuttAlex05]</span></a> Item 51; <a class="reference internal" href="#Cplusplus03"><span class="xref myst">[C++03]</span></a> §15.2(3), §17.4.4.8(3), <a class="reference internal" href="#Meyers96"><span class="xref myst">[Meyers96]</span></a> §11, <a class="reference internal" href="#Stroustrup00"><span class="xref myst">[Stroustrup00]</span></a> §14.4.7, §E.2-4, <a class="reference internal" href="#Sutter00"><span class="xref myst">[Sutter00]</span></a> §8, §16, <a class="reference internal" href="#Sutter02"><span class="xref myst">[Sutter02]</span></a> §18-19</p>
</section>
</section>
<section id="define-copy-move-and-destroy-consistently">
<h3><a name="Sd-consistent"></a>Definire la copia, lo spostamento e la distruzione in modo coerente<a class="headerlink" href="#define-copy-move-and-destroy-consistently" title="Link to this heading">¶</a></h3>
<section id="id1955">
<h4>Motivo<a class="headerlink" href="#id1955" title="Link to this heading">¶</a></h4>
<p>???</p>
</section>
<section id="id1956">
<h4>Nota<a class="headerlink" href="#id1956" title="Link to this heading">¶</a></h4>
<p>Se si definisce un costruttore copia, si deve anche definire un operatore di assegnazione copia.</p>
</section>
<section id="id1957">
<h4>Nota<a class="headerlink" href="#id1957" title="Link to this heading">¶</a></h4>
<p>Se si definisce un costruttore di spostamento [move], si deve anche definire un operatore di assegnazione move.</p>
</section>
<section id="id1958">
<h4>Esempio<a class="headerlink" href="#id1958" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {
public:
    X(const X&amp;) { /* stuff */ }

    // BAD: failed to also define a copy assignment operator

    X(x&amp;&amp;) noexcept { /* stuff */ }

    // BAD: failed to also define a move assignment operator

    // ...
};

X x1;
X x2 = x1; // ok
x2 = x1;   // pitfall: either fails to compile, or does something suspicious
</pre></div>
</div>
<p>Se si definisce un distruttore, non è necessario utilizzare l’operazione di copia o spostamento generata dal compilatore; probabilmente è necessario definire o sopprimere la copia e/o il [move].</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {
    HANDLE hnd;
    // ...
public:
    ~X() { /* custom stuff, such as closing hnd */ }
    // suspicious: no mention of copying or moving -- what happens to hnd?
};

X x1;
X x2 = x1; // pitfall: either fails to compile, or does something suspicious
x2 = x1;   // pitfall: either fails to compile, or does something suspicious
</pre></div>
</div>
<p>Se si definisce la copia e qualsiasi base o membro ha un tipo che definisce un’operazione di spostamento, è necessario definire anche un’operazione di spostamento.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class X {
    string s; // defines more efficient move operations
    // ... other data members ...
public:
    X(const X&amp;) { /* stuff */ }
    X&amp; operator=(const X&amp;) { /* stuff */ }

    // BAD: failed to also define a move construction and move assignment
    // (why wasn&#39;t the custom &quot;stuff&quot; repeated here?)
};

X test()
{
    X local;
    // ...
    return local;  // pitfall: will be inefficient and/or do the wrong thing
}
</pre></div>
</div>
<p>Se si definisce o un costruttore copia, un operatore di assegnazione copia o un distruttore, probabilmente è necessario definire gli altri.</p>
</section>
<section id="id1959">
<h4>Nota<a class="headerlink" href="#id1959" title="Link to this heading">¶</a></h4>
<p>Se si deve definire una di queste cinque funzioni, significa che serve qualcosa in più del comportamento di default – e che le cinque sono asimmetricamente correlate. Ecco come:</p>
<ul class="simple">
<li><p>Se si scrive/disabilita o il costruttore copia o l’operatore di assegnazione copia, c’è probabilmente bisogno di fare lo stesso per l’altra: se uno fa un lavoro «speciale», probabilmente dovrebbe esserlo anche l’altro perché le due funzioni dovrebbero avere effetti simili. (Si veda il Punto 53, che sviluppa questo punto da solo).</p></li>
<li><p>Se si scrivono esplicitamente le funzioni di copia, probabilmente è necessario scrivere il distruttore: Se il lavoro «speciale» nel costruttore copia consiste anche nell’allocare o duplicare qualche risorsa (p.es., memoria, file, socket), si devono disallocarle nel distruttore.</p></li>
<li><p>Se si scrive esplicitamente il distruttore, probabilmente si deve esplicitamente scrivere o disabilitare la copia: Se si deve scrivere un distruttore un po” più complicato, spesso è perché si deve manualmente rilasciare una risorsa contenuta nell’oggetto. Se è così, è probabile che tali risorse richiedano un’attenta duplicazione e quindi si deve fare attenzione a come gli oggetti vengono copiati e assegnati, oppure disabilitare completamente la copia.</p></li>
</ul>
<p>In molti casi, mantenere correttamente le risorse incapsulate utilizzando il oggetti «proprietari» RAII «, può eliminare la necessità di scrivere da soli queste operazioni. (Si veda il Punto 13.)</p>
<p>Preferire i membri speciali generati dal compilatore (compreso <code class="docutils literal notranslate"><span class="pre">=default</span></code>); solo questi possono essere classificati come «banali», e almeno uno dei principali fornitori della libreria standard ottimizza le classi con membri speciali banali. È probabile che ciò diventi una pratica comune.</p>
<p><strong>Eccezioni</strong>: Quando una delle funzioni speciali viene dichiarata solo per renderle non-public o virtuali, ma senza una semantica speciale, ciò non implica che le altre siano necessarie. In rari casi, le classi che hanno membri di tipi strani (come i riferimenti membro) non sono un’eccezione perché hanno una semantica di copia peculiare. In una classe che contiene un riferimento, è probabilmente necessario scrivere il costruttore copia e l’operatore di assegnazione, ma il distruttore predefinito fa già la cosa giusta. (Si noti che l’utilizzo di un riferimento membro è quasi sempre sbagliato).</p>
<p><strong>Riferimenti</strong>: <a class="reference internal" href="#SuttAlex05"><span class="xref myst">[SuttAlex05]</span></a> Item 52; <a class="reference internal" href="#Cline99"><span class="xref myst">[Cline99]</span></a> §30.01-14, <a class="reference internal" href="#Koenig97"><span class="xref myst">[Koenig97]</span></a> §4, <a class="reference internal" href="#Stroustrup00"><span class="xref myst">[Stroustrup00]</span></a> §5.5, §10.4, <a class="reference internal" href="#SuttHysl04b"><span class="xref myst">[SuttHysl04b]</span></a></p>
<p>Riepilogo delle regole sulla gestione delle risorse:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Cr-safety"><span class="xref myst">Fornire una robusta sicurezza alle risorse; cioè, mai perdere [leak] niente che si ritenga possa essere una risorsa</span></a></p></li>
<li><p><a class="reference internal" href="#Cr-never"><span class="xref myst">Mai restituire o generare un’eccezione [throw] mentre si tiene una risorsa non di proprietà di un handle</span></a></p></li>
<li><p><a class="reference internal" href="#Cr-raw"><span class="xref myst">Un puntatore «semplice» o un riferimento non è mai un handle di una risorsa</span></a></p></li>
<li><p><a class="reference internal" href="#Cr-outlive"><span class="xref myst">Non lasciare mai che un puntatore sopravviva all’oggetto a cui punta</span></a></p></li>
<li><p><a class="reference internal" href="#Cr-templates"><span class="xref myst">Usare i template per esprimere i contenitori (ed altri gestori di risorse))</span></a></p></li>
<li><p><a class="reference internal" href="#Cr-value-return"><span class="xref myst">Restituire i contenitori per valore (basandosi, per efficienza, sullo spostamento [move] o sull’elisione della copia)</span></a></p></li>
<li><p><a class="reference internal" href="#Cr-handle"><span class="xref myst">Se una classe è un handle di una risorsa, necessita di un costruttore, un distruttore, e le operazioni di copia e/o spostamento</span></a></p></li>
<li><p><a class="reference internal" href="#Cr-list"><span class="xref myst">Se una classe è un contenitore, fornirle un costruttore con un elenco-di-inizializzatori</span></a></p></li>
</ul>
</section>
<section id="discussion-provide-strong-resource-safety-that-is-never-leak-anything-that-you-think-of-as-a-resource">
<h4><a name="Cr-safety"></a>Discussione: Fornire una robusta sicurezza alle risorse; cioè, mai perdere [leak] niente che si ritenga possa essere una risorsa<a class="headerlink" href="#discussion-provide-strong-resource-safety-that-is-never-leak-anything-that-you-think-of-as-a-resource" title="Link to this heading">¶</a></h4>
<section id="id1960">
<h5>Motivo<a class="headerlink" href="#id1960" title="Link to this heading">¶</a></h5>
<p>Prevenire i leak. I leak possono provocare la degradazione delle prestazioni, errori misteriosi, crash di sistema, e violazioni della sicurezza.</p>
<p><strong>Formulazione alternativa</strong>: Fare in modo che ogni risorsa rappresentata come un oggetto di qualche classe gestisca il proprio ciclo di vita.</p>
</section>
<section id="id1961">
<h5>Esempio<a class="headerlink" href="#id1961" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;class T&gt;
class Vector {
private:
    T* elem;   // sz elements on the free store, owned by the class object
    int sz;
    // ...
};
</pre></div>
</div>
<p>Questa classe è un gestore di risorsa. Gestisce il ciclo di vita delle <code class="docutils literal notranslate"><span class="pre">T</span></code>. Per farlo, <code class="docutils literal notranslate"><span class="pre">Vector</span></code> deve definire o cancellare <a class="reference internal" href="#Rc-five"><span class="xref myst">l’insieme delle operazioni speciali</span></a> (costruttori, un distruttore, ecc.).</p>
</section>
<section id="id1962">
<h5>Esempio<a class="headerlink" href="#id1962" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>??? &quot;odd&quot; non-memory resource ???
</pre></div>
</div>
</section>
<section id="id1963">
<h5>Imposizione<a class="headerlink" href="#id1963" title="Link to this heading">¶</a></h5>
<p>La tecnica base per evitare i leak consiste nell’avere ogni risorsa posseduta da un gestore della risorsa con un distruttore adatto. Un «checker» potrebbe trovare dei «semplici <code class="docutils literal notranslate"><span class="pre">new</span></code>». Dato un elenco di funzioni di allocazione in stile C (p.es., <code class="docutils literal notranslate"><span class="pre">fopen()</span></code>), un «checker» potrebbe anche trovare usi che non sono gestiti da un handle della risorsa. In generale, i «puntatori semplici» si possono vedere con sospetto, segnalati e/o analizzati. Un elenco completo delle risorse non può essere generato senza un input umano (la definizione di «una risorsa» è necessariamente troppo generale), ma si può «parametrizzare» un tool con un elenco di risorse.</p>
</section>
</section>
<section id="discussion-never-return-or-throw-while-holding-a-resource-not-owned-by-a-handle">
<h4><a name="Cr-never"></a>Discussione: Mai restituire o generare un’eccezione [throw] mentre si tiene una risorsa non di proprietà di un handle<a class="headerlink" href="#discussion-never-return-or-throw-while-holding-a-resource-not-owned-by-a-handle" title="Link to this heading">¶</a></h4>
<section id="id1964">
<h5>Motivo<a class="headerlink" href="#id1964" title="Link to this heading">¶</a></h5>
<p>Ci sarebbe un leak.</p>
</section>
<section id="id1965">
<h5>Esempio<a class="headerlink" href="#id1965" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int i)
{
    FILE* f = fopen(&quot;a file&quot;, &quot;r&quot;);
    ifstream is { &quot;another file&quot; };
    // ...
    if (i == 0) return;
    // ...
    fclose(f);
}
</pre></div>
</div>
<p>Se <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">0</span></code> l’handle del file per <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">file</span></code> provoca un leak. D’altra parte, l”<code class="docutils literal notranslate"><span class="pre">ifstream</span></code> per <code class="docutils literal notranslate"><span class="pre">another</span> <span class="pre">file</span></code> verrà chiuderà correttamente il suo file (dopo la distruzione). Se è necessario utilizzare un puntatore esplicito, anziché un handle della risorsa con una semantica specifica, usare un <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> o uno <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> con un delete personalizzato:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int i)
{
    unique_ptr&lt;FILE, int(*)(FILE*)&gt; f(fopen(&quot;a file&quot;, &quot;r&quot;), fclose);
    // ...
    if (i == 0) return;
    // ...
}
</pre></div>
</div>
<p>Meglio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void f(int i)
{
    ifstream input {&quot;a file&quot;};
    // ...
    if (i == 0) return;
    // ...
}
</pre></div>
</div>
</section>
<section id="id1966">
<h5>Imposizione<a class="headerlink" href="#id1966" title="Link to this heading">¶</a></h5>
<p>Un checker deve considerare sospetti tutti i «puntatori semplici». Probabilmente un checker deve far riferimento ad un elenco delle risorse fornito da un umano. Come inizio [starters], sappiamo dei contenitori della libreria standard, <code class="docutils literal notranslate"><span class="pre">string</span></code> e degli smart pointer. L’utilizzo di <code class="docutils literal notranslate"><span class="pre">span</span></code> e <code class="docutils literal notranslate"><span class="pre">string_view</span></code> dovrebbe aiutare molto (non sono handle di risorse).</p>
</section>
</section>
<section id="discussion-a-raw-pointer-or-reference-is-never-a-resource-handle">
<h4><a name="Cr-raw"></a>Discussione: Un puntatore «semplice» o un riferimento non è mai un handle di una risorsa<a class="headerlink" href="#discussion-a-raw-pointer-or-reference-is-never-a-resource-handle" title="Link to this heading">¶</a></h4>
<section id="id1967">
<h5>Motivo<a class="headerlink" href="#id1967" title="Link to this heading">¶</a></h5>
<p>Essere in grado di distinguere i proprietari dalle viste.</p>
</section>
<section id="id1968">
<h5>Nota<a class="headerlink" href="#id1968" title="Link to this heading">¶</a></h5>
<p>Questo è indipendente da come si «scrive» il puntatore: <code class="docutils literal notranslate"><span class="pre">T*</span></code>, <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">Ptr&lt;T&gt;</span></code> e <code class="docutils literal notranslate"><span class="pre">Range&lt;T&gt;</span></code> non sono proprietari [owner].</p>
</section>
</section>
<section id="discussion-never-let-a-pointer-outlive-the-object-it-points-to">
<h4><a name="Cr-outlive"></a>Discussione: Non lasciare mai che un puntatore sopravviva all’oggetto a cui punta<a class="headerlink" href="#discussion-never-let-a-pointer-outlive-the-object-it-points-to" title="Link to this heading">¶</a></h4>
<section id="id1969">
<h5>Motivo<a class="headerlink" href="#id1969" title="Link to this heading">¶</a></h5>
<p>Per evitare errori estremamente difficili da trovare. De-referenziare puntatore del genere porta a un comportamento indefinito e potrebbe violare il sistema dei tipi.</p>
</section>
<section id="id1970">
<h5>Esempio<a class="headerlink" href="#id1970" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>string* bad()   // really bad
{
    vector&lt;string&gt; v = { &quot;This&quot;, &quot;will&quot;, &quot;cause&quot;, &quot;trouble&quot;, &quot;!&quot; };
    // leaking a pointer into a destroyed member of a destroyed object (v)
    return &amp;v[0];
}

void use()
{
    string* p = bad();
    vector&lt;int&gt; xx = {7, 8, 9};
    // undefined behavior: x might not be the string &quot;This&quot;
    string x = *p;
    // undefined behavior: we don&#39;t know what (if anything) is allocated a location p
    *p = &quot;Evil!&quot;;
}
</pre></div>
</div>
<p>Le <code class="docutils literal notranslate"><span class="pre">string</span></code>he di <code class="docutils literal notranslate"><span class="pre">v</span></code> vengono distrutte all’uscita da <code class="docutils literal notranslate"><span class="pre">bad()</span></code> e così anche lo stesso <code class="docutils literal notranslate"><span class="pre">v</span></code>. Il puntatore restituito punta alla memoria non allocata nel free store. Questa memoria (puntata da <code class="docutils literal notranslate"><span class="pre">p</span></code>) potrebbe essere stata riallocata al momento dell’esecuzione di <code class="docutils literal notranslate"><span class="pre">*p</span></code>. Potrebbe non esserci alcuna <code class="docutils literal notranslate"><span class="pre">string</span></code> da leggere e una scrittura in <code class="docutils literal notranslate"><span class="pre">p</span></code> potrebbe facilmente corrompere oggetti di tipo diverso.</p>
</section>
<section id="id1971">
<h5>Imposizione<a class="headerlink" href="#id1971" title="Link to this heading">¶</a></h5>
<p>Molti compilatori già allertano per i casi semplici ed hanno le informazioni per fare altro. Si esamini qualsiasi puntatore restituito da una funzione sospetta. Usare i contenitori, gli handle delle risorse e le viste (p.es., <code class="docutils literal notranslate"><span class="pre">span</span></code> noti per non essere handle di risorse) per ridurre il numero di casi da esaminare. Per cominciare, si esamini ogni classe con un distruttore come handle di risorsa.</p>
</section>
</section>
<section id="discussion-use-templates-to-express-containers-and-other-resource-handles">
<h4><a name="Cr-templates"></a>Discussione: Usare i template per esprimere i contenitori (ed altri gestori di risorse)<a class="headerlink" href="#discussion-use-templates-to-express-containers-and-other-resource-handles" title="Link to this heading">¶</a></h4>
<section id="id1972">
<h5>Motivo<a class="headerlink" href="#id1972" title="Link to this heading">¶</a></h5>
<p>Per fornire staticamente una gestione di elementi [type-safe].</p>
</section>
<section id="id1973">
<h5>Esempio<a class="headerlink" href="#id1973" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt; class Vector {
    // ...
    T* elem;   // point to sz elements of type T
    int sz;
};
</pre></div>
</div>
</section>
</section>
<section id="discussion-return-containers-by-value-relying-on-move-or-copy-elision-for-efficiency">
<h4><a name="Cr-value-return"></a>Discussione: Restituire i contenitori per valore (basandosi, per efficienza, sullo spostamento [move] o sull’elisione della copia)<a class="headerlink" href="#discussion-return-containers-by-value-relying-on-move-or-copy-elision-for-efficiency" title="Link to this heading">¶</a></h4>
<section id="id1974">
<h5>Motivo<a class="headerlink" href="#id1974" title="Link to this heading">¶</a></h5>
<p>Semplificare il codice ed eliminare la necessità di una gestione esplicita della memoria. Portare un oggetto in uno scope più esterno, prolungandone così la durata.</p>
<p><strong>Si veda anche</strong>: <a class="reference internal" href="#Rf-out"><span class="xref myst">F.20, l’argomento generale sulla «restituzione» dei valori in output</span></a></p>
</section>
<section id="id1975">
<h5>Esempio<a class="headerlink" href="#id1975" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vector&lt;int&gt; get_large_vector()
{
    return ...;
}

auto v = get_large_vector(); //  return by value is ok, most modern compilers will do copy elision
</pre></div>
</div>
</section>
<section id="id1976">
<h5>Eccezione<a class="headerlink" href="#id1976" title="Link to this heading">¶</a></h5>
<p>Si vedano le Eccezioni in <a class="reference internal" href="#Rf-out"><span class="xref myst">F.20</span></a>.</p>
</section>
<section id="id1977">
<h5>Imposizione<a class="headerlink" href="#id1977" title="Link to this heading">¶</a></h5>
<p>Controllare i puntatori e i riferimenti restituiti dalle funzioni e vedere se vengono assegnati a handle di risorse (p.es., a un <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code>).</p>
</section>
</section>
<section id="discussion-if-a-class-is-a-resource-handle-it-needs-a-constructor-a-destructor-and-copy-and-or-move-operations">
<h4><a name="Cr-handle"></a>Discussione: Se una classe è un handle di una risorsa, necessita di un costruttore, un distruttore, e le operazioni di copia e/o spostamento<a class="headerlink" href="#discussion-if-a-class-is-a-resource-handle-it-needs-a-constructor-a-destructor-and-copy-and-or-move-operations" title="Link to this heading">¶</a></h4>
<section id="id1978">
<h5>Motivo<a class="headerlink" href="#id1978" title="Link to this heading">¶</a></h5>
<p>Fornire il controllo completo della durata della risorsa. Fornire un insieme coerente di operazioni sulla risorsa.</p>
</section>
<section id="id1979">
<h5>Esempio<a class="headerlink" href="#id1979" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>??? Messing with pointers
</pre></div>
</div>
</section>
<section id="id1980">
<h5>Nota<a class="headerlink" href="#id1980" title="Link to this heading">¶</a></h5>
<p>Se tutti i membri sono handle di risorse, affidarsi, ove possibile, alle operazioni speciali di default.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt; struct Named {
    string name;
    T value;
};
</pre></div>
</div>
<p>Ora <code class="docutils literal notranslate"><span class="pre">Named</span></code> ha un costruttore di default, un distruttore e delle efficienti operazioni di copia e spostamento, purché le abbia <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
</section>
<section id="id1981">
<h5>Imposizione<a class="headerlink" href="#id1981" title="Link to this heading">¶</a></h5>
<p>In generale, un tool non può sapere se una classe è un handle di una risorsa. Tuttavia, se una classe ha alcune delle <a class="reference internal" href="#SS-ctor"><span class="xref myst">operazioni di default</span></a>, dovrebbe avere tutto e se la classe ha un membro che è un handle di risorsa, dovrebbe essere considerata come handle di risorse.</p>
</section>
</section>
<section id="discussion-if-a-class-is-a-container-give-it-an-initializer-list-constructor">
<h4><a name="Cr-list"></a>Discussione: Se una classe è un contenitore, fornirle un costruttore con un elenco-di-inizializzatori<a class="headerlink" href="#discussion-if-a-class-is-a-container-give-it-an-initializer-list-constructor" title="Link to this heading">¶</a></h4>
<section id="id1982">
<h5>Motivo<a class="headerlink" href="#id1982" title="Link to this heading">¶</a></h5>
<p>Normalmente si ha bisogno di un insieme iniziale di elementi.</p>
</section>
<section id="id1983">
<h5>Esempio<a class="headerlink" href="#id1983" title="Link to this heading">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>template&lt;typename T&gt; class Vector {
public:
    Vector(std::initializer_list&lt;T&gt;);
    // ...
};

Vector&lt;string&gt; vs { &quot;Nygaard&quot;, &quot;Ritchie&quot; };
</pre></div>
</div>
</section>
<section id="id1984">
<h5>Imposizione<a class="headerlink" href="#id1984" title="Link to this heading">¶</a></h5>
<p>Quando una classe è un contenitore? ???</p>
</section>
</section>
</section>
</section>
<section id="appendix-d-supporting-tools">
<h2><a name="S-tools"></a>Appendice D: Tool di supporto<a class="headerlink" href="#appendix-d-supporting-tools" title="Link to this heading">¶</a></h2>
<p>Questa sezione contiene un elenco di tool che supportano direttamente l’adozione delle «C++ Core Guidelines». Questo non intende essere un elenco esaustivo di strumenti utili alla scrittura di buon codice C++. Se un tool è specificatamente progettato per supportare e collegarsi alle «C++ Core Guidelines» è candidato per l’inclusione.</p>
<section id="tools-clang-tidy">
<h3><a name="St-clangtidy"></a>Tools: <a class="reference external" href="http://clang.llvm.org/extra/clang-tidy/checks/list.html">Clang-tidy</a><a class="headerlink" href="#tools-clang-tidy" title="Link to this heading">¶</a></h3>
<p>Clang-tidy ha una serie di regole che specificamente impongono le «C++ Core Guidelines». Queste regole vengono chiamate nel pattern <code class="docutils literal notranslate"><span class="pre">cppcoreguidelines-*</span></code>.</p>
</section>
<section id="tools-cppcorecheck">
<h3><a name="St-cppcorecheck"></a>Tools: <a class="reference external" href="https://docs.microsoft.com/en-us/visualstudio/code-quality/using-the-cpp-core-guidelines-checkers">CppCoreCheck</a><a class="headerlink" href="#tools-cppcorecheck" title="Link to this heading">¶</a></h3>
<p>L’analisi del codice C++ del compilatore Microsoft contiene una serie di regole specificamente finalizzate all’applicazione delle «C++ Core Guidelines».</p>
</section>
</section>
<section id="glossary">
<h2><a name="S-glossary"></a>Glossario<a class="headerlink" href="#glossary" title="Link to this heading">¶</a></h2>
<p>Una definizione relativamente informale dei termini usati nelle linee-guida (basato sul glossario in <a class="reference external" href="http://www.stroustrup.com/programming.html">Programming: Principles and Practice using C++</a>)</p>
<p>Maggiori informazioni su molti argomenti riguardo al C++ si possono trovare sul sito della <a class="reference external" href="https://isocpp.org">Standard C++ Foundation</a>.</p>
<ul class="simple">
<li><p><em>ABI</em>: Application Binary Interface, una specifica per una data piattaforma hardware combinata col sistema operativo. In contrapposizione alle API.</p></li>
<li><p><em>classe astratta</em>: una classe che non può essere usata direttamente per creare oggetti; spesso usata per definire un’interfaccia per le classi derivate. Una classe viene resa astratta avendo una funzione virtuale pura o solo costruttori protetti.</p></li>
<li><p><em>astrazione</em>: una descrizione che ignora in modo selettivo o deliberato (nasconde) dei dettagli (p.es., i dettagli implementativi); ignoranza selettiva.</p></li>
<li><p><em>indirizzo</em>: un valore che consente di trovare un oggetto nella memoria del computer.</p></li>
<li><p><em>algoritmo</em>: una procedura o una formula per risolvere un problema; una serie finita di passaggi computazionali per produrre un risultato.</p></li>
<li><p><em>alias</em>: un modo alternativo per riferirsi ad un oggetto; spesso un nome, un puntatore o un riferimento.</p></li>
<li><p><em>API</em>: Application Programming Interface, un insieme di funzioni che formano la comunicazione tra i vari componenti software. In contrapposizione alla ABI.</p></li>
<li><p><em>applicazione</em>: un programma o un insieme di programmi che viene considerato un’entità dagli utenti.</p></li>
<li><p><em>approssimazione</em>: qualcosa (p.es., un valore o un progetto) che è quasi (un valore o un progetto) perfetto o ideale. Spesso un’approssimazione è il risultato di un compromesso con l’ideale.</p></li>
<li><p><em>argomento</em>: un valore passato ad una funzione o a un template, in cui vi si accede tramite un parametro.</p></li>
<li><p><em>array</em>: una sequenza omogenea di elementi, solitamente numerati, p.es., <code class="docutils literal notranslate"><span class="pre">[0:max)</span></code>.</p></li>
<li><p><em>asserzione</em>: un’istruzione inserita in un programma per affermare (asserire) che qualcosa deve sempre essere vero in questo punto del programma.</p></li>
<li><p><em>classe base</em>: un tipo da cui si intende derivare (p.es., ha una funzione non-<code class="docutils literal notranslate"><span class="pre">final</span></code> virtual function), , e gli oggetti di tale tipo si devono usare solo indirettamente (p.es., tramite puntatore). [In termini rigorosi, «classe base» potrebbe essere definita come «qualcosa da cui derivare» ma stiamo specificando in termini di intenti del progettista della classe.] Tipicamente una classe base ha una o più funzioni virtuali.</p></li>
<li><p><em>bit</em>: l’unita elementare dell’informazione in un computer. Un bit può avere un valore di 0 o di 1.</p></li>
<li><p><em>bug</em>: un errore in un programma.</p></li>
<li><p><em>byte</em>: l’unità elementare di indirizzamento nella maggior parte dei computer. Solitamente, un byte contiene 8 bit.</p></li>
<li><p><em>classe</em>: un tipo definito dall’utente [user-defined] che può contenere dati membro, funzioni membro e tipi membro.</p></li>
<li><p><em>codice</em>: un programma o parte di esso; usato ambiguamente sia per il codice sorgente che per il codice oggetto.</p></li>
<li><p><em>compilatore</em>: un programma che trasforma il codice sorgente in codice oggetto.</p></li>
<li><p><em>complessità</em>: una nozione difficile-da-definire-precisamente della misura della difficoltà di costruire una soluzione ad un problema o della stessa soluzione. Talvolta la complessità è usata per indicare (semplicemente) una stima del numero di operazioni necessarie per eseguire un algoritmo.</p></li>
<li><p><em>computazione</em>: l’esecuzione di un certo codice, solitamente prendendo qualche input e producendo qualche output.</p></li>
<li><p><em>concetto</em>: (1) una nozione e un’idea; (2) un insieme di requisiti, solitamente per l’argomento di un template.</p></li>
<li><p><em>tipo concreto</em>: un tipo che non è una classe base, e gli oggetti di tale tipo sono destinati ad essere utilizzati direttamente (non solo tramite puntatore/indirezione), la sua dimensione è nota, può solitamente essere allocato ovunque decida il programmatore (p.es., staticamente o sullo stack).</p></li>
<li><p><em>costante</em>: un valore che non può essere cambiato (in un determinato scope); non mutabile.</p></li>
<li><p><em>costruttore</em>: un’operazione che inizializza («costruisce») un oggetto. In genere un costruttore stabilisce un invariante e spesso acquisisce le risorse necessarie per un oggetto per essere usate (che vengono poi generalmente rilasciate da un distruttore).</p></li>
<li><p><em>contenitore</em>: un oggetto che contiene elementi (atri oggetti).</p></li>
<li><p><em>copia</em>: un’operazione che fa in modo che due oggetti abbiano valori uguali al confronto. Si veda anche spostamento [move].</p></li>
<li><p><em>correttezza</em>: un programma o parte di esso è corretto se soddisfa le sue specifiche. Sfortunatamente, una specifica può essere incompleta o incoerente, oppure può non rispondere alle aspettative degli utenti. Quindi, per produrre un codice accettabile, talvolta si deve fare di più che seguire semplicemente le specifiche formali.</p></li>
<li><p><em>costo</em>: il costo (p.es., in tempo del programmatore, in tempo di esecuzione o in spazio) per produrre un programma o eseguirlo. Idealmente, il costo dovrebbe essere in funzione della complessità.</p></li>
<li><p><em>customization point</em>: ???</p></li>
<li><p><em>dati</em>: i valori usati in un calcolo.</p></li>
<li><p><em>debugging</em>: la ricerca e la rimozione di errori in un programma; di solito molto meno sistematico dei test.</p></li>
<li><p><em>dichiarazione</em>: la specifica di un nome col suo tipo in un programma.</p></li>
<li><p><em>definizione</em>: una dichiarazione di un’entità che fornisce tutte le informazioni necessarie per consentire ad un programma di usarla. Definizione semplificata: una dichiarazione che alloca memoria.</p></li>
<li><p><em>classe derivata</em>: una classe derivata da una o più classi base.</p></li>
<li><p><em>progetto [design]</em>: una descrizione generale di come un software dovrebbe operare per rispondere alle sue specifiche.</p></li>
<li><p><em>distruttore</em>: un’operazione implicitamente invocata (chiamata) quando un oggetto viene distrutto (p.es., uscendo dal suo scope). Spesso rilascia le risorse.</p></li>
<li><p><em>incapsulamento</em>: la protezione di qualcosa che deve essere privato (p.es., i dettagli implementativi) da accessi non autorizzati.</p></li>
<li><p><em>errore</em>: una discrepanza tra ciò che ragionevolmente ci si aspetta da un programma (spesso espresso come un requisito o una guida per l’utente) e quello che effettivamente fa il programma.</p></li>
<li><p><em>eseguibile</em>: un programma pronto a girare (ad essere eseguito) su un computer.</p></li>
<li><p><em>feature creep</em>: una tendenza ad aggiungere funzionalità in eccesso a un programma «per ogni evenienza».</p></li>
<li><p><em>file</em>: un contenitore di informazioni permanenti in un computer.</p></li>
<li><p><em>numero in virgola mobile [floating-point]</em>: l’approssimazione in un computer di un numero reale, come ad esempio 7.93 e 10.78e-3.</p></li>
<li><p><em>funzione</em>: una unità di codice, con un nome, che può essere invocata (chiamata) da diverse parti di un programma; una unità logica di calcolo.</p></li>
<li><p><em>programmazione generica</em>: uno stile di programmazione incentrato sulla progettazione e un’efficiente implementazione degli algoritmi. Un algoritmo generico funzionerà con tutti i tipi di argomenti che risponderanno ai suoi requisiti. In C++, solitamente la programmazione generica usa i template.</p></li>
<li><p><em>variabile globale</em>: tecnicamente, un oggetto, con un nome, nello scope del namespace.</p></li>
<li><p><em>gestore [handle]</em>: una classe che consente l’accesso ad altro tramite un puntatore o un riferimento membro. Si veda anche risorsa, copia, spostamento [move].</p></li>
<li><p><em>header</em>: un file contenente le dichiarazioni usate per condividere le interfacce tra le parti di un programma.</p></li>
<li><p><em>occultamento [hiding]</em>: l’atto di impedire la visualizzazione o l’accesso diretto ad un’informazione. Per esempio, un nome da uno scope nidificato (interno) può evitare che lo stesso nome da uno scope più esterno (racchiuso) dell’essere usato direttamente.</p></li>
<li><p><em>ideale</em>: la versione perfetta di qualcosa di cui ci si sta occupando. Solitamente ci sono dei compromessi da fare e ci si accontenta di un’approssimazione.</p></li>
<li><p><em>implementazione</em>: (1)  l’atto di scrivere e testare il codice; (2) il codice che implementa un programma.</p></li>
<li><p><em>loop infinito</em>: un ciclo [loop] dove la condizione di terminazione non diventa mai vera. Si veda iterazione.</p></li>
<li><p><em>ricorsione infinita</em>: una ricorsione che non finisce fino a quando la macchina non esaurisce la memoria per effettuare le chiamate. In realtà, questa ricorsione non è mai infinita ma viene interrotta da un errore hardware.</p></li>
<li><p><em>information hiding</em>: l’atto di separare l’interfaccia dall’implementazione, nascondendo così i dettagli dell’implementazione non destinati all’attenzione degli utenti e fornendo un’astrazione</p></li>
<li><p><em>inizializzare</em>: dare ad un oggetto il suo primo (iniziale) valore.</p></li>
<li><p><em>input</em>: i valori usati da una elaborazione (p.es., gli argomenti di una funzione o i caratteri digitati su una tastiera).</p></li>
<li><p><em>intero [integer]</em>: un numero intero, come 42 e -99.</p></li>
<li><p><em>interfaccia</em>: una dichiarazione o una serie di dichiarazioni che specifica come un pezzo di codice (come una funzione o una classe) debba essere chiamato.</p></li>
<li><p><em>invariante</em>: qualcosa che deve essere sempre vero in un dato punto (o punti) di un programma; tipicamente usato per descrivere lo stato (l’insieme dei valori) di un oggetto o lo stato di un loop prima di entrare nelle istruzioni da ripetere.</p></li>
<li><p><em>iterazione</em>: l’atto di eseguire ripetutamente un pezzo di codice; si vada ricorsione.</p></li>
<li><p><em>iteratore</em>: un oggetto che identifica un elemento di una sequenza.</p></li>
<li><p><em>ISO</em>: International Organization for Standardization (Organizzazione Internazionale per la Standardizzazione). Il linguaggio C++ è uno standard ISO, ISO/IEC 14882. Ulteriori informazioni su <a class="reference external" href="http://iso.org">iso.org</a>.</p></li>
<li><p><em>libreria [library]</em>: una raccolta di tipi, funzioni, classi, ecc. che implementa un insieme di servizi (astrazioni) pensati per essere potenzialmente utilizzati come parte di più programmi.</p></li>
<li><p><em>ciclo-di-vita [lifetime]</em>: il tempo dall’inizializzazione di un oggetto fino a quando diventa inutilizzabile (esce dallo scope, viene cancellato o il programma termina).</p></li>
<li><p><em>linker</em>: un programma che unisce file di codice oggetto e librerie formando un programma eseguibile.</p></li>
<li><p><em>letterale [literal]</em>: una notazione che indica direttamente un valore, così come 12 indica il valore intero di «dodici».</p></li>
<li><p><em>ciclo [loop]</em>: un pezzo di codice eseguito ripetutamente; in C++, solitamente un’istruzione «for» o un’istruzione <code class="docutils literal notranslate"><span class="pre">while</span></code>.</p></li>
<li><p><em>spostamento [move]</em>: un’operazione ce trasferisce un valore da un oggetto ad un altro lasciandosi dietro un valore che rappresenti il «vuoto». Si veda anche la copia.</p></li>
<li><p><em>tipo move-only</em>: un tipo concreto spostabile ma non copiabile.</p></li>
<li><p><em>mutabile [mutable]</em>: modificabile; l’opposto di immutabile, costante e invariabile.</p></li>
<li><p><em>oggetto</em>: (1) una regione di memoria inizializzata di un tipo noto che contiene un valore di quel tipo; (2) una regione di memoria.</p></li>
<li><p><em>codice oggetto</em>: l’output di un compilatore inteso come input per un linker (affinché il linker produca codice eseguibile).</p></li>
<li><p><em>file oggetto</em>: un file contenente codice oggetto.</p></li>
<li><p><em>programmazione object-oriented</em>: (OOP) uno stile di programmazione incentrato sulla progettazione e l’uso di classi e gerarchie di classi.</p></li>
<li><p><em>operazione</em>: qualcosa che può eseguire qualche azione, come una funzione o un operatore.</p></li>
<li><p><em>output</em>: i valori prodotti da una elaborazione (p.es., il risultato di una funzione o le righe di caratteri scritte sullo schermo).</p></li>
<li><p><em>overflow</em>: la produzione di un valore che non può essere memorizzato nella sua destinazione prevista.</p></li>
<li><p><em>overload</em>: la definizione di due funzioni o operatori con lo stesso nome ma tipi di argomenti diversi (operandi).</p></li>
<li><p><em>override</em>: definire una funzione in una classe derivata con lo stesso nome e tipi di argomenti di una funzione virtuale nella classe base, rendendo così la funzione richiamabile attraverso l’interfaccia definita dalla classe base.</p></li>
<li><p><em>proprietario [owner]</em>: un oggetto responsabile del rilascio di una risorsa.</p></li>
<li><p><em>paradigma</em>: un termine un po” pretenzioso per uno stile di progettazione o programmazione; usato spesso con (l’errata) implicazione che esiste un paradigma che sia superiore a tutti gli altri.</p></li>
<li><p><em>parametro</em>: una dichiarazione di un input esplicito di una funzione o di un template. Quando viene chiamata, una funzione può accedere agli argomenti passati tramite i nomi dei suoi parametri.</p></li>
<li><p><em>puntatore</em>: (1) un valore usato per identificare un oggetto di un certo tipo nella memoria; (2) una variabile che contiene tale valore.</p></li>
<li><p><em>post-condizione</em>: una condizione che deve mantenuta all’uscita da un blocco di codice, come una funzione o un loop.</p></li>
<li><p><em>pre-condizione</em>: una condizione che deve mantenuta entrando in un blocco di codice, come una funzione o un loop.</p></li>
<li><p><em>programma</em>: codice (probabilmente corredato con dei dati) che è sufficientemente completo da poter essere eseguito da un computer.</p></li>
<li><p><em>programmazione</em>: l’arte di esprimere col codice delle soluzioni a dei problemi.</p></li>
<li><p><em>linguaggio di programmazione</em>: un linguaggio per esprimere programmi.</p></li>
<li><p><em>pseudo codice</em>: una descrizione di un calcolo scritto con una notazione informale anziché con un linguaggio di programmazione.</p></li>
<li><p><em>funzione virtuale pura</em>: una funzione virtuale che deve essere sovrascritta in una classe derivata.</p></li>
<li><p><em>RAII</em>: («Resource Acquisition Is Initialization») una tecnica di base per la gestione delle risorse basata sugli scope.</p></li>
<li><p><em>range</em>: una sequenza di valori che si possono descrivere con un punto iniziale ed uno finale. Per esempio, <code class="docutils literal notranslate"><span class="pre">[0:5)</span></code> indica i valori 0, 1, 2, 3 e 4.</p></li>
<li><p><em>ricorsione</em>: l’azione di una funzione che chiama se stessa; cfr. iterazione.</p></li>
<li><p><em>riferimento</em>: (1) un valore che descrive la locazione di un oggetto di un certo tipo nella memoria; (2) una variabile che contiene tale valore.</p></li>
<li><p><em>espressione regolare</em>: una notazione per i pattern in stringhe di caratteri.</p></li>
<li><p><em>regolare</em>: un tipo semi-regolare che è confrontabile per l’uguaglianza (vedere il concetto <code class="docutils literal notranslate"><span class="pre">std::regular</span></code>). Dopo una copia, l’oggetto copiato risulta uguale all’oggetto originale, se confrontato. Un tipo regolare si comporta come i tipi nativi come <code class="docutils literal notranslate"><span class="pre">int</span></code> ed è confrontabile con <code class="docutils literal notranslate"><span class="pre">==</span></code>. In particolare, un oggetto di un tipo regolare può essere copiato, e il risultato della copia è un oggetto separato che risulta uguale al primo se si confrontano. Si veda anche <em>tipo semi-regolare</em>.</p></li>
<li><p><em>requisito</em>: (1) una descrizione del comportamento desiderato di un programma o di parte di un programma; (2) una descrizione delle assunzioni che una funzione o un template fa sui suoi argomenti.</p></li>
<li><p><em>risorsa</em>: qualcosa che viene acquisito e che deve poi essere rilasciato, come un handle di file, un lock o della memoria. Si veda anche handle, proprietario [owner].</p></li>
<li><p><em>arrotondamento</em>: conversione di un valore al valore matematicamente più vicino di un tipo meno preciso.</p></li>
<li><p><em>RTTI</em>: Run-Time Type Information. ???</p></li>
<li><p><em>scope</em>: la regione del testo di un programma (il codice sorgente) entro cui si può far riferimento ad un nome.</p></li>
<li><p><em>semi-regolare</em>: un tipo concreto che sia copiabile (oltre che spostabile) e costruibile per default (vedere il concetto <code class="docutils literal notranslate"><span class="pre">std::semiregular</span></code>). Il risultato di una copia è un oggetto indipendente con lo stesso valore dell’originale. Un tipo semiregolare si comporta approssimativamente come un tipo nativo come <code class="docutils literal notranslate"><span class="pre">int</span></code>, ma possibilmente senza un operatore <code class="docutils literal notranslate"><span class="pre">==</span></code>. Si veda anche <em>tipo regolare</em>.</p></li>
<li><p><em>sequenza</em>: elementi che si possono scorrere con un ordine lineare.</p></li>
<li><p><em>software</em>: una raccolta di pezzi di codice e dati correlati; spesso usato in modo intercambiabile con programma.</p></li>
<li><p><em>codice sorgente</em>: il codice prodotto da un programmatore e (in linea di principio) leggibile da altri programmatori.</p></li>
<li><p><em>file sorgente</em>: un file contenente il codice sorgente.</p></li>
<li><p><em>specifica</em>: una descrizione di quello che dovrebbe fare un pezzo di codice.</p></li>
<li><p><em>standard</em>: una definizione ufficialmente concordata di qualcosa, come un linguaggio di programmazione.</p></li>
<li><p><em>stato</em>: un insieme di valori.</p></li>
<li><p><em>STL</em>: i contenitori, gli iteratori e gli algoritmi facenti parte della libreria standard.</p></li>
<li><p><em>stringa</em>: una sequenza di caratteri.</p></li>
<li><p><em>stile</em>: un insieme di tecniche per la programmazione che portano ad un uso coerente delle funzionalità del linguaggio; talvolta usato in senso molto limitato per riferirsi solo alle regole di basso livello sulla nomenclatura e l’aspetto del codice.</p></li>
<li><p><em>sotto-tipo</em>: un tipo derivato; un tipo che ha tutte le proprietà di un altro tipo e probabilmente delle altre.</p></li>
<li><p><em>super-tipo</em>: un tipo base; un tipo che ha un sotto-insieme delle proprietà di un tipo.</p></li>
<li><p><em>sistema</em>: (1) un programma o un insieme di programmi per eseguire un’attività su un computer; (2) un’abbreviazione per «sistema operativo», ovvero, l’ambiente di esecuzione fondamentale e gli strumenti [tool] per un computer.</p></li>
<li><p><em>TS</em>: <a class="reference external" href="https://www.iso.org/deliverables-all.html?type=ts">Technical Specification</a>, Una «Specifica Tecnica» indirizza un lavoro ancora in fase di sviluppo tecnico o dove si ritiene che ci sarà una futura possibilità, ma non immediata, per un riconoscimento in uno Standard Internazionale. Una Specifica Tecnica viene pubblicata per un uso immediato, ma fornisce anche un mezzo per ottenere dei feedback. Lo scopo è quello di essere eventualmente trasformato e ripubblicato come Standard Internazionale.</p></li>
<li><p><em>template</em>: una classe o una funzione parametrizzata con uno o più tipi o (durante la compilazione) con dei valori; il costrutto base del linguaggio C++ che supporta la programmazione generica.</p></li>
<li><p><em>testing</em>: una ricerca sistematica degli errori in un programma.</p></li>
<li><p><em>compromesso [trade-off]</em>: il risultato del bilanciamento tra diversi criteri di progettazione e implementazione.</p></li>
<li><p><em>troncamento</em>: la perdita di informazioni in una conversione da un tipo ad un altro che non può rappresentare esattamente il tipo da convertire.</p></li>
<li><p><em>tipo</em>: qualcosa che definisce l’insieme dei possibili valori e l’insieme delle possibili operazioni per un oggetto.</p></li>
<li><p><em>non-inizializzato</em>: lo stato (indefinito) di un oggetto prima che venga inizializzato.</p></li>
<li><p><em>unità</em>: (1) una misura standard che dà significato ad un valore (p.es., km per una distanza); (2) una parte distinta (p.es. con un nome) di un tutto più grande.</p></li>
<li><p><em>caso d’uso</em>: uno specifico uso (solitamente semplice) di un programma per testarne il funzionamento e mostrarne lo scopo.</p></li>
<li><p><em>valore</em>: un insieme di bit nella memoria interpretati secondo un tipo.</p></li>
<li><p><em>tipo valore</em>: un termine che qualcuno usa per indicare un tipo regolare o semi-regolare.</p></li>
<li><p><em>variabile</em>: un oggetto di un certo tipo con un nome; contiene un valore a meno che non sia non-inizializzato.</p></li>
<li><p><em>funzione virtuale</em>: una funzione membro che può essere sovrascritta in una classe derivata.</p></li>
<li><p><em>word</em>: una unità base di memoria in un computer, spesso l’unità usata per contenere un intero.</p></li>
</ul>
</section>
<section id="to-do-unclassified-proto-rules">
<h2><a name="S-unclassified"></a>To-do: Proto-regole non classificate<a class="headerlink" href="#to-do-unclassified-proto-rules" title="Link to this heading">¶</a></h2>
<p>Questa è la lista delle cose da fare. Alla fine, le voci diventeranno regole o parti di esse. Oppure, si deciderà di non cambiare nulla e la voce verrà cancellata.</p>
<ul>
<li><p>Nessuna funzione friend distante</p></li>
<li><p>Si dovrebbe affrontare il progetto fisico (cosa c’è in un file) e quello su larga scala (librerie, gruppi di librerie)?</p></li>
<li><p>I namespace</p></li>
<li><p>Evitare di usare direttive negli scope globali (eccetto std ed altri namespace «fondamentali» (p.es. experimental))</p></li>
<li><p>Quanto devono essere granulari i namespace? Tutte le classi/funzioni progettate per funzionare assieme e rilasciate insieme (come definite in Sutter/Alexandrescu) oppure qualcosa di più restrittivo o più ampio?</p></li>
<li><p>Ci dovrebbero essere dei namespace inline (tipo <code class="docutils literal notranslate"><span class="pre">std::literals::*_literals</span></code>)?</p></li>
<li><p>Evitare le conversioni implicite</p></li>
<li><p>Le funzioni membro const dovrebbero essere [thread safe] … aka, ma io non cambio effettivamente la variabile, le assegno solo un valore la prima volta che la chiamo … argh</p></li>
<li><p>Inizializzare sempre le variabili, utilizzare le liste di inizializzazione per i dati membri.</p></li>
<li><p>A chiunque scriva un’interfaccia pubblica che prenda o restituisca <code class="docutils literal notranslate"><span class="pre">void*</span></code> gli si dovrebbero tagliare le mani. Questa è stata la favorita per diversi anni. :)</p></li>
<li><p>Dove possibile usare <code class="docutils literal notranslate"><span class="pre">const</span></code> per: funzioni membro, variabili e (urrà) <code class="docutils literal notranslate"><span class="pre">const_iterators</span></code></p></li>
<li><p>Utilizzare <code class="docutils literal notranslate"><span class="pre">auto</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(size)</span></code> rispetto a <code class="docutils literal notranslate"><span class="pre">{initializers}</span></code> rispetto a <code class="docutils literal notranslate"><span class="pre">{Extent{size}}</span></code></p></li>
<li><p>Non astrarre troppo [overabstract]</p></li>
<li><p>Mai passare un puntatore nello stack della chiamata</p></li>
<li><p>verso una funzione sottostante</p></li>
<li><p>Dovrebbero esserci delle linee-guida per scegliere tra i polimorfismi? SI. stile classico (funzioni virtuali, semantica del riferimento) rispetto allo «Sean Parent» (semantica del valore, [type-erased], cose come <code class="docutils literal notranslate"><span class="pre">std::function</span></code>)  rispetto a CRTP/static [Curiously Recurring Template Pattern]? SI Forse anche rispetto a [tag dispatch]?</p></li>
<li><p>le chiamate virtuali dovrebbero essere bandite dai costruttori/distruttori nelle linee-guida? SI. Molte persone le bandiscono, anche se si pensa che siano un grande punto di forza del C++ ??? -preserving (D ha tanto deluso quando è andato verso Java). QUALE SARÀ UN BUON ESEMPIO?</p></li>
<li><p>Parlando di lambda, cosa peserebbe nella decisione tra lambda e classi (locali?) nelle chiamate di algoritmi e altri scenari sulle callback?</p></li>
<li><p>E parlando di <code class="docutils literal notranslate"><span class="pre">std::bind</span></code>, Stephen T. Lavavej lo critica così tanto che c’è da chiedersi se in futuro sparirà. Si dovrebbero invece consigliare le lambda?</p></li>
<li><p>Cosa fare con i leak di temporanei? : <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">(s1</span> <span class="pre">+</span> <span class="pre">s2).c_str();</span></code></p></li>
<li><p>invalidazione di un puntatore/iteratore che ha a che fare con puntatori appesi [dangling]:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  void bad()
  {
      int* p = new int[700];
      int* q = &amp;p[7];
      delete p;

      vector&lt;int&gt; v(700);
      int* q2 = &amp;v[7];
      v.resize(900);

      // ... use q and q2 ...
  }
</pre></div>
</div>
</li>
<li><p>LSP [Liskov Substitution Principle]</p></li>
<li><p>ereditarietà privata rispetto ai membri</p></li>
<li><p>evitare come variabili membro di classi statiche (conflitti, variabili quasi-globali)</p></li>
<li><p>Usare protezioni con lock RAII (<code class="docutils literal notranslate"><span class="pre">lock_guard</span></code>, <code class="docutils literal notranslate"><span class="pre">unique_lock</span></code>, <code class="docutils literal notranslate"><span class="pre">shared_lock</span></code>), mai chiamare <code class="docutils literal notranslate"><span class="pre">mutex.lock</span></code> e <code class="docutils literal notranslate"><span class="pre">mutex.unlock</span></code> direttamente (RAII)</p></li>
<li><p>Preferire lock non-ricorsivi (spesso usati per aggirare cattive scelte [reasoning], [overhead])</p></li>
<li><p>Unire [join] i thread! (a causa di <code class="docutils literal notranslate"><span class="pre">std::terminate</span></code> nel distruttore se non è unito [joined] o staccato [detached] … c’è una buona ragione per staccare [detach] i thread?) – ??? potrebbe la libreria di supporto fornire un wrapper RAII per <code class="docutils literal notranslate"><span class="pre">std::thread</span></code>?</p></li>
<li><p>Se si devono acquisire due o più mutex contemporaneamente, usare <code class="docutils literal notranslate"><span class="pre">std::lock</span></code> (o un altro algoritmo per evitare i [deadlock]?)</p></li>
<li><p>Quando si usa una <code class="docutils literal notranslate"><span class="pre">condition_variable</span></code>, proteggere sempre la condizione con un mutex (il booleano atomico il cui valore è settato esternamente al mutex è sbagliato!), ed usare lo stesso mutex per la variabile della condizione stessa.</p></li>
<li><p>Mai usare <code class="docutils literal notranslate"><span class="pre">atomic_compare_exchange_strong</span></code> con <code class="docutils literal notranslate"><span class="pre">std::atomic&lt;user-defined-struct&gt;</span></code> (le differenze materia di riempimento, mentre <code class="docutils literal notranslate"><span class="pre">compare_exchange_weak</span></code> in un loop converge ad un riempimento stabile)</p></li>
<li><p>i singoli oggetti <code class="docutils literal notranslate"><span class="pre">shared_future</span></code> non sono [thread-safe]: due thread non possono aspettare per lo stesso oggetto <code class="docutils literal notranslate"><span class="pre">shared_future</span></code> (possono attendere su copie di <code class="docutils literal notranslate"><span class="pre">shared_future</span></code> che si riferiscono allo stesso stato condiviso)</p></li>
<li><p>I singoli oggetti <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> non sono thread-safe: thread diversi possono chiamare funzioni membro non-<code class="docutils literal notranslate"><span class="pre">const</span></code> su <em>different</em> <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> che fanno riferimento allo stesso oggetto condiviso, ma un thread non può chiamare una funzione membro non-<code class="docutils literal notranslate"><span class="pre">const</span></code> di un oggetto <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> mentre un altro thread accede allo stesso oggetto <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> (se o si deve fare, si consideri invece <code class="docutils literal notranslate"><span class="pre">atomic_shared_ptr</span></code>)</p></li>
<li><p>regole per l’aritmetica</p></li>
</ul>
</section>
<section id="bibliography">
<h2>Bibliografia<a class="headerlink" href="#bibliography" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><a name="Abrahams01"></a>
[Abrahams01]:  D. Abrahams. <a class="reference external" href="http://www.boost.org/community/exception_safety.html">Exception-Safety in Generic Components</a>.</p></li>
<li><p><a name="Alexandrescu01"></a>
[Alexandrescu01]:  A. Alexandrescu. Modern C++ Design (Addison-Wesley, 2001).</p></li>
<li><p><a name="Cplusplus03"></a>
[C++03]:           ISO/IEC 14882:2003(E), Programming Languages — C++ (updated ISO and ANSI C++ Standard including the contents of (C++98) plus errata corrections).</p></li>
<li><p><a name="Cargill92"></a>
[Cargill92]:       T. Cargill. C++ Programming Style (Addison-Wesley, 1992).</p></li>
<li><p><a name="Cline99"></a> [Cline99]:         M. Cline, G. Lomow e M. Girou. C++ FAQs (2ndEdition) (Addison-Wesley, 1999).</p></li>
<li><p><a name="Dewhurst03"></a>
[Dewhurst03]:      S. Dewhurst. C++ Gotchas (Addison-Wesley, 2003).</p></li>
<li><p><a name="Henricson97"></a>
[Henricson97]:     M. Henricson and E. Nyquist. Industrial Strength C++ (Prentice Hall, 1997).</p></li>
<li><p><a name="Koenig97"></a> [Koenig97]:        A. Koenig e B. Moo. Ruminations on C++ (Addison-Wesley, 1997).</p></li>
<li><p><a name="Lakos96"></a>
[Lakos96]:         J. Lakos. Large-Scale C++ Software Design (Addison-Wesley, 1996).</p></li>
<li><p><a name="Meyers96"></a>
[Meyers96]:        S. Meyers. More Effective C++ (Addison-Wesley, 1996).</p></li>
<li><p><a name="Meyers97"></a>
[Meyers97]:        S. Meyers. Effective C++ (2nd Edition) (Addison-Wesley, 1997).</p></li>
<li><p><a name="Meyers01"></a>
[Meyers01]:        S. Meyers. Effective STL (Addison-Wesley, 2001).</p></li>
<li><p><a name="Meyers05"></a>
[Meyers05]:        S. Meyers. Effective C++ (3rd Edition) (Addison-Wesley, 2005).</p></li>
<li><p><a name="Meyers15"></a>
[Meyers15]:        S. Meyers. Effective Modern C++ (O’Reilly, 2015).</p></li>
<li><p><a name="Murray93"></a>
[Murray93]:        R. Murray. C++ Strategies and Tactics (Addison-Wesley, 1993).</p></li>
<li><p><a name="Stroustrup94"></a>
[Stroustrup94]:    B. Stroustrup. The Design and Evolution of C++ (Addison-Wesley, 1994).</p></li>
<li><p><a name="Stroustrup00"></a>
[Stroustrup00]:    B. Stroustrup. The C++ Programming Language (Special 3rdEdition) (Addison-Wesley, 2000).</p></li>
<li><p><a name="Stroustrup05"></a>
[Stroustrup05]:    B. Stroustrup. <a class="reference external" href="http://www.stroustrup.com/SELLrationale.pdf">A rationale for semantically enhanced library languages</a>.</p></li>
<li><p><a name="Stroustrup13"></a>
[Stroustrup13]:    B. Stroustrup. <a class="reference external" href="http://www.stroustrup.com/4th.html">The C++ Programming Language (4th Edition)</a>. Addison Wesley 2013.</p></li>
<li><p><a name="Stroustrup14"></a>
[Stroustrup14]:    B. Stroustrup. <a class="reference external" href="http://www.stroustrup.com/Tour.html">A Tour of C++</a>.
Addison Wesley 2014.</p></li>
<li><p><a name="Stroustrup15"></a>
[Stroustrup15]:    B. Stroustrup, Herb Sutter, and G. Dos Reis: <a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Introduction%20to%20type%20and%20resource%20safety.pdf">A brief introduction to C++”s model for type- and resource-safety</a>.</p></li>
<li><p><a name="SuttHysl04b"></a>
[SuttHysl04b]:     H. Sutter and J. Hyslop. <a class="reference external" href="https://web.archive.org/web/20120926011837/http://www.drdobbs.com/collecting-shared-objects/184401839">Collecting Shared Objects</a> (C/C++ Users Journal, 22(8), August 2004).</p></li>
<li><p><a name="SuttAlex05"></a> [SuttAlex05]:      H. Sutter e  A. Alexandrescu. C++ Coding Standards. Addison-Wesley 2005.</p></li>
<li><p><a name="Sutter00"></a>
[Sutter00]:        H. Sutter. Exceptional C++ (Addison-Wesley, 2000).</p></li>
<li><p><a name="Sutter02"></a>
[Sutter02]:        H. Sutter. More Exceptional C++ (Addison-Wesley, 2002).</p></li>
<li><p><a name="Sutter04"></a>
[Sutter04]:        H. Sutter. Exceptional C++ Style (Addison-Wesley, 2004).</p></li>
<li><p><a name="Taligent94"></a>
[Taligent94]: Taligent’s Guide to Designing Programs (Addison-Wesley, 1994).</p></li>
</ul>
</section>
<span id="document-CONTRIBUTING"></span><section id="contributing-to-the-c-core-guidelines">
<h2>Contribuire alle C++ Core Guidelines<a class="headerlink" href="#contributing-to-the-c-core-guidelines" title="Link to this heading">¶</a></h2>
<blockquote>
<div><p>«All’interno del C++ c’è un più piccolo, semplice e sicuro linguaggio, che lotta per uscire fuori». – <cite>Bjarne Stroustrup</cite></p>
</div></blockquote>
<p>Le C++ Core Guidelines costituiscono un lavoro di gruppo guidato da Bjarne Stroustrup, proprio come lo stesso linguaggio C++. Sono il risultato di molti anni-uomo di discussioni e progettazione con diverse organizzazioni. Per come sono progettate incoraggiano una generale applicabilità ed un’ampia adozione ma si possono liberamente copiare e modificare per soddisfare le esigenze della propria organizzazione.</p>
<p>I contributi alle C++ Core Guidelines vengono incoraggiati in diversi modi:</p>
<ul class="simple">
<li><p><strong>feedback individuale</strong> Siete sviluppatori appassionati del vostro codice? Unitevi alla discussione in <a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/issues">Issues</a>. Vogliamo sapere quali regole vi garbano e quali no Ci sono regole eccessivamente difficili da applicare? Il fornitore del compilatore segue adeguatamente le Guidelines Support Library (p.es., <a class="reference external" href="https://github.com/microsoft/gsl">l’implementazione di Microsoft delle GSL</a>)?</p></li>
<li><p><strong>Adozione nelle organizzazioni</strong> Sebbene le linee-guida siano progettate per essere largamente adottate, devono anche essere modificate per adattarsi alle esigenze specifiche dell’organizzazione. Incoraggiamo le organizzazioni a fare un fork di questo «repo» creandosi la propria copia di queste linee-guida con delle modifiche che ne riflettano le necessità. Si consiglia di esplicitare nel titolo che sono delle linee-guida proprie e che costituiscono un fork della propria organizzazione e di fornire un link al set originale delle <a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines">guidelines</a>. E se una qualsiasi delle modifiche risultasse appropriata per essere inserite nelle linee-guida originali, aprite un <a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/issues">Issue</a> che porti ad una “pull request”.</p></li>
<li><p><strong>Manutenzione delle Guidelines</strong> Le C++ Core Guidelines sono state create da una vasta gamma di conoscenze diffuse in diverse organizzazioni in tutto il mondo. Se voi o la vostra organizzazione volete collaborare a creare le linee-guida, prendete in considerazione di diventare un redattore o un manutentore. Se siete degli esperti in C++ che vogliono davvero partecipare, mandate una mail a <a class="reference external" href="mailto:coreguidelines&#37;&#52;&#48;isocpp&#46;org?subject=Maintain%20the%20C++%20Code%20Guidelines">email coreguidelines<span>&#64;</span>isocpp<span>&#46;</span>org</a>.</p></li>
</ul>
</section>
<section id="contributor-license-agreement">
<h2>Accordo di Licenza per i Collaboratori<a class="headerlink" href="#contributor-license-agreement" title="Link to this heading">¶</a></h2>
<p>Contribuendo al contenuto delle C++ Core Guidelines (p.es., inviando una “pull request” da inserire in questo repository) si accettano quelli che della <a class="reference external" href="https://isocpp.org/about">Standard C++ Foundation</a> sono i <a class="reference external" href="https://isocpp.org/home/terms-of-use">Termini d’Uso</a>, in special modo tutti i termini specificati in materia di Brevetti e Copyright.</p>
<ul class="simple">
<li><p>Voi garantite che il vostro materiale è originale o che avete il diritto di contribuire ad esso.</p></li>
<li><p>Per quanto riguarda il materiale in proprio possesso, concedete una licenza mondiale, non-esclusiva, irrevocabile, trasferibile e esente da royalty per il materiale fornito alla Standard C++ Foundation per mostrare, riprodurre, eseguire, distribuire e creare opere derivate da esso per uso commerciale o non commerciale. Rispetto a qualsiasi altro materiale da voi fornito, questo deve essere coperto da una licenza sufficiente a consentire alla Standard C++ Foundation di mostrare, riprodurre, eseguire, distribuire e creare opere derivate da esso per uso commerciale o non commerciale.</p></li>
<li><p>Accettate che, se il materiale viene successivamente riportato nello standard C++ ISO/IEC in qualsiasi forma, sarà soggetto a tutte le politiche ISO/IEC JTC 1 inclusi i <a class="reference external" href="http://www.iso.org/iso/home/policies.htm">copyright</a>, i <a class="reference external" href="http://www.iso.org/iso/home/standards_development/governance_of_technical_work/patents.htm">brevetti</a>, e le <a class="reference external" href="http://www.itscj.ipsj.or.jp/sc29/29w7proc.htm">procedure</a>; tutte le domande su tali politiche vanno rivolte alla <a class="reference external" href="http://www.iso.org/iso/home/about.htm">ISO Central Secretariat</a>.</p></li>
</ul>
</section>
<section id="pull-requests">
<h2>Pull request<a class="headerlink" href="#pull-requests" title="Link to this heading">¶</a></h2>
<p>Accogliamo con favore le “pull request” per delle modifiche mirate alle linee-guida–correzione ai bug negli esempi, chiarimento di frasi ambigue, ecc. Le modifiche più significative devono prima essere discusse nelle <a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/issues">Issue</a> e il numero della Issue dev’essere incluso nella “pull request”.  Per le modifiche relative alle linee-guida, specificare il numero della regola nell’Issue e/o nella Pull Request.</p>
<p>Le modifiche devono essere apportate in un commit child di un commit recente nel branch master.  Se si apportano molte piccole modifiche, creare dei PR [Pull Request] separati per minimizzare problemi nel merge.</p>
<section id="document-style-guidelines">
<h3>Linee-guida sullo Stile del Documento<a class="headerlink" href="#document-style-guidelines" title="Link to this heading">¶</a></h3>
<p>I documenti in questo repository sono scritti in uno specifico dialetto del Markdown, che lascia delle ambiguità sulla formattazione del testo.  Chiediamo che le [pull request] mantengano le seguenti linee-guida stilistiche, sebbene siamo consapevoli che il documento potrebbe già non essere coerente.</p>
<section id="indentation">
<h4>Indentazione<a class="headerlink" href="#indentation" title="Link to this heading">¶</a></h4>
<p>Il codice e il testo nidificato devono utilizzare multipli di 4 spazi di rientro e nessun carattere di tabulazione, in questo modo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void func(const int x)
{
    std::cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;
}
</pre></div>
</div>
</section>
<section id="code-blocks">
<h4>Blocchi di Codice<a class="headerlink" href="#code-blocks" title="Link to this heading">¶</a></h4>
<p>Usare un’indentazione di 4 spazi per attivare il parsing del codice, anziché <a class="reference external" href="https://help.github.com/articles/github-flavored-markdown/#fenced-code-blocks">blocchi di codice incorniciato</a> o qualsiasi altro stile, in questo modo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This is some document text, with an example below:

    void func()
    {
        std::cout &lt;&lt; &quot;This is code.\n&quot;;
    }
</pre></div>
</div>
</section>
<section id="document-style-decisions">
<h4>Decisioni sullo stile del documento<a class="headerlink" href="#document-style-decisions" title="Link to this heading">¶</a></h4>
<p>Abbiamo discusso e deciso su diversi stili del documento. Si prega di non aprire PR [Pull Request] che rivisitino questi punti stilistici:</p>
<ul class="simple">
<li><p>Il CppCoreGuidelines.md è un file unico nel dialetto GH del Markdown. Non è suddiviso in più capitoli.</p></li>
<li><p>Nelle Core Guidelines non usiamo l’evidenziazione della sintassi. Cfr. PRs #33, #96, #328, and #779. Se si desidera evidenziare la sintassi, è possibile visualizzare la versione «pretty» su http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines o eseguire un proprio post-processing.</p></li>
<li><p>Restiamo fedeli al set di caratteri ASCII. Non usiamo i trattini-em di Unicode, gli spazi di Unicode, o belle virgolette. Molte persone modificano questo file con i loro vari editor di testo. L’ASCII è semplice e universale.</p></li>
</ul>
</section>
</section>
<section id="update-dictionary">
<h3>Aggiornamento del dizionario<a class="headerlink" href="#update-dictionary" title="Link to this heading">¶</a></h3>
<p>Gli esempi di codice nelle linee-guida vengono eseguiti tramite un correttore ortografico.  Assicurarsi di aggiungere i nomi delle nuove classi e variabili a <a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/scripts/hunspell/isocpp.dic">scripts/hunspell/isocpp.dic</a>.</p>
</section>
<section id="miscellaneous">
<h3>Miscellanea<a class="headerlink" href="#miscellaneous" title="Link to this heading">¶</a></h3>
<p>Per evitare problemi di fine-riga, impostare <code class="docutils literal notranslate"><span class="pre">autocrlf</span> <span class="pre">=</span> <span class="pre">input</span></code> e <code class="docutils literal notranslate"><span class="pre">whitespace</span> <span class="pre">=</span> <span class="pre">cr-at-eol</span></code> nella propria configurazione git.</p>
</section>
</section>
<span id="document-SECURITY"></span><section id="security-policy">
<h2>Policy di Sicurezza<a class="headerlink" href="#security-policy" title="Link to this heading">¶</a></h2>
<section id="reporting-a-vulnerability">
<h3>Riportare una Vulnerabilità<a class="headerlink" href="#reporting-a-vulnerability" title="Link to this heading">¶</a></h3>
<p>Eventuali vulnerabilità devono essere comunicate a cppcg-editors&#64;isocpp.org</p>
</section>
</section>
</div>
</section>
<section id="indices-and-tables">
<h1>Indici e tabelle<a class="headerlink" href="#indices-and-tables" title="Link to this heading">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Indice</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Indice dei moduli</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Cerca</span></a></p></li>
</ul>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">C++ Core Guidelines</a></h1>








<h3>Navigazione</h3>
<p class="caption" role="heading"><span class="caption-text">Contenuti:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="#document-README">Per iniziare</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#background-and-scope">Background e scopo</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#contributions-and-license">Contributi e LICENZA</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-CppCoreGuidelines"><a name="main"></a>C++ Core Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#abstract"><a name="S-abstract"></a>Sommario</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#in-introduction"><a name="S-introduction"></a>In: Introduzione</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#p-philosophy"><a name="S-philosophy"></a>P: Filosofia</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#i-interfaces"><a name="S-interfaces"></a>I: Interfacce</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#f-functions"><a name="S-functions"></a>F: Funzioni</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#c-classes-and-class-hierarchies"><a name="S-class"></a>C: Classi e gerarchie di classi</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#enum-enumerations"><a name="S-enum"></a>Enum: Enumerazioni</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#r-resource-management"><a name="S-resource"></a>R: Gestione delle risorse</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#es-expressions-and-statements"><a name="S-expr"></a>ES: Espressioni e istruzioni</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#per-performance"><a name="S-performance"></a>Per: Prestazione</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#cp-concurrency-and-parallelism"><a name="S-concurrency"></a>CP: Concorrenza e parallelismo</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#e-error-handling"><a name="S-errors"></a>E: Gestione degli errori [Error handling]</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#con-constants-and-immutability"><a name="S-const"></a>Con: Costanti e immutabilità</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#t-templates-and-generic-programming"><a name="S-templates"></a>T: Template e programmazione generica</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#cpl-c-style-programming"><a name="S-cpl"></a>CPL: Programmazione C-style</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#sf-source-files"><a name="S-source"></a>SF: File sorgenti</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#sl-the-standard-library"><a name="S-stdlib"></a>SL: La Libreria Standard [Standard Library]</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#a-architectural-ideas"><a name="S-A"></a>A: Idee architetturali</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#nr-non-rules-and-myths"><a name="S-not"></a>NR: Non-Regole e miti</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#rf-references"><a name="S-references"></a>RF: Riferimenti</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#pro-profiles"><a name="S-profile"></a>Pro: Profili</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#gsl-guidelines-support-library"><a name="S-gsl"></a>GSL: Libreria di supporto alle linee-guida [Guidelines support library]</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#nl-naming-and-layout-suggestions"><a name="S-naming"></a>NL: Suggerimenti per la nomenclatura e il layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#faq-answers-to-frequently-asked-questions"><a name="S-faq"></a>FAQ: Risposte a domande frequenti</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#appendix-a-libraries"><a name="S-libraries"></a>Appendice A: Librerie</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#appendix-b-modernizing-code"><a name="S-modernizing"></a>Appendice B: Modernizzazione del codice</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#appendix-c-discussion"><a name="S-discussion"></a>Appendice C: Discussione</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#appendix-d-supporting-tools"><a name="S-tools"></a>Appendice D: Tool di supporto</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#glossary"><a name="S-glossary"></a>Glossario</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#to-do-unclassified-proto-rules"><a name="S-unclassified"></a>To-do: Proto-regole non classificate</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#bibliography">Bibliografia</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-CONTRIBUTING">Contribuire alle C++ Core Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#contributor-license-agreement">Accordo di Licenza per i Collaboratori</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#pull-requests">Pull request</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-SECURITY">Policy di Sicurezza</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, BravoBaldo 
(Traduzione: Baldassarre Cesarano).
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>