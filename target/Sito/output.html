<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>CppCoreGuidelines</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="c-core-guidelines"><a name="main"></a>C++ Core Guidelines</h1>
<p>8 dicembre 2019</p>
<p>Editori:</p>
<ul>
<li><a href="http://www.stroustrup.com">Bjarne Stroustrup</a></li>
<li><a href="http://herbsutter.com/">Herb Sutter</a></li>
</ul>
<p>Traduzione:</p>
<ul>
<li><a href="baldassarre.cesarano%20(AT)%20libero.it">Baldassarre Cesarano</a></li>
</ul>
<p>Questo è un documento vivo in costante miglioramento. Se fosse stato un progetto open-source (software), starebbe alla release 0.8. La copia, l’uso, la modifica e la creazione di opere derivate da questo progetto sono concesse con una licenza simile a quella del MIT. Per contribuire a questo progetto si richiede l’accettazione di una “Licenza per Collaboratori” [Contributor License]. Si consulti il file allegato <a href="LICENSE">LICENZA</a> per i dettagli. Questo progetto è a disposizione degli “utenti amichevoli” per usarlo, copiarlo, modificarlo e ricavarne altri lavori, sperando in input costruttivi.</p>
<p>I commenti e i suggerimenti per migliorare sono sempre benvenuti. Si prevede di modificare ed estendere questo documento man mano che migliorano la nostra comprensione, il linguaggio e l’insieme delle librerie disponibili. Nel commentare, si tenga presente <a href="#S-introduction">l’introduzione</a> che delinea i nostri obiettivi e l’approccio generale. L’elenco dei contributori si trova <a href="#SS-ack">qui</a>.</p>
<p>Problemi:</p>
<ul>
<li>I gruppi di regole non sono stati completamente controllati per quanto riguarda la completezza, la consistenza e l’obbligatorietà.</li>
<li>Tre punti interrogativi (???) contrassegnano la riconosciuta mancanza di informazioni</li>
<li>Le sezioni dei riferimenti [reference] sono aggiornate; molte fonti antecedenti al C++11 sono troppo vecchie.</li>
<li>Per un elenco più o meno aggiornato di cose da fare: <a href="#S-unclassified">Da-fare [To-do]: Proto-regole non classificate</a></li>
</ul>
<p>Si può <a href="#S-abstract">leggere una spiegazione dello scopo e sulla struttura di questa Guida</a> o semplicemente proseguire oltre:</p>
<ul>
<li><a href="#S-introduction">In: Introduzione</a></li>
<li><a href="#S-philosophy">P: Filosofia</a></li>
<li><a href="#S-interfaces">I: Interfacce</a></li>
<li><a href="#S-functions">F: Funzioni</a></li>
<li><a href="#S-class">C: Classi e gerarchie di classi</a></li>
<li><a href="#S-enum">Enum: Enumerazioni</a></li>
<li><a href="#S-resource">R: Gestione delle risorse [Resource management]</a></li>
<li><a href="#S-expr">ES: Espressioni e istruzioni</a></li>
<li><a href="#S-performance">Per: Prestazione</a></li>
<li><a href="#S-concurrency">CP: Concorrenza e parallelismo</a></li>
<li><a href="#S-errors">E: Gestione degli errori [Error handling]</a></li>
<li><a href="#S-const">Con: Costanti e immutabilità</a></li>
<li><a href="#S-templates">T: Template e programmazione generica</a></li>
<li><a href="#S-cpl">CPL: Programmazione C-style</a></li>
<li><a href="#S-source">SF: File sorgenti [Source files]</a></li>
<li><a href="#S-stdlib">SL: La libreria Standard [Standard Library]</a></li>
</ul>
<p>Sezioni di supporto:</p>
<ul>
<li><a href="#S-A">A: Idee architetturali</a></li>
<li><a href="#S-not">NR: Non-Regole e miti</a></li>
<li><a href="#S-references">RF: Riferimenti</a></li>
<li><a href="#S-profile">Pro: Profili</a></li>
<li><a href="#S-gsl">GSL: Libreria di supporto alle linee-guida [Guidelines Support Library]</a></li>
<li><a href="#S-naming">NL: Regole di nomenclatura e layout</a></li>
<li><a href="#S-faq">FAQ: Risposte a domande frequenti</a></li>
<li><a href="#S-libraries">Appendice A: Librerie</a></li>
<li><a href="#S-modernizing">Appendice B: Modernizzazione del codice</a></li>
<li><a href="#S-discussion">Appendice C: Discussione</a></li>
<li><a href="#S-tools">Appendice D: Tool di supporto</a></li>
<li><a href="#S-glossary">Glossario</a></li>
<li><a href="#S-unclassified">To-do: Proto-regole non classificate</a></li>
</ul>
<p>Si possono provare le regole per delle specifiche funzionalità del linguaggio:</p>
<ul>
<li>assegnazione: <a href="#Rc-regular">tipi regolari</a> – <a href="#Rc-initialize">preferire l’inizializzazione</a> – <a href="#Rc-copy-semantic">copia</a> – <a href="#Rc-move-semantic">spostamento [move]</a> – <a href="#Rc-matched">altre operazioni</a> – <a href="#Rc-eqdefault">default</a></li>
<li><code>classi</code>: <a href="#Rc-org">dati</a> – <a href="#Rc-struct">invarianti</a> – <a href="#Rc-member">membri</a> – <a href="#Rc-helper">helper</a> – <a href="#SS-concrete">tipi concreti</a> – <a href="#S-ctor">=, ctors e dtors [costruttori e distruttori]</a> – <a href="#SS-hier">gerarchie</a> – <a href="#SS-overload">operatori</a></li>
<li><code>concetti</code>: <a href="#SS-concepts">regole</a> – <a href="#Rt-raise">nella programmazione generica</a> – <a href="#Rt-concepts">argomenti di template</a> – <a href="#Rt-low">semantica</a></li>
<li>costruttore: <a href="#Rc-struct">invariante</a> – <a href="#Rc-ctor">stabilire l’invariante</a> – <a href="#Rc-throw"><code>eccezioni [throw]</code></a> – <a href="#Rc-default0">default</a> – <a href="#Rc-default">non necessario</a> – <a href="#Rc-explicit"><code>esplicito</code></a> – <a href="#Rc-delegating">delegante</a> – <a href="#Rc-ctor-virtual"><code>virtuale</code></a></li>
<li><code>classe</code> derivata: <a href="#Rh-domain">quando usarla</a> – <a href="#Rh-abstract">come interfaccia</a> – <a href="#Rh-dtor">distruttori</a> – <a href="#Rh-copy">copia</a> – <a href="#Rh-get">[getter] e [setter]</a> – <a href="#Rh-mi-interface">ereditarietà multipla</a> – <a href="#Rh-using">overloading</a> – <a href="#Rc-copy-virtual">slicing</a> – <a href="#Rh-dynamic_cast"><code>dynamic_cast</code></a></li>
<li>distruttore: <a href="#Rc-matched">e costruttori</a> – <a href="#Rc-dtor">quando è necessario?</a> – <a href="#Rc-dtor-fail">potrebbe non fallire</a></li>
<li>eccezione: <a href="#S-errors">errori</a> – <a href="#Re-throw"><code>throw</code></a> – <a href="#Re-errors">solo per gli errori</a> – <a href="#Re-noexcept"><code>noexcept</code></a> – <a href="#Re-catch">minimizzare <code>try</code></a> – <a href="#Re-no-throw-codes">e se non ci fossero eccezioni?</a></li>
<li><code>for</code>: <a href="#Res-for-range">range-for e for</a> – <a href="#Res-for-while">for e while</a> – <a href="#Res-for-init">inizializzatore</a> – <a href="#Res-empty">body vuoto</a> – <a href="#Res-loop-counter">variabile del loop</a> – <a href="#Res-???">tipo della variabile del loop ???</a></li>
<li>funzione: <a href="#Rf-package">nomenclatura</a> – <a href="#Rf-logical">operazione singola</a> – <a href="#Rf-noexcept">senza throw</a> – <a href="#Rf-smart">argomenti</a> – <a href="#Rf-conventional">passaggio di argomenti</a> – <a href="#Rf-out-multi">valori di ritorno multipli</a> – <a href="#Rf-return-ptr">puntatori</a> – <a href="#Rf-capture-vs-overload">lambda</a></li>
<li><code>inline</code>: <a href="#Rf-inline">piccole funzioni</a> – <a href="#Rs-inline">negli header</a></li>
<li>inizializzazione: <a href="#Res-always">sempre</a> – <a href="#Res-list">preferire <code>{}</code></a> – <a href="#Res-lambda-init">lambda</a> – <a href="#Rc-in-class-initializer">inizializzatori in-class</a> – <a href="#Rc-initialize">membri della classe</a> – <a href="#Rc-factory">funzioni factory</a></li>
<li>espressione lambda: <a href="#SS-lambdas">quando usarla</a></li>
<li>operatore: <a href="#Ro-conventional">convenzionale</a> – <a href="#Ro-conversion">evitare la conversione degli operatori</a> – <a href="#Ro-lambda">e le lambda</a></li>
<li><code>public</code>, <code>private</code>, e <code>protected</code>: <a href="#Rc-private">information hiding</a> – <a href="#Rh-public">consistenza</a> – <a href="#Rh-protected"><code>protected</code></a></li>
<li><code>static_assert</code>: <a href="#Rp-compile-time">controllo in fase di compilazione</a> – <a href="#Rt-check-class">e concept</a></li>
<li><code>struct</code>: <a href="#Rc-org">per organizzare i dati</a> – <a href="#Rc-struct">usare se non sono invarianti</a> – <a href="#Rc-class">senza membri privati</a></li>
<li><code>template</code>: <a href="#Rt-raise">astrazioni</a> – <a href="#Rt-cont">contenitori</a> – <a href="#Rt-concepts">concetti</a></li>
<li><code>unsigned</code>: <a href="#Res-mix">e signed</a> – <a href="#Res-unsigned">manipolazione dei bit</a></li>
<li><code>virtual</code>: <a href="#Ri-abstract">interfacce</a> – <a href="#Rc-concrete">non <code>virtual</code></a> – <a href="#Rc-dtor-virtual">distruttore</a> – <a href="#Rc-dtor-fail">mai fallire</a></li>
</ul>
<p>Potete vedere le bozze dei progetti usati per esprimere le regole:</p>
<ul>
<li>assertion: ???</li>
<li>error: ???</li>
<li>eccezione: garanzia di eccezione (???)</li>
<li>failure: ???</li>
<li>invariante: ???</li>
<li>leak: ???</li>
<li>libreria: ???</li>
<li>precondizione: ???</li>
<li>post-condizione: ???</li>
<li>risorsa: ???</li>
</ul>
<h1 id="sommario"><a name="S-abstract"></a>Sommario</h1>
<p>Questo documento è un insieme di linee-guida sul buon uso del C++. Lo scopo delle linee-guida è quello di aiutare le persone ad usare il C++ moderno in modo efficace. Per “C++ moderno” si intende l’uso efficace del C++ standard ISO (attualmente C++17, ma quasi tutte le raccomandazioni si applicano anche al C++14 e al C++11). In altre parole, come si vorreste che fosse il vostro codice tra 5 anni, potendo iniziare da adesso? Tra 10 anni?</p>
<p>Le linee-guida si concentrano sulle questioni di livello relativamente più alto, come le interfacce, la gestione delle risorse, la gestione della memorie e la concorrenza. Queste regole riguardano l’applicazione dell’architettura e il design della libreria. Seguire le regole porterà ad un codice staticamente type-safe, senza leak [perdite] di risorse, e che intercetta molti più errori logici di programmazione di quanto avvenga nel normale codice oggi. E girerà velocemente – ci si può permettere di fare le cose nel modo giusto.</p>
<p>Ci occupiamo un po’ meno dei problemi di basso livello, come le convenzioni sui nomi e lo stile di indentazione. Tuttavia, niente di ciò che può aiutare il programmatore è fuori luogo.</p>
<p>Il nostro gruppo iniziale di regole enfatizza la sicurezza (sotto varie forme) e la semplicità. Potrebbero essere anche troppo severe. Ci aspettiamo di dover introdurre più eccezioni per venire meglio incontro alle esigenze del mondo reale. Abbiamo bisogno anche di più regole.</p>
<p>Troverete alcune delle regole contrarie alle vostre aspettative e persino contrarie alla vostra esperienza. Se non vi abbiamo suggerito di modificare in alcun modo di cambiare lo stile del vostro codice, abbiamo fallito! Provate a verificare o confutare le regole! In particolare, vorremmo davvero avere su alcune nostre regole un sostegno con misure ed esempi migliori.</p>
<p>Troverete alcune regole ovvie o addirittura banali. Ricordate che lo scopo di una linea-guida è quello di aiutare qualcuno che ha meno esperienza o che proviene da un diverso background o da un diverso linguaggio a mettersi al passo.</p>
<p>Molte delle regole sono progettate per essere supportate da uno tool di analisi. Le violazioni delle regole verranno contrassegnate con riferimenti (o link) alla regola violata. Non ci aspettiamo che memorizziate tutte le regole senza aver prima provato a scrivere il codice. Un modo di pensare a queste linee-guida è come a una specifica per dei tool leggibile dagli umani.</p>
<p>Le regole sono pensate per un introduzione graduale su una base di codice. Per questo abbiamo in programma la realizzazione di tool e speriamo che anche altri lo facciano.</p>
<p>I commenti e i suggerimenti per migliorare sono sempre benvenuti. Si prevede di modificare ed estendere questo documento man mano che migliorano la nostra comprensione, il linguaggio e l’insieme delle librerie disponibili.</p>
<h1 id="in-introduzione"><a name="S-introduction"></a>In: Introduzione</h1>
<p>Questa è una serie di linee-guida basilari per il C++ moderno (attualmente C++17) che tengono conto sia dei possibili futuri miglioramenti che dell’ ISO Technical Specifications (TSs). L’obiettivo è quello di aiutare i programmatori C++ a scrivere codice più semplice, più efficiente e più manutenibile.</p>
<p>Sommario dell’introduzione:</p>
<ul>
<li><a href="#SS-readers">In.target: Chi sono i lettori?</a></li>
<li><a href="#SS-aims">In.aims: Obiettivi</a></li>
<li><a href="#SS-non">In.not: Non-obiettivi</a></li>
<li><a href="#SS-force">In.force: Imposizione</a></li>
<li><a href="#SS-struct">In.struct: La struttura di questo documento</a></li>
<li><a href="#SS-sec">In.sec: Sezioni principali</a></li>
</ul>
<h2 id="in.target-chi-sono-i-lettori"><a name="SS-readers"></a>In.target: Chi sono i lettori?</h2>
<p>Tutti i programmatori C++. Tra cui <a href="#S-cpl">i programmatori che potrebbero prendere in considerazione il C</a>.</p>
<h2 id="in.aims-obiettivi"><a name="SS-aims"></a>In.aims: Obiettivi</h2>
<p>Lo scopo delle linee-guida è quello di aiutare gli sviluppatori ad adottare il C++ moderno (attualmente C++17) e per ottenere uno stile più uniforme nel codice.</p>
<p>Non ci illudiamo di vedere effettivamente applicate ognuna di queste regole a qualsiasi codice. L’aggiornamento dei vecchi sistemi è difficile. Tuttavia, crediamo che un programma che usi una regola è meno soggetto ad errori e più manutenibile di uno che non lo faccia. Spesso, le regole portano anche ad uno sviluppo iniziale più veloce/facile. Per quanto sappiamo, queste regole conducono ad un codice che funziona altrettanto bene, se non meglio, di quello più vecchio, con tecniche più convenzionali; sono pensate per seguire il principio dello zero-overhead (“quello che non si usa, non si paga” e “quando si usa bene un meccanismo di astrazione, si ottengono almeno le stesse buone prestazioni di quelle col codice scritto a mano utilizzando i costrutti del linguaggio di livello più basso”). Si considerino queste regole ideali per il nuovo codice, un’opportunità da sfruttare quando si lavora su vecchio codice e si tenti di avvicinarsi il più possibile a tali ideali. Da ricordare:</p>
<h3 id="in.0-non-farsi-prendere-dal-panico"><a name="R0"></a>In.0: Non farsi prendere dal panico!</h3>
<p>Si prenda il tempo necessario per capire le implicazioni di una regola di una linea-guida per il proprio programma.</p>
<p>Queste linee-guida sono progettate secondo il principio del “sottoinsieme di un insieme” (<a href="#Stroustrup05">Stroustrup05</a>). Non definiscono semplicemente un sottoinsieme del C++ da usare (per affidabilità, prestazioni o altro). Esse, invece, raccomandano fermamente l’uso di alcune semplici “estensioni” (<a href="#S-gsl">componenti della libreria</a>) che rendono ridondanti le funzionalità più soggette ad errori del C++, in modo che possano essere vietate (nel nostro set di regole).</p>
<p>Le regole enfatizzano la sicurezza del tipo statico e la sicurezza delle risorse. Per questo motivo, enfatizzano le possibilità di controllare i range, per evitare la de-referenziazione di <code>nullptr</code>, per evitare il dangling [penzolamento] dei puntatori, e l’uso sistematico delle eccezioni (tramite il RAII). In parte per questo e in parte per minimizzare la confusione nel codice come fonte di errori, le regole enfatizzano anche la semplicità e il dover nascondere la complessità necessaria dietro interfacce ben definite.</p>
<p>Molte delle regole sono normative. Ci si trova a disagio con regole che dicono semplicemente “non fare questo!” senza dare un’alternativa. Una conseguenza di ciò è che alcune regole possono essere supportate solo dall’euristica, anziché da controlli precisi e meccanicamente verificabili. Altre regole esprimono principi generali. Per queste regole più generali, di quelle più dettagliate e specifiche, consentono un controllo parziale.</p>
<p>Queste linee-guida riguardano il nucleo [core] del C++ e il suo utilizzo. Ci si aspetta che la maggior parte delle grandi organizzazioni, delle aree di applicazione specifiche e persino dei grandi progetti necessiteranno di ulteriori regole, forse di altre restrizioni e un ulteriore supporto della libreria. Per esempio, i programmatori [hard-real-time] solitamente non possono usare liberamente il [free store] (memoria dinamica) e sono limitati nella scelta delle librerie. Noi incoraggiamo lo sviluppo di regole più specifiche da aggiungere a queste “core guidelines”. Costruite le piccole basi della vostra libreria ideale ed usatela, anziché abbassare il vostro livello di programmazione per glorificare il codice assembly.</p>
<p>Le regole sono progettate per consentirne una <a href="#S-modernizing">graduale adozione</a>.</p>
<p>Alcune regole mirano ad aumentare le varie forme di sicurezza mentre altre tendono a ridurre la probabilità di incidenti, molte fanno entrambe le cose. Le linee-guida volte alla prevenzione di incidenti spesso vietano codice C++ perfettamente legale. Tuttavia, quando ci sono due modi per esprimere un’idea e uno si è mostrato una comune fonte di errori e l’altro no, proviamo a guidare i programmatori verso quest’ultima.</p>
<h2 id="in.not-non-obiettivi"><a name="SS-non"></a>In.not: Non-obiettivi</h2>
<p>Le regole non intendono essere minime o ortogonali. In particolare, le regole generali possono essere semplici, ma impossibili da imporre. Inoltre, spesso è difficile comprendere le implicazioni di una regola generale. Regole più specializzate sono spesso più facili da capire e da applicare, ma senza regole generali formerebbero solo un lungo elenco di casi speciali. Forniamo regole volte ad aiutare i principianti così come regole a supporto degli esperti. Alcune delle regole si possono completamente imporre, ma al tre sono basate sull’euristica.</p>
<p>Queste regole non sono pensate per essere lette in sequenza, come un libro.</p>
<p>Si possono consultare usando i link. Tuttavia, il loro uso principale previsto è quello di essere usate per i tool. Cioè, un tool cerca le violazioni per poi restituire i link alle regole violate. Le regole quindi forniscono ragioni, esempi di potenziali conseguenze della violazione e suggeriscono rimedi.</p>
<p>Queste linee-guida non intendono sostituire un tutorial C++. Se serve un tutorial per un certo livello di esperienza, si vedano <a href="#S-references">le referenze</a>.</p>
<p>Questa non è una guida su come convertire del vecchio codice C++ in un codice più moderno. Essa ha lo scopo di articolare in modo concreto le idee per il codice nuovo. Tuttavia, si veda <a href="#S-modernizing">la sezione della modernizzazione</a> per alcuni possibili approcci alla modernizzazione/ringiovanimento/aggiornamento. È importante sottolineare che le regole supportano l’adozione graduale: in genere è impossibile convertire completamente una grande quantità di codice in una volta sola.</p>
<p>Queste linee guida non sono pensate per essere complete ed esatte in ogni dettaglio tecnico-linguistico. Per l’ultima parola sui problemi di definizione del linguaggio, comprese tutte le eccezioni alle regole generali e ogni funzionalità, si veda lo standard ISO del C++.</p>
<p>Le regole non sono intese per obbligare a scrivere in un sottoinsieme impoverito del C++. Esse sono <em>enfaticamente</em> non intese per definire, per esempio, un sottoinsieme simil-Java del C++. Non sono intese a definire un unico “vero linguaggio C++”. Apprezziamo espressività e prestazioni senza compromessi.</p>
<p>Le regole non sono indipendenti dal valore. Hanno lo scopo di rendere il codice più semplice e più corretto/più sicuro della maggior parte del codice C++ esistente, senza perdita di prestazioni. Hanno lo scopo di inibire del codice C++ perfettamente valido ma correlato ad errori, complessità superflua o basse prestazioni.</p>
<p>Le regole non sono precise al punto in cui una persona (o una macchina) le possa seguire ciecamente. Le parti che lo impongono cercano di farlo, ma si preferisce lasciare una regola o una definizione un po’ nel vago ed aperta all’interpretazione anziché specificare qualcosa di preciso e sbagliato. A volte, la precisione arriva solo col tempo e l’esperienza. Il progetto non è (ancora) una formalismo matematico.</p>
<p>Le regole non sono perfette. Una regola può nuocere vietando qualcosa di utile in una determinata situazione. Una regola può nuocere non riuscendo a proibire qualcosa che apre la strada ad un errore grave in una determinata situazione. Una regola può causare molti danni essendo vaga, ambigua, inapplicabile o abilitando ogni soluzione a un problema. È impossibile soddisfare completamente il criterio del “non danneggiare”. L’obiettivo, invece, è il meno ambizioso: “Fai del tuo meglio per la maggior parte dei programmatori”; se non puoi vivere con una regola, contestala, ignorala, ma non diluirla fino a farle perdere di significato. Inoltre, suggerisci un miglioramento.</p>
<h2 id="in.force-imposizione"><a name="SS-force"></a>In.force: Imposizione</h2>
<p>Le regole senza un’imposizione non sono gestibili per grandi basi di codice. L’imposizione di tutte le regole è possibile solo per un piccolo insieme di semplici regole o per una specifica comunità di utenti.</p>
<ul>
<li>Ma vogliamo molte regole e vogliamo regole che tutti possano usare..</li>
<li>Ma persone diverse hanno esigenze diverse.</li>
<li>Ma alle persone non piace leggere molte regole.</li>
<li>Ma la gente non ricorda molte regole.</li>
</ul>
<p>Quindi, abbiamo bisogno di una suddivisione per soddisfare le tante esigenze.</p>
<ul>
<li>Ma una suddivisione arbitraria porta al caos.</li>
</ul>
<p>Vogliamo linee-guida che aiutino molte persone, rendano il codice più uniforme e incoraggino fortemente le persone a modernizzare il loro codice. Vogliamo incoraggiare le migliori pratiche, anziché lasciare tutto alle scelte individuali e alle pressioni del management. L’ideale è usare tutte le regole; questo porta i maggiori benefici.</p>
<p>Questo aggiunge parecchi interrogativi. Cerchiamo di risolvere quelli che utilizzano i tool. Ogni regola ha una sezione <strong>Imposizione</strong> che elenca le idee per imporla. L’imposizione si può ottenere con la revisione del codice, l’analisi statica, col compilatore o con dei controlli durante l’esecuzione. Ove possibile, preferiamo il controllo “meccanico” (gli umani sono lenti, inaccurati e si annoiano facilmente) e quello statico. I controlli a run-time vengono suggeriti raramente dove non esiste un’alternativa; non vogliamo sparpagliare controlli a casaccio. Se opportuno, etichettiamo una regola (nelle sezioni <strong>Imposizione</strong>) col nome di gruppi di regole correlate (dette “profili”). Una regola può far parte di più profili o di nessuno. Per cominciare, abbiamo alcuni profili corrispondenti ai bisogni comuni (desideri, ideali):</p>
<ul>
<li><strong>type</strong>: Nessuna violazione del tipo (reinterpretando una <code>T</code> come una <code>U</code> tramite i cast, le union o le vararg)</li>
<li><strong>bounds</strong>: Nessuna violazione dei limiti [bound] (accedere oltre il range di un array)</li>
<li><strong>lifetime</strong>: Nessun leak (non riuscire ad eseguire un <code>delete</code> o eseguire <code>delete</code> multipli) e nessun accesso ad oggetti invalidi (de-referenziazione di <code>nullptr</code>, usando un riferimento dangling [penzolante]).</li>
</ul>
<p>I profili sono intesi per essere utilizzati dai tool, ma servono anche come aiuto per il lettore umano. Non limitiamo il nostro commento nelle sezioni <strong>Imposizione</strong> alle cose che sappiamo come imporre; alcuni commenti sono semplici desideri che potrebbero ispirare qualche produttore di tool.</p>
<p>I tool che implementano queste regole devono rispettare la sintassi seguente per sopprimere esplicitamente una regola:</p>
<pre><code>[[gsl::suppress(tag)]]</code></pre>
<p>dove “tag” è il nome identificativo [anchor name] dell’elemento in cui appare la regola di Imposizione (p.es., per <a href="#Rh-public">C.134</a> è “Rh-public”), il nome di un profilo gruppo-di-regole (“type”, “bounds”, o “lifetime”), o una specifica regola di un profilo (<a href="#Pro-type-cstylecast">type.4</a>, o <a href="#Pro-bounds-arrayindex">bounds.2</a>).</p>
<h2 id="in.struct-la-struttura-di-questo-documento"><a name="SS-struct"></a>In.struct: La struttura di questo documento</h2>
<p>Ogni regola (linea-guida, suggerimento) può avere diverse parti:</p>
<ul>
<li>La regola stessa – p.es., <strong>nessun semplice <code>new</code></strong></li>
<li>Un numero di riferimento alla regola – p.es., <strong>C.7</strong> (la regola 7 relativa alle classi). Poiché le sezioni principali non sono intrinsecamente ordinate, utilizziamo le lettere come prima parte del “numero” di riferimento della regola. Lasciamo dei salti nella numerazione per ridurre al minimo le “interruzioni” nell’aggiungere o rimuovere regole.</li>
<li><strong>Motivi</strong> (ragioni, razionale, logica) – perché i programmatori hanno difficoltà a seguire regole che non capiscono</li>
<li><strong>Esempi</strong> – perché le regole sono difficili da capire in astratto; può essere positivo o negativo</li>
<li><strong>Alternative</strong> – per le regole “non farlo”</li>
<li><strong>Eccezioni</strong> – preferiamo semplici regole generali. Tuttavia, molte regole si applicano ampiamente, ma non universalmente, quindi è necessario elencare le eccezioni</li>
<li><strong>Enforcement</strong> <a href="#imposizione-408">Imposizione</a> – idee su come la regola potrebbe essere controllata “meccanicamente”</li>
<li><strong>See also</strong> [Vedi anche] – riferimenti a regole correlate e/o ulteriori discussioni (in questo documento o altrove)</li>
<li><strong>Note</strong> (commenti) – qualcosa che deve essere detto che non rientra nelle altre classificazioni</li>
<li><strong>Discussion</strong> – riferimenti a motivazioni più ampie e/o esempi posti al di fuori delle liste principali di regole</li>
</ul>
<p>Alcune regole sono difficili da verificare meccanicamente, ma tutte soddisfano i criteri minimi con cui un esperto programmatore possa individuare molte violazioni senza troppi problemi. Noi speriamo che i tool “meccanici” migliorino col tempo per approssimare quello che nota un programmatore esperto. Assumiamo, inoltre, che le regole vengano perfezionate nel tempo per renderle più precise e verificabili.</p>
<p>Una regola mira ad essere semplice, piuttosto che ben formulata per menzionare ogni caso alternativo e quelli speciali. Tali informazioni si trovano nelle sezioni <strong>Alternative</strong> e nelle sezioni <a href="#S-discussion">Discussion</a>. Se non si capisce una regola o non la si condivide, se ne visiti la <strong>Discussione</strong>e. Se si ritiene che manchi una discussione o che sia incompleta, si inserisce un <a href="https://github.com/isocpp/CppCoreGuidelines/issues">Issue</a> [problema] spiegando le proprie motivazioni e possibilmente un corrispondente PR [Pull Request].</p>
<p>Gli esempi sono scritti per illustrare le regole.</p>
<ul>
<li>Gli esempi non pretendono di avere una qualità da produzione né intendono sostituire i vari tutorial. Per esempio, molti esempi sono tecnico-linguistici ed usano nomi come <code>f</code>, <code>base</code>, o <code>x</code>.</li>
<li>Cerchiamo di assicurarci che i “buoni” esempi seguano le “Core Guidelines”.</li>
<li>I commenti che illustrano le regole spesso sarebbero inutili e/o distraenti in un “codice reale”.</li>
<li>Presupponiamo la conoscenza della libreria standard. Per esempio, usiamo il semplice <code>vector</code> anziché <code>std::vector</code>.</li>
</ul>
<p>Questo non è un manuale del linguaggio. È pensato per essere utile, oltre che completo, molto accurato sui dettagli tecnici, o una guida al codice esistente. Le fonti di informazioni consigliate sono disponibili nel<a href="#S-references">le referenze</a>.</p>
<h2 id="in.sec-sezioni-principali"><a name="SS-sec"></a>In.sec: Sezioni principali</h2>
<ul>
<li><a href="#S-introduction">In: Introduzione</a></li>
<li><a href="#S-philosophy">P: Filosofia</a></li>
<li><a href="#S-interfaces">I: Interfacce</a></li>
<li><a href="#S-functions">F: Funzioni</a></li>
<li><a href="#S-class">C: Classi e gerarchie di classi</a></li>
<li><a href="#S-enum">Enum: Enumerazioni</a></li>
<li><a href="#S-resource">R: Gestione delle risorse [Resource management]</a></li>
<li><a href="#S-expr">ES: Espressioni e istruzioni</a></li>
<li><a href="#S-performance">Per: Prestazione</a></li>
<li><a href="#S-concurrency">CP: Concorrenza e parallelismo</a></li>
<li><a href="#S-errors">E: Gestione degli errori [Error handling]</a></li>
<li><a href="#S-const">Con: Costanti e immutabilità</a></li>
<li><a href="#S-templates">T: Template e programmazione generica</a></li>
<li><a href="#S-cpl">CPL: Programmazione C-style</a></li>
<li><a href="#S-source">SF: File sorgenti [Source files]</a></li>
<li><a href="#S-stdlib">SL: La libreria Standard [Standard Library]</a></li>
</ul>
<p>Sezioni di supporto:</p>
<ul>
<li><a href="#S-A">A: Idee architetturali</a></li>
<li><a href="#S-not">NR: Non-Regole e miti</a></li>
<li><a href="#S-references">RF: Riferimenti</a></li>
<li><a href="#S-profile">Pro: Profili</a></li>
<li><a href="#S-gsl">GSL: Libreria di supporto alle linee-guida [Guidelines Support Library]</a></li>
<li><a href="#S-naming">NL: Regole di nomenclatura e layout</a></li>
<li><a href="#S-faq">FAQ: Risposte a domande frequenti</a></li>
<li><a href="#S-libraries">Appendice A: Librerie</a></li>
<li><a href="#S-modernizing">Appendice B: Modernizzazione del codice</a></li>
<li><a href="#S-discussion">Appendice C: Discussione</a></li>
<li><a href="#S-tools">Appendice D: Tool di supporto</a></li>
<li><a href="#S-glossary">Glossario</a></li>
<li><a href="#S-unclassified">To-do: Proto-regole non classificate</a></li>
</ul>
<p>Queste sezioni non sono ortogonali.</p>
<p>Ogni sezione (p.es., “P” per “Filosofia”) e ogni sottosezione (p.es., “C.hier” per “Class Hierarchies (OOP)”) ha un’abbreviazione per facilitarne la ricerca ed il riferimento. Le abbreviazioni della sezione principale sono utilizzate anche nei numeri delle regole (p.es., “C.11” per “Rendere concreti i tipi regolari”).</p>
<h1 id="p-filosofia"><a name="S-philosophy"></a>P: Filosofia</h1>
<p>Le regole in questa sezione sono molto generali.</p>
<p>Riepilogo delle regole della filosofia:</p>
<ul>
<li><a href="#Rp-direct">P.1: Esprimere le idee direttamente nel codice</a></li>
<li><a href="#Rp-Cplusplus">P.2: Scrivere in C++ Standard ISO</a></li>
<li><a href="#Rp-what">P.3: Esprimere le intenzioni</a></li>
<li><a href="#Rp-typesafe">P.4: Idealmente, un programma dovrebbe essere staticamente type safe</a></li>
<li><a href="#Rp-compile-time">P.5: Preferire il controllo durante la compilazione a quello durante l’esecuzione</a></li>
<li><a href="#Rp-run-time">P.6: Ciò che non può essere verificato in fase di compilazione dovrebbe essere verificabile in fase di esecuzione</a></li>
<li><a href="#Rp-early">P.7: Intercettare gli errori a run-time all’inizio</a></li>
<li><a href="#Rp-leak">P.8: Non perdere alcuna risorsa [leak]</a></li>
<li><a href="#Rp-waste">P.9: Non sprecare tempo o spazio</a></li>
<li><a href="#Rp-mutable">P.10: Preferire dati immutabili ai dati mutabili</a></li>
<li><a href="#Rp-library">P.11: Incapsulare costrutti disordinati, anziché distribuirli nel codice</a></li>
<li><a href="#Rp-tools">P.12: Usare tool appropriati</a></li>
<li><a href="#Rp-lib">P.13: Usare librerie di supporto appropriate</a></li>
</ul>
<p>Le regole filosofiche non sono generalmente controllabili meccanicamente. Tuttavia, sono le singole regole che riflettono questi temi filosofici. Senza una base filosofica, le regole più concrete/specifiche/verificabili mancano di logica.</p>
<h3 id="p.1-esprimere-le-idee-direttamente-nel-codice"><a name="Rp-direct"></a>P.1: Esprimere le idee direttamente nel codice</h3>
<h5 id="motivo">Motivo</h5>
<p>I compilatori non leggono i commenti (né i documenti dei progetti) e nemmeno molti programmatori (coerentemente). Ciò che è espresso nel codice ne ha definito la semantica e (in linea di principio) può essere verificato da compilatori e altri strumenti.</p>
<h5 id="esempio">Esempio</h5>
<pre><code>class Date {
public:
Month month() const;  // ok
int month();          // da non fare
// ...
};</code></pre>
<p>La prima dichiarazione di <code>month</code> è esplicita sul fatto che restituisce un <code>Month</code> e che non modifica lo stato dell’oggetto <code>Date</code>. La seconda versione lascia indovinare al lettore e si espone a più possibilità di bug non rilevati.</p>
<h5 id="esempio-cattivo">Esempio, cattivo</h5>
<p>Questo loop è una versione ridotta di <code>std::find</code>:</p>
<pre><code>void f(vector&lt;string&gt;&amp; v)
{
string val;
cin &gt;&gt; val;
// ...
int index = -1;                    // male, inoltre dovrebbe usare gsl::index
for (int i = 0; i &lt; v.size(); ++i) {
if (v[i] == val) {
index = i;
break;
}
}
// ...
}</code></pre>
<h5 id="esempio-buono">Esempio, buono</h5>
<p>Un’espressione di intenti molto più chiara sarebbe:</p>
<pre><code>void f(vector&lt;string&gt;&amp; v)
{
string val;
cin &gt;&gt; val;
// ...
auto p = find(begin(v), end(v), val);  // meglio
// ...
}</code></pre>
<p>Una libreria ben progettata esprime l’intento (cosa si deve fare, piuttosto che come si sta facendo qualcosa) molto meglio dell’uso diretto delle funzionalità del linguaggio.</p>
<p>Un programmatore C++ dovrebbe conoscere le basi della libreria standard e usarla dove appropriato. Qualsiasi programmatore dovrebbe conoscere le basi delle librerie fondamentali del progetto su cui si sta lavorando e usarle in modo appropriato. Qualsiasi programmatore che utilizza queste linee-guida deve conoscere la <a href="#S-gsl">guidelines support library</a> [Libreria di Supporto delle linee-guida], e usarla in modo appropriato.</p>
<h5 id="esempio-1">Esempio</h5>
<pre><code>change_speed(double s);   // male: cosa significa s?
// ...
change_speed(2.3);</code></pre>
<p>Un approccio migliore deve essere esplicito sul significato del double (nuova velocità o delta rispetto alla velocità precedente?) e all’unità di misura usata:</p>
<pre><code>change_speed(Speed s);    // meglio: il significato di s è specificato
// ...
change_speed(2.3);        // errore: nessuna unità
change_speed(23m / 10s);  // metri al secondo</code></pre>
<p>Avremmo potuto accettare un semplice <code>double</code> (senza unità di misura) come delta, ma sarebbe stato soggetto a errori. Se avessimo voluto sia la velocità assoluta che i delta, avremmo definito un tipo <code>Delta</code>.</p>
<h5 id="imposizione">Imposizione</h5>
<p>In generale molto difficile.</p>
<ul>
<li>usare <code>const</code> in modo coerente (controllare se le funzioni membro modificano il loro oggetto; controllare se le funzioni modificano gli argomenti passati per puntatore o per riferimento)</li>
<li>scarso uso dei cast (cast di sistema di tipo neutro)</li>
<li>rilevare il codice che imita la libreria standard (difficile)</li>
</ul>
<h3 id="p.2-scrivere-in-c-standard-iso"><a name="Rp-Cplusplus"></a>P.2: Scrivere in C++ Standard ISO</h3>
<h5 id="motivo-1">Motivo</h5>
<p>Questo è un insieme di linee-guida per la scrittura secondo il C++ Standard ISO.</p>
<h5 id="note">Note</h5>
<p>Esistono ambienti in cui sono necessarie estensioni, ad esempio per accedere alle risorse di sistema. In questi casi, localizzare l’uso delle estensioni necessarie e controllarne l’uso con le Coding Guidelines non-core. Se possibile, creare interfacce che incapsulino le estensioni in modo che possano essere disattivate e compilate su sistemi che non supportano tali estensioni.</p>
<p>Le estensioni spesso non hanno una semantica rigorosamente definita. Anche le estensioni comuni e implementate da più compilatori possono avere comportamenti leggermente diversi e il comportamento del caso limite come diretta conseguenza del <em>non</em> avere una definizione standard rigorosa. Con un sufficiente uso di una di queste estensioni, ci si dovrà aspettare un impatto sulla portabilità.</p>
<h5 id="note-1">Note</h5>
<p>L’uso di un C++ ISO valido non ne garantisce la portabilità (per non parlare della correttezza). Evitare la dipendenza dai comportamenti indefiniti (p.es., <a href="#Res-order">ordine di valutazione indefinito</a>) ed essere consapevoli dei costrutti con significato definito dall’implementazione (p.es., <code>sizeof(int)</code>).</p>
<h5 id="note-2">Note</h5>
<p>Esistono ambienti in cui sono necessarie restrizioni sull’uso del linguaggio C++ standard e o delle funzionalità di libreria, p.es., per evitare l’allocazione dinamica della memoria come richiesto dagli standard del software di controllo degli aerei. In questi casi, controllarne l’(ab)uso con un’estensione a queste “Coding Guidelines” personalizzate per lo specifico ambiente.</p>
<h5 id="imposizione-1">Imposizione</h5>
<p>Utilizzare un compilatore C++ aggiornato (attualmente C++17, C++14, o C++11) con una serie di opzioni che non accettano le estensioni.</p>
<h3 id="p.3-esprimere-le-intenzioni"><a name="Rp-what"></a>P.3: Esprimere le intenzioni</h3>
<h5 id="motivo-2">Motivo</h5>
<p>A meno che non venga dichiarato l’intento di parte del codice (p.es., nei nomi i nei commenti), è impossibile stabilire se il codice fa quello che dovrebbe fare.</p>
<h5 id="esempio-2">Esempio</h5>
<pre><code>gsl::index i = 0;
while (i &lt; v.size()) {
// ... fa qualcosa con v[i] ...
}</code></pre>
<p>Lo scopo del “solo” ciclare sugli elementi di <code>v</code> qui non è espresso. I dettagli di implementazione di un indice sono esposti (quindi se ne può abusare), e <code>i</code> sopravvive allo scope del ciclo, che può o meno essere voluto. Il lettore non può capire solo da questo pezzo di codice.</p>
<p>Meglio:</p>
<pre><code>for (const auto&amp; x : v) { /* fa qualcosa col valore di x */ }</code></pre>
<p>Ora, non vi è alcuna menzione esplicita del meccanismo di iterazione e il ciclo opera su un riferimento <code>const</code> agli elementi in modo che non possano verificarsi modifiche accidentali. Se si desidera la modifica, si scrive così:</p>
<pre><code>for (auto&amp; x : v) { /* modifica x */ }</code></pre>
<p>Per ulteriori dettagli dell’istruzione fo, cfr. <a href="#Res-for-range">ES.71</a>. Talvolta è meglio usare un algoritmo predefinito con nome significativo. Questo esempio usa il <code>for_each</code> per i Range TS perché esprime direttamente lo scopo:</p>
<pre><code>for_each(v, [](int x) { /* fa qualcosa col valore di x */ });
for_each(par, v, [](int x) { /* fa qualcosa col valore di x */ });</code></pre>
<p>L’ultima variante chiarisce che non si è interessati all’ordine con cui vengono gestiti gli elementi di <code>v</code>.</p>
<p>Un programmatore dovrebbe avere familiarità con</p>
<ul>
<li><a href="#S-gsl">La libreria di supporto alle linee-guida [Guidelines support library]</a></li>
<li><a href="#S-stdlib">La Libreria Standard del C++ ISO</a></li>
<li>Qualunque libreria fondamentale si usi nel progetto corrente</li>
</ul>
<h5 id="note-3">Note</h5>
<p>Formula alternativa: dire cosa dovrebbe essere fatto, anziché solamente come lo si dovrebbe fare.</p>
<h5 id="note-4">Note</h5>
<p>Alcuni costrutti del linguaggio esprimono le intenzioni meglio di altri.</p>
<h5 id="esempio-3">Esempio</h5>
<p>Se due <code>int</code> sono pensati per rappresentare le coordinate di un punto 2D, lo si dica:</p>
<pre><code>draw_line(int, int, int, int);  // oscuro
draw_line(Point, Point);        // più chiaro</code></pre>
<h5 id="imposizione-2">Imposizione</h5>
<p>Cercare schemi comuni per i quali esistono alternative migliori</p>
<ul>
<li>semplici cicli <code>for</code> rispetto ai cicli range-<code>for</code></li>
<li>interfacce <code>f(T*, int)</code> rispetto a interfacce <code>f(span&lt;T&gt;)</code></li>
<li>variabili dei loop in uno scope troppo ampio</li>
<li>direttamente <code>new</code> e <code>delete</code></li>
<li>funzioni con molti parametri di tipi nativi</li>
</ul>
<p>Vi è un ampio margine per l’intelligenza e una trasformazione semi-automatica del programma.</p>
<h3 id="p.4-idealmente-un-programma-dovrebbe-essere-staticamente-type-safe"><a name="Rp-typesafe"></a>P.4: Idealmente, un programma dovrebbe essere staticamente type safe</h3>
<h5 id="motivo-3">Motivo</h5>
<p>Idealmente, un programma dovrebbe essere completamente staticamente (durante la compilazione) type safe. Sfortunatamente, ciò non è possibile. Le aree problematiche sono:</p>
<ul>
<li>union</li>
<li>cast</li>
<li>decadimento di array [array decay]</li>
<li>errori dei range</li>
<li>Conversioni con riduzione [narrowing conversions]</li>
</ul>
<h5 id="note-5">Note</h5>
<p>Queste aree sono fonte di gravi problemi (p.es., crash e violazioni della sicurezza). Cerchiamo di fornire tecniche alternative.</p>
<h5 id="imposizione-3">Imposizione</h5>
<p>Possiamo vietare, limitare o rilevare le singole categorie di problemi separatamente, come richiesto e fattibile per i singoli programmi. Suggerire sempre un’alternativa. Per esempio:</p>
<ul>
<li>unioni – usare il <code>variant</code> (in C++17)</li>
<li>cast – minimizzarne l’uso; i template possono aiutare</li>
<li>array decay – usare <code>span</code> (dalle GSL)</li>
<li>errori range – usare <code>span</code></li>
<li>conversioni narrowing – minimizzarne l’uso utilizzando <code>narrow</code> o <code>narrow_cast</code> (dalle GSL) dove sono necessarie</li>
</ul>
<h3 id="p.5-preferire-il-controllo-durante-la-compilazione-a-quello-durante-lesecuzione"><a name="Rp-compile-time"></a>P.5: Preferire il controllo durante la compilazione a quello durante l’esecuzione</h3>
<h5 id="motivo-4">Motivo</h5>
<p>Chiarezza del codice e prestazioni. Non è necessario scrivere error handler per gli errori rilevati durante la compilazione.</p>
<h5 id="esempio-4">Esempio</h5>
<pre><code>// Int è un alias per gli interi
int bits = 0;         // da non fare: codice evitabile
for (Int i = 1; i; i &lt;&lt;= 1)
++bits;
if (bits &lt; 32)
cerr &lt;&lt; &quot;Int troppo piccolo\n&quot;;</code></pre>
<p>Questo esempio non riesce a fare ciò che sta cercando di fare (perché l’overflow è indefinito) e lo si dovrebbe sostituire un semplice <code>static_assert</code>:</p>
<pre><code>// Int è un alias per gli interi
static_assert(sizeof(Int) &gt;= 4);    // ok: check in fase di compilazione</code></pre>
<p>O, meglio ancora, basta usare il sistema dei tipi e sostituire <code>Int</code> con <code>int32_t</code>.</p>
<h5 id="esempio-5">Esempio</h5>
<pre><code>void read(int* p, int n);   // legge massimo n interi in *p

int a[100];
read(a, 1000);    // male, oltre la fine</code></pre>
<p>Meglio</p>
<pre><code>void read(span&lt;int&gt; r); // legge nell&#39;intervallo [range] degli interi r

int a[100];
read(a);        // meglio: lascia al compilatore la deduzione del numero di elementi</code></pre>
<p><strong>Formula alternativa</strong>: Non rimandare al tempo dell’esecuzione ciò che si può fare bene in fase di compilazione.</p>
<h5 id="imposizione-4">Imposizione</h5>
<ul>
<li>Cercare gli argomenti puntatori.</li>
<li>Cercare i check a run-time per le violazioni di range.</li>
</ul>
<h3 id="p.6-ciò-che-non-può-essere-verificato-in-fase-di-compilazione-dovrebbe-essere-verificabile-in-fase-di-esecuzione"><a name="Rp-run-time"></a>P.6: Ciò che non può essere verificato in fase di compilazione dovrebbe essere verificabile in fase di esecuzione</h3>
<h5 id="motivo-5">Motivo</h5>
<p>Lasciare errori difficili-da-rilevare in un programma espone a crash e risultati sbagliati.</p>
<h5 id="note-6">Note</h5>
<p>Idealmente, si rilevano tutti gli errori (quelli che non sono errori logici del programmatore) in fase di compilazione o di esecuzione. È impossibile rilevare tutti gli errori in fase di compilazione e spesso non è conveniente rilevare tutti gli altri errori in fase di esecuzione. Tuttavia, si dovrebbe cercare di scrivere programmi che in linea di principio possano essere controllati, con sufficienti risorse (programmi di analisi, controlli a run-time, risorse-macchina, tempo).</p>
<h5 id="esempio-cattivo-1">Esempio, cattivo</h5>
<pre><code>// compilato separatamente, possibilmente caricato dinamicamente
extern void f(int* p);

void g(int n)
{
// male: il numero di elementi non viene passato a f()
f(new int[n]);
}</code></pre>
<p>Quì, una parte cruciale delle informazioni (il numero degli elementi) è stato così accuratamente “oscurato” che l’analisi statica probabilmente non lo rileva e il controllo dinamico può risultare difficile quando <code>f()</code> è parte di un ABI [Application Binary Interface] che non fa “esaminare” questo puntatore. Si potrebbero includere informazioni utili nel [free store], ma richiederebbe modifiche globali e forse al compilatore. Quello che abbiamo qui è un progetto che rende molto difficile il rilevamento degli errori.</p>
<h5 id="esempio-cattivo-2">Esempio, cattivo</h5>
<p>Ovviamente si può passare il numero di elementi insieme al puntatore:</p>
<pre><code>// compilato separatamente, possibilmente caricato dinamicamente
extern void f2(int* p, int n);

void g2(int n)
{
f2(new int[n], m);  //male: il numero di elementi non viene passato a f()
}</code></pre>
<p>Passare il numero di elementi come argomento è meglio (e molto più comune) che passare solo il puntatore e fare affidamento su una convenzione (non dichiarata) per conoscere o scoprire il numero di elementi. Tuttavia (come mostrato), un semplice errore di battitura può introdurre un grave errore. La connessione tra i due argomenti di <code>f2()</code> è convenzionale, anziché esplicita.</p>
<p>Inoltre, è implicito che <code>f2()</code> dovrebbe eseguire un <code>delete</code> del suo argomento (o il chiamante a fatto un secondo errore?).</p>
<h5 id="esempio-cattivo-3">Esempio, cattivo</h5>
<p>I puntatori di gestione della libreria standard non riescono a passare la dimensione quando puntano ad un oggetto:</p>
<pre><code>// compilato separatamente, possibilmente caricato dinamicamente
// NB: questo presuppone che il codice chiamante sia compatibile ABI, con un
// compilatore C++ compatibile e la stessa implementazione di stdlib
extern void f3(unique_ptr&lt;int[]&gt;, int n);

void g3(int n)
{
f3(make_unique&lt;int[]&gt;(n), m);    // male: passa separatamente l&#39;ownership e la dimensione
}</code></pre>
<h5 id="esempio-6">Esempio</h5>
<p>Si deve passare il puntatore e il numero di elementi come un unico oggetto:</p>
<pre><code>extern void f4(vector&lt;int&gt;&amp;);   // compilato separatamente, possibilmente caricato dinamicamente
extern void f4(span&lt;int&gt;);      // compilato separatamente, possibilmente caricato dinamicamente
// NB: questo presuppone che il codice chiamante sia compatibile ABI, con un
// compilatore C++ compatibile e la stessa implementazione di stdlib implementation

void g3(int n)
{
vector&lt;int&gt; v(n);
f4(v);                     // passa un riferimento, conserva l&#39;ownership
f4(span&lt;int&gt;{v});          // passa una vista, conserva l&#39;ownership
}</code></pre>
<p>Questo progetto porta il numero di elementi come parte integrata di un oggetto, quindi gli errori sono improbabili e il controllo dinamico (a run-time) è sempre possibile, se non sempre conveniente.</p>
<h5 id="esempio-7">Esempio</h5>
<p>Come possiamo trasferire sia l’ownership assieme a tutte le informazioni necessarie a validarne l’uso?</p>
<pre><code>vector&lt;int&gt; f5(int n)    // OK: move
{
vector&lt;int&gt; v(n);
// ... inizializza v ...
return v;
}

unique_ptr&lt;int[]&gt; f6(int n)    // male: perde n
{
auto p = make_unique&lt;int[]&gt;(n);
// ... inizializza *p ...
return p;
}

owner&lt;int*&gt; f7(int n)    // male: perde n e ci potremmo dimenticare di eseguire il delete
{
owner&lt;int*&gt; p = new int[n];
// ... inizializza *p ...
return p;
}</code></pre>
<h5 id="esempio-8">Esempio</h5>
<ul>
<li>???</li>
<li>mostrare come dei possibili check sono evitati dalle interfacce che passano classi base polimorfiche, quando in effetti sanno di cosa hanno bisogno? O le stringhe come opzioni “free-style”</li>
</ul>
<h5 id="imposizione-5">Imposizione</h5>
<ul>
<li>Segnalare interfacce di tipo (puntatore, conteggio) (ciò evidenzierà un sacco di esempi che non si possono aggiustare per una questione di compatibilità)</li>
<li>???</li>
</ul>
<h3 id="p.7-rilevamento-degli-errori-a-run-time-allinizio"><a name="Rp-early"></a>P.7: Rilevamento degli errori a run-time all’inizio</h3>
<h5 id="motivo-6">Motivo</h5>
<p>Evita i “misteriosi” crash. Evitare errori che portano a risultati sbagliati (forse non riconosciuti).</p>
<h5 id="esempio-9">Esempio</h5>
<pre><code>void increment1(int* p, int n)    // male: soggetto a errori
{
for (int i = 0; i &lt; n; ++i) ++p[i];
}

void use1(int m)
{
const int n = 10;
int a[n] = {};
// ...
increment1(a, m);   // forse un refuso, forse si suppone m &lt;= n
// ma supponiamo che m == 20
// ...
}</code></pre>
<p>Qui abbiamo fatto un piccolo errore in <code>use1</code> che porterà a dei dati corrotti o a un crash. L’interfaccia di tipo (puntatore, conteggio) lascia <code>increment1()</code> senza un modo realistico per potersi difendere da errori out-of-range. Se si potessero controllare gli indici per l’accesso oltre i limiti, allora l’errore non verrebbe scoperto finché non si accede a <code>p[10]</code>. Si potrebbe controllare in anticipo migliorando il codice:</p>
<pre><code>void increment2(span&lt;int&gt; p)
{
for (int&amp; x : p) ++x;
}

void use2(int m)
{
const int n = 10;
int a[n] = {};
// ...
increment2({a, m});    // forse un refuso, forse si suppone m &lt;= n
// ...
}</code></pre>
<p>Ora, <code>m &lt;= n</code> si può verificare nel punto della chiamata (in anticipo) anziché dopo. Se fosse stato solo un errore di battitura intendendo usare <code>n</code> come limite, il codice si potrebbe ulteriormente semplificare (eliminando la possibilità di un errore):</p>
<pre><code>void use3(int m)
{
const int n = 10;
int a[n] = {};
// ...
increment2(a);   // non è necessario ripetere il numero degli elementi
// ...
}</code></pre>
<h5 id="esempio-cattivo-4">Esempio, cattivo</h5>
<p>Non controllare ripetutamente lo stesso valore. Non passare dati strutturati come stringhe:</p>
<pre><code>Date read_date(istream&amp; is);    // legge la data da istream

Date extract_date(const string&amp; s);    // estrae la data dalla stringa

void user1(const string&amp; date)    // manipola la data
{
auto d = extract_date(date);
// ...
}

void user2()
{
Date d = read_date(cin);
// ...
user1(d.to_string());
// ...
}</code></pre>
<p>La data viene validata due volte (dal costruttore <code>Date</code>) e passata come stringa di caratteri (dati non strutturati).</p>
<h5 id="esempio-10">Esempio</h5>
<p>L’eccesso di controlli può essere costoso. Ci sono casi in cui il controllo anticipato è stupido perché si potrebbe non aver mai bisogno del valore, o potrebbe servire solo una parte del valore che è più facile da testare rispetto all’intero valore. Allo stesso modo, non aggiungere controlli di validità che cambiano il comportamento asintotico della propria interfaccia (p.es., non aggiungere un check <code>O(n)</code> ad un’interfaccia con una complessità media di <code>O(1)</code>).</p>
<pre><code>class Jet {    // La fisica dice: e * e &lt; x * x + y * y + z * z
float x;
float y;
float z;
float e;
public:
Jet(float x, float y, float z, float e)
:x(x), y(y), z(z), e(e)
{
// Si dovrebbe controllare quì che i valori siano fisicamente significativi?
}

float m() const
{
// Si deve gestire quì il caso degenere?
return sqrt(x * x + y * y + z * z - e * e);
}

???
};</code></pre>
<p>La legge fisica per un jet (<code>e * e &lt; x * x + y * y + z * z</code>) non è un’invariante a causa della possibilità di errori di misura.</p>
<p>???</p>
<h5 id="imposizione-6">Imposizione</h5>
<ul>
<li>Cercare puntatori ed array: Eseguire un preventivo controllo del range e non ripetutamente</li>
<li>Cercare le conversioni: Eliminare o segnare le conversioni [narrowing]</li>
<li>Cercare i valori non controllati provenienti dall’input</li>
<li>Cercare i dati strutturati (oggetti o classi con degli invarianti) che vengono convertiti in stringhe</li>
<li>???</li>
</ul>
<h3 id="p.8-non-perdere-alcuna-risorsa-leak"><a name="Rp-leak"></a>P.8: Non perdere alcuna risorsa [leak]</h3>
<h5 id="motivo-7">Motivo</h5>
<p>Anche una crescita lenta delle risorse, col tempo, ne esaurirà la disponibilità. Questo è particolarmente importante per i programmi che girano a lungo, ma è un elemento essenziale del comportamento responsabile della programmazione.</p>
<h5 id="esempio-cattivo-5">Esempio, cattivo</h5>
<pre><code>void f(char* name)
{
FILE* input = fopen(name, &quot;r&quot;);
// ...
if (something) return;   // male: se something == true, si perde l&#39;handle di un file
// ...
fclose(input);
}</code></pre>
<p>Preferire il <a href="#Rr-raii">RAII</a>:</p>
<pre><code>void f(char* name)
{
ifstream input {name};
// ...
if (something) return;   // OK: nessun leak
// ...
}</code></pre>
<p><strong>Si veda anche</strong>: <a href="#S-resource">la sezione Gestione delle risorse</a></p>
<h5 id="note-7">Note</h5>
<p>Un leak è colloquialmente “qualsiasi cosa che non viene pulito”. La classificazione più importante è “tutto ciò che non può più essere ripulito”. Per esempio, allocare un oggetto sull’heap e poi perdere l’ultimo puntatore che punta a tale allocazione. Questa regola non dovrebbe essere presa come obbligatoria, perché tutte le allocazioni di oggetti di lunga durata devono essere restituite alla chiusura del programma. Per esempio, affidarsi al cleanup garantito dal sistema, come la chiusura del file o la deallocazione della memoria all’arresto del processo, può semplificare il codice. Tuttavia, fare affidamento su astrazioni che ripuliscono implicitamente può essere altrettanto semplice e spesso più sicuro.</p>
<h5 id="note-8">Note</h5>
<p>Imporre <a href="#SS-lifetime">il profilo di sicurezza a tutto il ciclo di vita</a> elimina i leak. Se combinato con la sicurezza delle risorse fornita dal <a href="#Rr-raii">RAII</a>, elimina la necessità di “garbage collection” (non generando garbage [immondizia]). Combinarlo con l’applicazione dei <a href="#SS-force">profili di tipo e bound</a> ottenendo una completa sicurezza di tipo e risorse, garantita dai tool.</p>
<h5 id="imposizione-7">Imposizione</h5>
<ul>
<li>Cercare i puntatori: Classificarli in non-owner (il default) e owner. Laddove possibile, sostituire gli owner con handle di risorse della libreria standard (come nell’esempio precedente). In alternativa, contrassegnare un owner come tale utilizzando <code>owner</code> della <a href="#S-gsl">GSL</a>.</li>
<li>Cercare i [naked] <code>new</code> e <code>delete</code></li>
<li>Cercare le funzioni note di allocazione delle risorse che restituiscono puntatori [raw] (come <code>fopen</code>, <code>malloc</code>, e <code>strdup</code>)</li>
</ul>
<h3 id="p.9-non-sprecare-tempo-o-spazio"><a name="Rp-waste"></a>P.9: Non sprecare tempo o spazio</h3>
<h5 id="motivo-8">Motivo</h5>
<p>Questo è il C++.</p>
<h5 id="note-9">Note</h5>
<p>Il tempo e lo spazio spesi bene per raggiungere un obiettivo (p.es., rapidità nello sviluppo, sicurezza delle risorse, o semplificazione dei test) non vengono persi. “Un altro vantaggio della ricerca dell’efficienza è che il processo costringe a comprendere il problema in modo più approfondito”. - Alex Stepanov</p>
<h5 id="esempio-cattivo-6">Esempio, cattivo</h5>
<pre><code>struct X {
char ch;
int i;
string s;
char ch2;

X&amp; operator=(const X&amp; a);
X(const X&amp;);
};

X waste(const char* p)
{
if (!p) throw Nullptr_error{};
int n = strlen(p);
auto buf = new char[n];
if (!buf) throw Allocation_error{};
for (int i = 0; i &lt; n; ++i) buf[i] = p[i];
// ... manipola il buffer ...
X x;
x.ch = &#39;a&#39;;
x.s = string(n);    // da a x.s spazio per *p
for (gsl::index i = 0; i &lt; x.s.size(); ++i) x.s[i] = buf[i];  // copia buf in x.s
delete[] buf;
return x;
}

void driver()
{
X x = waste(&quot;Argomento tipico&quot;);
// ...
}</code></pre>
<p>Sì, questa è una caricatura, ma abbiamo visto ogni singolo errore nel codice di produzione, e anche peggio. Si noti che il layout di <code>X</code> garantisce la perdita di almeno 6 byte (e molto probabilmente di più). La definizione spuria delle operazioni di copia disabilita la semantica del move rallentando l’operazione di ritorno (si noti che il Return Value Optimization [Ottimizzazione del Valore di Ritorno], RVO, quì non è garantita). L’uso di <code>new</code> e <code>delete</code> per <code>buf</code> è ridondante; se c’è davvero bisogno di una stringa locale, si dovrebbe usare una <code>string</code>. Ci sono molti altri bug prestazionali e complicazioni gratuite.</p>
<h5 id="esempio-cattivo-7">Esempio, cattivo</h5>
<pre><code>void lower(zstring s)
{
for (int i = 0; i &lt; strlen(s); ++i) s[i] = tolower(s[i]);
}</code></pre>
<p>Questo è in effetti un esempio di un codice di produzione. Possiamo vedere che nelle nostre condizioni abbiamo <code>i &lt; strlen(s)</code>. Questa espressione verrà valutata su ogni iterazione del ciclo, il che significa che <code>strlen</code> deve scorrere la stringa in ogni ciclo per scoprirne la lunghezza. Mentre il contenuto della stringa cambia, si presume che <code>toLower</code> non ne influenzerà la lunghezza, quindi è meglio memorizzare nella cache la lunghezza all’esterno del ciclo e non sostenere il costo di ogni iterazione.</p>
<h5 id="note-10">Note</h5>
<p>Un singolo esempio di spreco è raramente significativo e, laddove lo fosse, viene in genere facilmente eliminato da un esperto. Tuttavia, gli sprechi diffusi su tutto il codice possono diventare facilmente significativi e gli esperti non sono sempre disponibili come si vorrebbe. Lo scopo di questa regola (e le regole più specifiche che la supportano) è quello di eliminare la maggior parte de sprechi sull’uso del C++ prima che avvengano. Successivamente, si possono esaminare gli sprechi relativi agli algoritmi e ai requisiti, ma questo va oltre lo scopo di queste linee-guida.</p>
<h5 id="imposizione-8">Imposizione</h5>
<p>Molte regole più specifiche mirano agli obiettivi generali della semplicità e dell’eliminazione di sprechi.</p>
<ul>
<li>Contrassegnare un valore di ritorno inutilizzato da una funzione postfix definita dall’utente e senza default <code>operator++</code> o <code>operator--</code>. Preferire invece l’uso della forma prefissa. (Nota: Per “definita dall’utente e senza default” ha lo scopo di ridurre la confusione. Rivedere questa imposizione [enforcement] se si rivela ancora confusa nella pratica).</li>
</ul>
<h3 id="p.10-preferire-dati-immutabili-ai-dati-mutabili"><a name="Rp-mutable"></a>P.10: Preferire dati immutabili ai dati mutabili</h3>
<h5 id="motivo-9">Motivo</h5>
<p>È più facile ragionare sulle costanti che sulle variabili. Qualcosa di immutabile non può cambiare inaspettatamente. A volte l’immutabilità consente una migliore ottimizzazione Non si può avere un conflitto su una costante.</p>
<p>Cfr. <a href="#S-const">Con: Costanti e immutabilità</a></p>
<h3 id="p.11-incapsulare-costrutti-disordinati-anziché-distribuirli-nel-codice"><a name="Rp-library"></a>P.11: Incapsulare costrutti disordinati, anziché distribuirli nel codice</h3>
<h5 id="motivo-10">Motivo</h5>
<p>Il codice disordinato ha maggiori probabilità di nascondere bug ed è più difficile da scrivere. Una buona interfaccia è più semplice e sicura da usare. Codice disordinato e di basso livello genera più codice.</p>
<h5 id="esempio-11">Esempio</h5>
<pre><code>int sz = 100;
int* p = (int*) malloc(sizeof(int) * sz);
int count = 0;
// ...
for (;;) {
// ... leggi un int in x, esce dal loop se arriva la fine del file ...
// ... controlla che x sia valido ...
if (count == sz)
p = (int*) realloc(p, sizeof(int) * sz * 2);
p[count++] = x;
// ...
}</code></pre>
<p>Questo è di basso livello, prolisso e soggetto a errori. Per esempio, si “dimentica” di testare l’esaurimento della memoria. Invece, si potrebbe usare <code>vector</code>:</p>
<pre><code>vector&lt;int&gt; v;
v.reserve(100);
// ...
for (int x; cin &gt;&gt; x; ) {
// ... controlla che x sia valido ...
v.push_back(x);
}</code></pre>
<h5 id="note-11">Note</h5>
<p>Le librerie standard e la GSL sono esempi di questa filosofia. Ad esempio, invece di fare confusione con le matrici, le union, i cast, problemi coi cicli di vita, <code>gsl::owner</code>, ecc., che sono necessari per implementare astrazioni chiave, come <code>vector</code>, <code>span</code>, <code>lock_guard</code>, e <code>future</code>, si usano le librerie progettate ed implementate da gente con molto più tempo ed esperienza di quanto solitamente si ha. Allo stesso modo, possiamo e dobbiamo progettare e implementare librerie più specializzate, piuttosto che lasciare agli utenti (spesso a noi stessi) il compito di ottenere ripetutamente un buon codice di basso livello. Questa è una variante del <a href="#R0">principio del sottoinsieme di un insieme</a> che sta alla base di queste linee-guida.</p>
<h5 id="imposizione-9">Imposizione</h5>
<ul>
<li>Cercare il “codice disordinato” come la gestione complessa di un puntatore e casting al di fuori dell’implementazione delle astrazioni.</li>
</ul>
<h3 id="p.12-usare-tool-appropriati"><a name="Rp-tools"></a>P.12: Usare tool appropriati</h3>
<h5 id="motivo-11">Motivo</h5>
<p>Ci sono molte cose che vengono fatte meglio “dalla macchina”. I computer non si stancano né si annoiano a causa delle attività ripetitive. In genere abbiamo cose migliori da fare rispetto a svolgere ripetutamente attività di routine.</p>
<h5 id="esempio-12">Esempio</h5>
<p>Eseguire un analizzatore statico per verificare che il codice segua le linee-guida che si desidera che seguano.</p>
<h5 id="note-12">Note</h5>
<p>Cfr.</p>
<ul>
<li><a href="???">Tool di analisi statica</a></li>
<li><a href="#Rconc-tools">Tool di concorrenza</a></li>
<li><a href="???">Tool per i test</a></li>
</ul>
<p>Esistono molti altri tipi di strumenti, come repository di sorgenti, tool per la compilazione, ecc., ma questi vanno oltre lo scopo di queste linee-guida.</p>
<h5 id="note-13">Note</h5>
<p>Fare attenzione a non dipendere da catene di tool troppo elaborati o troppo specializzati. Potrebbero rendere il codice non-portabile.</p>
<h3 id="p.13-usare-librerie-di-supporto-appropriate"><a name="Rp-lib"></a>P.13: Usare librerie di supporto appropriate</h3>
<h5 id="motivo-12">Motivo</h5>
<p>L’uso di una libreria ben progettata, ben documentata e ben supportata consente di risparmiare tempo e fatica; tali qualità e documentazione sono probabilmente maggiori di quelle che si potrebbe fare se la maggior parte del tempo si dovesse impiegare in un’implementazione. Il costo(tempo, fatica, denaro, ecc.) di una libreria può essere suddiviso tra molti utenti. È più probabile che una libreria largamente utilizzata venga mantenuta aggiornata e trasferita su nuovi sistemi rispetto a una singola applicazione. La conoscenza di una biblioteca ampiamente utilizzata può far risparmiare tempo su altri/futuri progetti. Pertanto, se esiste una libreria adatta per il dominio dell’applicazione, utilizzarla.</p>
<h5 id="esempio-13">Esempio</h5>
<pre><code>std::sort(begin(v), end(v), std::greater&lt;&gt;());</code></pre>
<p>A meno che non si sia un esperto di algoritmi di ordinamento e si abbia un sacco di tempo, è più probabile che sia corretto e che funzioni più velocemente di qualsiasi cosa si scriva per un’applicazione specifica. È necessario un motivo per non utilizzare la libreria standard (o qualsiasi libreria di base utilizzata dall’applicazione) piuttosto che un motivo per utilizzarla.</p>
<h5 id="note-14">Note</h5>
<p>Per default usare</p>
<ul>
<li>La <a href="#S-stdlib">ISO C++ Standard Library</a></li>
<li>Le <a href="#S-gsl">Guidelines Support Library</a></li>
</ul>
<h5 id="note-15">Note</h5>
<p>Se non esiste una libreria ben progettata, ben documentata e ben supportata per un dominio importante, forse si dovrebbe progettarla e implementarla, per poi utilizzarla.</p>
<h1 id="i-interfacce"><a name="S-interfaces"></a>I: Interfacce</h1>
<p>Un’interfaccia è un contratto tra due parti di un programma. Indica con precisione cosa ci si aspetta da un fornitore di un servizio e l’essenziale da un utente di tale servizio. Avere buone interfacce (di facile comprensione, incoraggianti un uso efficiente, non soggetto a errori, col supporto di test, ecc.) è probabilmente il solo aspetto più importante dell’organizzazione del codice.</p>
<p>Riepilogo delle Regole delle interfacce:</p>
<ul>
<li><a href="#Ri-explicit">I.1: Rendere esplicite le interfacce</a></li>
<li><a href="#Ri-global">I.2: Evitare variabili globali non-<code>const</code></a></li>
<li><a href="#Ri-singleton">I.3: Evitare i singleton</a></li>
<li><a href="#Ri-typed">I.4: Creare interfacce precisamente e fortemente tipizzate</a></li>
<li><a href="#Ri-pre">I.5: Precondizioni dello stato (se c’è)</a></li>
<li><a href="#Ri-expects">I.6: Preferire <code>Expects()</code> per esprimere le precondizioni</a></li>
<li><a href="#Ri-post">I.7: Postcondizioni dello stato</a></li>
<li><a href="#Ri-ensures">I.8: Preferire <code>Ensures()</code> per esprimere le postcondizioni</a></li>
<li><a href="#Ri-concepts">I.9: Se un’interfaccia è un a template, documentarne i parametri usando i concept</a></li>
<li><a href="#Ri-except">I.10: Usare le eccezioni per segnalare un errore nell’eseguire un compito richiesto</a></li>
<li><a href="#Ri-raw">I.11: Mai trasferire l’ownership con un puntatore raw (<code>T*</code>) o un riferimento (<code>T&amp;</code>)</a></li>
<li><a href="#Ri-nullptr">I.12: Dichiarare un puntatore che non dev’essere null con <code>not_null</code></a></li>
<li><a href="#Ri-array">I.13: Non passare un array come singolo puntatore</a></li>
<li><a href="#Ri-global-init">I.22: Evitare complesse inizializzazioni di oggetti globali</a></li>
<li><a href="#Ri-nargs">I.23: Mantenere basso il numero degli argomenti di una funzione</a></li>
<li><a href="#Ri-unrelated">I.24: Evitare parametri adiacenti non correlati dello stesso tipo</a></li>
<li><a href="#Ri-abstract">I.25: Preferire le classi astratte come interfacce alle gerarchie di classi</a></li>
<li><a href="#Ri-abi">I.26: Se si vuole un cross-compiler ABI, si usi un sottoinsieme in stile C</a></li>
<li><a href="#Ri-pimpl">I.27: Per una libreria ABI stabile, si consideri l’idioma Pimpl</a></li>
<li><a href="#Ri-encapsulate">I.30: Incapsulare le violazioni alla regola</a></li>
</ul>
<p><strong>Si veda anche</strong>:</p>
<ul>
<li><a href="#S-functions">F: Funzioni</a></li>
<li><a href="#SS-concrete">C.concrete: Tipi concreti</a></li>
<li><a href="#SS-hier">C.hier: Gerarchie di classi</a></li>
<li><a href="#SS-overload">C.over: Overloading e operatori overloaded [sovraccaricati]</a></li>
<li><a href="#SS-containers">C.con: Contenitori ed altri handle di risorse</a></li>
<li><a href="#S-errors">E: Gestione degli errori [Error handling]</a></li>
<li><a href="#S-templates">T: Template e programmazione generica</a></li>
</ul>
<h3 id="i.1-rendere-esplicite-le-interfacce"><a name="Ri-explicit"></a>I.1: Rendere esplicite le interfacce</h3>
<h5 id="motivo-13">Motivo</h5>
<p>Correttezza. I presupposti non indicati in un’interfaccia sono facilmente trascurati e difficili da testare.</p>
<h5 id="esempio-cattivo-8">Esempio, cattivo</h5>
<p>Il controllo del comportamento di una funzione attraverso una variabile globale (scope del namespace) (una modalità di chiamata) è implicita e potenzialmente confusa. Per esempio:</p>
<pre><code>int round(double d)
{
return (round_up) ? ceil(d) : d;    // da non fare: dipendenza &quot;invisibile&quot;
}</code></pre>
<p>Non sarà ovvio ad un chiamante che il significato di due chiamate a <code>round(7.2)</code> possa avere risultati diversi.</p>
<h5 id="eccezione">Eccezione</h5>
<p>A volte si controllano i dettagli di un insieme di operazioni tramite una variabile d’ambiente, p.es. output normale anziché verboso o debug anziché ottimizzato. L’uso di un controllo-non-locale è potenzialmente confuso, ma regola solo i dettagli di implementativi di una semantica che sarebbe altrimenti fissa.</p>
<h5 id="esempio-cattivo-9">Esempio, cattivo</h5>
<p>Il reporting tramite variabili non locali (p.es., <code>errno</code>) viene facilmente ignorato. Per esempio:</p>
<pre><code>// da non fare: nessun test del valore di ritorno di printf
fprintf(connection, &quot;logging: %d %d %d\n&quot;, x, y, s);</code></pre>
<p>Cosa succede se la connessione si interrompe così che non si produca alcun output del log? Cfr. I.???.</p>
<p><strong>Alternativa</strong>: Sollevare un’eccezione. Un’eccezione non può essere ignorata.</p>
<p><strong>Formula alternativa</strong>: Evitare il passaggio di informazioni tramite un’interfaccia attraverso uno stato non-locale o implicito. Notare che le funzioni membro non-<code>const</code> passano le informazioni ad altre funzioni membro tramite lo stato del loro oggetto.</p>
<p><strong>Formula alternativa</strong>: Un’interfaccia dovrebbe essere una funzione o un insieme di funzioni. Le funzioni possono essere funzioni template e gruppi di funzioni possono essere classi o classi template.</p>
<h5 id="imposizione-10">Imposizione</h5>
<ul>
<li>(Semplice) Una funzione non dovrebbe prendere decisioni sul flusso di controllo in base ai valori delle variabili dichiarate nello scope del namespace.</li>
<li>(Semplice) Una funzione non dovrebbe scrivere nelle variabili dichiarate nello scope del namespace</li>
</ul>
<h3 id="i.2-evitare-variabili-globali-non-const"><a name="Ri-global"></a>I.2: Evitare variabili globali non-<code>const</code></h3>
<h5 id="motivo-14">Motivo</h5>
<p>Le variabili globali non-<code>const</code> nascondono le dipendenze rendendole soggette a modifiche imprevedibili.</p>
<h5 id="esempio-14">Esempio</h5>
<pre><code>struct Data {
// ... un sacco di cose ...
} data;            // data è non-const

void compute()     // da non fare
{
// ... uso di data ...
}

void output()     // da non fare
{
// ... uso di data ...
}</code></pre>
<p>Chi altri potrebbe modificare <code>data</code>?</p>
<p><strong>Attenzione</strong>: L’inizializzazione degli oggetti globali non è completamente ordinata. Se si usa un oggetto globale, lo si inizializzi con una costante. Si noti che è possibile avere un’inizializzazione indefinita anche per oggetti <code>const</code>.</p>
<h5 id="eccezione-1">Eccezione</h5>
<p>Un oggetto globale spesso è meglio di un singleton.</p>
<h5 id="note-16">Note</h5>
<p>Le costanti globali sono utili.</p>
<h5 id="note-17">Note</h5>
<p>La regola contro le variabili globali si applica anche alle variabili nello scope del namespace.</p>
<p><strong>Alternativa</strong>: Se si usano dati globali (più in generale nello scope del namespace scope) per evitarne la copia, si prenda in considerazione il passare i dati come oggetto per riferimento a <code>const</code>. Un’altra soluzione è quella di definire i dati come lo stato di alcuni oggetti e le operazioni come funzioni membro.</p>
<p><strong>Warning</strong>: Attenzione ai conflitti sui dati: Se un thread può accedere a dati non locali (o dati passati per riferimento) mentre un altro thread esegue il chiamato, si può avere un conflitto. Ogni puntatore o riferimento a dati mutabili è un potenziale conflitto.</p>
<p>L’uso di puntatori o riferimenti globali per accedere e modificare i dati non-costanti e, in caso contrario, non-globali, non è un’alternativa migliore alle variabili globali non-costanti poiché ciò non risolve il problema delle dipendenze nascoste o delle potenziali condizioni di conflitti dei dati.</p>
<h5 id="note-18">Note</h5>
<p>Non è possibile avere una condition conflittuale su dati immutabili.</p>
<p><strong>Riferimenti</strong>: Si vedano le <a href="#SS-call">regole per chiamate a funzioni</a>.</p>
<h5 id="note-19">Note</h5>
<p>La regola è “evitare”, non “non usare”. Naturalmente ci saranno (rare) eccezioni, come <code>cin</code>, <code>cout</code>, e <code>cerr</code>.</p>
<h5 id="imposizione-11">Imposizione</h5>
<p>(Semplice) Riportare tutte le variabili non-<code>const</code> dichiarate nello scope del namespace e i puntatori/riferimenti globali a dati non-const.</p>
<h3 id="i.3-evitare-i-singleton"><a name="Ri-singleton"></a>I.3: Evitare i singleton</h3>
<h5 id="motivo-15">Motivo</h5>
<p>I singleton sono fondamentalmente complicati oggetti globali sotto mentite spoglie.</p>
<h5 id="esempio-15">Esempio</h5>
<pre><code>class Singleton {
// ... tante cose per garantire la creazione di un solo oggetto Singleton,
// correttamente inizializzato, ecc.
};</code></pre>
<p>Esistono molte varianti dell’idea di singleton. Questo è parte del problema.</p>
<h5 id="note-20">Note</h5>
<p>Se non si desidera modificare un oggetto globale, dichiararlo <code>const</code> o <code>constexpr</code>.</p>
<h5 id="eccezione-2">Eccezione</h5>
<p>È possibile utilizzare il più semplice “singleton” (così semplice che spesso non viene considerato un singleton) per ottenerne l’inizializzazione al primo utilizzo, se presente:</p>
<pre><code>X&amp; myX()
{
static X my_x {3};
return my_x;
}</code></pre>
<p>Questa è una delle soluzioni più efficaci ai problemi relativi all’ordine di inizializzazione. In un ambiente multi-thread, l’inizializzazione dell’oggetto statico non introduce un conflitto (a meno che non si acceda con noncuranza a un oggetto shared dal suo costruttore).</p>
<p>Si noti che l’inizializzazione di uno <code>static</code> locale non implica una condizione conflitto. Tuttavia, se la distruzione di <code>X</code> implica un’operazione che dev’essere sincronizzata, si deve usare una soluzione meno semplice. Per esempio:</p>
<pre><code>X&amp; myX()
{
static auto p = new X {3};
return *p;  // potentiale leak
}</code></pre>
<p>Ora qualcuno deve eseguire il <code>delete</code> di quest’oggetto quell’oggetto in modo opportunamente sicuro per essere thread-safe. Questo è soggetto a errori, quindi non usiamo questa tecnica a meno che</p>
<ul>
<li><code>myX</code> stia in un codice multi-threaded,</li>
<li>che l’oggetto <code>X</code> debba essere distrutto (p.es., perché rilascia una risorsa), e</li>
<li>il codice del distruttore di <code>X</code> deve essere sincronizzato.</li>
</ul>
<p>Se, come molti fanno, si definisce un singleton come una classe per cui viene creato un solo oggetto, funzioni come <code>myX</code> non sono dei singleton, e questa utile tecnica non fa eccezione alla regola no-singleton.</p>
<h5 id="imposizione-12">Imposizione</h5>
<p>In generale molto difficile.</p>
<ul>
<li>Cercare le classi con <code>singleton</code> nel nome.</li>
<li>Cercare classi per le quali viene creato un solo oggetto (contando gli oggetti o esaminando i costruttori).</li>
<li>Se una classe X ha una funzione statica pubblica che contiene una funzione statica locale del tipo X della classe e restituisce un puntatore o un riferimento ad essa, vietarlo.</li>
</ul>
<h3 id="i.4-creare-interfacce-precisamente-e-fortemente-tipizzate"><a name="Ri-typed"></a>I.4: Creare interfacce precisamente e fortemente tipizzate</h3>
<h5 id="motivo-16">Motivo</h5>
<p>I tipi costituiscono la più semplice e ottimale documentazione, migliorano la leggibilità grazie al loro significato ben definito e vengono controllati al momento della compilazione. Inoltre, il codice tipizzato con precisione viene spesso meglio ottimizzato.</p>
<h5 id="esempio-da-non-fare">Esempio, da non fare</h5>
<p>Si consideri:</p>
<pre><code>void pass(void* data);    // il tipo void* è vago e sospetto</code></pre>
<p>I chiamanti non sono sicuri di quali tipi siano ammessi e se i dati possano essere mutati come <code>const</code> se non specificato. Si noti che tutti i tipi di puntatore vengono convertiti implicitamente in void*, quindi è facile per i chiamanti fornire questo valore.</p>
<p>Il chiamato deve eseguire un <code>static_cast</code> dei dati ad un tipo non verificato per usarlo. Questo è soggetto a errori ed è verboso.</p>
<p>Utilizzare solo <code>const void*</code> per passare i dati in progetti che sono indescrivibili in in C++. Si consideri invece l’uso di un <code>variant</code> o un puntatore alla base.</p>
<p><strong>Alternativa</strong>: Spesso, un parametro template può eliminare il <code>void*</code> trasformandolo in un <code>T*</code> o in un <code>T&amp;</code>. Per il codice generico questi <code>T</code> possono essere parametri di template generali o vincolati al concept.</p>
<h5 id="esempio-cattivo-10">Esempio, cattivo</h5>
<p>Si consideri:</p>
<pre><code>draw_rect(100, 200, 100, 500); // cosa esattamente indicano i numeri?

draw_rect(p.x, p.y, 10, 20); // quali unità sono 10 e 20?</code></pre>
<p>È chiaro che il chiamante sta descrivendo un rettangolo, ma non è chiaro a quali parti si riferiscono. Inoltre, un <code>int</code> può rappresentare forme arbitrarie di informazioni, compresi i valori di molte unità, quindi dobbiamo indovinare il significato dei quattro <code>int</code>. Molto probabilmente, i primi due sono una coppia di coordinate <code>x</code>,<code>y</code>, ma che sono gli ultimi due?</p>
<p>Commenti e nomi di parametri possono essere d’aiuto, ma potremmo essere espliciti:</p>
<pre><code>void draw_rectangle(Point top_left, Point bottom_right);
void draw_rectangle(Point top_left, Size height_width);

draw_rectangle(p, Point{10, 20});  // due angoli
draw_rectangle(p, Size{10, 20});   // un angolo e una coppia(altezza, larghezza)</code></pre>
<p>Ovviamente, non possiamo rilevare tutti gli errori attraverso il sistema di tipi statici (p.es., il fatto che un primo argomento sia considerato un punto in alto a sinistra è lasciato alla convenzione (nomenclatura e commenti)).</p>
<h5 id="esempio-cattivo-11">Esempio, cattivo</h5>
<p>Si consideri:</p>
<pre><code>set_settings(true, false, 42); // cosa indicano i numeri?</code></pre>
<p>I tipi dei parametri e i loro valori non comunicano quali impostazioni vengono specificate o cosa significano quei valori.</p>
<p>Questo progetto è più esplicito, sicuro e leggibile:</p>
<pre><code>alarm_settings s{};
s.enabled = true;
s.displayMode = alarm_settings::mode::spinning_light;
s.frequency = alarm_settings::every_10_seconds;
set_settings(s);</code></pre>
<p>Nel caso di un insieme di valori booleani prendere in considerazione l’uso di un flag enum; un pattern che esprima un insieme di valori booleani.</p>
<pre><code>enable_lamp_options(lamp_option::on | lamp_option::animate_state_transitions);</code></pre>
<h5 id="esempio-cattivo-12">Esempio, cattivo</h5>
<p>Nel seguente esempio, dall’interfaccia non è chiaro cosa significhi <code>time_to_blink</code> means: Secondi? Millisecondi?</p>
<pre><code>void blink_led(int time_to_blink) // male -- l&#39;unità è ambigua
{
// ...
// fa qualcosa con time_to_blink
// ...
}

void use()
{
blink_led(2);
}</code></pre>
<h5 id="esempio-buono-1">Esempio, buono</h5>
<p>I tipi <code>std::chrono::duration</code> (C++11) aiutano a rendere esplicita l’unità di durata del tempo.</p>
<pre><code>void blink_led(milliseconds time_to_blink) // buono -- l&#39;unità è esplicita
{
// ...
// fa qualcosa con time_to_blink
// ...
}

void use()
{
blink_led(1500ms);
}</code></pre>
<p>La funzione può anche essere scritta in modo tale da accettare qualsiasi unità di durata.</p>
<pre><code>template&lt;class rep, class period&gt;
void blink_led(duration&lt;rep, period&gt; time_to_blink) // buono -- accetta qualsiasi unità
{
// assume che il millisecondo sia l&#39;unità più piccola
auto milliseconds_to_blink = duration_cast&lt;milliseconds&gt;(time_to_blink);
// ...
//  fa qualcosa con milliseconds_to_blink
// ...
}

void use()
{
blink_led(2s);
blink_led(1500ms);
}</code></pre>
<h5 id="imposizione-13">Imposizione</h5>
<ul>
<li>(Semplice) Segnala l’uso di <code>void*</code> come parametro o tipo di ritorno.</li>
<li>(Semplice) Segnala l’uso di più di un parametro <code>bool</code>.</li>
<li>(Difficile da fare bene) Cercare le funzioni che usano troppi argomenti di tipo primitivo..</li>
</ul>
<h3 id="i.5-precondizioni-dello-stato-se-cè"><a name="Ri-pre"></a>I.5: Precondizioni dello stato (se c’è)</h3>
<h5 id="motivo-17">Motivo</h5>
<p>Gli argomenti hanno un significato che può limitarne l’uso corretto nel chiamato.</p>
<h5 id="esempio-16">Esempio</h5>
<p>Si consideri:</p>
<pre><code>double sqrt(double x);</code></pre>
<p>Qui <code>x</code> dev’essere non negativo. Il sistema dei tipi non può (facilmente e naturalmente) esprimerlo, quindi si devono usare altri mezzi. Per esempio:</p>
<pre><code>double sqrt(double x); // x dev&#39;essere non negativo</code></pre>
<p>Alcune precondizioni possono essere espresse come asserzioni. Per esempio:</p>
<pre><code>double sqrt(double x) { Expects(x &gt;= 0); /* ... */ }</code></pre>
<p>Idealmente, quell’<code>Expects(x &gt;= 0)</code> dovrebbe far parte dell’interfaccia di <code>sqrt()</code> ma ciò non si fa facilmente. Per ora, lo inseriamolo nella definizione (corpo della funzione).</p>
<p><strong>References</strong>: <code>Expects()</code> è descritto nella <a href="#S-gsl">GSL</a>.</p>
<h5 id="note-21">Note</h5>
<p>Preferire una specifica formale dei requisiti, come <code>Expects(p);</code>. Se ciò non è possibile, utilizzare il testo inglese nei commenti, ad esempio <code>// the sequence [p:q) is ordered using&lt;</code>.</p>
<h5 id="note-22">Note</h5>
<p>La maggior parte delle funzioni membro ha come precondizione alcune invarianti della classe. Tale invariante è stabilito da un costruttore e deve essere ristabilito all’uscita da ogni funzione membro chiamata dall’esterno della classe. Non è necessario menzionarlo per ciascuna funzione membro.</p>
<h5 id="imposizione-14">Imposizione</h5>
<p>(Non imponibile)</p>
<p><strong>Si veda anche</strong>: Le regole per il passaggio dei puntatori. ???</p>
<h3 id="i.6-preferire-expects-per-esprimere-le-precondizioni"><a name="Ri-expects"></a>I.6: Preferire <code>Expects()</code> per esprimere le precondizioni</h3>
<h5 id="motivo-18">Motivo</h5>
<p>Per chiarire che la condizione è una precondizione e per abilitare l’uso del tool.</p>
<h5 id="esempio-17">Esempio</h5>
<pre><code>int area(int height, int width)
{
Expects(height &gt; 0 &amp;&amp; width &gt; 0);            // buono
if (height &lt;= 0 || width &lt;= 0) my_error();   // criptico
// ...
}</code></pre>
<h5 id="note-23">Note</h5>
<p>Le precondizioni si possono stabilire in molti modi, inclusi i commenti, istruzioni <code>if</code>, e <code>assert()</code>. Questo può rendere arduo distinguerle dal normale codice, difficile da aggiornare, difficile da gestire con tool, e potrebbe avere la semantica sbagliata (si vuol sempre abortire in debug mode e mai controllare durante l’esecuzione in produzione?).</p>
<h5 id="note-24">Note</h5>
<p>Le precondizioni dovrebbero far parte dell’interfaccia anziché far parte dell’implementazione, ma non c’è ancora il supporto del linguaggio per farlo. Appena sarà disponibile il supporto del linguaggio (p.es., cfr. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf">contract proposal</a>) adotteremo la versione standard delle precondizioni, delle postcondizioni e delle asserzioni.</p>
<h5 id="note-25">Note</h5>
<p><code>Expects()</code> si può usare anche per controllare una condizione in mezzo ad un algoritmo.</p>
<h5 id="note-26">Note</h5>
<p>No, l’uso di <code>unsigned</code> non è un buon modo per bypassare il problema per <a href="#Res-nonnegative">assicurarsi che il valore sia non-negativo</a>.</p>
<h5 id="imposizione-15">Imposizione</h5>
<p>(Non imponibile) Trovare i diversi modi con cui asserire le precondizioni non è fattibile. Attenzione a quelli facilmente identificabili (<code>assert()</code>) ha un valore discutibile in assenza del supporto del linguaggio.</p>
<h3 id="i.7-postcondizioni-dello-stato"><a name="Ri-post"></a>I.7: Postcondizioni dello stato</h3>
<h5 id="motivo-19">Motivo</h5>
<p>Per rilevare incomprensioni sul risultato e forse catturare implementazioni errate.</p>
<h5 id="esempio-cattivo-13">Esempio, cattivo</h5>
<p>Si consideri:</p>
<pre><code>int area(int height, int width) { return height * width; }  // non buono</code></pre>
<p>Qui, abbiamo (incautamente) escluso la specifica della precondizione, quindi non è esplicito che altezza e larghezza debbano essere positive. Abbiamo anche tralasciato la specifica della postcondizione, quindi non è ovvio che l’algoritmo (<code>height * width</code>) è sbagliato per le aree più grandi dell’intero più grande. Può capitare un overflow. Si consideri di usare:</p>
<pre><code>int area(int height, int width)
{
auto res = height * width;
Ensures(res &gt; 0);
return res;
}</code></pre>
<h5 id="esempio-cattivo-14">Esempio, cattivo</h5>
<p>Si prenda in considerazione un famoso bug di sicurezza:</p>
<pre><code>void f()    // problematico
{
char buffer[MAX];
// ...
memset(buffer, 0, sizeof(buffer));
}</code></pre>
<p>Non è stata dichiarata alcuna postcondizione che il buffer dev’essere ripulito e l’ottimizzatore ha eliminato le apparentemente ridondanti chiamate a <code>memset()</code>:</p>
<pre><code>void f()    // meglio
{
char buffer[MAX];
// ...
memset(buffer, 0, sizeof(buffer));
Ensures(buffer[0] == 0);
}</code></pre>
<h5 id="note-27">Note</h5>
<p>Le postcondizioni sono spesso dichiarate in modo informale in un commento che indica lo scopo di una funzione; si può usare <code>Ensures()</code> per renderlo più sistematico, visibile, e verificabile.</p>
<h5 id="note-28">Note</h5>
<p>Le postcondizioni sono particolarmente importanti quando si riferiscono a qualcosa che non si riflette direttamente in un risultato restituito.</p>
<h5 id="esempio-18">Esempio</h5>
<p>Si consideri una funzione che gestisce un <code>Record</code>, con un <code>mutex</code> per evitare conflitti:</p>
<pre><code>mutex m;

void manipulate(Record&amp; r)    // da non fare
{
m.lock();
// ... no m.unlock() ...
}</code></pre>
<p>Qui abbiamo “dimenticato” di dichiarare che il <code>mutex</code> dovrebbe essere rilasciato, quindi non sappiamo se il fallimento per assicurare il rilascio del <code>mutex</code> fosse un bug o voluto. Il dichiarare la postcondizione lo avrebbe chiarito:</p>
<pre><code>void manipulate(Record&amp; r)    // postcondizione: m è sbloccato all&#39;uscita
{
m.lock();
// ... nessun m.unlock() ...
}</code></pre>
<p>Il bug ora è ovvio (ma solo ad un umano che legga i commenti).</p>
<p>Meglio ancora, usare il <a href="#Rr-raii">RAII</a> per assicurarsi che la postcondizione (“il lock dev’essere rilasciato”) sia scolpita nel codice:</p>
<pre><code>void manipulate(Record&amp; r)    // migliore
{
lock_guard&lt;mutex&gt; _ {m};
// ...
}</code></pre>
<h5 id="note-29">Note</h5>
<p>Idealmente, le postcondizioni sono indicate nell’interfaccia/dichiarazione in modo che gli utenti possano facilmente vederle. Nell’interfaccia è possibile specificare solo le postcondizioni relative agli utenti. Le postcondizioni relative solo allo stato interno appartengono alla definizione/implementazione.</p>
<h5 id="imposizione-16">Imposizione</h5>
<p>(Non imponibile) Questa è una linea-guida filosofica che è impossibile da controllare direttamente nel caso generale. Controlli specifici al dominio (come i controlli per la ritenzione del lock) esistono per molte toolchain.</p>
<h3 id="i.8-preferire-ensures-per-esprimere-le-postcondizioni"><a name="Ri-ensures"></a>I.8: Preferire <code>Ensures()</code> per esprimere le postcondizioni</h3>
<h5 id="motivo-20">Motivo</h5>
<p>Per chiarire che la condizione è un postcondizionato e per consentire l’uso di tool.</p>
<h5 id="esempio-19">Esempio</h5>
<pre><code>void f()
{
char buffer[MAX];
// ...
memset(buffer, 0, MAX);
Ensures(buffer[0] == 0);
}</code></pre>
<h5 id="note-30">Note</h5>
<p>Le postcondizioni possono essere dichiarate in molti modi, inclusi i commenti, istruzioni <code>if</code> e <code>assert()</code>. Ciò può renderli difficili da distinguere dal normale codice, difficili da aggiornare, difficili da gestire con dei tool e avere una semantica sbagliata.</p>
<p><strong>Alternative</strong>: Le post-condizioni di tipo “questa risorsa dev’essere rilasciata” si esprimono meglio col <a href="#Rr-raii">RAII</a>.</p>
<h5 id="note-31">Note</h5>
<p>Idealmente, questo <code>Ensures</code> dovrebbe far parte dell’interfaccia, ma ciò non è facile da fare. Per ora, lo inseriamolo nella definizione (corpo della funzione). Quando sarà disponibile il supporto del linguaggio (p.es., si veda <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf">contract proposal</a>) si adotterà a versione standard delle precondizioni, delle postcondizioni e delle asserzioni.</p>
<h5 id="imposizione-17">Imposizione</h5>
<p>(Non imponibile) Trovare i diversi modi con cui asserire le postcondizioni non è fattibile. Attenzione a quelli facilmente identificabili (<code>assert()</code>) ha un valore discutibile in assenza del supporto del linguaggio.</p>
<h3 id="i.9-se-uninterfaccia-è-un-a-template-documentarne-i-parametri-usando-i-concept"><a name="Ri-concepts"></a>I.9: Se un’interfaccia è un a template, documentarne i parametri usando i concept</h3>
<h5 id="motivo-21">Motivo</h5>
<p>Rendere l’interfaccia esattamente specificata e controllabile durante la compilazione in un (non molto distante) futuro.</p>
<h5 id="esempio-20">Esempio</h5>
<p>Isare i Concept ISO in stile TS della specifica dei requisiti. Per esempio:</p>
<pre><code>template&lt;typename Iter, typename Val&gt;
// requires InputIterator&lt;Iter&gt; &amp;&amp; EqualityComparable&lt;ValueType&lt;Iter&gt;&gt;, Val&gt;
Iter find(Iter first, Iter last, Val v)
{
// ...
}</code></pre>
<h5 id="note-32">Note</h5>
<p>Presto (forse nel 2018), la maggior parte dei compilatori sarà in grado di controllare le clausole <code>requires</code> una volta rimosso il <code>//</code>. I concetti sono supportati GCC 6.1 e successivi.</p>
<p><strong>Si veda anche</strong>: <a href="#SS-GP">Programmazione generica</a> e <a href="#SS-concepts">concept</a>.</p>
<h5 id="imposizione-18">Imposizione</h5>
<p>(Non ancora applicabile) C’è una specifica del linguaggio in esame. Quando tale funzionalità del linguaggio sarà disponibile, avvisa che un qualsiasi parametro template non-variadico non risulta vincolato da un concept ((nella sua dichiarazione o citato in una clausola <code>requires</code>).</p>
<h3 id="i.10-usare-le-eccezioni-per-segnalare-un-errore-nelleseguire-un-compito-richiesto"><a name="Ri-except"></a>I.10: Usare le eccezioni per segnalare un errore nell’eseguire un compito richiesto</h3>
<h5 id="motivo-22">Motivo</h5>
<p>Non dovrebbe essere possibile ignorare un errore perché ciò potrebbe lasciare il sistema o un computo in uno stato indefinito (o imprevisto). Questa è una delle principali fonti di errori.</p>
<h5 id="esempio-21">Esempio</h5>
<pre><code>int printf(const char* ...);    // male: restituisce un numero negativo se l&#39;output fallisce

template &lt;class F, class ...Args&gt;
// buono: esegue system_error se non è in grado di avviare un nuovo thread
explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);</code></pre>
<h5 id="note-33">Note</h5>
<p>Che cos’è un errore?</p>
<p>Un errore indica che la funzione non può raggiungere lo scopo dichiarato (incluse l’instaurazione delle postcondizioni). Chiamando del codice che ignora un errore può portare a risultati errati o a uno stato del sistema indefinito. Ad esempio, non essere in grado di connettersi a un server remoto non è di per sé un errore: il server può rifiutare una connessione per tutta una serie di motivi, quindi la cosa naturale è quella di restituire un risultato che il chiamante dovrebbe sempre controllare. Tuttavia, se il non riuscire a stabilire una connessione viene considerato un errore, allora tale errore dovrebbe generare un’eccezione.</p>
<h5 id="eccezione-3">Eccezione</h5>
<p>Molte funzioni di interfacce (p.es., gli handler signal di UNIX) usano codici di errore (p.es., <code>errno</code>) per segnalare quali sono realmente i codici di stato, piuttosto che degli errori. Se non si ha una buona alternativa all’uso di questi, allora il chiamarli non viola la regola.</p>
<h5 id="alternativa">Alternativa</h5>
<p>Se non si possono usare le eccezioni (p.es., perché il proprio codice è pieno di puntatori vecchio stile o perché ci sono seri vincoli di real-time), si considera l’uso di uno stile che restituisca una coppia di valori:</p>
<pre><code>int val;
int error_code;
tie(val, error_code) = do_something();
if (error_code) {
// ... gestisce l&#39;errore all&#39;uscita ...
}
// ... usa val ...</code></pre>
<p>Questo stile sfortunatamente porta a variabili non inizializzate. A partire da C++17 si può usare la funzionalità delle “structured bindings” per inizializzare le variabili direttamente dai valori di ritorno:</p>
<pre><code>auto [val, error_code] = do_something();
if (error_code) {
// ... gestisce l&#39;errore all&#39;uscita ...
}
// ... usa val ...</code></pre>
<h5 id="note-34">Note</h5>
<p>Non consideriamo la “performance” un motivo valido per non usare le eccezioni.</p>
<ul>
<li>Spesso, il controllo e la gestione espliciti degli errori consumano tanto tempo e spazio quanto la gestione delle eccezioni.</li>
<li>Spesso, un codice più pulito produce migliori prestazioni con le eccezioni (semplificando la tracciabilità dei percorsi attraverso il programma e la loro ottimizzazione).</li>
<li>Una buona regola per il codice critico per le prestazioni è quella di spostare il controllo all’esterno della parte critica del codice (<a href="#Rper-checking">checking</a>).</li>
<li>Alla lunga, un codice più regolare si ottimizza meglio.</li>
<li><a href="#Rper-measure">Misurare</a> sempre e accuratamente prima di lamentarsi delle prestazioni.</li>
</ul>
<p><strong>Vedere anche</strong>: <a href="#Ri-pre">I.5</a> e <a href="#Ri-post">I.7</a> per riportare violazioni di precondizione e postcondizione.</p>
<h5 id="imposizione-19">Imposizione</h5>
<ul>
<li>(Non imponibile) Questa è una linea-guida filosofica che è impossibile da controllare direttamente.</li>
<li>Cercare <code>errno</code>.</li>
</ul>
<h3 id="i.11-mai-trasferire-lownership-con-un-puntatore-raw-t-o-un-riferimento-t"><a name="Ri-raw"></a>I.11: Mai trasferire l’ownership con un puntatore raw (<code>T*</code>) o un riferimento (<code>T&amp;</code>)</h3>
<h5 id="motivo-23">Motivo</h5>
<p>In caso di dubbi sul fatto che sia il chiamante o il chiamato a possedere un oggetto, possono avere dei leak o una prematura distruzione.</p>
<h5 id="esempio-22">Esempio</h5>
<p>Si consideri:</p>
<pre><code>X* compute(args)    // da non fare
{
X* res = new X{};
// ...
return res;
}</code></pre>
<p>Chi esegue il delete dell’<code>X</code> restituito? Il problema sarebbe più difficile da individuare se <code>compute</code> restituisca un riferimento. Si valuti di restituire il risultato per valore (si usa la semantica move se il risultato e grande):</p>
<pre><code>vector&lt;double&gt; compute(args)  // buono
{
vector&lt;double&gt; res(10000);
// ...
return res;
}</code></pre>
<p><strong>Alternative</strong>: <a href="#Rr-smartptrparam">Passaggio dell’ownership</a> usando uno “smart pointer”, come un <code>unique_ptr</code> (per l’ownership esclusiva) e <code>shared_ptr</code> (per un’ownership condivisa). Tuttavia, è meno elegante e spesso meno efficiente rispetto al restituire l’oggetto stesso, quindi usare gli smart pointer solo se è necessaria la semantica del riferimento.</p>
<p><strong>Alternative</strong>: Talvolta il codice pre-esistente non si può modificare a causa dei requisiti di compatibilità ABI o per mancanza di risorse. In tal caso, contrassegnare i puntatori proprietari utilizzando <code>owner</code> dalla <a href="#S-gsl">Guidelines Support Library</a>:</p>
<pre><code>owner&lt;X*&gt; compute(args)    // Ora è chiaro il trasferimento dell&#39;ownership
{
owner&lt;X*&gt; res = new X{};
// ...
return res;
}</code></pre>
<p>Questo dice ai tool di analisi che <code>res</code> è un owner [proprietario]. Cioè, il suo valore deve subire un <code>delete</code> o dev’essere trasferito ad un altro owner, come viene fatto qui dal <code>return</code>.</p>
<p><code>owner</code> viene utilizzato in modo simile nell’implementazione degli handle delle risorse.</p>
<h5 id="note-35">Note</h5>
<p>Si presume che ogni oggetto passato come semplice puntatore (o iteratore) sia proprietà del chiamante, in modo che il suo ciclo di vita sia gestito dal chiamante. In altri termini: le API che trasferiscono l’ownership sono relativamente rare rispetto alle API che passano puntatori, quindi il default è “nessun trasferimento dell’ownership”.</p>
<p><strong>Si veda anche </strong>: <a href="#Rf-conventional">Passaggio di argomenti</a>, <a href="#Rr-smartptrparam">uso di argomenti smart pointer</a> e <a href="#Rf-value-return">valore di ritorno</a>.</p>
<h5 id="imposizione-20">Imposizione</h5>
<ul>
<li>(Semplice) Un warning su un <code>delete</code> di un puntatore semplice che non sia un <code>owner&lt;T&gt;</code>. Suggeriamo l’uso dell’handle delle risorse della libreria standard o l’uso di <code>owner&lt;T&gt;</code>.</li>
<li>(Semplice) Un warning o in caso di errore del <code>reset</code> o l’esplicito <code>delete</code> di un puntatore <code>owner</code> su ogni percorso del codice.</li>
<li>(Semplice) Un warning se il valore di ritorno di un <code>new</code> o il valore di ritorno <code>owner</code> di una chiamata a una funzione viene assegnato ad un puntatore o ad un riferimento non-<code>owner</code>.</li>
</ul>
<h3 id="i.12-dichiarare-un-puntatore-che-non-devessere-null-con-not_null"><a name="Ri-nullptr"></a>I.12: Dichiarare un puntatore che non dev’essere null con <code>not_null</code></h3>
<h5 id="motivo-24">Motivo</h5>
<p>Per evitare la de-referenziazione degli errori <code>nullptr</code>. Per migliorare le prestazioni evitando controlli ridondanti per <code>nullptr</code>.</p>
<h5 id="esempio-23">Esempio</h5>
<pre><code>int length(const char* p);            // non è chiaro se la lunghezza(nullptr) sia valida

length(nullptr);                      // OK?

int length(not_null&lt;const char*&gt; p);  // meglio: possiamo supporre che p non possa essere nullptr

int length(const char* p);            // dobbiamo supporre che p possa essere nullptr</code></pre>
<p>Dichiarando l’intento nel sorgente, gli implementatori e i tool possono eseguire una diagnostica migliore, come la ricerca di alcune classi di errore con l’analisi statica ed eseguire ottimizzazione come la rimozione di branch e test nulli.</p>
<h5 id="note-36">Note</h5>
<p><code>not_null</code> è definito nella <a href="#S-gsl">Guidelines Support Library</a>.</p>
<h5 id="note-37">Note</h5>
<p>L’assunzione che il puntatore a <code>char</code> punti ad una stringa C-style (una stringa di caratteri terminata con zero) era ancora implicita ed una potenziale sorgente di confusione e di errori. Usare <code>czstring</code> preferendola a <code>const char*</code>.</p>
<pre><code>// possiamo supporre che p non possa essere nullptr
// possiamo supporre che p punti a una array di caratteri &#39;zero-terminated&#39;
int length(not_null&lt;zstring&gt; p);</code></pre>
<p>Nota: <code>length()</code> è, ovviamente, uno <code>std::strlen()</code> in incognito.</p>
<h5 id="imposizione-21">Imposizione</h5>
<ul>
<li>(Semplice) ((Foundation)) Se una funzione controlla se un parametro puntatore è <code>nullptr</code> prima di accedervi, su tutti i percorsi del flusso di controllo, allora si emette un warning sul fatto che dovrebbe essere dichiarato <code>not_null</code>.</li>
<li>(Complesso) Se una funzione con puntatore come valore di ritorno si accerta che non sia <code>nullptr</code> su tutti i path di ritorno, allora si emette un warning sul fatto che il tipo restituito si dovrebbe dichiarare <code>not_null</code>.</li>
</ul>
<h3 id="i.13-non-passare-un-array-come-singolo-puntatore"><a name="Ri-array"></a>I.13: Non passare un array come singolo puntatore</h3>
<h5 id="motivo-25">Motivo</h5>
<p>Le interfacce di tipo (puntatore, dimensione) sono soggette ad errori. Inoltre, un semplice puntatore (ad un array) deve fare affidamento su una convenzione per consentire al chiamato di determinarne la dimensione.</p>
<h5 id="esempio-24">Esempio</h5>
<p>Si consideri:</p>
<pre><code>void copy_n(const T* p, T* q, int n); // copia da [p:p+n) a [q:q+n)</code></pre>
<p>Cosa succede se sono presenti meno di <code>n</code> elementi nell’array puntato da <code>q</code> ? Allora, probabilmente si sovrascrive della memoria estranea [unrelated]. Cosa succede se nell’array sono presenti meno di <code>n</code> elementi nell’array puntato da <code>p</code>? Allora, probabilmente, si leggerà da una memoria estranea [unrelated]. O è un comportamento indefinito o un bug potenzialmente molto pericoloso.</p>
<h5 id="alternativa-1">Alternativa</h5>
<p>Si consideri l’uso di uno span esplicito:</p>
<pre><code>void copy(span&lt;const T&gt; r, span&lt;T&gt; r2); // copia r in r2</code></pre>
<h5 id="esempio-cattivo-15">Esempio, cattivo</h5>
<p>Si consideri:</p>
<pre><code>void draw(Shape* p, int n);  // interfaccia scadente; codice scadente
Circle arr[10];
// ...
draw(arr, 10);</code></pre>
<p>Passare <code>10</code> come l’argomento <code>n</code> può essere un errore: la convenzione più comune è assumere <code>[0:n)</code> ma non è detto da nessuna parte. Peggio ancora è che la chiamata a <code>draw()</code> non viene compilata affatto: c’è stata una conversione implicita da un array a un puntatore (array decay) e poi un’altra conversione implicita da <code>Circle</code> a <code>Shape</code>. Non è possibile che <code>draw()</code> possa iterare in sicurezza per tutto quell’array: non ha modo di conoscere la dimensione degli elementi.</p>
<p><strong>Alternative</strong>: Utilizzare una classe di supporto per garantire che il numero di elementi sia corretto e per prevenire conversioni implicite pericolose. Per esempio:</p>
<pre><code>void draw2(span&lt;Circle&gt;);
Circle arr[10];
// ...
draw2(span&lt;Circle&gt;(arr));  // dedurre il numero di elementi
draw2(arr);    // dedurre il tipo di elemento e la dimensione dell&#39;array

void draw3(span&lt;Shape&gt;);
draw3(arr);    // errore: impossibile convertire Circle[10] in span&lt;Shape&gt;</code></pre>
<p>Questo <code>draw2()</code> passa la stessa quantità di informazioni a <code>draw()</code>, ma rende esplicito il fatto che si supponga essere un range di <code>Circle</code>. Cfr. ???.</p>
<h5 id="eccezione-4">Eccezione</h5>
<p>Usare <code>zstring</code> e <code>czstring</code> per rappresentare stringhe C-style e zero-terminated. Ma quando lo si fa, si usa <code>std::string_view</code> o <code>string_span</code> della <a href="#GSL">GSL</a> per evitare errori di range.</p>
<h5 id="imposizione-22">Imposizione</h5>
<ul>
<li>(Semplice) ((Bounds)) Segnala un warning per ogni espressione che si baserebbe sulla conversione implicita di un tipo di array ad un tipo di puntatore. Consentire delle eccezioni per tipi di puntatori zstring/czstring.</li>
<li>(Semplice) ((Bounds)) Segnala un warning per ogni operazione aritmetica o espressione di tipo puntatore che risulti nel valore di un tipo puntatore. Consentire delle eccezioni per tipi di puntatori zstring/czstring.</li>
</ul>
<h3 id="i.22-evitare-complesse-inizializzazioni-di-oggetti-globali"><a name="Ri-global-init"></a>I.22: Evitare complesse inizializzazioni di oggetti globali</h3>
<h5 id="motivo-26">Motivo</h5>
<p>Una complessa inizializzazione può portare ad un ordine indefinito di esecuzione.</p>
<h5 id="esempio-25">Esempio</h5>
<pre><code>// file1.c

extern const X x;

const Y y = f(x);   // legge x; scrive y

// file2.c

extern const Y y;

const X x = g(y);   // legge y; scrive x</code></pre>
<p>Poiché <code>x</code> e <code>y</code> stanno in unità di traduzione diverse, l’ordine delle chiamate a <code>f()</code> e <code>g()</code> non è definito; si accederà ad un <code>const</code> non inizializzato. Ciò dimostra che il problema dell’ordine di inizializzazione per gli oggetti globali (scope del namespace) non è limitato alle <em>variabili</em> globali.</p>
<h5 id="note-38">Note</h5>
<p>I problemi sull’ordine di inizializzazione diventano particolarmente difficili da gestire nel codice concorrente. Di solito è meglio evitare del tutto gli oggetti globali (scope del namespace).</p>
<h5 id="imposizione-23">Imposizione</h5>
<ul>
<li>Segnalare gli inizializzatori dei globali che chiamano funzioni non-<code>constexpr</code></li>
<li>Segnalare gli inizializzatori dei globali che accedono ad oggetti <code>extern</code></li>
</ul>
<h3 id="i.23-mantenere-basso-il-numero-degli-argomenti-di-una-funzione"><a name="Ri-nargs"></a>I.23: Mantenere basso il numero degli argomenti di una funzione</h3>
<h5 id="motivo-27">Motivo</h5>
<p>Avere molti argomenti espone a delle opportunità di confusione. Passare molti argomenti spesso è costoso rispetto a delle alternative.</p>
<h5 id="discussione">Discussione</h5>
<p>I due motivi più comuni del perché le funzioni hanno troppi parametri sono:</p>
<ol type="1">
<li><p><em>Mancanza di un’astrazione.</em> Manca un’astrazione, quindi è un valore composto passato come singoli elementi anziché come un singolo oggetto che impone [enforces] un invariante. Questo non solo espande la lista dei parametri, ma porta ad errori perché i valori dei componenti non sono più protetti da un invariante imposto [enforced].</p></li>
<li><p><em>Violazione di “una funzione, una responsabilità”.</em> La funzione sta tentando di fare di più di una cosa e probabilmente necessita di un refactoring.</p></li>
</ol>
<h5 id="esempio-26">Esempio</h5>
<p>La funzione <code>merge()</code> della standard-library è al limite di ciò che si può gestire comodamente:</p>
<pre><code>template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);</code></pre>
<p>Si noti che ciò è dovuto al problema 1 precedente – mancanza di un’astrazione. Anziché passare un range (astrazione), la STL passa una coppia di iteratori (calori dei componenti non incapsulati).</p>
<p>Qui, si hanno quattro argomenti template e sei argomenti funzione. Per semplificarne gli usi più frequenti e più semplici, si può assegnare, come default, all’argomento di confronto <code>&lt;</code>:</p>
<pre><code>template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);</code></pre>
<p>Ciò non riduce la complessità totale, ma riduce la complessità di superficie presentata a molti utenti. Per ridurre davvero il numero di argomenti, si devono raggruppare gli argomenti in astrazioni ad un livello più alto:</p>
<pre><code>template&lt;class InputRange1, class InputRange2, class OutputIterator&gt;
OutputIterator merge(InputRange1 r1, InputRange2 r2, OutputIterator result);</code></pre>
<p>Raggruppare gli argomenti in “bundle” è una tecnica generale per ridurre il numero degli argomenti e per aumentare la possibilità di controllo.</p>
<p>In alternativa, potremmo usarei concept (come definiti dalla TS ISO) per definire la nozione dei tre tipi che si devono usare per il merge:</p>
<pre><code>Mergeable{In1, In2, Out}
OutputIterator merge(In1 r1, In2 r2, Out result);</code></pre>
<h5 id="esempio-27">Esempio</h5>
<p>I ‘Profile’ di sicurezza consigliano di sostituire</p>
<pre><code>void f(int* some_ints, int some_ints_length);  // MALE: in stile C, non sicuro</code></pre>
<p>con</p>
<pre><code>void f(gsl::span&lt;int&gt; some_ints);              // BUONO: sicuro, controllo dei limiti</code></pre>
<p>Qui, l’utilizzo di un’astrazione presenta vantaggi in termini di sicurezza e robustezza e riduce naturalmente anche il numero dei parametri.</p>
<h5 id="note-39">Note</h5>
<p>Quanti parametri sono troppi? Provare ad usarne meno di quattro (4) parametri. Ci sono funzioni che vengono meglio espresse con quattro parametri singoli, ma non di più.</p>
<p><strong>Alternative</strong>: Usare un’astrazione migliore: Raggruppare gli argomenti in oggetti significativi e passare gli oggetti (per valore o per riferimento).</p>
<p><strong>Alternative</strong>: Usare gli argomenti di default o gli overload per consentire le forme più comuni di chiamate da effettuarsi con pochi argomenti.</p>
<h5 id="imposizione-24">Imposizione</h5>
<ul>
<li>Avvisare quando una funzione dichiara due iteratori (compresi i puntatori) dello stesso tipo anzziché un range o una view.</li>
<li>(Non imponibile) Questa è una linea-guida filosofica che è impossibile da controllare direttamente.</li>
</ul>
<h3 id="i.24-evitare-parametri-adiacenti-non-correlati-dello-stesso-tipo"><a name="Ri-unrelated"></a>I.24: Evitare parametri adiacenti non correlati dello stesso tipo</h3>
<h5 id="motivo-28">Motivo</h5>
<p>Argomenti adiacenti dello stesso tipo si possono facilmente scambiare per errore.</p>
<h5 id="esempio-cattivo-16">Esempio, cattivo</h5>
<p>Si consideri:</p>
<pre><code>void copy_n(T* p, T* q, int n);  // copia da [p:p + n) a [q:q + n)</code></pre>
<p>Questa è una brutta variante dell’interfaccia in stile K&amp;R C. È facile invertire gli argomenti “da” e “a”.</p>
<p>Usare <code>const</code> per l’argomento “da”:</p>
<pre><code>void copy_n(const T* p, T* q, int n);  // copia da [p:p + n) a [q:q + n)</code></pre>
<h5 id="eccezione-5">Eccezione</h5>
<p>Se l’ordine dei parametri non è importante, non ci sono problemi:</p>
<pre><code>int max(int a, int b);</code></pre>
<h5 id="alternativa-2">Alternativa</h5>
<p>Non passare array come puntatori, passare un oggetto rappresentante un range (p.es., uno <code>span</code>):</p>
<pre><code>void copy_n(span&lt;const T&gt; p, span&lt;T&gt; q);  // copia da p a q</code></pre>
<h5 id="alternativa-3">Alternativa</h5>
<p>Definire una <code>struct</code> come il tipo del parametro e denominare adeguatamente i campi di tali parametri:</p>
<pre><code>struct SystemParams {
string config_file;
string output_path;
seconds timeout;
};
void initialize(SystemParams p);</code></pre>
<p>Questo tende a renderne chiare le invocazioni ai futuri lettori, poiché i parametri vengono spesso compilati per nome dal lato della chiamata.</p>
<h5 id="imposizione-25">Imposizione</h5>
<p>(Semplice) Sollevare un warning se due parametri consecutivi condividono lo stesso tipo.</p>
<h3 id="i.25-preferire-le-classi-astratte-come-interfacce-alle-gerarchie-di-classi"><a name="Ri-abstract"></a>I.25: Preferire le classi astratte come interfacce alle gerarchie di classi</h3>
<h5 id="motivo-29">Motivo</h5>
<p>Le classi astratte hanno maggiori probabilità di essere stabili rispetto alle classi base con uno stato.</p>
<h5 id="esempio-cattivo-17">Esempio, cattivo</h5>
<p>Si sapeva che <code>Shape</code> sarebbe comparso da qualche parte :-)</p>
<pre><code>class Shape {  // male: classe interfaccia caricata con dati
public:
Point center() const { return c; }
virtual void draw() const;
virtual void rotate(int);
// ...
private:
Point c;
vector&lt;Point&gt; outline;
Color col;
};</code></pre>
<p>Ciò costringerà ogni classe derivata a calcolare un centro, anche se non è un’operazione banale e se il centro non viene mai utilizzato. Similmente, non tutte le <code>Shape</code> hanno un <code>Color</code>, e molte <code>Shape</code> vengono meglio rappresentate senza un contorno definito come una sequenza di <code>Point</code>. Le classi astratte sono state inventate per scoraggiare gli utenti dallo scrivere tali classi:</p>
<pre><code>class Shape {    // meglio: Shape è un&#39;interfaccia pura
public:
virtual Point center() const = 0;   // funzioni virtuali pure
virtual void draw() const = 0;
virtual void rotate(int) = 0;
// ...
// ... nessun dato membro ...
// ...
virtual ~Shape() = default;
};</code></pre>
<h5 id="imposizione-26">Imposizione</h5>
<p>(Semplice) Avvisa se un puntatore/riferimento ad una classe <code>C</code> viene assegnata ad un puntatore/riferimento ad una base di <code>C</code> e la classe base contiene dai dati membro.</p>
<h3 id="i.26-se-si-vuole-un-cross-compiler-abi-si-usi-un-sottoinsieme-in-stile-c"><a name="Ri-abi"></a>I.26: Se si vuole un cross-compiler ABI, si usi un sottoinsieme in stile C</h3>
<h5 id="motivo-30">Motivo</h5>
<p>Compilatori diversi implementano layout binari diversi per le classi, la gestione delle eccezioni, i nomi delle funzioni e altri dettagli di implementazione.</p>
<h5 id="eccezione-6">Eccezione</h5>
<p>Su alcune piattaforme stanno emergendo delle ABI comuni (Application Binary Interface) [Interfaccie Binarie di Applicazioni] che liberano dalle restrizioni più draconiane (rigorose).</p>
<h5 id="note-40">Note</h5>
<p>Se si usa un solo compilatore, si può usare pienamente il C++ nelle interfacce. Ciò potrebbe richiedere la ricompilazione dopo un aggiornamento a una nuova versione del compilatore.</p>
<h5 id="imposizione-27">Imposizione</h5>
<p>(Non imponibile) È difficile identificare in modo affidabile dove un’interfaccia faccia parte di un ABI.</p>
<h3 id="i.27-per-una-libreria-abi-stabile-si-consideri-lidioma-pimpl"><a name="Ri-pimpl"></a>I.27: Per una libreria ABI stabile, si consideri l’idioma Pimpl</h3>
<h5 id="motivo-31">Motivo</h5>
<p>Dato che i dati-membro privati partecipano al layout di una classe e le funzioni-membro private partecipano alla risoluzione degli overload, la modifica di tali dettagli implementativi richie la ri-compilazione di tutti i chiamanti della classe. Una classe interfaccia non polimorfica contenente un puntatore ad un’implementazione (Pimpl [Pointer to implementation]) può isolare i chiamanti della classe dalle modifiche della sua implementazione al costo di un indirizzamento.</p>
<h5 id="esempio-28">Esempio</h5>
<p>interfaccia (widget.h)</p>
<pre><code>class widget {
class impl;
std::unique_ptr&lt;impl&gt; pimpl;
public:
void draw(); // API pubblica che sarà inoltrata [forwarded] all&#39;implementazione
widget(int); // definito nel file dell&#39;implementazione
~widget();   // definito nel file dell&#39;implementazione, dove l&#39;Impl è un tipo completo
widget(widget&amp;&amp;); // definito nel file dell&#39;implementazione
widget(const widget&amp;) = delete;
widget&amp; operator=(widget&amp;&amp;); // definito nel file dell&#39;implementazione
widget&amp; operator=(const widget&amp;) = delete;
};</code></pre>
<p>implementazione (widget.cpp)</p>
<pre><code>class widget::impl {
int n; // private data
public:
void draw(const widget&amp; w) { /* ... */ }
impl(int n) : n(n) {}
};
void widget::draw() { pimpl-&gt;draw(*this); }
widget::widget(int n) : pimpl{std::make_unique&lt;impl&gt;(n)} {}
widget::widget(widget&amp;&amp;) = default;
widget::~widget() = default;
widget&amp; widget::operator=(widget&amp;&amp;) = default;</code></pre>
<h5 id="note-41">Note</h5>
<p>Cfr. <a href="https://herbsutter.com/gotw/_100/">GOTW #100</a> e <a href="http://en.cppreference.com/w/cpp/language/pimpl">cppreference</a> per valutazioni [trade-offs] e ulteriori dettagli implementativiassociati a questo idioma.</p>
<h5 id="imposizione-28">Imposizione</h5>
<p>(Non imponibile) È difficile identificare in modo affidabile dove un’interfaccia faccia parte di un ABI.</p>
<h3 id="i.30-incapsulare-le-violazioni-alla-regola"><a name="Ri-encapsulate"></a>I.30: Incapsulare le violazioni alla regola</h3>
<h5 id="motivo-32">Motivo</h5>
<p>Per mantenere il codice semplice e sicuro. A volte sono necessarie tecniche brutte, insicure o soggette a errori per motivi logici o prestazionali. In tal caso, si mantengono locali, anziché “infettare” le interfacce in modo che gruppi più grandi di programmatori siano consapevoli delle sottigliezze. La complessità dell’implementazione non dovrebbe, se possibile, attraverso le interfacce passare nel codice utente.</p>
<h5 id="esempio-29">Esempio</h5>
<p>Si consideri un programma che, a seconda di una qualche forma di input (p.es., gli argomenti di <code>main</code>), dovrebbe prendere l’input da un file, dalla riga di comando o dallo standard input. Si potrebbe scrivere</p>
<pre><code>bool owned;
owner&lt;istream*&gt; inp;
switch (source) {
case std_in:        owned = false; inp = &amp;cin;                       break;
case command_line:  owned = true;  inp = new istringstream{argv[2]}; break;
case file:          owned = true;  inp = new ifstream{argv[2]};      break;
}
istream&amp; in = *inp;</code></pre>
<p>Ciò viola la regola <a href="#Res-always">contro le variabili non inizializzate</a>, la regola contro <a href="#Ri-raw">il trascurare l’ownership</a>, e la regola <a href="#Res-magic">contro le costanti magiche</a>. In particolare, qualcuno si deve ricordare di scrivere da qualche parte</p>
<pre><code>if (owned) delete inp;</code></pre>
<p>Si potrebbe gestire questo particolare esempio con <code>unique_ptr</code> con uno speciale deleter che non fa niente per <code>cin</code>, ma è complicato per i principianti (che possono facilmente incappare in questo problema) e l’esempio è per un più generale problema dove la proprietà che si vorrebbe considerare statica (qui, l’ownership) talvolta deve essere affrontata in fase di esecuzione. Gli esempi più comuni, più frequenti e più sicuri si possono gestire staticamente, quindi non vi si vuol aggiungere un costo o complessità. Ma si deve far fronte anche ai casi rari, meno sicuri e necessariamente più costosi. Tali esempi sono discussi in <a href="http://www.stroustrup.com/resource-model.pdf">[Str15]</a>.</p>
<p>Quindi, si scrive una classe</p>
<pre><code>class Istream { [[gsl::suppress(lifetime)]]
public:
enum Opt { from_line = 1 };
Istream() { }
Istream(zstring p) :owned{true}, inp{new ifstream{p}} {}            // legge dal file
Istream(zstring p, Opt) :owned{true}, inp{new istringstream{p}} {}  // legge dalla riga di comando
~Istream() { if (owned) delete inp; }
operator istream&amp; () { return *inp; }
private:
bool owned = false;
istream* inp = &amp;cin;
};</code></pre>
<p>Ora, la natura dinamica della proprietà di <code>istream</code> è stata incapsulata. Presumibilmente, si dovranno aggiungere in un codice reale un po’ di controlli per i potenziali errori.</p>
<h5 id="imposizione-29">Imposizione</h5>
<ul>
<li>Difficile, è difficile decidere quale codice rompi-regola è essenziale</li>
<li>Si segnala la soppressione della regola che abilita la violazione della regola attraverso le interfacce</li>
</ul>
<h1 id="f-funzioni"><a name="S-functions"></a>F: Funzioni</h1>
<p>Una funzione specifica un’azione o un calcolo che porta il sistema da uno stato consistente al successivo. È l’elemento fondamentale dei programmi.</p>
<p>Dovrebbe essere possibile dare un nome significativo alla funzione, specificare i requisiti dei suoi argomenti e indicare chiaramente la relazione tra gli argomenti e il risultato. Un’implementazione non è una specifica. Si provi a pensare a cosa fa una funzione e a come lo fa Le funzioni costituiscono la parte più critica nella maggior parte delle interfacce, quindi si vedano le regole per l’interfaccia.</p>
<p>Riepilogo delle regole delle funzioni:</p>
<p>Regole di definizione di una funzione:</p>
<ul>
<li><a href="#Rf-package">F.1: “Impacchettare” le operazioni significative in funzioni denominandole con cura</a></li>
<li><a href="#Rf-logical">F.2: Una funzione dovrebbe eseguire una sola operazione logica</a></li>
<li><a href="#Rf-single">F.3: Le funzioni devono essere brevi e semplici</a></li>
<li><a href="#Rf-constexpr">F.4: Se una funzione può essere valutata in fase di compilazione, la si dichiara <code>constexpr</code></a></li>
<li><a href="#Rf-inline">F.5: Se una funzione è molto piccola e time-critical, la si dichiara inline</a></li>
<li><a href="#Rf-noexcept">F.6: Se la funzione non può andare in errore [throw], la si dichiara <code>noexcept</code></a></li>
<li><a href="#Rf-smart">F.7: Per un uso generale, si prendono gli argomenti <code>T*</code> o <code>T&amp;</code> anziché gli smart pointer</a></li>
<li><a href="#Rf-pure">F.8: Preferire le funzioni pure</a></li>
<li><a href="#Rf-unused">F.9: I parametri inutilizzati devono essere senza nome</a></li>
</ul>
<p>Regole per l’espressione del passaggio dei parametri:</p>
<ul>
<li><a href="#Rf-conventional">F.15: Preferire metodi semplici e convenzionali per il passaggio delle informazioni</a></li>
<li><a href="#Rf-in">F.16: Per i parametri “in”, si passano i tipi copiati ‘a buon prezzo’ per valore e gli altri per riferimento a <code>const</code></a></li>
<li><a href="#Rf-inout">F.17: I parametri “in-out”, si passano per riferimento non-<code>const</code></a></li>
<li><a href="#Rf-consume">F.18: I parametri “si-sposterà”, si passano per <code>X&amp;&amp;</code> e <code>std::move</code></a></li>
<li><a href="#Rf-forward">F.19: I parametri “forward”, si passano per <code>TP&amp;&amp;</code> e solo <code>std::forward</code> il parametro</a></li>
<li><a href="#Rf-out">F.20: Per i valori “out”, preferire i valori di ritorno ai parametri di output</a></li>
<li><a href="#Rf-out-multi">F.21: Per il return di valori “out” multipli, preferire il ritorno di una struct o una tupla</a></li>
<li><a href="#Rf-ptr-ref">F.60: Preferire <code>T*</code> a <code>T&amp;</code> quando “nessun argomento” è una valida opzione</a></li>
</ul>
<p>Regole sulla semantica del passaggio dei parametri:</p>
<ul>
<li><a href="#Rf-ptr">F.22: Utilizzare <code>T*</code> o <code>owner&lt;T*&gt;</code> per designare un singolo oggetto</a></li>
<li><a href="#Rf-nullptr">F.23: Utilizzare <code>not_null&lt;T&gt;</code> per indicare che “null” non è un valore valido</a></li>
<li><a href="#Rf-range">F.24: Utilizzare <code>span&lt;T&gt;</code> o <code>span_p&lt;T&gt;</code> per indicare una sequenza semiaperta</a></li>
<li><a href="#Rf-zstring">F.25: Utilizzare <code>zstring</code> o <code>not_null&lt;zstring&gt;</code> per indicare una stringa C-style</a></li>
<li><a href="#Rf-unique_ptr">F.26: Utilizzare <code>unique_ptr&lt;T&gt;</code> per trasferire l’ownership dove è necessario un puntatore</a></li>
<li><a href="#Rf-shared_ptr">F.27: Utilizzare <code>shared_ptr&lt;T&gt;</code> per condividere l’ownership</a></li>
</ul>
<p><a name="Rf-value-return"></a>Regole di semantica del valore di ritorno:</p>
<ul>
<li><a href="#Rf-return-ptr">F.42: Restituire <code>T*</code> per indicare (solo) una posizione</a></li>
<li><a href="#Rf-dangle">F.43: Mai (direttamente o indirettamente) restituire un puntatore o un riferimento ad un oggetto locale</a></li>
<li><a href="#Rf-return-ref">F.44: Restituire <code>T&amp;</code> quando la copia è indesiderabile e non è necessario “restituire nessun oggetto”</a></li>
<li><a href="#Rf-return-ref-ref">F.45: Non restituire un <code>T&amp;&amp;</code></a></li>
<li><a href="#Rf-main">F.46: <code>int</code> è il tipo restituito da <code>main()</code></a></li>
<li><a href="#Rf-assignment-op">F.47: Restituire <code>T&amp;</code> dagli operatori di assegnamento</a></li>
<li><a href="#Rf-return-move-local">F.48: Non fare <code>return std::move(local)</code></a></li>
</ul>
<p>Altre regole sulle funzioni:</p>
<ul>
<li><a href="#Rf-capture-vs-overload">F.50: Usare una lambda quando una funzione non va (per acquisire le variabili locali o scrivere una funzione locale)</a></li>
<li><a href="#Rf-default-args">F.51: Potendo scegliere, si preferiscano gli argomenti con default rispetto all’overloading</a></li>
<li><a href="#Rf-reference-capture">F.52: Preferire l’acquisizione per riferimento nelle lambda da usare localmente, compresi quelli passati agli algoritmi</a></li>
<li><a href="#Rf-value-capture">F.53: Evitare l’acquisizione per riferimento nelle lambdas che si non si useranno localmente, compresi quelli restituiti, memorizzati nell’heap o passati da un altro thread</a></li>
<li><a href="#Rf-this-capture">F.54: Se si acquisisce <code>this</code>, se ne acquisiscono esplicitamente tutte le variabili (senza acquisirne i default)</a></li>
<li><a href="#F-varargs">F.55: Non usare gli argomenti <code>va_arg</code></a></li>
</ul>
<p>Le funzioni hanno forti somiglianze con le lambda e gli oggetti funzione.</p>
<p><strong>Si veda anche</strong>: <a href="#SS-lambdas">C.lambdas: Oggetti funzione e lambda</a></p>
<h2 id="f.def-definizioni-di-funzioni"><a name="SS-fct-def"></a>F.def: Definizioni di funzioni</h2>
<p>Una definizione di funzione è una dichiarazione di una funzione che specifica anche l’implementazione della funzione, il corpo della funzione.</p>
<h3 id="f.1-impacchettare-le-operazioni-significative-in-funzioni-dando-loro-un-nome-adeguato"><a name="Rf-package"></a>F.1: “Impacchettare” le operazioni significative in funzioni dando loro un nome adeguato</h3>
<h5 id="motivo-33">Motivo</h5>
<p>Escludere il le parti in comune rende il codice più leggibile, più riutilizzabile e limita gli errori del codice complicato. Se qualcosa è un’azione ben specificata, la si separa dal codice circostante e gli si da un nome.</p>
<h5 id="esempio-da-non-fare-1">Esempio, da non fare</h5>
<pre><code>void read_and_print(istream&amp; is)    // legge e stampa un int
{
int x;
if (is &gt;&gt; x)
cout &lt;&lt; &quot;l&#39;int è &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;;
else
cerr &lt;&lt; &quot;nessun int in input\n&quot;;
}</code></pre>
<p>In <code>read_and_print</code> è sbagliato quasi tutto. Legge, scrive (su un <code>ostream</code> fisso), scrive i messaggi di errore (su un <code>ostream</code> fisso), gestisce solo <code>int</code>s. Non c’è nulla da riutilizzare, le operazioni separate logicamente sono mischiate e le variabili locali restano visibili dopo l’uso. Per un piccolo esempio, questo sembra OK, ma se l’operazione di input, quella di output e la gestione degli errori fossero state più complicate, il groviglio potrebbe diventare difficile da capire.</p>
<h5 id="note-42">Note</h5>
<p>Se si scrive una lambda non banale che potenzialmente si possa utilizzare in più posti, gli si dà un nome e assegnandola a una variabile (di solito non locale).</p>
<h5 id="esempio-30">Esempio</h5>
<pre><code>sort(a, b, [](T x, T y) { return x.rank() &lt; y.rank() &amp;&amp; x.value() &lt; y.value(); });</code></pre>
<p>Dando un nome alla lambda, si spezza l’espressione nelle sue parti logiche fornendo un forte spunto al senso della lambda.</p>
<pre><code>auto lessT = [](T x, T y) { return x.rank() &lt; y.rank() &amp;&amp; x.value() &lt; y.value(); };

sort(a, b, lessT);
find_if(a, b, lessT);</code></pre>
<p>Il codice più breve non è sempre il migliore per prestazioni o manutenibilità.</p>
<h5 id="eccezione-7">Eccezione</h5>
<p>I corpi dei loop, comprese le lambda usate come corpi dei loop, raramente necessitano di avere un nome. Tuttavia, grandi loop (p.es., decine di righe o decine di pagine) possono costituire un problema. La regola <a href="#Rf-single">Le funzioni devono essere brevi e semplici</a> implica “I corpi dei loop devono essere brevi”. Allo stesso modo, le lambda usate come argomenti di callback talvolta non sono banali, ma è improbabile che siano riutilizzabili.</p>
<h5 id="imposizione-30">Imposizione</h5>
<ul>
<li>Cfr <a href="#Rf-single">Le funzioni devono essere brevi e semplici</a></li>
<li>Evidenziare le lambda identiche, o molto simili, utilizzate in più posti.</li>
</ul>
<h3 id="f.2-una-funzione-dovrebbe-eseguire-una-sola-operazione-logica"><a name="Rf-logical"></a>F.2: Una funzione dovrebbe eseguire una sola operazione logica</h3>
<h5 id="motivo-34">Motivo</h5>
<p>Una funzione che esegue una sola operazione è più semplice da comprendere, testare e riutilizzare.</p>
<h5 id="esempio-31">Esempio</h5>
<p>Si consideri:</p>
<pre><code>void read_and_print()    // male
{
int x;
cin &gt;&gt; x;
// controllo per gli errori
cout &lt;&lt; x &lt;&lt; &quot;\n&quot;;
}</code></pre>
<p>Questo è un monolite che ha a che fare con uno specifico input e non avrà mai un altro (diverso) uso. Invece, suddividiamo le funzioni in parti logiche appropriate e parametrizzate:</p>
<pre><code>int read(istream&amp; is)    // meglio
{
int x;
is &gt;&gt; x;
// controllo per gli errori
return x;
}

void print(ostream&amp; os, int x)
{
os &lt;&lt; x &lt;&lt; &quot;\n&quot;;
}</code></pre>
<p>In questo modo si può riutilizzare dove necessario:</p>
<pre><code>void read_and_print()
{
auto x = read(cin);
print(cout, x);
}</code></pre>
<p>Se fosse necessario, si potrebbero ulteriormente ‘templatizzare’ <code>read()</code> e <code>print()</code> sul tipo di dato, il maccanismo di I/O, la risposta agli errori, ecc. Esempio:</p>
<pre><code>auto read = [](auto&amp; input, auto&amp; value)    // meglio
{
input &gt;&gt; value;
// controllo per gli errori
};

auto print(auto&amp; output, const auto&amp; value)
{
output &lt;&lt; value &lt;&lt; &quot;\n&quot;;
}</code></pre>
<h5 id="imposizione-31">Imposizione</h5>
<ul>
<li>Sospettare delle funzioni con più di un parametro “out”. Utilizzare, invece, i valori di ritorno, comprese le <code>tuple</code> per restituire valori multipli.</li>
<li>Sospettare delle “grandi” funzioni che rientrano in una schermata dell’editor. Si consideri di riscrivere la funzione come sotto-operazioni più piccole e con dei nomi adeguati.</li>
<li>Si considerino sospette le funzioni con più di 7 parametri.</li>
</ul>
<h3 id="f.3-le-funzioni-devono-essere-brevi-e-semplici"><a name="Rf-single"></a>F.3: Le funzioni devono essere brevi e semplici</h3>
<h5 id="motivo-35">Motivo</h5>
<p>Le funzioni di grandi dimensioni sono difficili da leggere, hanno maggiori probabilità di contenere codice complesso e hanno maggiori probabilità di avere variabili in vita oltre il loro scope. Le funzioni con strutture di controllo complesse hanno maggiori probabilità di essere lunghe e hanno maggiori probabilità di nascondere errori logici.</p>
<h5 id="esempio-32">Esempio</h5>
<p>Si consideri:</p>
<pre><code>double simple_func(double val, int flag1, int flag2)
// simple_func: prende un valore e restituisce in output l&#39;ASIC atteso,
// dati i due flag della modalità.
{
double intermediate;
if (flag1 &gt; 0) {
intermediate = func1(val);
if (flag2 % 2)
intermediate = sqrt(intermediate);
}
else if (flag1 == -1) {
intermediate = func1(-val);
if (flag2 % 2)
intermediate = sqrt(-intermediate);
flag1 = -flag1;
}
if (abs(flag2) &gt; 10) {
intermediate = func2(intermediate);
}
switch (flag2 / 10) {
case 1: if (flag1 == -1) return finalize(intermediate, 1.171);
break;
case 2: return finalize(intermediate, 13.1);
default: break;
}
return finalize(intermediate, 0.);
}</code></pre>
<p>Questo è troppo complicato. Come essere certi di aver gestito correttamente tutte le possibili alternative? Sì, infrange anche altre regole.</p>
<p>Si può riscrivere:</p>
<pre><code>double func1_muon(double val, int flag)
{
// ???
}

double func1_tau(double val, int flag1, int flag2)
{
// ???
}

double simple_func(double val, int flag1, int flag2)
// simple_func: prende un valore e restituisce in output l&#39;ASIC atteso,
// dati i due flag della modalità.
{
if (flag1 &gt; 0)
return func1_muon(val, flag2);
if (flag1 == -1)
// handled by func1_tau: flag1 = -flag1;
return func1_tau(-val, flag1, flag2);
return 0.;
}</code></pre>
<h5 id="note-43">Note</h5>
<p>“Non rientra nello schermo” è spesso una buona definizione pratica di “troppo grande”. Le funzioni tra una e cinque righe dovrebbero considerarsi la norma.</p>
<h5 id="note-44">Note</h5>
<p>Suddividere le grandi funzioni in funzioni più piccole e con nomi significativi. Le funzioni piccole e semplici si mettono facilmente inline dove se il costo di una call è significativo.</p>
<h5 id="imposizione-32">Imposizione</h5>
<ul>
<li>Segnalare le funzioni che non “rientrano nello schermo”. Quanto è grande uno schermo? Provare 60 righe per 140 caratteri; questo è all’incirca il massimo di una comoda pagina di un libro.</li>
<li>Segnalare le funzioni troppo complesse. Quanto è complesso il troppo complesso? Si potrebbe usare la complessità ciclomatica. Provare “più di 10 percorsi logici”. Un semplice switch vale un percorso.</li>
</ul>
<h3 id="f.4-se-una-funzione-può-essere-valutata-in-fase-di-compilazione-la-si-dichiara-constexpr"><a name="Rf-constexpr"></a>F.4: Se una funzione può essere valutata in fase di compilazione, la si dichiara <code>constexpr</code></h3>
<h5 id="motivo-36">Motivo</h5>
<p><code>constexpr</code> serve per dire al compilatore di consentirne la valutazione durante la compilazione.</p>
<h5 id="esempio-33">Esempio</h5>
<p>Il famoso o famigerato fattoriale:</p>
<pre><code>constexpr int fac(int n)
{
constexpr int max_exp = 17;      // constexpr consente a max_exp di essere usato in Expects
Expects(0 &lt;= n &amp;&amp; n &lt; max_exp);  // evità l&#39;underflow e l&#39;overflow
int x = 1;
for (int i = 2; i &lt;= n; ++i) x *= i;
return x;
}</code></pre>
<p>Questo è C++14. Per il C++11, si usa una formulazione ricorsiva di <code>fac()</code>.</p>
<h5 id="note-45">Note</h5>
<p><code>constexpr</code> non garantisce la valutazione in fase di compilazione; garantisce solo che la funzione può essere valutata al momento della compilazione per degli argomenti costanti se il programmatore lo richiede o se il compilatore decide di farlo per ottimizzare.</p>
<pre><code>constexpr int min(int x, int y) { return x &lt; y ? x : y; }

void test(int v)
{
int m1 = min(-1, 2);            // probabile valutazione durante la compilazione
constexpr int m2 = min(-1, 2);  // valutazione durante la compilazione
int m3 = min(-1, v);            // valutazione durante l&#39;esecuzione
constexpr int m4 = min(-1, v);  // errore: non si può valutare durante la compilazione
}</code></pre>
<h5 id="note-46">Note</h5>
<p>Non cercare di rendere tutte le funzioni <code>constexpr</code>. La maggior parte dei calcoli viene fatta meglio durante l’esecuzione.</p>
<h5 id="note-47">Note</h5>
<p>Qualsiasi API che possa eventualmente dipendere da una configurazione a run-time di alto livello o da logiche aziendali non dovrebbe essere <code>constexpr</code>. Tale personalizzazione non può essere valutata dal compilatore, e qualsiasi funzione <code>constexpr</code>che dipenda da quell’API dovrebbe essere riscritta o non dev’essere <code>constexpr</code>.</p>
<h5 id="imposizione-33">Imposizione</h5>
<p>Impossibile e non necessario. Il compilatore genera un errore se viene chiamata una funzione non-<code>constexpr</code> dove è richiesta una costante.</p>
<h3 id="f.5-se-una-funzione-è-molto-piccola-e-time-critical-la-si-dichiara-inline"><a name="Rf-inline"></a>F.5: Se una funzione è molto piccola e time-critical, la si dichiara <code>inline</code></h3>
<h5 id="motivo-37">Motivo</h5>
<p>Alcuni ottimizzatori riescono a mettere inline senza tale suggerimento del programmatore, ma è meglio non farci affidamento. Misurare! Negli ultimi 40 circa, ci sono stati promessi compilatori che mettessero inline meglio degli umani senza alcun suggerimento. Stiamo ancora aspettando. Specificando <code>inline</code> si invoglia il compilatore a fare un lavoro migliore.</p>
<h5 id="esempio-34">Esempio</h5>
<pre><code>inline string cat(const string&amp; s, const string&amp; s2) { return s + s2; }</code></pre>
<h5 id="eccezione-8">Eccezione</h5>
<p>Non mettere <code>inline</code> una funzione in quella che dovrebbe essere un’interfaccia stabile a meno di non essere certi che non cambierà. Una funzione inline è parte dell’ABI [Application Binary Interface].</p>
<h5 id="note-48">Note</h5>
<p><code>constexpr</code> implica <code>inline</code>.</p>
<h5 id="note-49">Note</h5>
<p>Le funzioni membro definite nella nella classe sono per default <code>inline</code>.</p>
<h5 id="eccezione-9">Eccezione</h5>
<p>Le funzioni template (comprese le funzioni template membro) vengono normalmente definite negli header e quindi sono inline.</p>
<h5 id="imposizione-34">Imposizione</h5>
<p>Segnalare le funzioni <code>inline</code> che hanno più di tre istruzioni e che potrebbero essere dichiarate non inline (come le funzioni membro delle classi).</p>
<h3 id="f.6-se-la-funzione-non-può-andare-in-errore-throw-la-si-dichiara-noexcept"><a name="Rf-noexcept"></a>F.6: Se la funzione non può andare in errore [throw], la si dichiara <code>noexcept</code></h3>
<h5 id="motivo-38">Motivo</h5>
<p>Se non si suppone che venga generata un’eccezione, non si può assumere che il programma la gestisca e dev’essere terminato al più presto. Dichiarando una funzione <code>noexcept</code> si aiutano gli ottimizzatori a ridurre il numero di percorsi di esecuzione alternativi. Si accelera anche l’uscita dopo un errore.</p>
<h5 id="esempio-35">Esempio</h5>
<p>Si inserisce <code>noexcept</code> su tutte le funzioni scritte totalmente in C o un qualsiasi altro linguaggio che non gestisca le eccezioni. La C++ Standard Library lo fa implicitamente per tutte le funzioni nella C Standard Library.</p>
<h5 id="note-50">Note</h5>
<p>Le funzioni <code>constexpr</code>possono andare in errore quando vengono valutate a run time, quindi potrebbe essere necessario definirne alcune <code>noexcept</code>.</p>
<h5 id="esempio-36">Esempio</h5>
<p>Si può usare <code>noexcept</code> anche su funzioni che possono sbagliare:</p>
<pre><code>vector&lt;string&gt; collect(istream&amp; is) noexcept
{
vector&lt;string&gt; res;
for (string s; is &gt;&gt; s;)
res.push_back(s);
return res;
}</code></pre>
<p>Se <code>collect()</code> esaurisce la memoria, il programma va in crash. A meno che il programma non sia concepito per sopravvivere all’esaurimento della memoria, questa potrebbe essere la cosa giusta da fare; <code>terminate()</code> può generare informazioni adeguate nel log degli errori (ma dopo aver esaurito la memoria è difficile fare qualcosa di intelligente).</p>
<h5 id="note-51">Note</h5>
<p>Si deve essere consapevoli dell’ambiente di esecuzione in cui gira il proprio codice quando si decide di dichiarare una funzione <code>noexcept</code>, specialmente per i problemi causati dagli errori e dalle allocazioni. Un codice che si intende essere perfettamente generale (come la libreria standard ed il codice di altre utility simili) deve supportare ambienti dove una ecezione <code>bad_alloc</code> può essere gestita in modo significativo. Tuttavia, la maggior parte dei programmi e degli ambienti di esecuzione non è in grado di gestire in modo significativo un errore di allocazione e, in quei casi, l’interruzione del programma è la risposta più pulita e semplice a un errore di allocazione. Se si sa che il proprio codice non possa risponderead un errore di allocazione, può essere opportuno aggiungere <code>noexcept</code> anche alle funzioni che allocano.</p>
<p>In altri termini: Nella maggior parte dei programmi, la maggior parte delle funzioni può andare in errore (p.es., perché usano <code>new</code>, chiamano funzioni che lo fanno o usano funzioni di libreria che riportano un errore da gestire), quindi non ci si limiti a spargere i <code>noexcept</code> dappertutto senza considerare se sia possibile gestire gli errori.</p>
<p><code>noexcept</code> è più utile (e chiaramente più corretta) per le funzioni a basso livello usate di frequente.</p>
<h5 id="note-52">Note</h5>
<p>I distruttori, le funzioni <code>swap</code>, le operazioni move, e i costruttori di default non dovrebbero mai sollevare eccezioni. Si veda anche <a href="#Rc-default00">C.44</a>.</p>
<h5 id="imposizione-35">Imposizione</h5>
<ul>
<li>Segnalare le funzioni non <code>noexcept</code>, ma che non sollevano errori.</li>
<li>Segnalare gli <code>swap</code>, i <code>move</code>, i distruttori e i costruttori di default.</li>
</ul>
<h3 id="f.7-per-un-uso-generale-si-prendono-gli-argomenti-t-o-t-anziché-gli-smart-pointer"><a name="Rf-smart"></a>F.7: Per un uso generale, si prendono gli argomenti <code>T*</code> o <code>T&amp;</code> anziché gli smart pointer</h3>
<h5 id="motivo-39">Motivo</h5>
<p>Il passaggio di uno smart pointer trasferisce o condivide la proprietà e deve essere utilizzato solo quando si intende la semantica della proprietà (cfr. <a href="#Rr-smartptrparam">R.30</a>). Il passaggio tramite smart pointer limita l’uso di una funzione ai chiamanti che usano gli smart pointer. Il passaggio di uno smart pointer shared (p.es., <code>std::shared_ptr</code>) implica un costo a run-time.</p>
<h5 id="esempio-37">Esempio</h5>
<pre><code>// accetta qualsiasi int*
void f(int*);

// può accettare solo int per i quali si vuol trasferire la proprietà
void g(unique_ptr&lt;int&gt;);

// può accettare solo int per i quali si vuol condividere la proprietà
void g(shared_ptr&lt;int&gt;);

// non cambia la propretà, ma richiede una particolare ownership del chiamante
void h(const unique_ptr&lt;int&gt;&amp;);

// accetta qualsiasi int
void h(int&amp;);</code></pre>
<h5 id="esempio-cattivo-18">Esempio, cattivo</h5>
<pre><code>// chiamato
void f(shared_ptr&lt;widget&gt;&amp; w)
{
// ...
use(*w); // usa solo w -- la durata [lifetime] non è affatto usata
// ...
};</code></pre>
<p>Si veda in seguito in <a href="#Rr-smartptrparam">R.30</a>.</p>
<h5 id="note-53">Note</h5>
<p>Possiamo intercettare staticamente i puntatori appesi [dangling], quindi non è necessario affidarsi alla gestione delle risorse per evitare violazioni di tali puntatori.</p>
<p><strong>Si veda anche</strong>:</p>
<ul>
<li><a href="#Rf-ptr-ref">Preferire <code>T*</code> a <code>T&amp;</code> quando “nessun argomento” è una valida opzione</a></li>
<li><a href="#Rr-summary-smartptrs">Riepilogo delle regole sugli smart pointer</a></li>
</ul>
<h5 id="imposizione-36">Imposizione</h5>
<p>Segnala un parametro di tipo smart pointer (un tipo che fa l’overload di <code>operator-&gt;</code> o di <code>operator*</code>) per cui non viene usata la semantica della proprietà; questo è</p>
<ul>
<li>copiabile ma mai copiato/spostato [moved] o ‘movable’ ma mai spostato</li>
<li>e che non viene mai modificato né passato ad un’altra funzione che potrebbe farlo.</li>
</ul>
<h3 id="f.8-preferire-le-funzioni-pure"><a name="Rf-pure"></a>F.8: Preferire le funzioni pure</h3>
<h5 id="motivo-40">Motivo</h5>
<p>Sulle funzioni pure è più facile ragionarci, a volte sono più facili da ottimizzare (ed anche da parallelizzare), e talvolta si possono memoizzare [!=memorizzare].</p>
<h5 id="esempio-38">Esempio</h5>
<pre><code>template&lt;class T&gt;
auto square(T t) { return t * t; }</code></pre>
<h5 id="imposizione-37">Imposizione</h5>
<p>Non è possibile.</p>
<h3 id="f.9-i-parametri-inutilizzati-devono-essere-senza-nome"><a name="Rf-unused"></a>F.9: I parametri inutilizzati devono essere senza nome</h3>
<h5 id="motivo-41">Motivo</h5>
<p>Leggibilità. Soppressione dei warning sui parametri inutilizzati.</p>
<h5 id="esempio-39">Esempio</h5>
<pre><code>X* find(map&lt;Blob&gt;&amp; m, const string&amp; s, Hint);   // c&#39;era una volta un hint</code></pre>
<h5 id="note-54">Note</h5>
<p>La possibilità di avere parametri senza nome è stata introdotta all’inizio del 1980 per risolvere questo problema.</p>
<h5 id="imposizione-38">Imposizione</h5>
<p>Segnalare i nomi dei parametri inutilizzati.</p>
<h2 id="f.call-passaggio-di-parametri"><a name="SS-call"></a>F.call: Passaggio di parametri</h2>
<p>Esistono vari modi per passare i parametri ad una funzione e per restituire dei valori.</p>
<h3 id="f.15-preferire-metodi-semplici-e-convenzionali-per-il-passaggio-delle-informazioni"><a name="Rf-conventional"></a>F.15: Preferire metodi semplici e convenzionali per il passaggio delle informazioni</h3>
<h5 id="motivo-42">Motivo</h5>
<p>L’uso di tecniche “insolite e ingegnose” provoca sorpresa, rallenta la comprensione da parte di altri programmatori e favorisce i bug. Se si sente veramente il bisogno di un’ottimizzazione al di là delle comuni tecniche, effettuare delle misure per essere sicuri che sia un effettivo miglioramento e si documenti/commenti perché la miglioria potrebbe non essere portabile.</p>
<p>Le seguenti tabelle riassumono i consigli nelle linee-guida seguenti, F.16-21.</p>
<p>Passaggio di parametri normale:</p>
<figure>
<img src="./param-passing-normal.png" title="Passaggio di parametri normale" alt="" /><figcaption>Tabella dei normali passaggi di parametri</figcaption>
</figure>
<p>Passaggio di parametri avanzato:</p>
<figure>
<img src="./param-passing-advanced.png" title="Passaggio di parametri avanzato" alt="" /><figcaption>Tabella dei passaggi di parametri avanzati</figcaption>
</figure>
<p>Utilizzare le tecniche avanzate solo dopo averne dimostrato la necessità documentandola in un commento.</p>
<p>Per il passaggio di sequenze di caratteri, cfr. <a href="#SS-string">String</a>.</p>
<h3 id="f.16-per-i-parametri-in-si-passano-i-tipi-copiati-a-buon-prezzo-per-valore-e-gli-altri-per-riferimento-a-const"><a name="Rf-in"></a>F.16: Per i parametri “in”, si passano i tipi copiati ‘a buon prezzo’ per valore e gli altri per riferimento a <code>const</code></h3>
<h5 id="motivo-43">Motivo</h5>
<p>Entrambi comunicano al chiamante che una funzione non modificherà l’argomento ed entrambi consentono l’inizializzazione per rvalue.</p>
<p>Quello che è “economico da copiare” dipende dall’architettura della macchina, ma due o tre word (double, puntatori, riferimenti) solitamente è meglio passarli per valore. Quando la copia è economica, nulla ne batte la semplicità e la sicurezza e per gli oggetti piccoli (fino a due o tre word) è anche più veloce del passaggio per riferimento perché non richiede, alla funzione, un’indirezione extra per l’accesso.</p>
<h5 id="esempio-40">Esempio</h5>
<pre><code>void f1(const string&amp; s);  // OK: passaggio per riferimento a const; è sempre economico

void f2(string s);         // male: potenzialmente costoso

void f3(int x);            // OK: Imbattibile

void f4(const int&amp; x);     // male: in f4() c&#39;è un overhead per l&#39;accesso</code></pre>
<p>Per i (soli) usi avanzati, dove c’è davvero bisogno di ottimizzare gli rvalue passati come parametri “input-only”:</p>
<ul>
<li>Se la funzione eseguirà incondizionatamente un move dell’argomento, prenderlo per <code>&amp;&amp;</code>. Cfr. <a href="#Rf-consume">F.18</a>.</li>
<li>Se la funzione manterrà la copia dell’argomento, oltre a passarlo per <code>const&amp;</code> (per gli lvalue), si aggiunge un overload che passa il parametro per <code>&amp;&amp;</code> (per gli rvalue) e, nel corpo della funzione, degli <code>std::move</code> su di esso alla sua destinazione. In sostanza, questi overload aggiungono un “si-sposterà-da”; cfr. <a href="#Rf-consume">F.18</a>.</li>
<li>In casi speciali, come i parametri “input + copia” multipli, si considera l’uso del ‘perfect forwarding’. Cfr. <a href="#Rf-forward">F.19</a>.</li>
</ul>
<h5 id="esempio-41">Esempio</h5>
<pre><code>int multiply(int, int); // soli int in input, si passano per valore

// il suffisso è input-only ma non economico quanto un int, passaggio per const&amp;
string&amp; concatenate(string&amp;, const string&amp; suffix);

void sink(unique_ptr&lt;widget&gt;);  // solo in input e sposta la proprietà di widget</code></pre>
<p>Evitare “tecniche esoteriche” come:</p>
<ul>
<li>Passaggio di argomenti come <code>T&amp;&amp;</code> “per efficienza”. La maggior parte delle voci sulle prestazione del passaggio per <code>&amp;&amp;</code> sono false o debole (ma si vedano <a href="#Rf-consume">F.18</a> e <a href="#Rf-forward">F.19</a>).</li>
<li>Restituzione di <code>const T&amp;</code> dalle assegnazioni e operazioni simili (cfr. <a href="#Rf-assignment-op">F.47</a>.)</li>
</ul>
<h5 id="esempio-42">Esempio</h5>
<p>Supponendo che <code>Matrix</code> abbia le operazioni move (possibilmente mantenendo i suoi elementi in un <code>std::vector</code>):</p>
<pre><code>Matrix operator+(const Matrix&amp; a, const Matrix&amp; b)
{
Matrix res;
// ... riempie res con la somma ...
return res;
}

Matrix x = m1 + m2;  // costruttore move

y = m3 + m3;         // assegnazione move</code></pre>
<h5 id="note-55">Note</h5>
<p>L’ottimizzazione del valore di ritorno non gestisce il caso dell’assegnazione, ma l’assegnazione move lo fa.</p>
<p>Si può assumere che un riferimento riguardi un oggetto valido (regola de linguaggio). Non esiste un (legittimo) “riferimento null”. Se si necessita della nozione di un valore opzionale, si usa un puntatore, <code>std::optional</code> o un valore speciale usato per denotare “nessun valore”.</p>
<h5 id="imposizione-39">Imposizione</h5>
<ul>
<li>(Semplice) ((Foundation)) Si emette un warning quando un parametro che viene passato per valore ha una dimensione maggiore di <code>2 * sizeof(void*)</code>. Si suggerisce di usare, invece, un riferimento a <code>const</code>.</li>
<li>(Semplice) ((Foundation)) Si emette un warning quando un parametro passato per riferimento a <code>const</code> ha una dimensione inferiore a <code>2 * sizeof(void*)</code>. Si suggerisce, invece, di passare per valore.</li>
<li>(Semplice) ((Foundation)) Si emette un warning quando un parametro passato per riferimento a <code>const</code> è <code>move</code>d.</li>
</ul>
<h3 id="f.17-i-parametri-in-out-si-passano-per-riferimento-non-const"><a name="Rf-inout"></a>F.17: I parametri “in-out”, si passano per riferimento non-<code>const</code></h3>
<h5 id="motivo-44">Motivo</h5>
<p>Ciò chiarisce ai chiamanti che si presuppone che l’oggetto verrà modificato.</p>
<h5 id="esempio-43">Esempio</h5>
<pre><code>void update(Record&amp; r);  // presume che update scriva in r</code></pre>
<h5 id="note-56">Note</h5>
<p>Un argomento <code>T&amp;</code> può passare informazioni ad una funzione così come estrarne. Quindi <code>T&amp;</code> potrebbe essere un parametro-in-out. Questo di per sé può essere un problema e una fonte di errori:</p>
<pre><code>void f(string&amp; s)
{
s = &quot;New York&quot;;  // errore non ovvio
}

void g()
{
string buffer = &quot;.................................&quot;;
f(buffer);
// ...
}</code></pre>
<p>Qui, chi ha scritto <code>g()</code> sta fornendo un buffer a <code>f()</code> da riempire, ma <code>f()</code> semplicemente lo sostituisce (ad un costo leggermente superiore della semplice copia dei caratteri). Un brutto errore logico può aversi se chi scrive <code>g()</code> assume erroneamente la dimensione del <code>buffer</code>.</p>
<h5 id="imposizione-40">Imposizione</h5>
<ul>
<li>(Moderate) ((Foundation)) Emette un warning per le funzioni relative a riferimenti di parametri non-<code>const</code> che <em>non</em> scrivono in essi.</li>
<li>(Simple) ((Foundation)) Emette un warning quando un parametro non-<code>const</code> passato per riferimento [viene spostato] ne viene fatto un <code>move</code>.</li>
</ul>
<h3 id="f.18-i-parametri-si-sporterà-si-passano-per-x-e-stdmove-the-parameter"><a name="Rf-consume"></a>F.18: I parametri “si-sporterà”, si passano per <code>X&amp;&amp;</code> e <code>std::move</code> the parameter</h3>
<h5 id="motivo-45">Motivo</h5>
<p>È efficiente ed elimina i bug dal lato della chiamata: <code>X&amp;&amp;</code> si lega [bind] agli rvalue, cosa che richiede una esplicita <code>std::move</code> dal lato del chiamante se si passa un lvalue.</p>
<h5 id="esempio-44">Esempio</h5>
<pre><code>void sink(vector&lt;int&gt;&amp;&amp; v) {   // sink prende la proprietà di tutto quello che possiede l&#39;argomento
// quì, di solito, potrebbero esserci accessi const di v
store_somewhere(std::move(v));
// solitamente quì on si usa più v; viene spostato
}</code></pre>
<p>Si noti che <code>std::move(v)</code> consente a <code>store_somewhere()</code> di lasciare <code>v</code> in uno stato spostato [moved-from]. <a href="#Rc-move-semantic">Questo potrebbe essere pericoloso</a>.</p>
<h5 id="eccezione-10">Eccezione</h5>
<p>I tipi a proprietà unica che sono move-only ed economici-da-spostare, come <code>unique_ptr</code>, si possono passare anche per valore che è più semplice da scrivere e si ha lo stesso effetto. Passando per valore si genera un’operazione extra (economica) di move, ma si preferisce innanzitutto la semplicità e la chiarezza.</p>
<p>Per esempio:</p>
<pre><code>template &lt;class T&gt;
void sink(std::unique_ptr&lt;T&gt; p) {
// usa p ... forse std::move(p) altrove in seguito
}   // p viene distrutto</code></pre>
<h5 id="imposizione-41">Imposizione</h5>
<ul>
<li>Segnala tutti i parametri <code>X&amp;&amp;</code> (dove <code>X</code> non è il nome di un parametro di tipo template) dove il corpo della funzione li usa senza <code>std::move</code>.</li>
<li>Segnala l’accesso a oggetti spostati [moved-from].</li>
<li>Non spostare condizionalmente oggetti</li>
</ul>
<h3 id="f.19-i-parametri-forward-si-passano-per-tp-e-solo-stdforward-il-parametro"><a name="Rf-forward"></a>F.19: I parametri “forward”, si passano per <code>TP&amp;&amp;</code> e solo <code>std::forward</code> il parametro</h3>
<h5 id="motivo-46">Motivo</h5>
<p>Se l’oggetto deve essere passato ad altro codice e non direttamente usato da questa funzione, vogliamo rendere questa funzione agnostica rispetto all’argomento <code>const</code> e rvalue.</p>
<p>In quel caso, e solo in quel caso, si rende il parametro <code>TP&amp;&amp;</code> dove <code>TP</code> è un parametro di tipo template – esso contemporaneamente <em>ignora</em> e <em>preserva</em> l’essere <code>const</code> e rvalue. Pertanto, qualsiasi codice che utilizza un <code>TP&amp;&amp;</code> dichiara implicitamente che esso stesso non considera le variabili <code>const</code> e rvalue (perché le ignora), ma che intende passare il valore ad un altro codice che si occuperà di <code>const</code> e rvalue (dato che è preservato). Se usato come parametro <code>TP&amp;&amp;</code> è sicuro perché qualsiasi oggetto temporaneo passato dal chiamante vivrà per tutta la durata della chiamata alla funzione. Un parametro di tipo <code>TP&amp;&amp;</code> deve essenzialmente essere sempre inoltrato tramite <code>std::forward</code> nel corpo della funzione.</p>
<h5 id="esempio-45">Esempio</h5>
<pre><code>template &lt;class F, class... Args&gt;
inline auto invoke(F f, Args&amp;&amp;... args) {
return f(forward&lt;Args&gt;(args)...);
}

??? calls ???</code></pre>
<h5 id="imposizione-42">Imposizione</h5>
<ul>
<li>Si segnala una funzione che prende un parametro <code>TP&amp;&amp;</code> (dove <code>TP</code> è il nome di un parametro di tipo template) e ci fa qualsiasi cosa ma non lo <code>std::forward</code> esattamente una volta su ogni percorso statico.</li>
</ul>
<h3 id="f.20-per-i-valori-out-preferire-i-valori-di-ritorno-ai-parametri-di-output"><a name="Rf-out"></a>F.20: Per i valori “out”, preferire i valori di ritorno ai parametri di output</h3>
<h5 id="motivo-47">Motivo</h5>
<p>Un valore restituito è auto-documentante, mentre un <code>&amp;</code> potrebbe essere sia in-out che solo-out e potrebbe essere usato erroneamente.</p>
<p>Ciò include anche grandi oggetti come i contenitori standard che usano operazioni implicite di move per le prestazioni e per evitare un’esplicita gestione della memoria.</p>
<p>Se ci sono più valori da restituire, si <a href="#Rf-out-multi">usa una tupla</a> o un simile tipo multi-membro.</p>
<h5 id="esempio-46">Esempio</h5>
<pre><code>// OK: restituisce i puntatori agli elementi col valore x
vector&lt;const int*&gt; find_all(const vector&lt;int&gt;&amp;, int x);

// Male: mette i puntatori agli elementi col valore x come in-out
void find_all(const vector&lt;int&gt;&amp;, vector&lt;const int*&gt;&amp; out, int x);</code></pre>
<h5 id="note-57">Note</h5>
<p>Una <code>struct</code> di molti (singolarmente economici per il move) elementi si può risultare costosa per il move.</p>
<p>Non è consigliabile restituire un valore <code>const</code>. Un consiglio così vecchio è ormai obsoleto; non aggiunge valore e interferisce con la semantica di move.</p>
<pre><code>const vector&lt;int&gt; fct();    // male: questo &quot;const&quot; è più un problema che altro

vector&lt;int&gt; g(const vector&lt;int&gt;&amp; vx)
{
// ...
fct() = vx;   // impedito dal &quot;const&quot;
// ...
return fct(); // copia costosa: la semantica del move viene soppressa dal &quot;const&quot;
}</code></pre>
<p>L’argomento per aggiungere <code>const</code> ad un valore di ritornoè che impedisce (rarissimamente) accessi accidentali a un elemento temporaneo. L’argomento contro è che impedisce (molto di frequente) l’uso della semantica move.</p>
<h5 id="eccezioni">Eccezioni</h5>
<ul>
<li>Per i tipi [non-value], come i tipi nella gerarchia ereditaria, si restituisce un oggetto con <code>unique_ptr</code> o con <code>shared_ptr</code>.</li>
<li>Se un tipo è cstoso da subire un move (p.es., <code>array&lt;BigPOD&gt;</code>), si consideri di allocarlo nel [free store] e restituirne un handle (p.es., <code>unique_ptr</code>), o passandolo in un riferimento ad un oggetto destinazione non-<code>const</code> da riempire (da usarsi come parametro di uscita).</li>
<li>Per riutilizzare un oggetto che porta il suo contenuto (p.es., <code>std::string</code>, <code>std::vector</code>) attraverso più chiamate alla funzione in un loop interno: lo si <a href="#Rf-out-multi">tratta come un parametro in/out e lo si passa per riferimento</a>.</li>
</ul>
<h5 id="esempio-47">Esempio</h5>
<pre><code>struct Package {      // caso eccezionale: oggetto costoso-per-il-move
char header[16];
char load[2024 - 16];
};

Package fill();       // Male: grande valore di ritorno
void fill(Package&amp;);  // OK

int val();            // OK
void val(int&amp;);       // Male: val legge il proprio argomento</code></pre>
<h5 id="imposizione-43">Imposizione</h5>
<ul>
<li>Segnalare il riferimento a parametri non-<code>const</code> che non vengono letti prima di essere scritti e sono di un tipo economico da restituire; questi dovrebbero essere valori di ritorno in “out”.</li>
<li>Segnala la restituzione di un valore <code>const</code>. Per risolvere il problema: Rimuovere <code>const</code> nel restituire un valore non-<code>const</code>.</li>
</ul>
<h3 id="f.21-per-il-return-di-valori-out-multipli-preferire-il-ritorno-di-una-struct-o-una-tupla"><a name="Rf-out-multi"></a>F.21: Per il return di valori “out” multipli, preferire il ritorno di una struct o una tupla</h3>
<h5 id="motivo-48">Motivo</h5>
<p>Un valore di ritorno si auto-dichiara come valore “output-only”. Si noti che il C++ ha più valori di ritorno, per convenzione usando una <code>tupla</code> (compreso <code>pair</code>), forse con l’ulteriore vantaggio di <code>tie</code> dal lato del chiamante. Preferire l’uso di una struttura con un nome dove ci sono semantiche sul valore restituito. Altrimenti, è utile una <code>tuple</code> senza nome, nel codice generico.</p>
<h5 id="esempio-48">Esempio</h5>
<pre><code>// BAD: parametro output-only documentato in un commento
int f(const string&amp; input, /*output only*/ string&amp; output_data)
{
// ...
output_data = something();
return status;
}

// GOOD: auto-descrittivo
tuple&lt;int, string&gt; f(const string&amp; input)
{
// ...
return make_tuple(status, something());
}</code></pre>
<p>La libreria standard di C++98 usava già questo stile, perché una <code>pair</code> è una <code>tuple</code> di due elementi. Per esempio, dato un <code>set&lt;string&gt; my_set</code>, si consideri:</p>
<pre><code>// C++98
result = my_set.insert(&quot;Hello&quot;);
if (result.second) do_something_with(result.first);    // workaround</code></pre>
<p>Col C++11 lo possiamo scrivere mettendo il risultato direttamente nelle variabili locali esistenti:</p>
<pre><code>UnCertoTipo iter;                                // il default inizializza se non abbiamo già
AltroTipo success;                        // usato queste variabili per altri scopi

tie(iter, success) = my_set.insert(&quot;Hello&quot;);   // normale valore di ritorno
if (success) do_something_with(iter);</code></pre>
<p>Col C++17 si possono usare i “structured bindings” per dichiarare ed inizializzare le variabili multiple:</p>
<pre><code>if (auto [ iter, success ] = my_set.insert(&quot;Hello&quot;); success) do_something_with(iter);</code></pre>
<h5 id="eccezione-11">Eccezione</h5>
<p>A volte c’è bisogno di passare un oggetto ad una funzione per modificarne lo stato. In questi casi, passare l’oggetto per riferimento <a href="#Rf-inout"><code>T&amp;</code></a> è solitamente la tecnica giusta. Restituire esplicitamente un parametro in-out ancora come valore di ritorno spesso non è necessario. Per esempio:</p>
<pre><code>istream&amp; operator&gt;&gt;(istream&amp; is, string&amp; s);    // molto simile a std::operator&gt;&gt;()

for (string s; cin &gt;&gt; s; ) {
// fa qualcosa con la riga
}</code></pre>
<p>Qui, sia <code>s</code> che <code>cin</code> vengono usati come parametri in-out. Si passa <code>cin</code> per riferimento (non-<code>const</code>) per essere in grado di modificarne lo stato. Si passa <code>s</code> per evitare ripetute allocazioni. Riutilizzando <code>s</code> (passato per riferimento), si alloca nuova memoria solo quando è necessario espandere la capacità di <code>s</code>. Questa tecnica è talvolta detta schema di “out allocato-dal-chiamante” ed è particolarmente utile per i tipi, come <code>string</code> e <code>vector</code>, che eseguono allocazioni nel [free store].</p>
<p>Per confrontare, se si passassero i valori in uscita come valori di ritorno, si farebbe qualcosa del genere:</p>
<pre><code>pair&lt;istream&amp;, string&gt; get_string(istream&amp; is);  // non raccomandato
{
string s;
is &gt;&gt; s;
return {is, s};
}

for (auto p = get_string(cin); p.first; ) {
// fa qualcosa con p.second
}</code></pre>
<p>Riteniamo che sia notevolmente meno elegante con prestazioni significativamente meno performanti.</p>
<p>Per una lettura veramente rigorosa di questa regola (F.21), l’eccezione non è realmente un’eccezione perché si basa su parametri in-out, anziché su parametri di out citati nella regola. Tuttavia, preferiamo essere espliciti, piuttosto che criptici.</p>
<h5 id="note-58">Note</h5>
<p>In molti casi, può essere utile restituire un tipo specifico definito dall’utente. Per esempio:</p>
<pre><code>struct Distance {
int value;
int unit = 1;   // 1 significa metri
};

Distance d1 = measure(obj1);        // accesso a d1.value e a d1.unit
auto d2 = measure(obj2);            // accesso a d2.value e a d2.unit
auto [value, unit] = measure(obj3); // accesso a value e a unit; in qualche modo ridondante
// per chi non conosce measure()
auto [x, y] = measure(obj4);        // da non fare; è probabile che confonda</code></pre>
<p>I super-generici <code>pair</code> e <code>tuple</code> si devono usare solo quando il valore restituito rappresenta entità indipendenti anziché un’astrazione.</p>
<p>Un altro esempio, si usa uno specifico tipo lungo le righe di <code>variant&lt;T, error_code&gt;</code>, anziché usare la generica <code>tupla</code>.</p>
<h5 id="imposizione-44">Imposizione</h5>
<ul>
<li>I parametri di output devono essere sostituiti da valori di ritorno. Un parametro di output è quello in cui la funzione scrive, invoca una funzione funzione membro non-<code>const</code> o lo passa come non-<code>const</code>.</li>
</ul>
<h3 id="f.22-utilizzare-t-o-ownert-per-designare-un-singolo-oggetto"><a name="Rf-ptr"></a>F.22: Utilizzare <code>T*</code> o <code>owner&lt;T*&gt;</code> per designare un singolo oggetto</h3>
<h5 id="motivo-49">Motivo</h5>
<p>Leggibilità: chiarisce il significato di un semplice puntatore. Consente un significativo supporto di tool.</p>
<h5 id="note-59">Note</h5>
<p>Nel tradizionale codice C e C++, si usa un semplice <code>T*</code> per molti scopi molto diversi, come:</p>
<ul>
<li>Identificare un (singolo) oggetto (da non cancellare in questa funzione)</li>
<li>Puntare ad un oggetto allocato nel [free store] (e cancellarlo in seguito)</li>
<li>Contenere il <code>nullptr</code></li>
<li>Identificare una stringa C-style (array di caratteri ‘zero-terminated’)</li>
<li>Identificare un array con una lunghezza specificata separatamente</li>
<li>Identificare una posizione in un array</li>
</ul>
<p>Questo rende difficile capire cosa fa il codice e cosa dovrebbe fare. Complica il controllo e il supporto dei tool.</p>
<h5 id="esempio-49">Esempio</h5>
<pre><code>void use(int* p, int n, char* s, int* q)
{
p[n - 1] = 666; // Bad: non si sa se p punti n elementi;
// si suppone che non lo faccia o si usa span&lt;int&gt;
cout &lt;&lt; s;      // Bad: non si sa se questo s punta ad un array zero-terminated di caratteri;
// si suppone che non lo faccia o si usa zstring
delete q;       // Bad: non si sa se *q sia allocato sul [free store];
// si assume che non lo sia o si usa owner
}</code></pre>
<p>Meglio</p>
<pre><code>void use2(span&lt;int&gt; p, zstring s, owner&lt;int*&gt; q)
{
p[p.size() - 1] = 666; // OK, è possibile intercettare un errore di range
cout &lt;&lt; s; // OK
delete q;  // OK
}</code></pre>
<h5 id="note-60">Note</h5>
<p><code>owner&lt;T*&gt;</code> rappresenta la proprietà [ownership], <code>zstring</code> rappresenta una stringa C-style.</p>
<p><strong>Inoltre</strong>: Si suppone che un <code>T*</code> ottenuto da uno smart pointer a <code>T</code> (p.es., <code>unique_ptr&lt;T&gt;</code>) punti ad un singolo elemento.</p>
<p><strong>Si veda anche</strong>: <a href="#S-gsl">Libreria di supporto</a></p>
<p><strong>Si veda anche</strong>: <a href="#Ri-array">Non passare un array come singolo puntatore</a></p>
<h5 id="imposizione-45">Imposizione</h5>
<ul>
<li>(Semplice) ((Bounds)) Segnala un warning per ogni operazione aritmetica o espressione di tipo puntatore che risulti nel valore di un tipo puntatore.</li>
</ul>
<h3 id="f.23-utilizzare-not_nullt-per-indicare-che-null-non-è-un-valore-valido"><a name="Rf-nullptr"></a>F.23: Utilizzare <code>not_null&lt;T&gt;</code> per indicare che “null” non è un valore valido</h3>
<h5 id="motivo-50">Motivo</h5>
<p>Chiarezza. Una funzione con un parametro <code>not_null&lt;T&gt;</code> chiarisce che il chiamante della funzione è responsabile di tutti i controlli <code>nullptr</code> necessari. Allo stesso modo, una funzione con un valore di ritorno <code>not_null&lt;T&gt;</code> chiarisce che il chiamante della funzione non deve controllare per <code>nullptr</code>.</p>
<h5 id="esempio-50">Esempio</h5>
<p><code>not_null&lt;T*&gt;</code> rende ovvio ad un lettore (umano o una macchina) che un test per <code>nullptr</code> non è necessario prima di dereferenziare. Inoltre, durante il debug, <code>owner&lt;T*&gt;</code> e <code>not_null&lt;T&gt;</code> si possono automatizzare per il controllo della correttezza.</p>
<p>Si consideri:</p>
<pre><code>int length(Record* p);</code></pre>
<p>Quando si chiama <code>length(p)</code> si deve prima verificare se <code>p</code> sia <code>nullptr</code>? L’implementazione di <code>length()</code> dovrebbe verificare se <code>p</code> è <code>nullptr</code>?</p>
<pre><code>// è compito del chiamante assicurarsi che p != nullptr
int length(not_null&lt;Record*&gt; p);

// l&#39;implementatore di length() deve presumere che p == nullptr se possibile
int length(Record* p);</code></pre>
<h5 id="note-61">Note</h5>
<p>Si presume che un <code>not_null&lt;T*&gt;</code> non sia <code>nullptr</code>; un <code>T*</code> può essere <code>nullptr</code>; entrambi si possono rappresentare in memoria come un <code>T*</code> (quindi non è implicito alcun overhead a run-time).</p>
<h5 id="note-62">Note</h5>
<p><code>not_null</code> non è solo per i puntatori [built-in]. Funziona con <code>unique_ptr</code>, <code>shared_ptr</code> ed altri tipi di puntatori.</p>
<h5 id="imposizione-46">Imposizione</h5>
<ul>
<li>(Semplice) Emette un warning se un [raw] puntatore viene dereferenziato senza essere testato contro i <code>nullptr</code> (o equivalente) in una funzione, suggerendo che, invece, sia dichiarato <code>not_null</code>.</li>
<li>(Semplice) Solleva un errore se un puntatore [raw] viene a volte dereferenziato dopo un test per <code>nullptr</code> (o equivalente) in una funzione e talvolta non lo è.</li>
<li>(Semplice) Emette un earning se un puntatore <code>not_null</code> viene testato per <code>nullptr</code> in una funzione.</li>
</ul>
<h3 id="f.24-utilizzare-spant-o-span_pt-per-indicare-una-sequenza-semiaperta"><a name="Rf-range"></a>F.24: Utilizzare <code>span&lt;T&gt;</code> o <code>span_p&lt;T&gt;</code> per indicare una sequenza semiaperta</h3>
<h5 id="motivo-51">Motivo</h5>
<p>Intervalli informali/non-espliciti sono fonte di errori.</p>
<h5 id="esempio-51">Esempio</h5>
<pre><code>X* find(span&lt;X&gt; r, const X&amp; v);    // cerca v in r

vector&lt;X&gt; vec;
// ...
auto p = find({vec.begin(), vec.end()}, X{});  // cerca X{} in vec</code></pre>
<h5 id="note-63">Note</h5>
<p>Gli intervalli sono estremamente comuni nel codice C++. In genere, sono impliciti e il loro corretto utilizzo è molto difficile da garantire. In particolare, data una coppia di argomenti <code>(p, n)</code> che designa un array <code>[p:p+n)</code>, è generalmente impossibile sapere se ci sono davvero <code>n</code> elementi a cui accedere dopo <code>*p</code>. <code>span&lt;T&gt;</code> e <code>span_p&lt;T&gt;</code> sono semplici classi di supporto [helper] che designano un intervallo <code>[p:q)</code> e un intervallo che inizia con <code>p</code> e termina con il primo elemento per cui un predicato è vero, rispettivamente.</p>
<h5 id="esempio-52">Esempio</h5>
<p>Un <code>span</code> rappresenta un intervallo di elementi, ma come si possono manipolare gli elementi di quell’intervallo?</p>
<pre><code>void f(span&lt;int&gt; s)
{
// attraversamento di range (garantito corretto)
for (int x : s) cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;

// attraversamento in stile C (potenzialmente controllato)
for (gsl::index i = 0; i &lt; s.size(); ++i) cout &lt;&lt; s[i] &lt;&lt; &#39;\n&#39;;

// accesso random (potenzialmente controllato)
s[7] = 9;

// estrae i puntatori (potenzialmente controllato)
std::sort(&amp;s[0], &amp;s[s.size() / 2]);
}</code></pre>
<h5 id="note-64">Note</h5>
<p>Un oggetto <code>span&lt;T&gt;</code> non possiede i suoi elementi ed è così piccolo che si può passare per valore.</p>
<p>Passare un oggetto <code>span</code> come argomento è esattamente tanto efficiente quanto passare, come argomenti, una coppia di puntatori o passare un puntatore ed un conteggio intero.</p>
<p><strong>Si veda anche</strong>: <a href="#S-gsl">Libreria di supporto</a></p>
<h5 id="imposizione-47">Imposizione</h5>
<p>(Complicato) Solleva un warning dove gli accesso ai parametri puntatore sono limitati da altri parametri che siano di tipo intero e suggerisce che si dovrebbe, invece, usare <code>span</code>.</p>
<h3 id="f.25-utilizzare-zstring-o-not_nullzstring-per-indicare-una-stringa-c-style"><a name="Rf-zstring"></a>F.25: Utilizzare <code>zstring</code> o <code>not_null&lt;zstring&gt;</code> per indicare una stringa C-style</h3>
<h5 id="motivo-52">Motivo</h5>
<p>Le stringhe in stile C sono onnipresenti. Sono definiti per convenzione: array di caratteri zero-terminated. Si deve far distinzione tra le stringhe C-style e i puntatori ad un singolo carattere o puntatori vecchio stile ad un array di caratteri.</p>
<p>Se non c’è bisogno della terminazione null, si usa <code>string_view</code>.</p>
<h5 id="esempio-53">Esempio</h5>
<p>Si consideri:</p>
<pre><code>int length(const char* p);</code></pre>
<p>Quando si chiama <code>length(s)</code> si deve controllare prima se <code>s</code> è <code>nullptr</code>? L’implementazione di <code>length()</code> dovrebbe verificare se <code>p</code> è <code>nullptr</code>?</p>
<pre><code>// l&#39;implementatore di length() deve assumere che sia possibile che p == nullptr
int length(zstring p);

// è compito del chiamante assicurarsi che p != nullptr
int length(not_null&lt;zstring&gt; p);</code></pre>
<h5 id="note-65">Note</h5>
<p><code>zstring</code> non rappresenta la proprietà [ownership].</p>
<p><strong>Si veda anche</strong>: <a href="#S-gsl">Libreria di supporto</a></p>
<h3 id="f.26-utilizzare-unique_ptrt-per-trasferire-lownership-dove-è-necessario-un-puntatore"><a name="Rf-unique_ptr"></a>F.26: Utilizzare <code>unique_ptr&lt;T&gt;</code> per trasferire l’ownership dove è necessario un puntatore</h3>
<h5 id="motivo-53">Motivo</h5>
<p>L’uso di <code>unique_ptr</code> è il modo più economico per passare un puntatore in modo sicuro.</p>
<p><strong>Si veda anche</strong>: <a href="#Rc-factory">C.50</a> riguardo quando restituire uno <code>shared_ptr</code> da una factory.</p>
<h5 id="esempio-54">Esempio</h5>
<pre><code>unique_ptr&lt;Shape&gt; get_shape(istream&amp; is)  // assembla shape dallo stream di input
{
auto kind = read_header(is); // legge l&#39;header ed identifica la successiva shape in input
switch (kind) {
case kCircle:
return make_unique&lt;Circle&gt;(is);
case kTriangle:
return make_unique&lt;Triangle&gt;(is);
// ...
}
}</code></pre>
<h5 id="note-66">Note</h5>
<p>Bisogna passare un puntatore anziché un oggetto se quello che si sta trasferendo è un oggetto di una gerarchia di classi che deve essere usato attraverso un’interfaccia (classe base).</p>
<h5 id="imposizione-48">Imposizione</h5>
<p>(Semplice) Solleva un warning se una funzione restituisce un semplice puntatore allocato localmente. Suggerisce, invece, di usare o <code>unique_ptr</code> o <code>shared_ptr</code>.</p>
<h3 id="f.27-utilizzare-shared_ptrt-per-condividere-lownership"><a name="Rf-shared_ptr"></a>F.27: Utilizzare <code>shared_ptr&lt;T&gt;</code> per condividere l’ownership</h3>
<h5 id="motivo-54">Motivo</h5>
<p>L’uso dello <code>std::shared_ptr</code> è il modo standard per rappresentare la proprietà [ownership] condivisa. Ovvero, l’ultimo proprietario cancella l’oggetto.</p>
<h5 id="esempio-55">Esempio</h5>
<pre><code>shared_ptr&lt;const Image&gt; im { read_image(somewhere) };

std::thread t0 {shade, args0, top_left, im};
std::thread t1 {shade, args1, top_right, im};
std::thread t2 {shade, args2, bottom_left, im};
std::thread t3 {shade, args3, bottom_right, im};

// scllega [detach] i thread
// l&#39;ultimo thread per finire cancella l&#39;immagine</code></pre>
<h5 id="note-67">Note</h5>
<p>Preferire un <code>unique_ptr</code> rispetto a uno <code>shared_ptr</code> se non c’è mai più di un solo proprietario per volta. <code>shared_ptr</code>è per la proprietà condivisa [shared].</p>
<p>Si noti che l’uso pervasivo di <code>shared_ptr</code> ha un costo (operazioni atomiche sul contatore dei riferimenti dello <code>shared_ptr</code> ha un costo globale misurabile).</p>
<h5 id="alternativa-4">Alternativa</h5>
<p>Avere un solo oggetto proprietario dell’oggetto condiviso (p.es. un oggetto in uno scope) e distruggerlo (preferibilmente implicitamente) quando tutte le utenze sono completate.</p>
<h5 id="imposizione-49">Imposizione</h5>
<p>(Non imponibile) Questo è un pattern troppo complesso per essere rilevato affidabilmente.</p>
<h3 id="f.60-preferire-t-a-t-quando-nessun-argomento-è-una-valida-opzione"><a name="Rf-ptr-ref"></a>F.60: Preferire <code>T*</code> a <code>T&amp;</code> quando “nessun argomento” è una valida opzione</h3>
<h5 id="motivo-55">Motivo</h5>
<p>Un puntatore (<code>T*</code>) può essere un <code>nullptr</code> e un riferimento (<code>T&amp;</code>) non può, non c’è nessun valido “riferimento null”. A volte avere <code>nullptr</code>, anziché indicare “nessun oggetto”, è utile, ma in caso contrario, un riferimento è una notazione più semplice e può produrre un codice migliore.</p>
<h5 id="esempio-56">Esempio</h5>
<pre><code>string zstring_to_string(zstring p) // zstring è un char*; che è una stringa C-style
{
if (!p) return string{};    // p potrebbe essere nullptr; ci si ricordi di controllare
return string{p};
}

void print(const vector&lt;int&gt;&amp; r)
{
// r fa riferimento ad un vector&lt;int&gt;; nessun controllo necessario
}</code></pre>
<h5 id="note-68">Note</h5>
<p>È possibile, ma non un C++ valido, costruire un riferimento che sia essenzialmente un <code>nullptr</code> (p.es., <code>T* p = nullptr; T&amp; r = (T&amp;)*p;</code>). Questo errore è molto raro.</p>
<h5 id="note-69">Note</h5>
<p>Se si preferisce la notazione del puntatore (<code>-&gt;</code> e/o <code>*</code> rispetto a <code>.</code>), <code>not_null&lt;T*&gt;</code> fornisce le stesse garanzie di <code>T&amp;</code>.</p>
<h5 id="imposizione-50">Imposizione</h5>
<ul>
<li>Flag ???</li>
</ul>
<h3 id="f.42-restituire-t-per-indicare-solo-una-posizione"><a name="Rf-return-ptr"></a>F.42: Restituire <code>T*</code> per indicare (solo) una posizione</h3>
<h5 id="motivo-56">Motivo</h5>
<p>Ecco a cosa servono i puntatori. Restituire un <code>T*</code> per trasferire la proprietà è un uso improprio.</p>
<h5 id="esempio-57">Esempio</h5>
<pre><code>Node* find(Node* t, const string&amp; s)  // cerca s in un albero binario di Node
{
if (!t || t-&gt;name == s) return t;
if ((auto p = find(t-&gt;left, s))) return p;
if ((auto p = find(t-&gt;right, s))) return p;
return nullptr;
}</code></pre>
<p>Se non è <code>nullptr</code>, il puntatore restituito da <code>find</code> indica un <code>Node</code> contenente <code>s</code>. È importante sottolineare che ciò non implica un trasferimento della proprietà dell’oggetto puntato al chiamante.</p>
<h5 id="note-70">Note</h5>
<p>Le posizioni possono anche essere trasferite da iteratori, indici e riferimenti. Un riferimento è spesso un’alternativa superiore ad un puntatore <a href="#Rf-ptr-ref">se non c’è bisogno di usare <code>nullptr</code></a> o <a href="???">se l’oggetto a cui si fa riferimento non deve cambiare</a>.</p>
<h5 id="note-71">Note</h5>
<p>Non restituire un puntatore a qualcosa che non rientra nello scope del chiamante; cfr. <a href="#Rf-dangle">F.43</a>.</p>
<p><strong>Si veda anche</strong>: <a href="#???">discussione sulla prevenzione dei puntatori ‘appesi’ [dangling]</a></p>
<h5 id="imposizione-51">Imposizione</h5>
<ul>
<li>Segnalare i <code>delete</code>, <code>std::free()</code>, ecc. applicati a un semplice <code>T*</code>. Solo i proprietari [owner] devono essere cancellati.</li>
<li>Segnalare i <code>new</code>, <code>malloc()</code>, ecc. assegnati a semplici <code>T*</code>. Solo i proprietari dovrebbero essere responsabili della cancellazione.</li>
</ul>
<h3 id="f.43-mai-direttamente-o-indirettamente-restituire-un-puntatore-o-un-riferimento-ad-un-oggetto-locale"><a name="Rf-dangle"></a>F.43: Mai (direttamente o indirettamente) restituire un puntatore o un riferimento ad un oggetto locale</h3>
<h5 id="motivo-57">Motivo</h5>
<p>Per evitare i crash e la corruzione dei dati che avviene a causa dei puntatori ’appesi [dangling].</p>
<h5 id="esempio-cattivo-19">Esempio, cattivo</h5>
<p>All’uscita da una funzione i suoi oggetti locali non esistono più:</p>
<pre><code>int* f()
{
int fx = 9;
return &amp;fx;  // BAD
}

void g(int* p)   // sembra abbastanza innocente
{
int gx;
cout &lt;&lt; &quot;*p == &quot; &lt;&lt; *p &lt;&lt; &#39;\n&#39;;
*p = 999;
cout &lt;&lt; &quot;gx == &quot; &lt;&lt; gx &lt;&lt; &#39;\n&#39;;
}

void h()
{
int* p = f();
int z = *p;  // legge da uno stack frame abbandonato (bad)
g(p);        // passa, il puntatore ad uno stack frame abbandonato, ad una funzione (bad)
}</code></pre>
<p>Qui su una popolare implementazione si ottiene l’output:</p>
<pre><code>*p == 999
gx == 999</code></pre>
<p>C’era da aspettarselo in quanto la chiamata a <code>g()</code> riutilizza lo spazio abbandonato dello stack della chiamata a <code>f()</code> quindi <code>*p</code> fa riferimento ad uno spazio occupato, ora, da <code>gx</code>.</p>
<ul>
<li>Si immagini cosa accadrebbe se <code>fx</code> e <code>gx</code> fossero di tipi diversi.</li>
<li>Si immagini cosa accadrebbe se <code>fx</code> e <code>gx</code> fossero di un tipo con un invariante.</li>
<li>Si immagini cosa accadrebbe se si passassero più puntatori ‘appesi’ [dangling] in un gruppo più esteso di funzioni.</li>
<li>Si immagini cosa potrebbe fare un cracker con quel puntatore ‘appeso’ [dangling].</li>
</ul>
<p>Fortunatamente, la maggior parte (tutti?) i moderni compilatori intercettano ed avvisano se capita questo semplice caso.</p>
<h5 id="note-72">Note</h5>
<p>Questo vale anche per i riferimenti:</p>
<pre><code>int&amp; f()
{
int x = 7;
// ...
return x;  // Bad: restituisce il riferimento ad un oggetto che sta per essere distrutto
}</code></pre>
<h5 id="note-73">Note</h5>
<p>Questo vale solo alle variabili locali non-<code>static</code>. Tutte le variabili <code>static</code> sono (come indica il nome) allocate staticamente, quindi i puntatori ad esse non possono essere ‘appesi’.</p>
<h5 id="esempio-cattivo-20">Esempio, cattivo</h5>
<p>Non tutti gli esempi di perdita [leaking] di un puntatore ad una variabile locale sono così ovvi:</p>
<pre><code>int* glob;       // le variabili globali sono da evitare per diversi motivi

template&lt;class T&gt;
void steal(T x)
{
glob = x();  // BAD
}

void f()
{
int i = 99;
steal([&amp;] { return &amp;i; });
}

int main()
{
f();
cout &lt;&lt; *glob &lt;&lt; &#39;\n&#39;;
}</code></pre>
<p>Qui si riesce a leggere la locazione abbandonata dalla chiamata a <code>f</code>. Il puntatore memorizzato in <code>glob</code> potrebbe essere utilizzato molto e provocare problemi imprevedibili.</p>
<h5 id="note-74">Note</h5>
<p>L’indirizzo di una variabile locale si può “restituire”/persa: con un comando return, con un parametro di out <code>T&amp;</code>, come membro di un oggetto restituito, come elemento di un array restituito ed in altri modi.</p>
<h5 id="note-75">Note</h5>
<p>Esempi simili si possono costruire “appendendo” [leaking] un puntatore da uno scope più interno verso uno più esterno; tali esempi vengono gestiti in modo equivalente ai [leak] dei puntatori uscendo da una funzione.</p>
<p>Una variante leggermente diversa del problema consiste nel piazzare i puntatori in un contenitore che sopravvive agli oggetti cui punta.</p>
<p><strong>Si veda anche</strong>: Un altro modo per ottenere puntatori appesi [dangling] è l’<a href="#???">invalidazione del puntatore</a>. Si può rilevare/prevenire con tecniche simili.</p>
<h5 id="imposizione-52">Imposizione</h5>
<ul>
<li>I compilatori tendono ad intercettare il return di un riferimento ad un valore locale e in molti casi anche il rilevamento di puntatori a valori locali.</li>
<li>L’analisi statica può rilevare molti pattern comuni sull’uso dei puntatori che si riferiscono a delle posizioni (eliminando, quindi, i puntatori appesi [dangling])</li>
</ul>
<h3 id="f.44-restituire-tquando-la-copia-è-indesiderabile-e-non-è-necessario-restituire-nessun-oggetto"><a name="Rf-return-ref"></a>F.44: Restituire <code>T&amp;</code>quando la copia è indesiderabile e non è necessario “restituire nessun oggetto”</h3>
<h5 id="motivo-58">Motivo</h5>
<p>Il linguaggio garantisce che un <code>T&amp;</code> faccia riferimento ad un oggetto, quindi non è necessario il test per il <code>nullptr</code>.</p>
<p><strong>Si veda anche</strong>: La restituzione di un riferimento non implica il trasferimento della proprietà: <a href="#???">discussione sulla prevenzione dei puntatori ‘appesi’ [dangling]</a> e <a href="#???">discussione sulla proprietà [ownership]</a>.</p>
<h5 id="esempio-58">Esempio</h5>
<pre><code>class Car
{
array&lt;wheel, 4&gt; w;
// ...
public:
wheel&amp; get_wheel(int i) { Expects(i &lt; w.size()); return w[i]; }
// ...
};

void use()
{
Car c;
wheel&amp; w0 = c.get_wheel(0); // w0 ha la stessa durata di c
}</code></pre>
<h5 id="imposizione-53">Imposizione</h5>
<p>Si evidenziano le funzioni dove nessuna espressione <code>return</code> potrebbe restituire <code>nullptr</code></p>
<h3 id="f.45-non-restituire-un-t"><a name="Rf-return-ref-ref"></a>F.45: Non restituire un <code>T&amp;&amp;</code></h3>
<h5 id="motivo-59">Motivo</h5>
<p>Si sta chiedendo di restituire un riferimento a un oggetto temporaneo distrutto. Un <code>&amp;&amp;</code> è una calamita per gli oggetti temporanei.</p>
<h5 id="esempio-59">Esempio</h5>
<p>Un riferimento a rvalue restituito esce dallo scope alla fine di tutta l’espressione da cui viene restituito:</p>
<pre><code>auto&amp;&amp; x = max(0, 1);   // OK, finora
foo(x);                 // Comportamento indefinito</code></pre>
<p>Questo tipo di utilizzo è una frequente fonte di bug, spesso è erroneamente segnalato come un bug del compilatore. Un implementatore di una funzione dovrebbe evitare queste trappole agli utenti.</p>
<p>Il <a href="#SS-lifetime">profilo di sicurezza della durata</a> (quando è completamente implementato) catturerà questi problemi.</p>
<h5 id="esempio-60">Esempio</h5>
<p>Restituire un riferimento rvalue va bene quando il riferimento all’oggetto temporaneo viene passato “all’interno” di una chiamata; in quel caso, è garantito che il temporaneo sopravviva alla chiamata a funzione (cfr. <a href="#Rf-consume">F.18</a> e <a href="#Rf-forward">F.19</a>). Tuttavia, non va bene quando si passa questo riferimento “salendo” verso uno scope più ampio. Per le funzioni passanti [passthrough] che trasferiscono i parametri (per normale riferimento o un perfetto forwarding) e vogliono restituire dei valori, si restituisce il semplice tipo dedotto da <code>auto</code>, (non <code>auto&amp;&amp;</code>).</p>
<p>Si supponga che <code>F</code> ritorni per valore:</p>
<pre><code>template&lt;class F&gt;
auto&amp;&amp; wrapper(F f)
{
log_call(typeid(f)); // o qualunque strumentazione
return f();          // BAD: restituisce un riferimento ad un temporaneo
}</code></pre>
<p>Meglio:</p>
<pre><code>template&lt;class F&gt;
auto wrapper(F f)
{
log_call(typeid(f)); // o qualunque strumentazione
return f();          // OK
}</code></pre>
<h5 id="eccezione-12">Eccezione</h5>
<p><code>std::move</code> e <code>std::forward</code> restituiscono <code>&amp;&amp;</code>, ma quelli sono solo cast – usati per convenzione solo in contesti di espressioni dove un riferimento ad un oggetto temporaneo viene passato nella stessa espressione prima che il temporaneo venga distrutto. Non si conoscono altri buoni esempi per restituire <code>&amp;&amp;</code>.</p>
<h5 id="imposizione-54">Imposizione</h5>
<p>Segnala qualsiasi uso di <code>&amp;&amp;</code> come tipo di ritorno, eccetto in <code>std::move</code> e <code>std::forward</code>.</p>
<h3 id="f.46-int-è-il-tipo-restituito-da-main"><a name="Rf-main"></a>F.46: <code>int</code> è il tipo restituito da <code>main()</code></h3>
<h5 id="motivo-60">Motivo</h5>
<p>È una regola del linguaggio ma violata con delle “estensioni al linguaggio” così spesso che vale la pena citarla. Dichiarare il <code>main</code> (l’unico <code>main</code> globale di un programma) <code>void</code> limita la portabilità.</p>
<h5 id="esempio-61">Esempio</h5>
<pre><code>void main() { /* ... */ };  // bad, non è C++

int main()
{
std::cout &lt;&lt; &quot;Questo è il modo per farlo\n&quot;;
}</code></pre>
<h5 id="note-76">Note</h5>
<p>Ne parliamo solo a causa della persistenza di questo errore nella comunità.</p>
<h5 id="imposizione-55">Imposizione</h5>
<ul>
<li>Dovrebbe farlo il compilatore</li>
<li>Se il compilatore non lo fa, lasciare che lo segnalino i tools</li>
</ul>
<h3 id="f.47-restituire-t-dagli-operatori-di-assegnament"><a name="Rf-assignment-op"></a>F.47: Restituire <code>T&amp;</code> dagli operatori di assegnament</h3>
<h5 id="motivo-61">Motivo</h5>
<p>La convenzione per gli operatori di overload (specie sui tipi di valore) è per <code>operator=(const T&amp;)</code> per eseguire l’assegnazione e poi ritornare (non-<code>const</code>) <code>*this</code>. Ciò garantisce la coerenza con i tipi della libreria standard e segue il principio “fa come fanno gli int”.</p>
<h5 id="note-77">Note</h5>
<p>Storicamente c’erano alcune indicazioni per fare in modo che l’operatore di assegnazione restituisse <code>const T&amp;</code>. Questo principalmente per evitare il codice nella forma di <code>(a = b) = c</code> – tale codice non è abbastanza comune da giustificare la violazione della coerenza con i tipi standard.</p>
<h5 id="esempio-62">Esempio</h5>
<pre><code>class Foo
{
public:
...
Foo&amp; operator=(const Foo&amp; rhs) {
// Membri copia.
...
return *this;
}
};</code></pre>
<h5 id="imposizione-56">Imposizione</h5>
<p>Dovrebbe essere imposto dai tool controllando il tipo di ritorno (e il valore di ritorno) di qualsiasi operatore di assegnamento.</p>
<h3 id="f.48-non-fare-return-stdmovelocal"><a name="Rf-return-move-local"></a>F.48: Non fare <code>return std::move(local)</code></h3>
<h5 id="motivo-62">Motivo</h5>
<p>Con la garanzia dell’elisione della copia [copy elision], ora si ottiene quasi sempre un peggioramento delle prestazioni utilizzando espressamente <code>std::move</code> nel comando return.</p>
<h5 id="esempio-cattivo-21">Esempio, cattivo</h5>
<pre><code>S f()
{
S result;
return std::move(result);
}</code></pre>
<h5 id="esempio-buono-2">Esempio, buono</h5>
<pre><code>S f()
{
S result;
return result;
}</code></pre>
<h5 id="imposizione-57">Imposizione</h5>
<p>Questo dovrebbe essere imposto con dei tool controllando l’espressione del return.</p>
<h3 id="f.50-usare-una-lambda-quando-una-funzione-non-va-per-acquisire-le-variabili-locali-o-scrivere-una-funzione-locale"><a name="Rf-capture-vs-overload"></a>F.50: Usare una lambda quando una funzione non va (per acquisire le variabili locali o scrivere una funzione locale)</h3>
<h5 id="motivo-63">Motivo</h5>
<p>Le funzioni non possono acquisire variabili locali o definite nello scope locale; ce ce n’è bisogno, è preferibile una lambda dove possibile altrimenti un oggetto funzione apposito. D’altra parte, lambda e oggetti funzione non consentono l’overload; se c’è bisogno dell’overload, è preferibile una funzione (i workaround per avere l’overload delle lambda sono ornati [ornate]). Se funzionano entrambi, è preferibile la scrittura di una funzione; si usa il tool necessario più semplice.</p>
<h5 id="esempio-63">Esempio</h5>
<pre><code>// scrivere una funzione che dovrebbe solo prendere un int o una stringa
// -- l&#39;overloading viene naturale
void f(int);
void f(const string&amp;);

// scrivere un oggetto funzione che deve catturare lo stato locale ed apparire
// nelo scope dell&#39;istruzione o dell&#39;espressione -- viene naturale una lambda
vector&lt;work&gt; v = lots_of_work();
for (int tasknum = 0; tasknum &lt; max; ++tasknum) {
pool.run([=, &amp;v]{
/*
...
... process 1 / max - th of v, the tasknum - th chunk
...
*/
});
}
pool.join();</code></pre>
<h5 id="eccezione-13">Eccezione</h5>
<p>Le generiche lambda offrono un modo conciso di scrivere funzioni template e quindi possono risultare utili quando una normale funzione template farebbe lo stesso ma con un po’ più di sintassi. Questo vantaggio probabilmente scomparirà in futuro quando tutte le funzioni avranno la possibilità di avere i parametri Concept.</p>
<h5 id="imposizione-58">Imposizione</h5>
<ul>
<li>Genera un warning quando c’è il nome di una non-generica lambda (p.es., <code>auto x = [](int i){ /*...*/; };</code>) che non cattura niente ed appare nello scope globale. Scrivere, invece, una normale funzione.</li>
</ul>
<h3 id="f.51-potendo-scegliere-si-preferiscano-gli-argomenti-con-default-rispetto-alloverloading"><a name="Rf-default-args"></a>F.51: Potendo scegliere, si preferiscano gli argomenti con default rispetto all’overloading</h3>
<h5 id="motivo-64">Motivo</h5>
<p>I default degli argomenti forniscono semplicemente delle interfacce alternative ad una singola implementazione. Non esiste alcuna garanzia che un insieme di funzioni sovraccaricate [overloaded] implementino tutte la stessa semantica. L’uso degli argomenti con default può evitare la replica del codice.</p>
<h5 id="note-78">Note</h5>
<p>È possibile scegliere tra utilizzare l’argomento di default e l’overloading quando le alternative vengono da una set di argomenti con gli stessi tipi. Per esempio:</p>
<pre><code>void print(const string&amp; s, format f = {});</code></pre>
<p>oppure</p>
<pre><code>void print(const string&amp; s);  // usa il formato col default
void print(const string&amp; s, format f);</code></pre>
<p>Non c’è scelta quando un set di funzioni viene utilizzato per eseguire un’operazione semanticamente equivalente a un insieme di tipi. Per esempio:</p>
<pre><code>void print(const char&amp;);
void print(int);
void print(zstring);</code></pre>
<h5 id="si-veda-anche">Si veda anche</h5>
<p><a href="#Rh-virtual-default-arg">Argomenti di default per funzioni virtuali</a></p>
<h5 id="imposizione-59">Imposizione</h5>
<ul>
<li>Solleva un warning su un insieme di overload dove questi hanno gli stessi parametri iniziali (p.es., <code>f(int)</code>, <code>f(int, const string&amp;)</code>, <code>f(int, const string&amp;, double)</code>). (Nota: Rivedere questo ‘enforcement’ se è troppo confuso nella pratica).</li>
</ul>
<h3 id="f.52-preferire-lacquisizione-per-riferimento-nelle-lambda-da-usare-localmente-compresi-quelli-passati-agli-algoritmi"><a name="Rf-reference-capture"></a>F.52: Preferire l’acquisizione per riferimento nelle lambda da usare localmente, compresi quelli passati agli algoritmi</h3>
<h5 id="motivo-65">Motivo</h5>
<p>Per efficienza e correttezza, si deve quasi sempre acquisire per riferimento quando si usa la lambda localmente. Questo comprende anche quando si scrivono o si chiamano algoritmi paralleli che sono locali perché si uniscono prima di tornare.</p>
<h5 id="discussione-1">Discussione</h5>
<p>La considerazione sull’efficienza è che la maggior parte dei tipi sono più economici da passare per riferimento che per valore.</p>
<p>La considerazione sulla correttezza è che molte chiamate vogliono hanno degli effetti collaterali sull’oggetto originale dal lato del chiamante (si veda l’esempio sotto). Questo si evita col passaggio per valore.</p>
<h5 id="note-79">Note</h5>
<p>Sfortunatamente, non esiste un modo semplice per acquisire per riferimento a <code>const</code> per ottenere l’efficienza di una chiamata locale ma anche per prevenire effetti collaterali.</p>
<h5 id="esempio-64">Esempio</h5>
<p>Qui, un oggetto di grandi dimensioni (un messaggio di rete) viene passato a un algoritmo iterativo e non è efficiente né corretto copiarlo (e potrebbe non essere copiabile):</p>
<pre><code>std::for_each(begin(sockets), end(sockets), [&amp;message](auto&amp; socket)
{
socket.send(message);
});</code></pre>
<h5 id="esempio-65">Esempio</h5>
<p>Questa è una semplice pipeline parallela a tre stadi. Ogni oggetto <code>stage</code> [stadio] incapsula un thread worker ed una coda [queue], ha una funzione <code>process</code> per accodare il lavoro [work] e nel suo distruttore si blocca automaticamente aspettando lo svuotamento della coda prima di completare il thread.</p>
<pre><code>void send_packets(buffers&amp; bufs)
{
stage encryptor([] (buffer&amp; b){ encrypt(b); });
stage compressor([&amp;](buffer&amp; b){ compress(b); encryptor.process(b); });
stage decorator([&amp;](buffer&amp; b){ decorate(b); compressor.process(b); });
for (auto&amp; b : bufs) { decorator.process(b); }
}  // si blocca automaticamente in attesa del completamento della pipeline</code></pre>
<h5 id="imposizione-60">Imposizione</h5>
<p>Segnala una lambda che cattura per riferimento, ma viene usata non solo localmente nello scope della funzione o viene passata ad una funzione per riferimento. (Nota: Questa regola è un’approssimazione, segnala i passaggi per puntatore come quelli simili a quelli memorizzati dal chiamato, scrivendo in una locazione dell’heap cui si accede tramite un parametro, restituendo la lambda, ecc. Le regole [Lifetime] forniranno anche regole generali che segnalano i puntatori [escaping] e i riferimenti compresi quelli tramite le lambda).</p>
<h3 id="f.53-evitare-lacquisizione-per-riferimento-nelle-lambdas-che-si-non-si-useranno-localmente-compresi-quelli-restituiti-memorizzati-nellheap-o-passati-da-un-altro-thread"><a name="Rf-value-capture"></a>F.53: Evitare l’acquisizione per riferimento nelle lambdas che si non si useranno localmente, compresi quelli restituiti, memorizzati nell’heap o passati da un altro thread</h3>
<h5 id="motivo-66">Motivo</h5>
<p>Puntatori e riferimenti a locali non dovrebbero sopravvivere al loro scope. Le lambda che catturano per riferimento sono solo un altro posto in cui memorizzare un riferimento a un oggetto locale e non dovrebbero farlo se sopravvivono (o una loro copia) allo scope.</p>
<h5 id="esempio-cattivo-22">Esempio, cattivo</h5>
<pre><code>int local = 42;

// Vuole un riferimento a local.
// Si noti che quando il programma esce da questo scope,
// local non esiste più, pertanto
// la chiamata a process() call avrà un comportamento indefinito!
thread_pool.queue_work([&amp;]{ process(local); });</code></pre>
<h5 id="esempio-buono-3">Esempio, buono</h5>
<pre><code>int local = 42;
// Vuole una copia di local.
// Poiché viene creata una copia di local, sarà
// sempre disponibile per la chiamata.
thread_pool.queue_work([=]{ process(local); });</code></pre>
<h5 id="imposizione-61">Imposizione</h5>
<ul>
<li>(Semplice) Emette un warning quando la ‘capture-list’ [lista dei parametri] contiene un riferimento ad una variabile definita localmente</li>
<li>(Complesso) Emette un warning quando la ‘capture-list’ contiene un riferimento ad una variabile dichiarata localmente e la lambda viene passata ad un contesto non-<code>const</code> e non-local</li>
</ul>
<h3 id="f.54-se-si-acquisisce-this-se-ne-acquisiscono-esplicitamente-tutte-le-variabili-senza-acquisirne-i-default"><a name="Rf-this-capture"></a>F.54: Se si acquisisce <code>this</code>, se ne acquisiscono esplicitamente tutte le variabili (senza acquisirne i default)</h3>
<h5 id="motivo-67">Motivo</h5>
<p>È confusionario. Scrivere <code>[=]</code> in una funzione membro sembra catturare per valore, mentre in realtà cattura tutti i dati membri per riferimento perché in effetti cattura il puntatore invisibile <code>this</code> per valore. Se si intende fare questo, si scriva esplicitamente <code>this</code>.</p>
<h5 id="esempio-66">Esempio</h5>
<pre><code>class My_class {
int x = 0;
// ...

void f() {
int i = 0;
// ...

auto lambda = [=]{ use(i, x); };   // BAD: &quot;sembra&quot; una cattura per copia/valore
// [&amp;] ha l&#39;dentica semantica e copia il puntatore this secondo le regole correnti
// [=,this] e [&amp;,this] non sono migliori e confondono

x = 42;
lambda(); // chiama use(0, 42);
x = 43;
lambda(); // chiama use(0, 43);

// ...

auto lambda2 = [i, this]{ use(i, x); }; // ok, più esplicito e meno confuso

// ...
}
};</code></pre>
<h5 id="note-80">Note</h5>
<p>Questo è oggetto di un’attiva discussione nella standardizzazione e potrebbe essere oggetto di una futura versione dello standard aggiungendo una nuova modalità di cattura o forse modificando il significato di <code>[=]</code>. Per ora, siate espliciti.</p>
<h5 id="imposizione-62">Imposizione</h5>
<ul>
<li>Segnala qualsiasi capture-list di lambda che specifica un’acquisizione di default e cattura anche <code>this</code> (esplicitamente o tramite acquisizione di default)</li>
</ul>
<h3 id="f.55-non-usare-gli-argomenti-va_arg"><a name="F-varargs"></a>F.55: Non usare gli argomenti <code>va_arg</code></h3>
<h5 id="motivo-68">Motivo</h5>
<p>La lettura da un <code>va_arg</code> presuppone che sia stato passato effettivamente il tipo corretto. Il passaggio con varargs presuppone che sia letto il tipo corretto. Questo è alquanto fragile perché non può essere imposta la sicurezza nel linguaggio e quindi si affida alla disciplina del programmatore per la correttezza.</p>
<h5 id="esempio-67">Esempio</h5>
<pre><code>int sum(...) {
// ...
while (/*...*/)
result += va_arg(list, int); // BAD, presuppone che vengano passati degli int
// ...
}

sum(3, 2); // ok
sum(3.14159, 2.71828); // BAD, indefinito

template&lt;class ...Args&gt;
auto sum(Args... args) { // GOOD, è molto più flessibile
return (... + args); // nota: C++17 &quot;fold expression&quot;
}

sum(3, 2); // ok: 5
sum(3.14159, 2.71828); // ok: ~5.85987</code></pre>
<h5 id="alternative">Alternative</h5>
<ul>
<li>overloading</li>
<li>template variadici</li>
<li>argomenti <code>variant</code></li>
<li><code>initializer_list</code> (omogenea)</li>
</ul>
<h5 id="note-81">Note</h5>
<p>La dichiarazione di un parametro <code>...</code> talvolta è utile nele tecniche che non implicano il passaggio il passaggio dell’argomento corrente, in particolare per dichiarare le funzioni “acchiappa-tutto [take-anything]” i modo da disabilitare “tutto il resto” in un insieme di overload o per esprimere il caso ‘onnicomprensivo’ [catchall] in un metaprogramma template.</p>
<h5 id="imposizione-63">Imposizione</h5>
<ul>
<li>Emette una diagnostica per l’uso di <code>va_list</code>, <code>va_start</code> o <code>va_arg</code>.</li>
<li>Emette una diagnostica per il passaggio di un argomento ad un parametro vararg di una funzione che non offre un overload per un tipo più specifico nella posizione del vararg. Per correggere: Utilizzare una funzione diversa o <code>[[suppress(types)]]</code>.</li>
</ul>
<h1 id="c-classi-e-gerarchie-di-classi"><a name="S-class"></a>C: Classi e gerarchie di classi</h1>
<p>Una classe è un tipo definito dall’utente, per il quale un programmatore può definire la rappresentazione, le operazioni e le interfacce. Le gerarchie di classi si usano per organizzare le classi correlate in strutture gerarchiche.</p>
<p>Riepilogo delle regole delle classi:</p>
<ul>
<li><a href="#Rc-org">C.1: Organizza i dati correlati in strutture (<code>struct</code> o <code>class</code>i)</a></li>
<li><a href="#Rc-struct">C.2: Utilizzare <code>class</code> se la classe ha un invariante; usare <code>struct</code> se i dati membro possono variare indipendentemente</a></li>
<li><a href="#Rc-interface">C.3: Rappresentare la distinzione tra un’interfaccia e un’implementazione con una classe</a></li>
<li><a href="#Rc-member">C.4: Creare una funzione membro solo se è necessario l’accesso diretto alla rappresentazione di una classe</a></li>
<li><a href="#Rc-helper">C.5: Inserire le funzioni helper nello stesso namespace della classe che supportano</a></li>
<li><a href="#Rc-standalone">C.7: Non definire una classe o un enum e dichiarare una variabile dello stesso tipo nella stessa istruzione</a></li>
<li><a href="#Rc-class">C.8: Usare <code>class</code> anziché <code>struct</code> se uno dei membri è non-public</a></li>
<li><a href="#Rc-private">C.9: Ridurre al minimo l’esposizione dei membri</a></li>
</ul>
<p>Sottosezioni:</p>
<ul>
<li><a href="#SS-concrete">C.concrete: Tipi concreti</a></li>
<li><a href="#S-ctor">C.ctor: Costruttori, assegnazioni e distruttori</a></li>
<li><a href="#SS-containers">C.con: Contenitori ed altri handle di risorse</a></li>
<li><a href="#SS-lambdas">C.lambdas: Oggetti funzione e lambda</a></li>
<li><a href="#SS-hier">C.hier: Gerarchie di classi (OOP)</a></li>
<li><a href="#SS-overload">C.over: Overloading e operatori overloaded [sovraccaricati]</a></li>
<li><a href="#SS-union">C.union: Unioni</a></li>
</ul>
<h3 id="c.1-organizza-i-dati-correlati-in-strutture-struct-o-classi"><a name="Rc-org"></a>C.1: Organizza i dati correlati in strutture (<code>struct</code> o <code>class</code>i)</h3>
<h5 id="motivo-69">Motivo</h5>
<p>Facilità di comprensione. Se i dati sono correlati (per motivi di fondo), tale fatto dovrebbe riflettersi nel codice.</p>
<h5 id="esempio-68">Esempio</h5>
<pre><code>void draw(int x, int y, int x2, int y2);  // BAD: relazioni implicite non necessarie
void draw(Point from, Point to);          // meglio</code></pre>
<h5 id="note-82">Note</h5>
<p>Una semplice classe, senza funzioni virtuali, non implica né spazio né tempo.</p>
<h5 id="note-83">Note</h5>
<p>Dal punto di vista del linguaggio <code>class</code> e<code>struct</code> differiscono solo per la visibilità di default dei loro membri.</p>
<h5 id="imposizione-64">Imposizione</h5>
<p>Probabilmente impossibile. Forse è possibile una ricerca euristica di elementi di dati utilizzati insieme.</p>
<h3 id="c.2-utilizzare-class-se-la-classe-ha-un-invariante-usare-struct-se-i-dati-membro-possono-variare-indipendentemente"><a name="Rc-struct"></a>C.2: Utilizzare <code>class</code> se la classe ha un invariante; usare <code>struct</code> se i dati membro possono variare indipendentemente</h3>
<h5 id="motivo-70">Motivo</h5>
<p>Leggibilità. Facilità di comprensione. L’uso di <code>class</code> avvisa il programmatore della necessità di un invariante. Questa è un’utile convenzione.</p>
<h5 id="note-84">Note</h5>
<p>Un invariante, è una condizione logica per i membri di un oggetto che un costruttore deve stabilire, affinché le funzioni membro pubblici la possano assumere. Dopo aver stabilito l’invariante (in genere da un costruttore), ogni funzione membro può essere chiamata per l’oggetto. Un invariante può essere dichiarato informalmente (p.es., in un commento) o più formalmente utilizzando <code>Expects</code>.</p>
<p>Se tutti i dati membro possono variare indipendentemente l’uno dall’altro, non è possibile alcun invariante.</p>
<h5 id="esempio-69">Esempio</h5>
<pre><code>struct Pair {  // i membri possono variare indipendentemente
string name;
int volume;
};</code></pre>
<p>ma:</p>
<pre><code>class Date {
public:
// convalida che  {yy, mm, dd} sia una data valida e inizializza
Date(int yy, Month mm, char dd);
// ...
private:
int y;
Month m;
char d;    // day [giorno]
};</code></pre>
<h5 id="note-85">Note</h5>
<p>Se una classe ha dati <code>privati</code>, un utente non può completamente inizializzare un oggetto senza l’uso di un costruttore. Quindi, chi definisce la classe fornirà un costruttore e deve specificarne il significato. Ciò significa effettivamente che chi definisce la classe deve definire un invariante.</p>
<p><strong>Si veda anche</strong>:</p>
<ul>
<li><a href="#Rc-class">definire una classa con dati privati con <code>class</code></a></li>
<li><a href="#Rl-order">È preferibile piazzare prima l’interfaccia in una classe</a></li>
<li><a href="#Rc-private">minimizzare l’esposizione dei membri</a></li>
<li><a href="#Rh-protected">Evitare dati <code>protected</code></a></li>
</ul>
<h5 id="imposizione-65">Imposizione</h5>
<p>Cercare le <code>struct</code> con tutti i dati privati e le <code>class</code>i con tutti i membri pubblici.</p>
<h3 id="c.3-rappresentare-la-distinzione-tra-uninterfaccia-e-unimplementazione-con-una-classe"><a name="Rc-interface"></a>C.3: Rappresentare la distinzione tra un’interfaccia e un’implementazione con una classe</h3>
<h5 id="motivo-71">Motivo</h5>
<p>Una distinzione esplicita tra interfaccia e implementazione migliora la leggibilità e semplifica la manutenzione.</p>
<h5 id="esempio-70">Esempio</h5>
<pre><code>class Date {
public:
Date();
// convalida che {yy, mm, dd} è una data valida e inizializza
Date(int yy, Month mm, char dd);

int day() const;
Month month() const;
// ...
private:
// ... una rappresentazione ...
};</code></pre>
<p>Ad esempio, ora possiamo cambiare la rappresentazione di una <code>Date</code> senza influire sui suoi utenti (è tuttavia probabile che si debba ricompilare).</p>
<h5 id="note-86">Note</h5>
<p>Ovviamente, usare una classe in questo modo per rappresentare la distinzione tra l’interfaccia e l’implementazione, non è l’unico modo. Per esempio, possiamo usare un set di dichiarazioni di funzioni indipendenti in un namespace, una classe base astratta o una funzione template con i concept per rappresentare un’interfaccia. Il problema più importante è distinguere esplicitamente tra un’interfaccia e i suoi “dettagli” di implementazione. Idealmente, e solitamente, un’interfaccia è molto più stabile delle sue implementazioni.</p>
<h5 id="imposizione-66">Imposizione</h5>
<p>???</p>
<h3 id="c.4-creare-una-funzione-membro-solo-se-è-necessario-laccesso-diretto-alla-rappresentazione-di-una-classe"><a name="Rc-member"></a>C.4: Creare una funzione membro solo se è necessario l’accesso diretto alla rappresentazione di una classe</h3>
<h5 id="motivo-72">Motivo</h5>
<p>Meno accoppiamento c’è con le funzioni membro, meno funzioni ci saranno che possono causare problemi modificando lo stato dell’oggetto, e si riduce il numero delle funzioni che si devono modificare dopo averne modificato la rappresentazione.</p>
<h5 id="esempio-71">Esempio</h5>
<pre><code>class Date {
// ... un&#39;interfaccia relativamente piccola ...
};

// funzioni helper:
Date next_weekday(Date);
bool operator==(Date, Date);</code></pre>
<p>Le “funzioni helper” non hanno bisogno dell’accesso diretto alla rappresentazione di una <code>Date</code>.</p>
<h5 id="note-87">Note</h5>
<p>Questa regola diventa ancora migliore se il C++ ha la<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0251r0.pdf">“uniform function call [chiamata a funzione uniforme]”</a>.</p>
<h5 id="eccezione-14">Eccezione</h5>
<p>Il linguaggio richiede che delle funzioni <code>virtual</code> siano membri, e non tutte le funzioni <code>virtual</code> accedono direttamente ai dati. In particolare, i membri di una classe astratta raramente lo fanno.</p>
<p>Nota <a href="https://parasol.tamu.edu/~yuriys/papers/OMM10.pdf">multi-methods</a>.</p>
<h5 id="eccezione-15">Eccezione</h5>
<p>Il linguaggio richiede gli operatori <code>=</code>, <code>()</code>, <code>[]</code>, e <code>-&gt;</code> siano membri.</p>
<h5 id="eccezione-16">Eccezione</h5>
<p>Un set di overload può avere dei membri che non accedono direttamente ai dati <code>private</code>:</p>
<pre><code>class Foobar {
public:
void foo(long x)    { /* modifica il dato privato */ }
void foo(double x) { foo(std::lround(x)); }
// ...
private:
// ...
};</code></pre>
<h5 id="eccezione-17">Eccezione</h5>
<p>Allo stesso modo, un insieme di funzioni può essere progettato per essere utilizzato in sequenza [chain]:</p>
<pre><code>x.scale(0.5).rotate(45).set_color(Color::red);</code></pre>
<p>In genere, alcune di queste funzioni, ma non tutte, accedono direttamente ai dati <code>private</code>.</p>
<h5 id="imposizione-67">Imposizione</h5>
<ul>
<li>Cercare le funzioni membro non-<code>virtual</code> che non toccano direttamente i dati membro. L’intoppo è che molte funzioni membro che lo fanno non hanno bisogno di toccare direttamente i dati membro.</li>
<li>Ignorare le funzioni <code>virtual</code>.</li>
<li>Ignorare le funzioni che fanno parte di un set di overload di cui almeno una funzione accede ai membri <code>private</code>.</li>
<li>Ignorare le funzioni che restituiscono <code>this</code>.</li>
</ul>
<h3 id="c.5-inserire-le-funzioni-helper-nello-stesso-namespace-della-classe-che-supportano"><a name="Rc-helper"></a>C.5: Inserire le funzioni helper nello stesso namespace della classe che supportano</h3>
<h5 id="motivo-73">Motivo</h5>
<p>Una funzione helper è una funzione (solitamente fornita da chi scrive la classe) che non necessita di accedere direttamente alla rappresentazione della classe, ma viene vista come parte dell’interfaccia utile alla classe. Posizionandole nello stesso namespace della classe, rende ovvia la loro relazione con la classe e consente loro essere trovate cercando gli argomenti dipendenti.</p>
<h5 id="esempio-72">Esempio</h5>
<pre><code>namespace Chrono { // qui teniamo i servizi relativi al tempo

class Time { /* ... */ };
class Date { /* ... */ };

// funzioni helper:
bool operator==(Date, Date);
Date next_weekday(Date);
// ...
}</code></pre>
<h5 id="note-88">Note</h5>
<p>Ciò è particolarmente importante per gli <a href="#Ro-namespace">operatori overloaded</a>.</p>
<h5 id="imposizione-68">Imposizione</h5>
<ul>
<li>Segnare le funzioni globali prendendo i tipi degli argomenti da un singolo namespace.</li>
</ul>
<h3 id="c.7-non-definire-una-classe-o-un-enum-e-dichiarare-una-variabile-dello-stesso-tipo-nella-stessa-istruzione"><a name="Rc-standalone"></a>C.7: Non definire una classe o un enum e dichiarare una variabile dello stesso tipo nella stessa istruzione</h3>
<h5 id="motivo-74">Motivo</h5>
<p>Mescolare una definizione di tipo e la definizione di un’altra entità nella stessa dichiarazione è confuso e non necessario.</p>
<h5 id="esempio-cattivo-23">Esempio, cattivo</h5>
<pre><code>struct Data { /*...*/ } data{ /*...*/ };</code></pre>
<h5 id="esempio-buono-4">Esempio, buono</h5>
<pre><code>struct Data { /*...*/ };
Data data{ /*...*/ };</code></pre>
<h5 id="imposizione-69">Imposizione</h5>
<ul>
<li>Segnalare se la <code>}</code> di una definizione di una classe o di una enumerazione non è seguita da un <code>;</code>. Il <code>;</code> è mancante.</li>
</ul>
<h3 id="c.8-usare-class-anziché-struct-se-uno-dei-membri-è-non-public"><a name="Rc-class"></a>C.8: Usare <code>class</code> anziché <code>struct</code> se uno dei membri è non-public</h3>
<h5 id="motivo-75">Motivo</h5>
<p>Leggibilità. Per chiarire che qualcosa viene nascosto/astratto. Questa è un’utile convenzione.</p>
<h5 id="esempio-cattivo-24">Esempio, cattivo</h5>
<pre><code>struct Date {
int d, m;

Date(int i, Month m);
// ... molte funzioni ...
private:
int y;  // year
};</code></pre>
<p>Non c’è nulla di sbagliato in questo codice per quanto riguarda le regole del C++, ma è quasi tutto sbagliato dal punto di vista del design. I dati privatisono nascosti lontano da quelli pubblici. I dati sono sparpagliati in più parti nella dichiarazione della classe. Le diverse parti di dati hanno un diverso accesso. Tutto ciò riduce la leggibilità e complica la manutenzione.</p>
<h5 id="note-89">Note</h5>
<p>In una classe è preferibile piazzare prima l’interfaccia, <a href="#Rl-order">cfr. NL.16</a>.</p>
<h5 id="imposizione-70">Imposizione</h5>
<p>Si segnalano le classi dichiarate con <code>struct</code> se c’è un membro <code>private</code> o <code>protected</code>.</p>
<h3 id="c.9-ridurre-al-minimo-lesposizione-dei-membri"><a name="Rc-private"></a>C.9: Ridurre al minimo l’esposizione dei membri</h3>
<h5 id="motivo-76">Motivo</h5>
<p>Incapsulamento. Nascondere le informazioni. Ridurre al minimo la possibilità di accesso involontario. Questo semplifica la manutenzione.</p>
<h5 id="esempio-73">Esempio</h5>
<pre><code>template&lt;typename T, typename U&gt;
struct pair {
T a;
U b;
// ...
};</code></pre>
<p>Qualunque cosa si faccia nella parte <code>//</code>, un qualsiasi utente di una <code>pair</code> può arbitrariamente e indipendentemente cambiarne la <code>a</code> e la <code>b</code>. In una base di codice di grandi dimensioni, non si può facilmente trovare quale codice fa cosa ai membri della <code>pair</code>. Questo potrebbe essere esattamente voluto, ma volendo far rispettare una relazione tra i membri, bisogna renderli <code>private</code> e imporre tale relazione (invariante) tramite i costruttori e le funzioni membro. Per esempio:</p>
<pre><code>class Distance {
public:
// ...
double meters() const { return magnitude*unit; }
void set_unit(double u)
{
// ... controlla che u sia un fattore di 10 ...
// ... cambia di conseguenza la grandezza ...
unit = u;
}
// ...
private:
double magnitude;
double unit;    // 1 sono i metri, 1000 i chilometri, 0.001 i millimetri, ecc.
};</code></pre>
<h5 id="note-90">Note</h5>
<p>Se non è possibile determinare facilmente l’insieme degli utenti diretti di un insieme di variabili, il tipo o l’utilizzo di tale insieme non può essere (facilmente) cambiato/migliorato. Questo è generalmente il caso dei i dati <code>public</code> e <code>protected</code>.</p>
<h5 id="esempio-74">Esempio</h5>
<p>Una classe può fornire due interfacce ai suoi utenti. Una per le classi derivate (<code>protected</code>) e una per gli utenti generici (<code>public</code>). Ad esempio, ad una classe derivata potrebbe essere consentito di saltare un controllo a runtime perché ne è già garantita la correttezza:</p>
<pre><code>class Foo {
public:
int bar(int x) { check(x); return do_bar(x); }
// ...
protected:
int do_bar(int x); // fa qualche operazione sui dati
// ...
private:
// ... dati ...
};

class Dir : public Foo {
//...
int mem(int x, int y)
{
/* ... fa qualcosa ... */
return do_bar(x + y); // OK: la classe derivata può bypassare il controllo
}
};

void user(Foo&amp; x)
{
int r1 = x.bar(1);      // OK, verificherà
int r2 = x.do_bar(2);   // errore: bypass del controllo
// ...
}</code></pre>
<h5 id="note-91">Note</h5>
<p>I dati <a href="#Rh-protected"><code>protected</code> sono una cattiva idea</a>.</p>
<h5 id="note-92">Note</h5>
<p>Preferire un ordine con prima i membri <code>public</code> poi i membri <code>protected</code> e infine quelli <code>private</code> <a href="#Rl-order">cfr.</a>.</p>
<h5 id="imposizione-71">Imposizione</h5>
<ul>
<li><a href="#Rh-protected">Segnare i dati protected</a>.</li>
<li>Segnare i miscugli con dati <code>public</code> e <code>dati</code> private</li>
</ul>
<h2 id="c.concrete-tipi-concreti"><a name="SS-concrete"></a>C.concrete: Tipi concreti</h2>
<p>L’ideale per una classe è essere un tipo regolare. Questo vuol dire più o meno “funzionare come un <code>int</code>”. Un tipo [concrete] è il più semplice tipo di classe. Un valore di un tipo regolare può essere copiato e il risultato di una copia è un oggetto indipendente con lo stesso valore dell’originale. Se un tipo [concrete] ha sia <code>=</code> che <code>==</code>, da <code>a = b</code> dovrebbe risultare che <code>a == b</code> sia <code>true</code>. Le classi [concrete] senza assegnazione ed uguaglianza possono essere definite, ma sono (e dovrebbero essere) rare. I tipi predefiniti del C++ sono regulari, così come le classi della standard-library, come <code>string</code>, <code>vector</code> e <code>map</code>. I tipi [concrete] vengono spesso definiti tipi di valore per distinguerli dai tipi utilizzati come parte di una gerarchia</p>
<p>Riepilogo delle regole sul tipo [concrete]:</p>
<ul>
<li><a href="#Rc-concrete">C.10: Preferire i tipi [concrete] alle gerarchie di classi</a></li>
<li><a href="#Rc-regular">C.11: Rendere [concrete] i tipi regolari</a></li>
</ul>
<h3 id="c.10-preferire-i-tipi-concrete-alle-gerarchie-di-classi"><a name="Rc-concrete"></a>C.10: Preferire i tipi [concrete] alle gerarchie di classi</h3>
<h5 id="motivo-77">Motivo</h5>
<p>Un tipo concreto è fondamentalmente più semplice di una gerarchia: più facile da progettare, più facile da implementare, più facile da usare, più facile da ragionarci, più piccolo e più veloce. È necessario un motivo (caso d’uso) per usare una gerarchia.</p>
<h5 id="esempio-75">Esempio</h5>
<pre><code>class Point1 {
int x, y;
// ... operazioni ...
// ... nessuna funzione virtuale ...
};

class Point2 {
int x, y;
// ... operazioni, alcune virtuali ...
virtual ~Point2();
};

void use()
{
Point1 p11 {1, 2};   // crea un oggetto sullo stack
Point1 p12 {p11};    // una copia

auto p21 = make_unique&lt;Point2&gt;(1, 2);   // crea un oggetto sul [free store]
auto p22 = p21-&gt;clone();                // fa una copia
// ...
}</code></pre>
<p>Se una classe può far parte di una gerarchia, se ne devono modificare gli oggetti (nel codice reale se non necessariamente nei piccoli esempi) tramite i puntatori o i riferimenti. Ciò implica più uso della memoria, più allocazioni e deallocazioni e più lavoro a run-time per eseguire le indirezioni risultanti.</p>
<h5 id="note-93">Note</h5>
<p>I tipi [concrete] si possono allocare sullo stack e possono essere membri di altre classi.</p>
<h5 id="note-94">Note</h5>
<p>L’uso dell’indirezione è fondamentale per le interfacce polimorfiche a run-time. L’overhead non è l’allocazione/deallocazione (questo è solo il caso più comune). Possiamo usare una classe base come interfaccia di un oggetto nello scope di una classe derivata. Questo viene fatto laddove l’allocazione dinamica è proibita (p.es. hard-real-time) e per fornire un’interfaccia stabile a qualche tipo di plug-in.</p>
<h5 id="imposizione-72">Imposizione</h5>
<p>???</p>
<h3 id="c.11-rendere-concreti-i-tipi-regolari"><a name="Rc-regular"></a>C.11: Rendere concreti i tipi regolari</h3>
<h5 id="motivo-78">Motivo</h5>
<p>I tipi regolari sono più facili da capire e discutere dei tipi non regolari (l’irregolarità richiede uno sforzo aggiuntivo per capire e usare).</p>
<h5 id="esempio-76">Esempio</h5>
<pre><code>struct Bundle {
string name;
vector&lt;Record&gt; vr;
};

bool operator==(const Bundle&amp; a, const Bundle&amp; b)
{
return a.name == b.name &amp;&amp; a.vr == b.vr;
}

Bundle b1 { &quot;il mio bundle&quot;, {r1, r2, r3}};
Bundle b2 = b1;
if (!(b1 == b2)) error(&quot;impossibile!&quot;);
b2.name = &quot;l&#39;altro bundle&quot;;
if (b1 == b2) error(&quot;No!&quot;);</code></pre>
<p>In particolare, se un tipo [concrete] ha un’assegnazione gli si dia anche un operatore di uguaglianza in modo che <code>a = b</code> implichi <code>a == b</code>.</p>
<h5 id="note-95">Note</h5>
<p>Gli handle per le risorse che non possono essere clonate, p.es., uno <code>scoped_lock</code> per un <code>mutex</code>, assomigliano ai tipi [concrete] in quanto molto spesso sono allocati sullo stack. Tuttavia, oggetti di questo tipo solitamente non possono essere copiati (invece, si possono in genere essere spostati), quindi non possono essere <code>regolari</code>; mentre tendono ad essere <code>semiregolari</code>. Spesso, questi tipi vengono definiti “move-only types” [tipi di solo spostamento].</p>
<h5 id="imposizione-73">Imposizione</h5>
<p>???</p>
<h2 id="c.ctor-costruttori-assegnazioni-e-distruttori"><a name="S-ctor"></a>C.ctor: Costruttori, assegnazioni e distruttori</h2>
<p>Queste funzioni controllano il ciclo di vita degli oggetti: creazione, copia, spostamento e distruzione. Definire i costruttori per garantire e semplificare l’inizializzazione delle classi.</p>
<p>Queste sono<em>operazioni di default</em>:</p>
<ul>
<li>un costruttore di default: <code>X()</code></li>
<li>un costruttore copia: <code>X(const X&amp;)</code></li>
<li>un costruttore di assegnazione: <code>operator=(const X&amp;)</code></li>
<li>un costruttore di spostamento [move]: <code>X(X&amp;&amp;)</code></li>
<li>un’assegnazione di spostamento: <code>operator=(X&amp;&amp;)</code></li>
<li>un distruttore: <code>~X()</code></li>
</ul>
<p>Per default, il compilatore definisce ciascuna di queste operazioni se viene usato, ma è possibile sopprimere il default.</p>
<p>Le operazioni di default sono un insieme di operazioni che assieme implementano la semantica del ciclo di vita di un oggetto. Per default, il C++ tratta le classi come tipi simil-valore, ma non tutti i tipi sono come i valori.</p>
<p>Regole sull’insieme delle operazioni di default:</p>
<ul>
<li><a href="#Rc-zero">C.20: Se si può evitare di definire un’operazione di default, lo si faccia</a></li>
<li><a href="#Rc-five">C.21: Se si definisce o <code>=delete</code> un’operazione di default, si definiscano o <code>=delete</code> tutte</a></li>
<li><a href="#Rc-matched">C.22: Uniformare le operazioni di default</a></li>
</ul>
<p>Regole del distruttore:</p>
<ul>
<li><a href="#Rc-dtor">C.30: Definire un distruttore se una classe necessita di un’azione esplicita alla distruzione di un oggetto</a></li>
<li><a href="#Rc-dtor-release">C.31: Tutte le risorse acquisite da una classe devono essere rilasciate dal distruttore della classe</a></li>
<li><a href="#Rc-dtor-ptr">C.32: Se una classe ha un puntatore [raw] (<code>T*</code>) o un riferimento (<code>T&amp;</code>), si valuti se potrebbe essere proprietario</a></li>
<li><a href="#Rc-dtor-ptr2">C.33: Se una classe ha un membro puntatore proprietario, definire o <code>=delete</code> di un distruttore</a></li>
<li><a href="#Rc-dtor-virtual">C.35: Il distruttore di una classe base dovrebbe essere sia public che virtual, oppure protected e non-virtual</a></li>
<li><a href="#Rc-dtor-fail">C.36: Un distruttore non può fallire</a></li>
<li><a href="#Rc-dtor-noexcept">C.37: Creare i distruttori come <code>noexcept</code></a></li>
</ul>
<p>Regole del costruttore:</p>
<ul>
<li><a href="#Rc-ctor">C.40: Definire un costruttore se una classe ha un invariante</a></li>
<li><a href="#Rc-complete">C.41: Un costruttore dovrebbe creare un oggetto completamente inizializzato</a></li>
<li><a href="#Rc-throw">C.42: Se un costruttore non è in grado di costruire un oggetto valido, generare un’eccezione</a></li>
<li><a href="#Rc-default0">C.43: Accertarsi che una classe copiabile (tipo valore) abbia un costruttore di default</a></li>
<li><a href="#Rc-default00">C.44: È preferibile che i costruttori di default siano semplici e che non sollevino errori [non-throwing]</a></li>
<li><a href="#Rc-default">C.45: Non definire un costruttore di default che inizializza solamente i dati membri; usare, invece, gli inizializzatori dei membri</a></li>
<li><a href="#Rc-explicit">C.46: Per default, dichiarare costruttori ad argomento singolo con <code>explicit</code></a></li>
<li><a href="#Rc-order">C.47: Definire e inizializzare le variabili membro secondo l’ordine di dichiarazione</a></li>
<li><a href="#Rc-in-class-initializer">C.48: Preferire gli inizializzatori [in-class] agli inizializzatori dei membri nei costruttori per gli inizializzatori costanti</a></li>
<li><a href="#Rc-initialize">C.49: Nei costruttori preferire l’inizializzazione alle assegnazioni</a></li>
<li><a href="#Rc-factory">C.50: Usare una funzione factory se c’è bisogno di un “comportamento virtuale” durante l’inizializzazione</a></li>
<li><a href="#Rc-delegating">C.51: Utilizzare i costruttori [delegating] per rappresentare azioni comuni a tutti i costruttori di una classe</a></li>
<li><a href="#Rc-inheriting">C.52: Usare i costruttori ereditati per importare i costruttori in una classe derivata che non necessita di un ulteriore inizializzazione</a></li>
</ul>
<p>Regole di copia e spostamento [move]:</p>
<ul>
<li><a href="#Rc-copy-assignment">C.60: Creare le assegnazioni di copia non-<code>virtuali</code>, prendere il parametro con <code>const&amp;</code>, e restiruire con non-<code>const&amp;</code></a></li>
<li><a href="#Rc-copy-semantic">C.61: Un’operazione di copia dovrebbe copiare</a></li>
<li><a href="#Rc-copy-self">C.62: Rendere l’assegnazione di copia sicura per l’auto-assegnazione</a></li>
<li><a href="#Rc-move-assignment">C.63: Rendere l’assegnazione di spostamento [move] non-<code>virtual</code>, prendere il parametro con <code>&amp;&amp;</code>, e restituire con non-<code>const&amp;</code></a></li>
<li><a href="#Rc-move-semantic">C.64: Un’operazione di [move] dovrebbe spostare e lasciare il sorgente in uno stato valido</a></li>
<li><a href="#Rc-move-self">C.65: Rendere l’assegnazione con spostamento sicura per l’auto-assegnazione</a></li>
<li><a href="#Rc-move-noexcept">C.66: Creare le operazioni di [move] come <code>noexcept</code></a></li>
<li><a href="#Rc-copy-virtual">C.67: Una classe polimorfica dovrebbe sopprimere la copia</a></li>
</ul>
<p>Altre regole delle operazioni di default:</p>
<ul>
<li><a href="#Rc-eqdefault">C.80: Utilizzare <code>=default</code> se si deve essere espliciti sull’uso della semantica di default</a></li>
<li><a href="#Rc-delete">C.81: Utilizzare <code>=delete</code> quando si vuol disabilitare il comportamento di default (senza volere un’alternativa)</a></li>
<li><a href="#Rc-ctor-virtual">C.82: Non richiamare funzioni virtuali nei costruttori e nei distruttori</a></li>
<li><a href="#Rc-swap">C.83: Per i tipi [value-like], si preveda di fornire una funzione di ‘swap’ di tipo <code>noexcept</code></a></li>
<li><a href="#Rc-swap-fail">C.84: Una funzione <code>swap</code> non può fallire</a></li>
<li><a href="#Rc-swap-noexcept">C.85: Rendere lo <code>swap</code> <code>noexcept</code></a></li>
<li><a href="#Rc-eq">C.86: Creare lo <code>==</code> simmetrico rispetto ai tipi di operandi e <code>noexcept</code></a></li>
<li><a href="#Rc-eq-base">C.87: Attenzione a <code>==</code> sulle classi base</a></li>
<li><a href="#Rc-hash">C.89: Rendere un <code>hash</code> <code>noexcept</code></a></li>
<li><a href="#Rc-memset">C.90: Affidarsi ai costruttori e agli operatori di assegnazione, non a memset né a memcpy</a></li>
</ul>
<h2 id="c.defop-operazioni-di-default"><a name="SS-defop"></a>C.defop: Operazioni di Default</h2>
<p>Per default, il linguaggio fornisce le operazioni di default con la loro semantica di default. Tuttavia, un programmatore può disabilitare o sostituire questi default.</p>
<h3 id="c.20-se-possibile-evitare-di-definire-le-operazioni-di-default"><a name="Rc-zero"></a>C.20: Se possibile, evitare di definire le operazioni di default</h3>
<h5 id="motivo-79">Motivo</h5>
<p>È il più semplice e fornisce la semantica più pulita.</p>
<h5 id="esempio-77">Esempio</h5>
<pre><code>struct Named_map {
public:
// ... nessuna operazione di default dichiarata ...
private:
string name;
map&lt;int, int&gt; rep;
};

Named_map nm;        // costruttore di default
Named_map nm2 {nm};  // costruttore copia</code></pre>
<p>Dato che <code>std::map</code> e <code>string</code> hanno entrambe funzioni speciali, non c’è bisogno di altro.</p>
<h5 id="note-96">Note</h5>
<p>Questa è conosciuta come “la regola dello zero”.</p>
<h5 id="imposizione-74">Imposizione</h5>
<p>(Non imponibile) Sebbene non imponibile, un buon analizzatore statico può rilevare schemi che segnalano un possibile miglioramento per soddisfare questa regola. Per esempio, una classe con una coppia (pointer, size) membro e un distruttore che esegue il <code>delete</code> del puntatore, probabilmente si potrebbe convertire in un <code>vector</code>.</p>
<h3 id="c.21-se-si-definisce-o-delete-unoperazione-di-default-si-definiscano-o-delete-tutte"><a name="Rc-five"></a>C.21: Se si definisce o <code>=delete</code> un’operazione di default, si definiscano o <code>=delete</code> tutte</h3>
<h5 id="motivo-80">Motivo</h5>
<p>Le <em>funzioni membro speciali</em> sono il costruttore di default, il costruttore copia, l’operatore di assegnazione per copia, l’operatore di spostamento [move], l’operatore di assegnazione per spostamento [move], e il distruttore.</p>
<p>La semantica delle funzioni speciali è strettamente correlata, quindi se una dev’essere dichiarata, è probabile che anche le altre si debbano prendere in considerazione.</p>
<p>Dichiarando una qualsiasi funzione membro speciale tranne un costruttore di default, anche se <code>=default</code> o <code>=delete</code>, sopprimerà la dichiarazione implicita di un costruttore [move] e un operatore di assegnazione [move]. Dichiarando un costruttore [move] o un operatore di assegnazione [move], anche come <code>=default</code> o <code>=delete</code>, si farà im modo che la generazione implicita, di un costruttore copia o di un operatore di assegnazione, venga definita come cancellata. Quindi appena viene dichiarata una qualsiasi delle funzioni speciali, si dovrebbero dichiarare tutte le altre per evitare effetti indesiderati come il trasformare tutti i potenziali spostamenti [move] nelle più costose copie o rendere una classe [move-only].</p>
<h5 id="esempio-cattivo-25">Esempio, cattivo</h5>
<pre><code>struct M2 {   // bad: insieme incompleto delle operazioni di default
public:
// ...
// ... nessuna operazione di copia o move ...
~M2() { delete[] rep; }
private:
pair&lt;int, int&gt;* rep;  // insieme di coppie [zero-terminated]
};

void use()
{
M2 x;
M2 y;
// ...
x = y;   // l&#39;assegnazione di default
// ...
}</code></pre>
<p>Dato che era necessaria un’“attenzione speciale” per il distruttore (qui, per deallocare), la probabilità che l’assegnazione di copia e di [move] (entrambi distruggono implicitamente un object) siano corrette, è bassa (qui, ci sarebbe una doppia cancellazione).</p>
<h5 id="note-97">Note</h5>
<p>Questa è notacome “la regoa del cinque” o “la regola del sei”, a seconda che si conti o meno il costruttore di default.</p>
<h5 id="note-98">Note</h5>
<p>Se si vuole un’implementazione di default o un’operazione di default (mentre se ne definisce l’altra), si scriva <code>=default</code> per mostrare che è intenzionale. Se non si vuole un’operazione di operation, la si sopprime con <code>=delete</code>.</p>
<h5 id="esempio-buono-5">Esempio, buono</h5>
<p>Quando un distruttore dev’essere dichiarato solo per renderlo <code>virtual</code>, può essere definito come di default. Per evitare la soppressione di operazioni [move] implicite, queste devono essere anche dichiarate, poii, per evitare che la classe diventi [move-only] (e non copiabile), si devono dichiarare le operazioni di copia:</p>
<pre><code>class AbstractBase {
public:
virtual ~AbstractBase() = default;
AbstractBase(const AbstractBase&amp;) = default;
AbstractBase&amp; operator=(const AbstractBase&amp;) = default;
AbstractBase(AbstractBase&amp;&amp;) = default;
AbstractBase&amp; operator=(AbstractBase&amp;&amp;) = default;
};</code></pre>
<p>In alternativa per evitare lo [slicing] come per la <a href="#Rc-copy-virtual">C.67</a>, si possono cancellare le operazioni di copia e [move]:</p>
<pre><code>class ClonableBase {
public:
virtual unique_ptr&lt;ClonableBase&gt; clone() const;
virtual ~ClonableBase() = default;
ClonableBase(const ClonableBase&amp;) = delete;
ClonableBase&amp; operator=(const ClonableBase&amp;) = delete;
ClonableBase(ClonableBase&amp;&amp;) = delete;
ClonableBase&amp; operator=(ClonableBase&amp;&amp;) = delete;
};</code></pre>
<p>Qui, definire solo le operazioni di [move] o solo quelle di copia, avrebbe lo stesso effetto, ma affermare esplicitamente l’intento per ciascun membro speciale, lo rende più ovvio al lettore.</p>
<h5 id="note-99">Note</h5>
<p>I compilatori applicano gran parte di questa regola e, idealmente, avvertono di qualsiasi violazione.</p>
<h5 id="note-100">Note</h5>
<p>Affidarsi ad un’operazione di copia, generata implicitamente, in una classe con un distruttore, è deprecato.</p>
<h5 id="note-101">Note</h5>
<p>Scrivere le sei funzioni membro speciali può essere soggetto a errori. Notare i tipi dei loro argomenti:</p>
<pre><code>class X {
public:
// ...
virtual ~X() = default;            // distruttore (virtuale se X deve essere una classe base)
X(const X&amp;) = default;             // costruttore copia
X&amp; operator=(const X&amp;) = default;  // assegnazione copia
X(X&amp;&amp;) = default;                  // costruttore [move]
X&amp; operator=(X&amp;&amp;) = default;       // assegnazione [move]
};</code></pre>
<p>Un errore minore (come uno di ortografia, tralasciando un <code>const</code>, usando <code>&amp;</code> anziché of <code>&amp;&amp;</code> o tralasciando una funzione speciale ) può causare errori o warning. Per evitare il tedio e la possibilità di errori, provare a seguire la <a href="#Rc-zero">regola dello zero</a>.</p>
<h5 id="imposizione-75">Imposizione</h5>
<p>(Semplice) Una classe dovrebbe avere una dichiarazione (anche un <code>=delete</code>) o per tutte o per nessuna funzione speciale.</p>
<h3 id="c.22-uniformare-le-operazioni-di-default"><a name="Rc-matched"></a>C.22: Uniformare le operazioni di default</h3>
<h5 id="motivo-81">Motivo</h5>
<p>Le operazioni di default sono concettualmente un insieme abbinato. La loro semantica è correlata. Gli utenti resteranno sorpresi se la costruzione copia/[move] e l’assegnazione copia/[move] fanno logicamente cose diverse. Gli utenti resteranno sorpresi se i costruttori e i distruttori non forniscono una vista coerente della gestione delle risorse. Gli utenti resteranno sorpresi la copia e il [move] non riflettono il modo in cui funzionano i costruttori e i distruttori.</p>
<h5 id="esempio-cattivo-26">Esempio, cattivo</h5>
<pre><code>class Silly {   // BAD: Operazioni di copia incoerenti
class Impl {
// ...
};
shared_ptr&lt;Impl&gt; p;
public:
Silly(const Silly&amp; a) : p{a.p} { *p = *a.p; }   // copia completa [deep]
Silly&amp; operator=(const Silly&amp; a) { p = a.p; }   // copia superficiale [shallow]
// ...
};</code></pre>
<p>Queste operazioni non concordano per la semantica della copia. Ciò porterà a confusione e bug.</p>
<h5 id="imposizione-76">Imposizione</h5>
<ul>
<li>(Complesso) Un costruttore di copia/[move] e una corrispondente operatore di assegnazione di copia/[move] devono scrivere le stesse variabili membro allo stesso livello di deferenza.</li>
<li>(copia/[move]) Ciascuna variabile membro scritta in un costruttore di copia/[move] deve essere inizializzata anche in tutti gli altri costruttori.</li>
<li>(Complesso) Se un costruttore di copia/[move] esegue una [deep copy] di una variabile membro, allora il distruttore deve modificare la variabile membro.</li>
<li>(Complesso) Se un distruttore modifica una variabile membro, tale variabile membro dev’essere scritta in qualsiasi costruttore o operatore di assegnazione di copia/[move].</li>
</ul>
<h2 id="c.dtor-distruttori"><a name="SS-dtor"></a>C.dtor: Distruttori</h2>
<p>“Questa classe ha bisogno di un distruttore?” è una domanda sul design sorprendentemente potente. Per la maggior parte delle classi la risposta è “no” o perché la classe non ha risorse o perché la distruzione è gestita dal<a href="#Rc-zero">la regola dello zero</a>; cioè, i suoi membri possono prendersi cura di se stessi per quanto riguarda la distruzione. Se la risposta è “sì”, ne consegue gran parte della progettazione della classe (cfr. <a href="#Rc-five">la regola del cinque</a>).</p>
<h3 id="c.30-definire-un-distruttore-se-una-classe-necessita-di-unazione-esplicita-alla-distruzione-di-un-oggetto"><a name="Rc-dtor"></a>C.30: Definire un distruttore se una classe necessita di un’azione esplicita alla distruzione di un oggetto</h3>
<h5 id="motivo-82">Motivo</h5>
<p>Un distruttore viene invocato implicitamente alla fine della vita di un oggetto. Se il distruttore di default è sufficiente, utilizzalo. Definire un distruttore non di default solo se una classe deve eseguire del codice che non fa già parte dei distruttori dei suoi membri.</p>
<h5 id="esempio-78">Esempio</h5>
<pre><code>template&lt;typename A&gt;
struct final_action {   // leggermente semplificato
A act;
final_action(A a) :act{a} {}
~final_action() { act(); }
};

template&lt;typename A&gt;
final_action&lt;A&gt; finally(A act)   // dedurre il tipo di azione
{
return final_action&lt;A&gt;{act};
}

void test()
{
auto act = finally([]{ cout &lt;&lt; &quot;Exit test\n&quot;; });  // stabilisce l&#39;azione di uscita
// ...
if (something) return;   // l&#39;azione è fatta qui
// ...
} // l&#39;azione è fatta qui</code></pre>
<p>Lo scopo di <code>final_action</code> è quello di ottenere l’esecuzione di un pezzo di codice (solitamente una lambda) al momento della distruzione.</p>
<h5 id="note-102">Note</h5>
<p>Ci cono due categorie generali di classi che richiedono un distruttore definito dall’utente:</p>
<ul>
<li>Una classe con una risorsa che non è già rappresentata come una classe con un distruttore, p.es., un <code>vector</code> o una classe di transazione.</li>
<li>Una classe che esiste principalmente per eseguire un’azione al momento della distruzione, come un tracer o un <code>final_action</code>.</li>
</ul>
<h5 id="esempio-cattivo-27">Esempio, cattivo</h5>
<pre><code>class Foo {   // bad; usa il costruttore di default
public:
// ...
~Foo() { s = &quot;&quot;; i = 0; vi.clear(); }  // ripulisce
private:
string s;
int i;
vector&lt;int&gt; vi;
};</code></pre>
<p>Il distruttore di default lo fa meglio, più efficientemente e non può andare in errore.</p>
<h5 id="note-103">Note</h5>
<p>Se il distruttore di default è necessario, ma la sua generazione è stata soppressa (p.es., definendo un costruttore di spostamento), si usa <code>=default</code>.</p>
<h5 id="imposizione-77">Imposizione</h5>
<p>Si cercano delle probabili “risorse implicite”, come puntatori e riferimenti. Si cercano le classi con distruttori anche se tutti i loro dati membro hanno dei distruttori.</p>
<h3 id="c.31-tutte-le-risorse-acquisite-da-una-classe-devono-essere-rilasciate-dal-distruttore-della-classe"><a name="Rc-dtor-release"></a>C.31: Tutte le risorse acquisite da una classe devono essere rilasciate dal distruttore della classe</h3>
<h5 id="motivo-83">Motivo</h5>
<p>Prevenire i [leak] delle risorse, specialmente in caso di errore.</p>
<h5 id="note-104">Note</h5>
<p>Per le risorse rappresentate come classi con un complet set di operazioni di default, ciò avviene automaticamente.</p>
<h5 id="esempio-79">Esempio</h5>
<pre><code>class X {
ifstream f;   // può possedere un file
// ... nessuna operazione di default definita o =deleted ...
};</code></pre>
<p>Nella <code>X</code>, <code>ifstream</code> chiude implicitamente qualsiasi file che potrebbe aver aperto alla distruzione del suo <code>X</code>.</p>
<h5 id="esempio-cattivo-28">Esempio, cattivo</h5>
<pre><code>class X2 {     // bad
FILE* f;   // può possedere un file
// ... nessuna operazione di default definita o =deleted ...
};</code></pre>
<p><code>X2</code> può produrre un [leak] di un handle di file.</p>
<h5 id="note-105">Note</h5>
<p>Che dire di un socket che non viene chiuso? Un distruttore o un’operazione di chiusura o pulizia <a href="#Rc-dtor-fail">non dovrebbe mai fallire</a>. Se capita, abbiamo un problema che non ha una soluzione davvero valida. Per cominciare, chi scrive un distruttore non sa perché il distruttore viene chiamato e non può “rifiutarsi di agire” lanciando un’eccezione. Si veda la <a href="#Sd-never-fail">discussione</a>. A peggiorare il problema, molte operazioni di “chiusura/rilascio” non si possono rieseguire. In molti hanno cercato di risolvere questo problema, ma non è nota alcuna soluzione generale. Se possibile, considerare la mancata chiusura/pulizia un errore progettuale fondamentale e terminare.</p>
<h5 id="note-106">Note</h5>
<p>Una classe può contenere puntatori e riferimenti a oggetti che non possiede. Ovviamente, tali oggetti non dovrebbero subire un <code>delete</code> da parte del distruttore della classe. Per esempio:</p>
<pre><code>Preprocessor pp { /* ... */ };
Parser p { pp, /* ... */ };
Type_checker tc { p, /* ... */ };</code></pre>
<p>Qui <code>p</code> fa riferimento a <code>pp</code> ma non lo possiede.</p>
<h5 id="imposizione-78">Imposizione</h5>
<ul>
<li>(Semplice) Se una classe ha variabili membro puntatori o riferimenti che sono proprietari (p.es., considerati proprietari utilizzando <code>gsl::owner</code>), allora questi dovrebbero essi referenziati nel suo distruttore.</li>
<li>(Difficile) Determinare se le variabili membro puntatori o riferimentisono proprietari quando non c’è alcuna istruzione esplicita sulla proprietà (p.es., guardando nei costruttori).</li>
</ul>
<h3 id="c.32-se-una-classe-ha-un-puntatore-raw-t-o-un-riferimento-t-si-valuti-se-potrebbe-essere-proprietario"><a name="Rc-dtor-ptr"></a>C.32: Se una classe ha un puntatore [raw] (<code>T*</code>) o un riferimento (<code>T&amp;</code>), si valuti se potrebbe essere proprietario</h3>
<h5 id="motivo-84">Motivo</h5>
<p>C’è un moltissimo codice che non è specifico sulla proprietà [ownership].</p>
<h5 id="esempio-80">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="note-107">Note</h5>
<p>Se <code>T*</code> o <code>T&amp;</code> sono proprietari, si contrassegnano con <code>owning</code>. Se <code>T*</code> non è proprietario, si prenda in considerazione di segnarlo con <code>ptr</code>. Ciò aiuterà la documentazione e l’analisi.</p>
<h5 id="imposizione-79">Imposizione</h5>
<p>Osservare l’inizializzazione dei puntatori menbro e dei riferimento ai membri e vedere se viene utilizzata un’allocazione.</p>
<h3 id="c.33-se-una-classe-ha-un-membro-puntatore-proprietario-definire-un-distruttore"><a name="Rc-dtor-ptr2"></a>C.33: Se una classe ha un membro puntatore proprietario, definire un distruttore</h3>
<h5 id="motivo-85">Motivo</h5>
<p>Un oggetto posseduto deve essere <code>deleted</code> quando avviene la distruzione dell’oggetto che lo possiede.</p>
<h5 id="esempio-81">Esempio</h5>
<p>Un membro puntatore può rappresentare una risorsa. <a href="#Rr-ptr">Un <code>T*</code> non dovrebbe farlo</a>, ma nel vecchio codice, era una cosa comune. Si consideri un <code>T*</code> un possibile proprietario e quindi sospetto.</p>
<pre><code>template&lt;typename T&gt;
class Smart_ptr {
T* p;   // BAD: vago sulla proprietà di *p
// ...
public:
// ... nessuna operazione di default user-defined ...
};

void use(Smart_ptr&lt;int&gt; p1)
{
// errore: p2.p viene perso [leaked] (se non nullptr e non di proprietà di qualche altro codice)
auto p2 = p1;
}</code></pre>
<p>Da notare che se si definisce un distruttore, si devono definire o cancellare [delete] <a href="#Rc-five">tutte le operazioni di default</a>:</p>
<pre><code>template&lt;typename T&gt;
class Smart_ptr2 {
T* p;   // BAD: vago sulla proprietà di *p
// ...
public:
// ... nessuna operazione di copia user-defined ...
~Smart_ptr2() { delete p; }  // p è proprietario!
};

void use(Smart_ptr2&lt;int&gt; p1)
{
auto p2 = p1;   // errore: doppio delete
}</code></pre>
<p>L’operazione copia di default eseguirà soltanto la copia di <code>p1.p</code> in <code>p2.p</code> portando ad una doppia distruzione di <code>p1.p</code>. Siate espliciti sulla proprietà:</p>
<pre><code>template&lt;typename T&gt;
class Smart_ptr3 {
owner&lt;T*&gt; p;   // OK: esplicito sulla proprietà di *p
// ...
public:
// ...
// ... operazioni di copia e [move] ...
~Smart_ptr3() { delete p; }
};

void use(Smart_ptr3&lt;int&gt; p1)
{
auto p2 = p1;   // OK: nessuna distruzione doppia
}</code></pre>
<h5 id="note-108">Note</h5>
<p>Spesso il modo più semplice per avere un distruttore è quello di sostituire il puntatore con uno smart pointer (p.es., <code>std::unique_ptr</code>) e lasciare che il compilatore organizzi opportunamente la distruzione implicita.</p>
<h5 id="note-109">Note</h5>
<p>Perché non richiedere semplicemente che tutti i puntatori proprietari siano “smart pointer”? Ciò a volte richiederebbe modifiche non banali al codice e potrebbe influire sulle ABI.</p>
<h5 id="imposizione-80">Imposizione</h5>
<ul>
<li>Una classe con un dato membro puntatore è sospetta.</li>
<li>Una classe con un <code>owner&lt;T&gt;</code> dovrebbe definire le proprie operazioni di default.</li>
</ul>
<h3 id="c.35-il-distruttore-di-una-classe-base-dovrebbe-essere-sia-public-che-virtual-oppure-protected-e-non-virtual"><a name="Rc-dtor-virtual"></a>C.35: Il distruttore di una classe base dovrebbe essere sia public che virtual, oppure protected e non-virtual</h3>
<h5 id="motivo-86">Motivo</h5>
<p>Per prevenire comportamenti indefiniti. Se il distruttore è pubblico, il codice chiamante può tentare di distruggere un oggetto derivato della classe tramite un puntatore alla classe base e il risultato è indefinito se il distruttore della classe base è non-virtual. Se il distruttore è protected, allora il codice chiamante non può distruggere, tramite un puntatore alla classe base e il distruttore non deve necessariamente essere virtual; deve essere protected, non private, in modo che i distruttori derivati lo possano invocare. In generale, chi scrive una classe base non conosce l’azione appropriata da farsi al momento della distruzione.</p>
<h5 id="discussione-2">Discussione</h5>
<p>Cfr. <a href="#Sd-dtor">questo nella sezione Discussione</a>.</p>
<h5 id="esempio-cattivo-29">Esempio, cattivo</h5>
<pre><code>struct Base {  // BAD: implicitamente ha un distruttore pubblico non virtuale
virtual void f();
};

struct D : Base {
string s {&quot;una risorsa da ripulire&quot;};
~D() { /* ... fa qualche pulizia ... */ }
// ...
};

void use()
{
unique_ptr&lt;Base&gt; p = make_unique&lt;D&gt;();
// ...
} // la distruzione di p chiama ~Base(), non ~D(), che &#39;perde&#39; [leak] D::s e forse anche altro</code></pre>
<h5 id="note-110">Note</h5>
<p>Una funzione virtuale definisce un’interfaccia per le classi derivate che possono essere utilizzate senza guardare le classi derivate. Se l’interfaccia consente la distruzione, dovrebbe essere sicuro farlo.</p>
<h5 id="note-111">Note</h5>
<p>Un distruttore deve essere non-private altrimenti se ne impedirà l’uso, per esempio:</p>
<pre><code>class X {
~X();   // distruttore privato
// ...
};

void use()
{
X a;                        // errore: non può distruggere
auto p = make_unique&lt;X&gt;();  // errore: non può distruggere
}</code></pre>
<h5 id="eccezione-18">Eccezione</h5>
<p>Possiamo immaginare un caso in cui si potrebbe volere un distruttore virtuale protetto: Quando un oggetto di un tipo derivato (e solo di questo tipo) dovrebbe poter distruggere <em>un altro</em> oggetto (non se stesso) tramite un puntatore alla base. Tuttavia, non abbiamo visto un caso del genere in pratica.</p>
<h5 id="imposizione-81">Imposizione</h5>
<ul>
<li>Una classe con una qualsiasi funzione virtuale dovrebbe avere un distruttore o pubblico o virtuale oppure protetto e non virtuale.</li>
</ul>
<h3 id="c.36-un-distruttore-non-può-fallire"><a name="Rc-dtor-fail"></a>C.36: Un distruttore non può fallire</h3>
<h5 id="motivo-87">Motivo</h5>
<p>In generale non sappiamo come scrivere un codice privo di errori se un distruttore dovesse fallire. La libreria standard richiede che tutte le classi con cui ha a che fare abbiano distruttori che sollevino eccezioni [throw].</p>
<h5 id="esempio-82">Esempio</h5>
<pre><code>class X {
public:
~X() noexcept;
// ...
};

X::~X() noexcept
{
// ...
if (cannot_release_a_resource) terminate();
// ...
}</code></pre>
<h5 id="note-112">Note</h5>
<p>In molti hanno cercato di escogitare uno schema infallibile per affrontare i fallimenti nei distruttori. Nessuno è riuscito a elaborare uno schema generale. Questo può essere un vero problema in pratica: Ad esempio, che dire di un socket che non si chiude? Chi scrive un distruttore non sa perché viene chiamato e non può fa s’ che si “rifiuti di agire” lanciando un’eccezione. Cfr. <a href="#Sd-never-fail">discussione</a>. A peggiorare il problema, molte operazioni di “chiusura/rilascio” non si possono rieseguire. Se possibile, considerare la mancata chiusura/pulizia un errore progettuale fondamentale e terminare.</p>
<h5 id="note-113">Note</h5>
<p>Dichiarare un distruttore <code>noexcept</code>. Ciò garantirà il normale completamento o la chiusura del programma.</p>
<h5 id="note-114">Note</h5>
<p>Se una risorsa non può essere rilasciata e il programma non può fallire, si provi a segnalare l’errore al resto del sistema in qualche modo (forse anche modificando qualche stato globale e sperando che qualcosa si accorga e sia in grado di provvedere). Bisogna essere pienamente consapevoli del fatto che questa tecnica è particolare e soggetta a errori. Si consideri l’esempio: “la mia connessione non si chiuderà”. Probabilmente c’è un problema all’altra estremità della connessione e solo un pezzo di codice responsabile di entrambe le estremità della connessione può gestire correttamente il problema. Il distruttore potrebbe inviare un messaggio (in qualche modo) alla parte responsabile del sistema, considerare di aver chiuso la connessione e tornare normalmente.</p>
<h5 id="note-115">Note</h5>
<p>Se un distruttore esegue operazioni che potrebbero non riuscire, può rilevare delle eccezioni e in qualche caso completare comunque correttamente (p.es., utilizzando un meccanismo diverso da quello che è andato in errore).</p>
<h5 id="imposizione-82">Imposizione</h5>
<p>(Semplice) Un distruttore dovrebbe essere dichiarato <code>noexcept</code> se può andare in errore.</p>
<h3 id="c.37-creare-i-distruttori-come-noexcept"><a name="Rc-dtor-noexcept"></a>C.37: Creare i distruttori come <code>noexcept</code></h3>
<h5 id="motivo-88">Motivo</h5>
<p><a href="#Rc-dtor-fail">Un distruttore non può fallire</a>. Se un distruttore tenta di uscire con un’eccezione, si tratta di un errore di progettazione e sarebbe meglio che il programma terminasse.</p>
<h5 id="note-116">Note</h5>
<p>Un distruttore (sia user-defined che generato dal compilatore) è implicitamente dichiarato <code>noexcept</code> (indipendentemente dal codice) se tutti i membri della sua classe hanno distruttori <code>noexcept</code>. Segnando esplicitamente i distruttori con <code>noexcept</code>, un autore si tutela dal fatto che il distruttore possa diventare implicitamente <code>noexcept(false)</code> aggiungendo o modificando un membro della classe.</p>
<h5 id="esempio-83">Esempio</h5>
<p>Non tutti i distruttori sono noexcept per default; un membro che possa lanciare un’eccezione [throwing] avvelena tutta la gerarchia della classe</p>
<pre><code>struct X {
Details x;  // sembra avere un distruttore [throwing]
// ...
~X() { }    // implicitamente noexcept(false); ovvero può [throw]
};</code></pre>
<p>Quindi, in caso di dubbio, dichiarare un distruttore noexcept.</p>
<h5 id="note-117">Note</h5>
<p>Perché non dichiarare quindi tutti i distruttori noexcept? Perché in molti casi questo – specialmente nei casi semplici – potrebbe generare disordine.</p>
<h5 id="imposizione-83">Imposizione</h5>
<p>(Semplice) Un distruttore dovrebbe essere dichiarato <code>noexcept</code> se può andare in errore.</p>
<h2 id="c.ctor-costruttori"><a name="SS-ctor"></a>C.ctor: Costruttori</h2>
<p>Un costruttore definisce come un oggetto viene inizializzato (costruito).</p>
<h3 id="c.40-definire-un-costruttore-se-una-classe-ha-un-invariante"><a name="Rc-ctor"></a>C.40: Definire un costruttore se una classe ha un invariante</h3>
<h5 id="motivo-89">Motivo</h5>
<p>Ecco a cosa servono i costruttori.</p>
<h5 id="esempio-84">Esempio</h5>
<pre><code>class Date {  // una Date rappresenta una data valida
// tra il 1 gennaio del 1900 al 31 dicembre del 2100
Date(int dd, int mm, int yy)
:d{dd}, m{mm}, y{yy}
{
if (!is_valid(d, m, y)) throw Bad_date{};  // impone un&#39;invariante
}
// ...
private:
int d, m, y;
};</code></pre>
<p>Spesso è una buona idea esprimere l’invariante come un’<code>Imposizione</code> sul costruttore.</p>
<h5 id="note-118">Note</h5>
<p>Un costruttore può essere utilizzato per comodità anche se una classe non ha un invariante. Per esempio:</p>
<pre><code>struct Rec {
string s;
int i {0};
Rec(const string&amp; ss) : s{ss} {}
Rec(int ii) :i{ii} {}
};

Rec r1 {7};
Rec r2 {&quot;Foo bar&quot;};</code></pre>
<h5 id="note-119">Note</h5>
<p>La regola della lista di inizializzatori del C++11 elimina la necessità di molti costruttori. Per esempio:</p>
<pre><code>struct Rec2{
string s;
int i;
Rec2(const string&amp; ss, int ii = 0) :s{ss}, i{ii} {}   // ridondante
};

Rec2 r1 {&quot;Foo&quot;, 7};
Rec2 r2 {&quot;Bar&quot;};</code></pre>
<p>Il costruttore di <code>Rec2</code> è ridondante. Inoltre, il default per un <code>int</code> sarà fatto meglio come un <a href="#Rc-in-class-initializer">inizializzatore di membro</a>.</p>
<p><strong>Si veda anche</strong>: <a href="#Rc-complete">costruire oggetti validi</a> e <a href="#Rc-throw">eccezioni nei costruttori</a>.</p>
<h5 id="imposizione-84">Imposizione</h5>
<ul>
<li>Contrassegnare le classi con operazioni di copia user-defined ma senza costruttore (una copia user-defined è un buon indicatore del fatto che la classe ha un invariante)</li>
</ul>
<h3 id="c.41-un-costruttore-dovrebbe-creare-un-oggetto-completamente-inizializzato"><a name="Rc-complete"></a>C.41: Un costruttore dovrebbe creare un oggetto completamente inizializzato</h3>
<h5 id="motivo-90">Motivo</h5>
<p>Un costruttore stabilisce l’invariante per una classe. L’utilizzatore di una classe dovrebbe poter supporre che un oggetto costruito è utilizzabile.</p>
<h5 id="esempio-cattivo-30">Esempio, cattivo</h5>
<pre><code>class X1 {
FILE* f;   // chiama init() prima di ogni altra funzione
// ...
public:
X1() {}
void init();   // inizializza f
void read();   // legge da f
// ...
};

void f()
{
X1 file;
file.read();   // c&#39;è un crash o una cattiva lettura!
// ...
file.init();   // troppo tardi
// ...
}</code></pre>
<p>I compilatori non leggono i commenti.</p>
<h5 id="eccezione-19">Eccezione</h5>
<p>Se una classe non può convenientemente costruire un oggetto valido, <a href="#Rc-factory">si una una funzione factory</a>.</p>
<h5 id="imposizione-85">Imposizione</h5>
<ul>
<li>(Semplice) Ogni costruttore dovrebbe inizializzare ogni variabile membro (o esplicitamente, tramite una chiamata a un ctor delegating, o con la costruzione di default).</li>
<li>(Ignoto) Se un costruttore ha un contratto <code>Ensures</code>, provare a vedere se vale come post-condizione.</li>
</ul>
<h5 id="note-120">Note</h5>
<p>Se un costruttore acquisisce una risorsa (per creare un oggetto valido), tale risorsa deve essere <a href="#Rc-dtor-release">rilasciata dal distruttore</a>. L’idioma dell’avere dei costruttori che acquisiscono risorse e distruttori che le rilasciano è detto <a href="#Rr-raii">RAII</a> (“Resource Acquisition Is Initialization”).</p>
<h3 id="c.42-se-un-costruttore-non-è-in-grado-di-costruire-un-oggetto-valido-generare-uneccezione"><a name="Rc-throw"></a>C.42: Se un costruttore non è in grado di costruire un oggetto valido, generare un’eccezione</h3>
<h5 id="motivo-91">Motivo</h5>
<p>Lasciare un oggetto invalido vuol dire andarsi a cercare i problemi.</p>
<h5 id="esempio-85">Esempio</h5>
<pre><code>class X2 {
FILE* f;
// ...
public:
X2(const string&amp; name)
:f{fopen(name.c_str(), &quot;r&quot;)}
{
if (!f) throw runtime_error{&quot;impossibile aprire &quot; + name};
// ...
}

void read();      // legge da f
// ...
};

void f()
{
X2 file {&quot;Zeno&quot;}; // in errore se il file non è aperto
file.read();      // per bene
// ...
}</code></pre>
<h5 id="esempio-cattivo-31">Esempio, cattivo</h5>
<pre><code>class X3 {     // bad: il costruttore si lascia dietro un oggetto non-valido
FILE* f;   // chiamare is_valid() prima di ogni altra funzione
bool valid;
// ...
public:
X3(const string&amp; name)
:f{fopen(name.c_str(), &quot;r&quot;)}, valid{false}
{
if (f) valid = true;
// ...
}

bool is_valid() { return valid; }
void read();   // legge da f
// ...
};

void f()
{
X3 file {&quot;Heraclides&quot;};
file.read();   // un crash o un&#39;errata lettura!
// ...
if (file.is_valid()) {
file.read();
// ...
}
else {
// ... gestione dell&#39;errore ...
}
// ...
}</code></pre>
<h5 id="note-121">Note</h5>
<p>Per una definizione di una variabile (p-es., sullo stack o come membro di un altro oggetto) non esiste alcuna esplicita chiamata a funzione da cui si possa restituire un codice d’errore. Lasciarsi dietro un oggetto invalido e affidarsi agli utilizzatori che verifichino costantemente la funzione <code>is_valid()</code> prima di usarlo è noioso, soggetto a errori ed inefficiente.</p>
<h5 id="eccezione-20">Eccezione</h5>
<p>Esistono domini, come alcuni sistemi in stretto real-time (si pensi ai controlli di un aereo) in cui (senza il supporto di strumenti aggiuntivi) la gestione delle eccezioni non è sufficientemente prevedibile da un punto di vista temporale. Lì deve essere utilizzata la tecnica <code>is_valid()</code>. In tali casi, controllare <code>is_valid()</code> spesso e simulare immediatamente il <a href="#Rr-raii">RAII</a>.</p>
<h5 id="alternativa-5">Alternativa</h5>
<p>Se si è tentati di usare qualche semantica [idiom] di “inizializzazione post-costruttore” o “inizializzazione a due fasi”, si desista. Se proprio si deve fare, si cerchi tra le <a href="#Rc-factory">funzioni factory</a>.</p>
<h5 id="note-122">Note</h5>
<p>Uno dei motivi per cui le persone hanno usato le funzioni <code>init()</code> anziché inizializzare direttamente nel costruttore è stato quello di evitare la replicazione del codice. <a href="#Rc-delegating">I costruttori delegating</a> e <a href="#Rc-in-class-initializer">l’inizializzazione di default dei membri</a> lo fanno meglio. Un’altra ragione è stata quella di ritardare l’inizializzazione finché non fosse stato necessario avere un oggetto; spesso la soluzione a ciò è <a href="#Res-init">non dichiarare una variabile finché non possa essere adeguatamente inizializzata</a></p>
<h5 id="imposizione-86">Imposizione</h5>
<p>???</p>
<h3 id="c.43-accertarsi-che-una-classe-copiabile-tipo-valore-abbia-un-costruttore-di-default"><a name="Rc-default0"></a>C.43: Accertarsi che una classe copiabile (tipo valore) abbia un costruttore di default</h3>
<h5 id="motivo-92">Motivo</h5>
<p>Molti linguaggi e strutture di librerie si affidano ai costruttori di default per inizializzare i propri elementi, p.es. <code>T a[10]</code> e <code>std::vector&lt;T&gt; v(10)</code>. Un costruttore di default spesso semplifica il compito di definire un adatto <a href="#???">stato spostato</a> per un tipo che sia anche copiabile.</p>
<h5 id="note-123">Note</h5>
<p>Un <a href="#SS-concrete">tipo di valore</a> è una classe copiabile (e solitamente anche confrontabile). È strettamente correlato alla nozione di tipo Regolare da <a href="http://elementsofprogramming.com/">EoP</a> e <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf">the Palo Alto TR</a>.</p>
<h5 id="esempio-86">Esempio</h5>
<pre><code>class Date { // BAD: nessun costruttore di default
public:
Date(int dd, int mm, int yyyy);
// ...
};

vector&lt;Date&gt; vd1(1000);   // qui è necessario il default di Date
vector&lt;Date&gt; vd2(1000, Date{Month::October, 7, 1885});   // alternativamente</code></pre>
<p>Il costruttore di default viene auto-generato solo se non c’è un costruttore dichiarato dall’utente, quindi è impossibile inizializzare il vettore <code>vd1</code> nell’esempio precedente. L’assenza di un valore di default può riservare delle sorprese agli utenti e complicarne l’uso, quindi se lo si può ragionevolmente definire, lo si faccia.</p>
<p>Si è scelto <code>Date</code> per incoraggiare il pensiero: Non c’è alcuna data di default “naturale” (il big bang è troppo lontano nel tempo per essere utile per la maggior parte delle persone), quindi questo esempio non è banale. <code>{0, 0, 0}</code> non è una data valida nella maggior parte dei sistemi di calendari, quindi si sceglie quello che potrebbe assomigliare al <code>NaN</code> dei numeri a virgola mobile. Tuttavia, la maggior parte delle classi <code>Date</code> realistiche hanno una “data iniziale” (p.es. è famoso il 1 gennaio 1970), quindi averla come default è solitamente banale.</p>
<pre><code>class Date {
public:
Date(int dd, int mm, int yyyy);
Date() = default; // [Vedi anche](#Rc-default)
// ...
private:
int dd = 1;
int mm = 1;
int yyyy = 1970;
// ...
};

vector&lt;Date&gt; vd1(1000);</code></pre>
<h5 id="note-124">Note</h5>
<p>Una classe con membri che abbiano tutti costruttori di default, ottiene implicitamente un costruttore di default:</p>
<pre><code>struct X {
string s;
vector&lt;int&gt; v;
};

X x; // significa X{{}, {}}; questo è la stringa vuota e il vettore vuoto</code></pre>
<p>Attenzione che i tipi [built-in] non vengono correttamente costruiti di default:</p>
<pre><code>struct X {
string s;
int i;
};

void f()
{
X x;    // x.s è inizializzato come stringa vuota; x.i non viene inizializzato

cout &lt;&lt; x.s &lt;&lt; &#39; &#39; &lt;&lt; x.i &lt;&lt; &#39;\n&#39;;
++x.i;
}</code></pre>
<p>Gli oggetti allocati staticamente di tipo [built-in] vengono per default inizializzati a <code>0</code>, ma non le variabili locali di tipo [built-in]. Attenzione che il compilatore potrebbe inizializzare per default le variabili locali di tipo [built-in], mentre una compilazione ottimizzata non lo farà. Pertanto, codice simile a quello dell’esempio precedente può sembrare funzionante, ma si basa su un comportamento indefinito. Assumendo che si voglia un’inizializzazione, un’inizializzazione di default può essere d’aiuto:</p>
<pre><code>struct X {
string s;
int i {};   // per default inizializza (a 0)
};</code></pre>
<h5 id="note-125">Note</h5>
<p>Le classi che non hanno una ragionevole costruzione di default sono solitamente anche non copiabili, quindi non rientrano in questa linea-guida.</p>
<p>Per esempio, una classe base non è un tipo di valore (le classi base non devono essere copiabili) e quindi non hanno necessariamente bisogno di un costruttore di default:</p>
<pre><code>// Shape è una classe base astratta, non un tipo di valore copiabile.
// Potrebbe o meno essere necessario un costruttore di default.
struct Shape {
virtual void draw() = 0;
virtual void rotate(int) = 0;
// =cancella le funzioni di copia/spostamento
// ...
};</code></pre>
<p>Una classe che deve acquisire una risorsa fornita dal chiamante durante la costruzione spesso non può avere un costruttore di default, ma non rientra in questa linea-guida poiché tale classe di solito non è comunque copiabile:</p>
<pre><code>// std::lock_guard non è un tipo di valore copiabile.
// Non ha un costruttore di default.
lock_guard g {mx};  // protegge il mutex mx
lock_guard g2;      // errore: non protegge niente</code></pre>
<p>Una classe che ha uno “stato speciale” che deve essere gestito separatamente dagli altri stati dalle funzioni membro o dagli utenti provoca un lavoro extra (e molto probabilmente più errori). Tale tipo può naturalmente usare lo stato speciale come valore costruito di default, indipendentemente dal fatto che sia o meno copiabile:</p>
<pre><code>// std::ofstream non è un tipo di valore copiabile.
// Capita di avere un costruttore di default
// che segue uno stato speciale &quot;non aperto&quot;.
ofstream out {&quot;Foobar&quot;};
// ...
out &lt;&lt; log(time, transaction);</code></pre>
<p>I tipi simili di stati speciali che sono copiabili, ad esempio i puntatori smart copiabili che hanno lo stato speciale “==nullptr”, devono utilizzare lo stato speciale come il valore di default nel costruttore.</p>
<p>Tuttavia, è preferibile avere un default per un costruttore di default anziché uno stato significativo come <code>std::string</code>s <code>""</code> e <code>std::vector</code>s <code>{}</code>.</p>
<h5 id="imposizione-87">Imposizione</h5>
<ul>
<li>Segnalare le classi che siano copiabili con <code>=</code> senza un costruttore di default</li>
<li>Segnalare le classi che sono confrontabili con <code>==</code> ma non copiabili</li>
</ul>
<h3 id="c.44-è-preferibile-che-i-costruttori-di-default-siano-semplici-e-che-non-sollevino-errori-non-throwing"><a name="Rc-default00"></a>C.44: È preferibile che i costruttori di default siano semplici e che non sollevino errori [non-throwing]</h3>
<h5 id="motivo-93">Motivo</h5>
<p>Essere in grado di impostare un valore ad “un default” senza le operazioni che possono fallire semplifica la gestione degli errori e il ragionamento sulle operazioni di [move].</p>
<h5 id="esempio-problematico">Esempio, problematico</h5>
<pre><code>template&lt;typename T&gt;
// elem punta all&#39;elemento space-elem allocato con new
class Vector0 {
public:
Vector0() :Vector0{0} {}
Vector0(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}
// ...
private:
own&lt;T*&gt; elem;
T* space;
T* last;
};</code></pre>
<p>Questo va bene ed è generale, ma impostando un <code>Vector0</code> a vuoto dopo un errore implica un’allocazione, che potrebbe non riuscire. Inoltre, avere un <code>Vector</code> di default rapresentato come <code>{new T[0], 0, 0}</code> sembra dispendioso. Per esempio, <code>Vector0&lt;int&gt; v[100]</code> costa 100 allocazioni.</p>
<h5 id="esempio-87">Esempio</h5>
<pre><code>template&lt;typename T&gt;
// elem è nullptr oppure punta a space-elem elementi allocati con new
class Vector1 {
public:
// imposta la rappresentazione a {nullptr, nullptr, nullptr}; senza generare errori
Vector1() noexcept {}
Vector1(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}
// ...
private:
own&lt;T*&gt; elem = nullptr;
T* space = nullptr;
T* last = nullptr;
};</code></pre>
<p>L’uso di <code>{nullptr, nullptr, nullptr}</code> rende <code>Vector1{}</code> economico, ma un caso speciale ed implica dei controlli a run-time. Impostare un <code>Vector1</code> a vuoto dopo aver rilevato un errore è banale.</p>
<h5 id="imposizione-88">Imposizione</h5>
<ul>
<li>Segnalare i costruttori di default che possono sollevare errori</li>
</ul>
<h3 id="c.45-non-definire-un-costruttore-di-default-che-inizializza-solamente-i-dati-membri-usare-invece-gli-inizializzatori-dei-membri"><a name="Rc-default"></a>C.45: Non definire un costruttore di default che inizializza solamente i dati membri; usare, invece, gli inizializzatori dei membri</h3>
<h5 id="motivo-94">Motivo</h5>
<p>Utilizzando gli inizializzatori dei membri [in-class], consente al compilatore di generavi la funzione. La funzione generata dal compilatore può essere più efficiente.</p>
<h5 id="esempio-cattivo-32">Esempio, cattivo</h5>
<pre><code>class X1 { // BAD: non usa gli inizializzatori dei membri
string s;
int i;
public:
X1() :s{&quot;default&quot;}, i{1} { }
// ...
};</code></pre>
<h5 id="esempio-88">Esempio</h5>
<pre><code>class X2 {
string s = &quot;default&quot;;
int i = 1;
public:
// usa il costruttore di default generato dal compilatore
// ...
};</code></pre>
<h5 id="imposizione-89">Imposizione</h5>
<p>(Semplice) Un costruttore di default dovrebbe fare di più del solo inizializzare le variabili membro con delle costanti.</p>
<h3 id="c.46-per-default-dichiarare-costruttori-ad-argomento-singolo-con-explicit"><a name="Rc-explicit"></a>C.46: Per default, dichiarare costruttori ad argomento singolo con explicit</h3>
<h5 id="motivo-95">Motivo</h5>
<p>Per evitare conversioni indesiderate.</p>
<h5 id="esempio-cattivo-33">Esempio, cattivo</h5>
<pre><code>class String {
public:
String(int);   // BAD
// ...
};

String s = 10;   // sorpresa: stringa di dimensioni 10</code></pre>
<h5 id="eccezione-21">Eccezione</h5>
<p>Se si vuole veramente una conversione implicita da parte dell’argomento del costruttore al tipo della classe, non usare <code>explicit</code>:</p>
<pre><code>class Complex {
public:
Complex(double d);   // OK: si vuole una conversione da d a {d, 0}
// ...
};

Complex z = 10.7;   // conversione attesa</code></pre>
<p><strong>Si veda anche</strong>: <a href="#Ro-conversion">Discussione sulle conversioni implicite</a></p>
<h5 id="note-126">Note</h5>
<p>I costruttori copia e [move] non devono essere creati con <code>explicit</code> perché non eseguono conversioni. I costruttori ‘explicit’ di copia/[move] rendono difficile il passaggio e la restituzione per valore.</p>
<h5 id="imposizione-90">Imposizione</h5>
<p>(Semplice) I costruttori con singolo argomento devono essere dichiarati <code>explicit</code>. Dei buoni costruttori con argomento singolo non-<code>explicit</code> sono rari nella maggior parte dei codici. Avvertire per quelli che non sono in una “lista positiva”.</p>
<h3 id="c.47-definire-e-inizializzare-le-variabili-membro-secondo-lordine-di-dichiarazione"><a name="Rc-order"></a>C.47: Definire e inizializzare le variabili membro secondo l’ordine di dichiarazione</h3>
<h5 id="motivo-96">Motivo</h5>
<p>Per ridurre al minimo la confusione e gli errori. Questo è l’ordine con cui avviene l’inizializzazione (indipendentemente dall’ordine degli inizializzatori dei membri).</p>
<h5 id="esempio-cattivo-34">Esempio, cattivo</h5>
<pre><code>class Foo {
int m1;
int m2;
public:
Foo(int x) :m2{x}, m1{++x} { }   // BAD: ordine di inizializzazione fuorviante
// ...
};

Foo x(1); // sorpresa: x.m1 == x.m2 == 2</code></pre>
<h5 id="imposizione-91">Imposizione</h5>
<p>(Semplice) Una lista degli inizializzatori dei membro deve indicare i membri nello stesso ordine con cui sono dichiarati.</p>
<p><strong>Si veda anche la </strong>: <a href="#Sd-order">Discussione</a></p>
<h3 id="c.48-preferire-gli-inizializzatori-in-class-agli-inizializzatori-dei-membri-nei-costruttori-per-gli-inizializzatori-costanti"><a name="Rc-in-class-initializer"></a>C.48: Preferire gli inizializzatori [in-class] agli inizializzatori dei membri nei costruttori per gli inizializzatori costanti</h3>
<h5 id="motivo-97">Motivo</h5>
<p>Rende esplicito che ci si aspetta di usare lo stesso valore in tutti i costruttori. Evita le ripetizioni. Evita problemi di manutenzione. Porta ad un codice più breve e più efficiente.</p>
<h5 id="esempio-cattivo-35">Esempio, cattivo</h5>
<pre><code>class X {   // BAD
int i;
string s;
int j;
public:
X() :i{666}, s{&quot;qqq&quot;} { }   // j non è inizializzato
X(int ii) :i{ii} {}         // s è &quot;&quot; e j non è inizializzato
// ...
};</code></pre>
<p>Come può un manutentore sapere se <code>j</code> sia stato deliberatamente lasciato non inizializzato (probabilmente è comunque una cattiva idea) e se è stato intenzionale dare a <code>s</code> il valore di default <code>""</code> in un caso e <code>qqq</code> in un altro (quasi certamente un bug)? Il problema con <code>j</code> (dimenticando di inizializzare un membro) si verifica spesso quando si aggiunge un nuovo membro a una classe esistente.</p>
<h5 id="esempio-89">Esempio</h5>
<pre><code>class X2 {
int i {666};
string s {&quot;qqq&quot;};
int j {0};
public:
X2() = default;        // tutti i membri sono inizializzati coi loro default
X2(int ii) :i{ii} {}   // s e j inizializzati ai loro default
// ...
};</code></pre>
<p><strong>Alternativa</strong>: Possiamo parzialmente avvantaggiarci dei benefici degi argomenti di default nei costruttori, e che non è raro nel codice più vecchio. Tuttavia, questo è meno esplicito, causa l’esistenza di più argomenti da passare, ed è ripetitivo quando ci sono più di un costruttore:</p>
<pre><code>class X3 {   // BAD: non &#39;explicit&#39;, l&#39;argomento che passa l&#39;overhead
int i;
string s;
int j;
public:
X3(int ii = 666, const string&amp; ss = &quot;qqq&quot;, int jj = 0)
:i{ii}, s{ss}, j{jj} { }   // tutti i membri sono inizializzati ai loro default
// ...
};</code></pre>
<h5 id="imposizione-92">Imposizione</h5>
<ul>
<li>(Semplice) Ogni costruttore dovrebbe inizializzare ogni variabile membro (o esplicitamente, tramite una chiamata a un ctor delegating, o con la costruzione di default).</li>
<li>(Semplice) Gli argomenti di default per i costruttori suggeriscono come l’inizializzatore [in-class] possa essere più appropriato.</li>
</ul>
<h3 id="c.49-nei-costruttori-preferire-linizializzazione-alle-assegnazioni"><a name="Rc-initialize"></a>C.49: Nei costruttori preferire l’inizializzazione alle assegnazioni</h3>
<h5 id="motivo-98">Motivo</h5>
<p>Una inizializzazione dichiara esplicitamente che viene eseguita l’inizializzazione, anziché l’assegnazione, e può essere più elegante ed efficiente. Previene gli errori “utilizzo prima della valorizzazione”.</p>
<h5 id="esempio-buono-6">Esempio, buono</h5>
<pre><code>class A {   // Good
string s1;
public:
A(czstring p) : s1{p} { }    // GOOD: costruisce direttamente (e la C -string è dichiarata esplicitamente)
// ...
};</code></pre>
<h5 id="esempio-cattivo-36">Esempio, cattivo</h5>
<pre><code>class B {   // BAD
string s1;
public:
B(const char* p) { s1 = p; }   // BAD: costruttore di default seguito da un&#39;assegnazione
// ...
};

class C {   // BRUTTO, ovvero pessimo
int* p;
public:
C() { cout &lt;&lt; *p; p = new int{10}; }   // uso accidentale prima di inizializzare
// ...
};</code></pre>
<h5 id="esempio-ancora-migliore">Esempio, ancora migliore</h5>
<p>Invece di quei <code>const char*</code>s si potrebbe usare <code>gsl::string_span</code> o (in C++17) <code>std::string_view</code> come <a href="#Rstr-view">un modo più generale di presentare gli argomenti ad una funzione</a>:</p>
<pre><code>class D {   // Good
string s1;
public:
A(string_view v) : s1{v} { }    // GOOD: costruisce direttamente
// ...
};</code></pre>
<h3 id="c.50-usare-una-funzione-factory-se-cè-bisogno-di-un-comportamento-virtuale-durante-linizializzazione"><a name="Rc-factory"></a>C.50: Usare una funzione factory se c’è bisogno di un “comportamento virtuale” durante l’inizializzazione</h3>
<h5 id="motivo-99">Motivo</h5>
<p>Se lo stato di un oggetto di una classe base deve dipendere dallo stato di una parte derivata dell’oggetto, bisogna usare una funzione virtuale (o equivalente) minimizzando la finestra di opportunità per abusare di un oggetto costruito male.</p>
<h5 id="note-127">Note</h5>
<p>Il tipo restituito dalla factory dovrebbe normalmente essere <code>unique_ptr</code> per default; se si condividono alcuni utilizzi, il chiamante può <code>spostare</code> lo <code>unique_ptr</code> in uno <code>shared_ptr</code>. Tuttavia, se l’autore della factory sa che tutti gli usi dell’oggetto restituito saranno condivisi, restituisce <code>shared_ptr</code> ed usa <code>make_shared</code> nel body per risparmiare un’allocazione.</p>
<h5 id="esempio-cattivo-37">Esempio, cattivo</h5>
<pre><code>class B {
public:
B() {
/* ... */
f(); // BAD: C.82: Non richiamare funzioni virtuali in costruttori e distruttori
/* ... */
}

virtual void f() = 0;
};</code></pre>
<h5 id="esempio-90">Esempio</h5>
<pre><code>class B {
protected:
class Token {};

public:
explicit B(Token) { /* ... */ }  // crea un oggetto inizializzato in modo imperfetto
virtual void f() = 0;

template&lt;class T&gt;
static shared_ptr&lt;T&gt; create()    // interfaccia per la creazione di oggetti condivisi
{
auto p = make_shared&lt;T&gt;(typename T::Token{});
p-&gt;post_initialize();
return p;
}

protected:
virtual void post_initialize()   // chiamata subito dopo la costruzione
{ /* ... */ f(); /* ... */ } // GOOD: il dispatch virtuale è sicuro
};

class D : public B {                 // alcune classi derivate
protected:
class Token {};

public:
explicit D(Token) : B{ B::Token{} } {}
void f() override { /* ...  */ };

protected:
template&lt;class T&gt;
friend shared_ptr&lt;T&gt; B::create();
};

shared_ptr&lt;D&gt; p = D::create&lt;D&gt;();  // creazione di un oggetto D</code></pre>
<p><code>make_shared</code> richiede che il costruttore sia pubblico. Richiedendo un <code>Token</code> protetto, il costruttore non può più essere chiamato pubblicamente, quindi evitiamo che un oggetto non completamente costruito se ne vada libero. Fornendo la funzione factory <code>create()</code>, si rende conveniente la costruzione (nel [free store]).</p>
<h5 id="note-128">Note</h5>
<p>Le funzioni factory convenzionali vengono allocate nel [free store], anziché sullo stack o in un oggetto che lo racchiude.</p>
<p><strong>Si veda anche la </strong>: <a href="#Sd-factory">Discussione</a></p>
<h3 id="c.51-utilizzare-i-costruttori-delegating-per-rappresentare-azioni-comuni-a-tutti-i-costruttori-di-una-classe"><a name="Rc-delegating"></a>C.51: Utilizzare i costruttori [delegating] per rappresentare azioni comuni a tutti i costruttori di una classe</h3>
<h5 id="motivo-100">Motivo</h5>
<p>Per evitare ripetizioni e accidentali differenze.</p>
<h5 id="esempio-cattivo-38">Esempio, cattivo</h5>
<pre><code>class Date {   // BAD: ripetitivo
int d;
Month m;
int y;
public:
Date(int dd, Month mm, year yy)
:d{dd}, m{mm}, y{yy}
{ if (!valid(d, m, y)) throw Bad_date{}; }

Date(int dd, Month mm)
:d{dd}, m{mm} y{current_year()}
{ if (!valid(d, m, y)) throw Bad_date{}; }
// ...
};</code></pre>
<p>L’azione comune diventa noiosa da scrivere e può accidentalmente non essere comune.</p>
<h5 id="esempio-91">Esempio</h5>
<pre><code>class Date2 {
int d;
Month m;
int y;
public:
Date2(int dd, Month mm, year yy)
:d{dd}, m{mm}, y{yy}
{ if (!valid(d, m, y)) throw Bad_date{}; }

Date2(int dd, Month mm)
:Date2{dd, mm, current_year()} {}
// ...
};</code></pre>
<p><strong>Si veda anche</strong>: se l’“azione ripetuta” è una semplice inizializzazione, si consideri <a href="#Rc-in-class-initializer">un inizializzatore [in-class] del membro</a>.</p>
<h5 id="imposizione-93">Imposizione</h5>
<p>(Moderato) Cercare parti di costruttori simili</p>
<h3 id="c.52-usare-i-costruttori-ereditati-per-importare-i-costruttori-in-una-classe-derivata-che-non-necessita-di-un-ulteriore-inizializzazione"><a name="Rc-inheriting"></a>C.52: Usare i costruttori ereditati per importare i costruttori in una classe derivata che non necessita di un ulteriore inizializzazione</h3>
<h5 id="motivo-101">Motivo</h5>
<p>Se sono necessari quei costruttori per una classe derivata, la loro re-implementazione è noiosa e soggetta ad errori.</p>
<h5 id="esempio-92">Esempio</h5>
<p><code>std::vector</code> ha molti costruttori complicati, quindi se si vuole il proprio <code>vector</code>, non lo si deve re-implementare:</p>
<pre><code>class Rec {
// ... dati e molti bei costruttori ...
};

class Oper : public Rec {
using Rec::Rec;
// ... nessun dato membro ...
// ... tante belle funzioni utili ...
};</code></pre>
<h5 id="esempio-cattivo-39">Esempio, cattivo</h5>
<pre><code>struct Rec2 : public Rec {
int x;
using Rec::Rec;
};

Rec2 r {&quot;foo&quot;, 7};
int val = r.x;   // non inizializzato</code></pre>
<h5 id="imposizione-94">Imposizione</h5>
<p>Assicurarsi che ogni membro della classe derivata sia inizializzato.</p>
<h2 id="c.copy-copia-e-spostamento"><a name="SS-copy"></a>C.copy: Copia e spostamento</h2>
<p>I tipi di valori dovrebbero generalmente essere copiabili, ma non le interfacce in una gerarchia di classi. Gli handle delle risorse possono o meno essere copiabili. I tipi possono essere definiti per lo spostamento per motivi logici o prestazionali.</p>
<h3 id="c.60-creare-le-assegnazioni-di-copia-non-virtuali-prendere-il-parametro-con-const-e-restiruire-con-non-const"><a name="Rc-copy-assignment"></a>C.60: Creare le assegnazioni di copia non-<code>virtuali</code>, prendere il parametro con <code>const&amp;</code>, e restiruire con non-<code>const&amp;</code></h3>
<h5 id="motivo-102">Motivo</h5>
<p>È semplice ed efficiente. Se si vuole ottimizzare per gli rvalue, si fornisce un overload che prende un <code>&amp;&amp;</code> (cfr. <a href="#Rf-consume">F.18</a>).</p>
<h5 id="esempio-93">Esempio</h5>
<pre><code>class Foo {
public:
Foo&amp; operator=(const Foo&amp; x)
{
// GOOD: non è necessario verificare l&#39;auto-assegnazione (prestazioni a parte)
auto tmp = x;
swap(tmp); // cfr. C.83
return *this;
}
// ...
};

Foo a;
Foo b;
Foo f();

a = b;    // assegna un lvalue: copia
a = f();  // assegna un rvalue: potenzialmente uno spostamento</code></pre>
<h5 id="note-129">Note</h5>
<p>La tecnica di implementazione dello <code>swap</code> offre la <a href="#Abrahams01">garanzia forte</a>.</p>
<h5 id="esempio-94">Esempio</h5>
<p>Cosa succede se si possono avere prestazioni superiori non creando una copia temporanea? Si consideri un semplice <code>Vector</code> destinato ad un dominio dove è comune l’assegnazione di <code>Vector</code> grandi e delle stesse dimensioni. In questo caso, la copia degli elementi implicita nella tecnica dell’implementazione dello <code>swap</code> potrebbe aumentare il costo di un ordine di grandezza:</p>
<pre><code>template&lt;typename T&gt;
class Vector {
public:
Vector&amp; operator=(const Vector&amp;);
// ...
private:
T* elem;
int sz;
};

Vector&amp; Vector::operator=(const Vector&amp; a)
{
if (a.sz &gt; sz) {
// ... usa la tecnica dello swap, non è migliorabile ...
return *this;
}
// ... copia sz elementi da *a.elem a elem ...
if (a.sz &lt; sz) {
// ... distrugge gli elementi superflui in *this ed aggiusta la dimensione ...
}
return *this;
}</code></pre>
<p>Scrivendo direttamente negli elementi target, si otterrà solo<a href="#Abrahams01">la garanzia di base</a> anziché la garanzia forte offerta dalla tecnica dello <code>swap</code>. Attenzione alle <a href="#Rc-copy-self">auto-assegnazioni</a>.</p>
<p><strong>Alternative</strong>: Se si ritiene di aver bisogno di un operatore di assegnazione <code>virtuale</code>, e si capisce perché è profondamente problematico, non lo si chiami <code>operator=</code>. Chiamare la funzione come <code>virtual void assign(const Foo&amp;)</code>. Cfr. <a href="#Rc-copy-virtual">costruttore copia contro <code>clone()</code></a>.</p>
<h5 id="imposizione-95">Imposizione</h5>
<ul>
<li>(Semplice) Un operatore di assegnazione non dovrebbe essere virtuale. Questo è un punto oscuro!</li>
<li>(Semplice) Un operatore di assegnazione dovrebbe restituire <code>T&amp;</code> per abilitare il concatenamento, non alternative come <code>const T&amp;</code> che interferisce con la componibilità e l’inseribilità degli oggetti nei contenitori.</li>
<li>(Moderato) Un operatore di assegnazione dovrebbe (implicitamente o esplicitamente) invocare tutti gli operatori di assegnazione base e membri. Si osservi il distruttore per determinare se il tipo ha la semantica del puntatore o quella del valore.</li>
</ul>
<h3 id="c.61-unoperazione-di-copia-dovrebbe-copiare"><a name="Rc-copy-semantic"></a>C.61: Un’operazione di copia dovrebbe copiare</h3>
<h5 id="motivo-103">Motivo</h5>
<p>Questa è la semantica generalmente assunta. Dopo <code>x = y</code>, si dovrebbe avere <code>x == y</code>. Dopo una copia <code>x</code> e <code>y</code> possono essere oggetti indipendenti (semantica del valore, come funzionano i tipi nativi non-puntatori e i tipi della libreria standard) o riferirsi a oggetti condivisi (semantica dei puntatori, come funzionano i puntatori).</p>
<h5 id="esempio-95">Esempio</h5>
<pre><code>class X {   // OK: semantica del valore
public:
X();
X(const X&amp;);     // copy X
void modify();   // cambia il valore di X
// ...
~X() { delete[] p; }
private:
T* p;
int sz;
};

bool operator==(const X&amp; a, const X&amp; b)
{
return a.sz == b.sz &amp;&amp; equal(a.p, a.p + a.sz, b.p, b.p + b.sz);
}

X::X(const X&amp; a)
:p{new T[a.sz]}, sz{a.sz}
{
copy(a.p, a.p + sz, p);
}

X x;
X y = x;
if (x != y) throw Bad{};
x.modify();
if (x == y) throw Bad{};   // presuppone la semantica del valore</code></pre>
<h5 id="esempio-96">Esempio</h5>
<pre><code>class X2 {  // OK: semantica del puntatore
public:
X2();
X2(const X2&amp;) = default; // copia superficiale
~X2() = default;
void modify();          // modifica il valore puntato
// ...
private:
T* p;
int sz;
};

bool operator==(const X2&amp; a, const X2&amp; b)
{
return a.sz == b.sz &amp;&amp; a.p == b.p;
}

X2 x;
X2 y = x;
if (x != y) throw Bad{};
x.modify();
if (x != y) throw Bad{};  // presuppone la semantica del puntatore</code></pre>
<h5 id="note-130">Note</h5>
<p>Preferire la semantica del valore a meno che non si stia costruendo uno “smart pointer”. La semantica del valore è la più semplice su cui ragionare ed è quella che si aspettano le strutture della libreria standard.</p>
<h5 id="imposizione-96">Imposizione</h5>
<p>(Non imponibile)</p>
<h3 id="c.62-rendere-lassegnazione-di-copia-sicura-per-lauto-assegnazione"><a name="Rc-copy-self"></a>C.62: Rendere l’assegnazione di copia sicura per l’auto-assegnazione</h3>
<h5 id="motivo-104">Motivo</h5>
<p>Se <code>x = x</code> modifica il valore di <code>x</code>, si resterà sorpresi ed avverranno brutti errori (spesso anche i leak).</p>
<h5 id="esempio-97">Esempio</h5>
<p>I contenitori della libreria standard gestiscono l’auto-assegnazione con eleganza ed efficienza:</p>
<pre><code>std::vector&lt;int&gt; v = {3, 1, 4, 1, 5, 9};
v = v;
// il valore di v resta {3, 1, 4, 1, 5, 9}</code></pre>
<h5 id="note-131">Note</h5>
<p>L’assegnazione di default generata dai membri che gestiscono correttamente l’auto-assegnazione gestisce correttamente l’auto-assegnazione.</p>
<pre><code>struct Bar {
vector&lt;pair&lt;int, int&gt;&gt; v;
map&lt;string, int&gt; m;
string s;
};

Bar b;
// ...
b = b;   // corretto ed efficiente</code></pre>
<h5 id="note-132">Note</h5>
<p>È possibile gestire l’auto-assegnazione testandola esplicitamente, ma spesso è più rapido e più elegante farlo senza un test (p.es., <a href="#Rc-swap">utilizzando <code>swap</code></a>).</p>
<pre><code>class Foo {
string s;
int i;
public:
Foo&amp; operator=(const Foo&amp; a);
// ...
};

Foo&amp; Foo::operator=(const Foo&amp; a)   // OK, ma c&#39;è un costo
{
if (this == &amp;a) return *this;
s = a.s;
i = a.i;
return *this;
}</code></pre>
<p>Questo è ovviamente sicuro e apparentemente efficiente. Tuttavia, cosa succede se facciamo un auto-assegnazione per un milione di assegnazioni? Questo ha a che fare con un milione di test ridondanti (ma dato che la risposta è essenzialmente la stessa, il predittore del branch [branch predictor] del computer indovinerà quasi sempre). Si consideri:</p>
<pre><code>Foo&amp; Foo::operator=(const Foo&amp; a)   // più semplice e forse molto meglio
{
s = a.s;
i = a.i;
return *this;
}</code></pre>
<p><code>std::string</code> è sicuro per l’auto-assegnazione così come lo sono gli <code>int</code>. Tutto il costo è sostenuto dal (raro) caso dell’auto-assegnazione.</p>
<h5 id="imposizione-97">Imposizione</h5>
<p>(Semplice) Gli operatori di assegnazione non devono avere lo schema <code>if (this == &amp;a) return *this;</code> ???</p>
<h3 id="c.63-rendere-lassegnazione-di-spostamento-move-non-virtual-prendere-il-parametro-con-e-restituire-con-non-const"><a name="Rc-move-assignment"></a>C.63: Rendere l’assegnazione di spostamento [move] non-<code>virtual</code>, prendere il parametro con <code>&amp;&amp;</code>, e restituire con non-<code>const &amp;</code></h3>
<h5 id="motivo-105">Motivo</h5>
<p>È semplice ed efficiente.</p>
<p><strong>Cfr.</strong>: <a href="#Rc-copy-assignment">La regola per l’assegnazione-copia</a>.</p>
<h5 id="imposizione-98">Imposizione</h5>
<p>Equivalente a quanto fatto per l’<a href="#Rc-copy-assignment">assegnazione-copia</a>.</p>
<ul>
<li>(Semplice) Un operatore di assegnazione non dovrebbe essere virtuale. Questo è un punto oscuro!</li>
<li>(Semplice) Un operatore di assegnazione dovrebbe restituire <code>T&amp;</code> per abilitare il concatenamento, non alternative come <code>const T&amp;</code> che interferisce con la componibilità e l’inseribilità degli oggetti nei contenitori.</li>
<li>(Moderato) Un operatore di assegnazione di spostamento dovrebbe (implicitamente o esplicitamente) invocare tutti gli operatori di assegnazione di spostamento base e membri.</li>
</ul>
<h3 id="c.64-unoperazione-di-move-dovrebbe-spostare-e-lasciare-il-sorgente-in-uno-stato-valido"><a name="Rc-move-semantic"></a>C.64: Un’operazione di [move] dovrebbe spostare e lasciare il sorgente in uno stato valido</h3>
<h5 id="motivo-106">Motivo</h5>
<p>Questa è la semantica generalmente assunta. Dopo <code>y = std::move(x)</code> il valore di <code>y</code> dovrebbe essere il valore che aveva <code>x</code> e <code>x</code> dovrebbe essere in uno stato valido.</p>
<h5 id="esempio-98">Esempio</h5>
<pre><code>template&lt;typename T&gt;
class X {   // OK: semantica del valore
public:
X();
X(X&amp;&amp; a) noexcept;  // sposta X
void modify();     // cambia il valore di X
// ...
~X() { delete[] p; }
private:
T* p;
int sz;
};


X::X(X&amp;&amp; a)
:p{a.p}, sz{a.sz}  // ruba la rappresentazione
{
a.p = nullptr;     // setta a &quot;empty&quot;
a.sz = 0;
}

void use()
{
X x{};
// ...
X y = std::move(x);
x = X{};   // OK
} // OK: x può essere distrutto</code></pre>
<h5 id="note-133">Note</h5>
<p>Idealmente, quello rimosso dovrebbe avere il valore di default del tipo. Accertarsene, a meno che non ci sia una ragione eccezionalmente buona per non farlo. Tuttavia, non tutti i tipi hanno un valore di default e per alcuni tipi stabilire il valore di default può risultare costoso. Lo standard richiede solo che l’oggetto da cui si è rimosso il valore possa essere distrutto. Spesso è possibile fare facilmente ed economicamente meglio: La libreria standard presuppone che sia possibile assegnare ad un oggetto da cui si è rimosso il valore. Lasciare sempre l’oggetto da cui si è rimosso il valore in uno stato valido (necessariamente specificato).</p>
<h5 id="note-134">Note</h5>
<p>A meno che non ci sia una ragione eccezionalmente forte per non farlo, fare in modo che <code>x = std::move(y); y = z;</code> funzioni con la semantica convenzionale.</p>
<h5 id="imposizione-99">Imposizione</h5>
<p>(Non imponibile) Cercare le assegnazioni ai membri nell’operazione di spostamento. Se c’è un costruttore di default, confrontare quelle assegnazioni con le inizializzazioni nel costruttore di default.</p>
<h3 id="c.65-rendere-lassegnazione-con-spostamento-sicura-per-lauto-assegnazione"><a name="Rc-move-self"></a>C.65: Rendere l’assegnazione con spostamento sicura per l’auto-assegnazione</h3>
<h5 id="motivo-107">Motivo</h5>
<p>Se <code>x = x</code> cambia il valore di <code>x</code>, si resterà sorpresi ed avverranno brutti errori. Tuttavia, solitamente la gente non scrive un’auto-assegnazione che si trasforma in uno spostamento, ma può accadere. Tuttavia, <code>std::swap</code> è implementato usando le operazioni di spostamento quindi se accidentalmente si fa uno <code>swap(a, b)</code> dove <code>a</code> e <code>b</code> si riferiscono allo stesso oggetto, il non riuscire a gestire l’auto-assegnazione potrebbe essere un serio e subdolo errore.</p>
<h5 id="esempio-99">Esempio</h5>
<pre><code>class Foo {
string s;
int i;
public:
Foo&amp; operator=(Foo&amp;&amp; a);
// ...
};

Foo&amp; Foo::operator=(Foo&amp;&amp; a) noexcept  // OK, ma ha un costo
{
if (this == &amp;a) return *this;  // questa riga è ridondante
s = std::move(a.s);
i = a.i;
return *this;
}</code></pre>
<p>L’obiezione dell’uno-su-un-milione rispetto al test <code>if (this == &amp;a) return *this;</code> della discussione sull’<a href="#Rc-copy-self">auto-assegnazione</a> è ancor più rilevante per l’auto-spostamento.</p>
<h5 id="note-135">Note</h5>
<p>Non è noto un modo generale per evitare un test <code>if (this == &amp;a) return *this;</code> per un assegnazione con spostamento e si ottiene ancora una risposta corretta (ovvero, dopo <code>x = x</code> il valore di <code>x</code> resta invariato).</p>
<h5 id="note-136">Note</h5>
<p>Lo standard ISO garantisce solo uno stato “valido ma non specificato” per i contenitori della standard-library. Sembra che questo non sia stato un problema nei 10 anni di utilizzo sperimentale ed in produzione. Si prega di contattare gli editori se si trova un contro esempio. La regola qui è più cautelativa ed insiste sulla completa sicurezza.</p>
<h5 id="esempio-100">Esempio</h5>
<p>Ecco un modo per spostare un puntatore senza un test (lo si immagini come codice nell’implementazione di un assegnazione con spostamento):</p>
<pre><code>// sposta da un other.ptr a this-&gt;ptr
T* temp = other.ptr;
other.ptr = nullptr;
delete ptr;
ptr = temp;</code></pre>
<h5 id="imposizione-100">Imposizione</h5>
<ul>
<li>(Moderato) Nel caso dell’auto-assegnazione, un operatore di assegnazione con spostamento non deve lasciare l’oggetto che aveva i membri puntatori che sono stati cancellati con <code>delete</code> o settati a <code>nullptr</code>.</li>
<li>(Non applicabile) Si veda l’uso dei tipi di contenitori nella standard-library (compreso <code>string</code>) e si considerino sicuri per gli usi ordinari (non life-critical).</li>
</ul>
<h3 id="c.66-creare-le-operazioni-di-move-come-noexcept"><a name="Rc-move-noexcept"></a>C.66: Creare le operazioni di [move] come <code>noexcept</code></h3>
<h5 id="motivo-108">Motivo</h5>
<p>Uno spostamento che va in errore [throwing] va contro le ragionevoli assunzioni della maggior parte delle persone. Uno spostamento [non-throwing] verrà usato in modo più efficiente dalla standard-library e dalle strutture del linguaggio.</p>
<h5 id="esempio-101">Esempio</h5>
<pre><code>template&lt;typename T&gt;
class Vector {
public:
Vector(Vector&amp;&amp; a) noexcept :elem{a.elem}, sz{a.sz} { a.sz = 0; a.elem = nullptr; }
Vector&amp; operator=(Vector&amp;&amp; a) noexcept { elem = a.elem; sz = a.sz; a.sz = 0; a.elem = nullptr; }
// ...
private:
T* elem;
int sz;
};</code></pre>
<p>Queste operazioni non generano errori [throw].</p>
<h5 id="esempio-cattivo-40">Esempio, cattivo</h5>
<pre><code>template&lt;typename T&gt;
class Vector2 {
public:
Vector2(Vector2&amp;&amp; a) { *this = a; }             // usa semplicemente la copia
Vector2&amp; operator=(Vector2&amp;&amp; a) { *this = a; }  // usa semplicemente la copia
// ...
private:
T* elem;
int sz;
};</code></pre>
<p>Questo <code>Vector2</code> non è solo inefficiente, ma dato che la copia di un vettore richiede un’allocazione, può andare in errore [throw].</p>
<h5 id="imposizione-101">Imposizione</h5>
<p>(Semplice) Un’operazione di spostamento deve essere contrassegnata con <code>noexcept</code>.</p>
<h3 id="c.67-una-classe-polimorfica-dovrebbe-sopprimere-la-copia"><a name="Rc-copy-virtual"></a>C.67: Una classe polimorfica dovrebbe sopprimere la copia</h3>
<h5 id="motivo-109">Motivo</h5>
<p>Una <em>classe polimorfica</em> è una classe che definisce o eredita almeno una funzione virtuale. È probabile che verrà usata come classe base per altre classi derivate con un comportamento polimorfico. Se viene accidentalmente passata per valore, col costruttore copia e le assegnazioni generate implicitamente, si rischia di ‘spaccare’: verrà copiata solo la porzione base dell’oggetto derivato, e il comportamento polimorfico risulterà corrotto.</p>
<h5 id="esempio-cattivo-41">Esempio, cattivo</h5>
<pre><code>class B { // BAD: la classe base polimorfica non sopprime la copia
public:
virtual char m() { return &#39;B&#39;; }
// ... nulla sulle operazioni di copia, quindi si usa il default ...
};

class D : public B {
public:
char m() override { return &#39;D&#39;; }
// ...
};

void f(B&amp; b) {
auto b2 = b; // oops, spaccatura dell&#39;oggetto; b2.m() restituirà &#39;B&#39;
}

D d;
f(d);</code></pre>
<h5 id="esempio-102">Esempio</h5>
<pre><code>class B { // GOOD: la classe polimorfica sopprime la copia
public:
B(const B&amp;) = delete;
B&amp; operator=(const B&amp;) = delete;
virtual char m() { return &#39;B&#39;; }
// ...
};

class D : public B {
public:
char m() override { return &#39;D&#39;; }
// ...
};

void f(B&amp; b) {
auto b2 = b; // ok,  il compilatore rileverà la copia involontaria e protesterà
}

D d;
f(d);</code></pre>
<h5 id="note-137">Note</h5>
<p>Se è necessario creare copie complete [deep] di oggetti polimorfici, si usano le funzioni <code>clone()</code>: cfr. <a href="#Rh-copy">C.130</a>.</p>
<h5 id="eccezione-22">Eccezione</h5>
<p>Le classi che rappresentano oggetti di eccezione devono sia essere polimorfiche che costruibili-per-copia.</p>
<h5 id="imposizione-102">Imposizione</h5>
<ul>
<li>Segnalauna classe polimorfica con un’operazione di copia non-cancellata.</li>
<li>Segnala un’assegnazione di oggetti di classi polimorfiche.</li>
</ul>
<h2 id="c.other-altre-regole-delle-operazioni-di-default">C.other: Altre regole delle operazioni di default</h2>
<p>Oltre alle operazioni per le quali il linguaggio offre implementazioni di default, ci sono alcune operazioni che sono così fondamentali che necessitano di regole per la loro definizione: confronti, <code>swap</code>, e <code>hash</code>.</p>
<h3 id="c.80-utilizzare-default-se-si-deve-essere-espliciti-sulluso-della-semantica-di-default"><a name="Rc-eqdefault"></a>C.80: Utilizzare <code>=default</code> se si deve essere espliciti sull’uso della semantica di default</h3>
<h5 id="motivo-110">Motivo</h5>
<p>È più probabile che il compilatore ottenga la giusta semantica di default e non è possibile implementare queste funzioni meglio del compilatore.</p>
<h5 id="esempio-103">Esempio</h5>
<pre><code>class Tracer {
string message;
public:
Tracer(const string&amp; m) : message{m} { cerr &lt;&lt; &quot;ingresso &quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; }
~Tracer() { cerr &lt;&lt; &quot;uscita &quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; }

Tracer(const Tracer&amp;) = default;
Tracer&amp; operator=(const Tracer&amp;) = default;
Tracer(Tracer&amp;&amp;) = default;
Tracer&amp; operator=(Tracer&amp;&amp;) = default;
};</code></pre>
<p>Dato che si è definito il distruttore, si devono definire le operazioni di copia e spostamento. Il <code>= default</code> è il modo migliore e più semplice per farlo.</p>
<h5 id="esempio-cattivo-42">Esempio, cattivo</h5>
<pre><code>class Tracer2 {
string message;
public:
Tracer2(const string&amp; m) : message{m} { cerr &lt;&lt; &quot;ingresso &quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; }
~Tracer2() { cerr &lt;&lt; &quot;uscita &quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; }

Tracer2(const Tracer2&amp; a) : message{a.message} {}
Tracer2&amp; operator=(const Tracer2&amp; a) { message = a.message; return *this; }
Tracer2(Tracer2&amp;&amp; a) :message{a.message} {}
Tracer2&amp; operator=(Tracer2&amp;&amp; a) { message = a.message; return *this; }
};</code></pre>
<p>Scrivere il codice per le operazioni di copia e spostamento è prolisso, noioso e soggetto ad errori. Un compilatore lo fa meglio.</p>
<h5 id="imposizione-103">Imposizione</h5>
<p>(Moderato) Il codice di un’operazione speciale non dovrebbe avere la stessa accessibilità e semantica della versione generata dal compilatore, perché sarebbe ridondante</p>
<h3 id="c.81-utilizzare-delete-quando-si-vuol-disabilitare-il-comportamento-di-default-senza-volere-unalternativa"><a name="Rc-delete"></a>C.81: Utilizzare <code>=delete</code> quando si vuol disabilitare il comportamento di default (senza volere un’alternativa)</h3>
<h5 id="motivo-111">Motivo</h5>
<p>In alcuni casi, un’operazione di default non è desiderabile.</p>
<h5 id="esempio-104">Esempio</h5>
<pre><code>class Immortal {
public:
~Immortal() = delete;   // non consente la distruzione
// ...
};

void use()
{
Immortal ugh;   // errore: non può essere distrutto
Immortal* p = new Immortal{};
delete p;       // errore: non può distruggere *p
}</code></pre>
<h5 id="esempio-105">Esempio</h5>
<p>Un <code>unique_ptr</code> può essere spostato, ma non copiato. Per farlo, ne vengono cancellate le operazioni di copia. Per evitare la copia è necessario il <code>=delete</code> accanto alle sue operazioni di copia dagli lvalue:</p>
<pre><code>template &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr {
public:
// ...
constexpr unique_ptr() noexcept;
explicit unique_ptr(pointer p) noexcept;
// ...
unique_ptr(unique_ptr&amp;&amp; u) noexcept;   // costruttore con spostamento
// ...
unique_ptr(const unique_ptr&amp;) = delete; // disabilita la copia da lvalue
// ...
};

unique_ptr&lt;int&gt; make();   // crea &quot;qualcosa&quot; e lo restituisce per spostamento

void f()
{
unique_ptr&lt;int&gt; pi {};
auto pi2 {pi};      // errore: nessun costruttore con spostamento da lvalue
auto pi3 {make()};  // OK, sposta: il risultato di make() è un rvalue
}</code></pre>
<p>Si noti che le funzioni eliminate devono essere pubbliche.</p>
<h5 id="imposizione-104">Imposizione</h5>
<p>L’eliminazione di un’operazione di default è (dovrebbe essere) basata sulla semantica desiderata della classe. Considerare tali classi sospette, ma mantenere un “elenco positivo” di classi dove un umano ha affermato che la semantica è corretta.</p>
<h3 id="c.82-non-richiamare-funzioni-virtuali-nei-costruttori-e-nei-distruttori"><a name="Rc-ctor-virtual"></a>C.82: Non richiamare funzioni virtuali nei costruttori e nei distruttori</h3>
<h5 id="motivo-112">Motivo</h5>
<p>La funzione chiamata sarà quella dell’oggetto appena costruito, anziché una funzione eventualmente sovrapposta [overriding] in una classe derivata. Ciò può risultare molto confuso. Peggio ancora, una chiamata diretta o indiretta ad una funzione virtuale pura non implementata da un costruttore o da un distruttore provoca un comportamento indefinito.</p>
<h5 id="esempio-cattivo-43">Esempio, cattivo</h5>
<pre><code>class Base {
public:
virtual void f() = 0;   // non implementata
virtual void g();       // implementata con la versione Base
virtual void h();       // implementata con la versione Base
virtual ~Base();        // implementata con la versione Base
};

class Derived : public Base {
public:
void g() override;   // fornisce l&#39;implementazione derivata (Derived)
void h() final;      // fornisce l&#39;implementazione derivata (Derived)

Derived()
{
// BAD: tenta di chiamare una funzione virtuale non implementata
f();

// BAD: chiamerà Derived::g, non dirotterà verso quella virtuale
g();

// GOOD: dichiara esplicitamente l&#39;intenzione di chiamare solo la versione visibile
Derived::g();

// ok, non serve una qualificazione, h è finale
h();
}
};</code></pre>
<p>Si noti che chiamare una specifica funzione qualificata esplicitamente non è una chiamata virtuale anche se la funzione è <code>virtual</code>e.</p>
<p><strong>Si vedano anche le</strong> <a href="#Rc-factory">funzioni factory</a> per come ottenere l’effetto di una chiamata a una funzione di una classe derivata senza rischiare il comportamento indefinito.</p>
<h5 id="note-138">Note</h5>
<p>Non c’è nulla di intrinsecamente sbagliato nel chiamare funzioni virtuali da costruttori o distruttori. La semantica di tali chiamate è “type safe”. Tuttavia, l’esperienza dimostra che tali chiamate sono raramente necessarie, confondono facilmente i manutentori e diventano una fonte di errori quando vengono utilizzate dai principianti.</p>
<h5 id="imposizione-105">Imposizione</h5>
<ul>
<li>Segnalare le chiamate a funzioni virtuali dai costruttori e dai distruttori.</li>
</ul>
<h3 id="c.83-per-i-tipi-value-like-si-preveda-di-fornire-una-funzione-di-swap-di-tipo-noexcept"><a name="Rc-swap"></a>C.83: Per i tipi [value-like], si preveda di fornire una funzione di ‘swap’ di tipo <code>noexcept</code></h3>
<h5 id="motivo-113">Motivo</h5>
<p>Uno <code>swap</code> può essere utile per implementare una serie di idiomi, da un sicuro spostamento di oggetti alla semplice implementazione di un’assegnazione, al fornire una funzione di ‘commit’ garantita che consenta di avere un codice chiamante fortemente esente da errori. Si consideri l’uso di swap per implementare l’assegnazione per copia in termini di costruzione-copia. Si vedano anche <a href="#Re-never-fail">distruttori, de-allocazione e swap non devono mai fallire</a>.</p>
<h5 id="esempio-buono-7">Esempio, buono</h5>
<pre><code>class Foo {
public:
void swap(Foo&amp; rhs) noexcept
{
m1.swap(rhs.m1);
std::swap(m2, rhs.m2);
}
private:
Bar m1;
int m2;
};</code></pre>
<p>Fornire una funzione <code>swap</code> non-membro nello stesso namespace per il proprio tipo, per la comodità dei chiamanti.</p>
<pre><code>void swap(Foo&amp; a, Foo&amp; b)
{
a.swap(b);
}</code></pre>
<h5 id="imposizione-106">Imposizione</h5>
<ul>
<li>(Semplice) Una classe senza funzioni virtuali dovrebbe avere una funzione membro <code>swap</code> dichiarata.</li>
<li>(Semplice) Quando una classe ha una funzione membro <code>swap</code>, dovrebbe essere dichiarata <code>noexcept</code>.</li>
</ul>
<h3 id="c.84-una-funzione-swap-non-può-fallire"><a name="Rc-swap-fail"></a>C.84: Una funzione <code>swap</code> non può fallire</h3>
<h5 id="motivo-114">Motivo</h5>
<p><code>swap</code> è largamente usata nei modi che si presumono non falliscano mai e i programmi non possono essere facilmente scritti per funzionare correttamente in presenza di una <code>swap</code> non riuscita. I contenitori e gli algoritmi della standard-library non funzioneranno correttamente se uno [swap] di un tipo di elemento fallisce.</p>
<h5 id="esempio-cattivo-44">Esempio, cattivo</h5>
<pre><code>void swap(My_vector&amp; x, My_vector&amp; y)
{
auto tmp = x;   // copia gli elementi
x = y;
y = tmp;
}</code></pre>
<p>Questo non è soltanto lento, ma se per gli elementi avviene un’allocazione di memoria in <code>tmp</code>, questo <code>swap</code> può fallire e farebbe fallire gli algoritmi STL se venissero usati.</p>
<h5 id="imposizione-107">Imposizione</h5>
<p>(Semplice) Quando una classe ha una funzione membro <code>swap</code>, dovrebbe essere dichiarata <code>noexcept</code>.</p>
<h3 id="c.85-rendere-lo-swap-noexcept"><a name="Rc-swap-noexcept"></a>C.85: Rendere lo <code>swap</code> <code>noexcept</code></h3>
<h5 id="motivo-115">Motivo</h5>
<p><a href="#Rc-swap-fail">Uno <code>swap</code> non può fallire</a>. Se uno <code>swap</code> tenta di uscire con un’eccezione, si tratta di un errore di progettazione ed è meglio che il programma termini.</p>
<h5 id="imposizione-108">Imposizione</h5>
<p>(Semplice) Quando una classe ha una funzione membro <code>swap</code>, dovrebbe essere dichiarata <code>noexcept</code>.</p>
<h3 id="c.86-creare-lo-simmetrico-rispetto-ai-tipi-di-operandi-e-noexcept"><a name="Rc-eq"></a>C.86: Creare lo <code>==</code> simmetrico rispetto ai tipi di operandi e <code>noexcept</code></h3>
<h5 id="motivo-116">Motivo</h5>
<p>Il trattamento asimmetrico degli operandi è inatteso e fonte di errori dove sono possibili delle conversioni. <code>==</code> è un’operazione fondamentale e i programmatori dovrebbero essere in grado di usarla senza paura di fallire.</p>
<h5 id="esempio-106">Esempio</h5>
<pre><code>struct X {
string name;
int number;
};

bool operator==(const X&amp; a, const X&amp; b) noexcept {
return a.name == b.name &amp;&amp; a.number == b.number;
}</code></pre>
<h5 id="esempio-cattivo-45">Esempio, cattivo</h5>
<pre><code>class B {
string name;
int number;
bool operator==(const B&amp; a) const {
return name == a.name &amp;&amp; number == a.number;
}
// ...
};</code></pre>
<p>Il confronto di <code>B</code> accetta le conversioni per il secondo operando, ma non per il primo.</p>
<h5 id="note-139">Note</h5>
<p>Se una classe è in uno stato di errore, come, per il <code>double</code>, il <code>NaN</code> , c’è la tentazione di fare un confronto con lo stato erroneo. L’alternativa consiste nel fare in modo che due stati erronei risultino uguali, mentre il confronto tra uno stato valido ed uno erroneo risulti falso.</p>
<h5 id="note-140">Note</h5>
<p>Questa regola si applica a tutti i soliti operatori di confronto: <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, e <code>&gt;=</code>.</p>
<h5 id="imposizione-109">Imposizione</h5>
<ul>
<li>Segnalare un <code>operator==()</code> per cui i tipi degli argomenti differiscano; lo stesso per gli altri operatori di confronto: <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, e <code>&gt;=</code>.</li>
<li>Segnalare i <code>operator==()</code> membri; lo stesso per gli altri operatori di confronto: <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, e <code>&gt;=</code>.</li>
</ul>
<h3 id="c.87-attenzione-a-sulle-classi-base"><a name="Rc-eq-base"></a>C.87: Attenzione a <code>==</code> sulle classi base</h3>
<h5 id="motivo-117">Motivo</h5>
<p>È davvero difficile scrivere un infallibile e utile <code>==</code> per una gerarchia.</p>
<h5 id="esempio-cattivo-46">Esempio, cattivo</h5>
<pre><code>class B {
string name;
int number;
virtual bool operator==(const B&amp; a) const
{
return name == a.name &amp;&amp; number == a.number;
}
// ...
};</code></pre>
<p>Il confronto di <code>B</code> accetta le conversioni per il secondo operando, ma non per il primo.</p>
<pre><code>class D :B {
char character;
virtual bool operator==(const D&amp; a) const
{
return name == a.name &amp;&amp; number == a.number &amp;&amp; character == a.character;
}
// ...
};

B b = ...
D d = ...
b == d;    // confronta name e number, ignora il character di d
d == b;    // error: no == defined
D d2;
d == d2;   // confronta name, number, e character
B&amp; b2 = d2;
b2 == d;   // confronta name e number, ignora i character di d2 e di d</code></pre>
<p>Naturalmente ci sono modi per far funzionare <code>==</code> in una gerarchia, ma gli approcci improvvisati non sono scalabili</p>
<h5 id="note-141">Note</h5>
<p>Questa regola si applica a tutti i soliti operatori di confronto: <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, e <code>&gt;=</code>.</p>
<h5 id="imposizione-110">Imposizione</h5>
<ul>
<li>Segnala un <code>operator==()</code> virtuale; lo stesso per altri operatori di confronto: <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, e <code>&gt;=</code>.</li>
</ul>
<h3 id="c.89-rendere-un-hash-noexcept"><a name="Rc-hash"></a>C.89: Rendere un <code>hash</code> <code>noexcept</code></h3>
<h5 id="motivo-118">Motivo</h5>
<p>Gli utenti dei contenitori che usano l’hash lo fanno indirettamente e non si aspettano una semplice eccezione. È un requisito della standard-library.</p>
<h5 id="esempio-cattivo-47">Esempio, cattivo</h5>
<pre><code>template&lt;&gt;
struct hash&lt;My_type&gt; {  // una specializzazione di cattiva hash errata
using result_type = size_t;
using argument_type = My_type;

size_t operator() (const My_type &amp; x) const
{
size_t xs = x.s.size();
if (xs &lt; 4) throw Bad_My_type{};    // &quot;Nessuno si aspetta l&#39;inquisizione spagnola!&quot;
return hash&lt;size_t&gt;()(x.s.size()) ^ trim(x.s);
}
};

int main()
{
unordered_map&lt;My_type, int&gt; m;
My_type mt{ &quot;asdfg&quot; };
m[mt] = 7;
cout &lt;&lt; m[My_type{ &quot;asdfg&quot; }] &lt;&lt; &#39;\n&#39;;
}</code></pre>
<p>Se bisogna definire una specializzazione di <code>hash</code>, provare semplicemente a combinare le specializzazioni di <code>hash</code> della libreria standard con <code>^</code> (xor). Ciò tende a funzionare meglio della “intelligenza” per i non-specialisti.</p>
<h5 id="imposizione-111">Imposizione</h5>
<ul>
<li>Segnalare gli <code>hash</code> con eccezioni.</li>
</ul>
<h3 id="c.90-affidarsi-ai-costruttori-e-agli-operatori-di-assegnazione-non-a-memset-né-a-memcpy"><a name="Rc-memset"></a>C.90: Affidarsi ai costruttori e agli operatori di assegnazione, non a <code>memset</code> né a <code>memcpy</code></h3>
<h5 id="motivo-119">Motivo</h5>
<p>Il meccanismo standard del C++ per costruire un’istanza di un tipo consiste nel richiamare il suo costruttore. Come specificato nella linea-guida <a href="#Rc-complete">C.41</a>: uncostruttore dovrebbe creare un oggetto completamente inizializzato. Non dovrebbe essere necessaria alcuna ulteriore inizializzazione, come per <code>memcpy</code>. Un tipo fornirà un costruttore copia e/o un operatore di assegnazione per creare adeguatamente una copia della classe, preservando le invarianti del tipo. Utilizzando memcpy per copiare un tipo non banalmente copiabile ha un comportamento indefinito. Spesso ciò provoca lo slicing, e la corruzione dei dati.</p>
<h5 id="esempio-buono-8">Esempio, buono</h5>
<pre><code>struct base
{
virtual void update() = 0;
std::shared_ptr&lt;int&gt; sp;
};

struct derived : public base
{
void update() override {}
};</code></pre>
<h5 id="esempio-cattivo-48">Esempio, cattivo</h5>
<pre><code>void init(derived&amp; a)
{
memset(&amp;a, 0, sizeof(derived));
}</code></pre>
<p>Questo è [type-unsafe] e sovrascrive la vtable.</p>
<h5 id="esempio-cattivo-49">Esempio, cattivo</h5>
<pre><code>void copy(derived&amp; a, derived&amp; b)
{
memcpy(&amp;a, &amp;b, sizeof(derived));
}</code></pre>
<p>Anche questo è type-unsafe e sovrascrive la vtable.</p>
<h5 id="imposizione-112">Imposizione</h5>
<ul>
<li>Segnalare il passaggio a <code>memset</code> o a <code>memcpy</code> di un tipo non-banalmente-copiabile.</li>
</ul>
<h2 id="c.con-contenitori-ed-altri-handle-di-risorse"><a name="SS-containers"></a>C.con: Contenitori ed altri handle di risorse</h2>
<p>Un contenitore è un oggetto che contiene una sequenza di oggetti di qualche tipo; <code>std::vector</code> è un archetipo di contenitore. Un handle [gestore] di una risorsa è una classe che possiede una risorsa; <code>std::vector</code> è il tipico handle di una risorsa; la sua risorsa è la sua sequenza degli elementi.</p>
<p>Riepilogo delle regole sui contenitori:</p>
<ul>
<li><a href="#Rcon-stl">C.100: Seguire la STL quando si definisce un contenitore</a></li>
<li><a href="#Rcon-val">C.101: Fornire una semantica di valore ad un contenitore</a></li>
<li><a href="#Rcon-move">C.102: Fornire ad un contenitore le operazioni di spostamento</a></li>
<li><a href="#Rcon-init">C.103: Fornire ad un contenitore un costruttore con una lista inizializzatrice</a></li>
<li><a href="#Rcon-empty">C.104: Fornire ad un contenitore un costruttore di default che lo imposti a vuoto</a></li>
<li>???</li>
<li><a href="#Rcon-ptr">C.109: Se un handle di risorsa ha una semantica di puntatore, fornire <code>*</code> e <code>-&gt;</code></a></li>
</ul>
<p><strong>Si vedano anche</strong>: <a href="#S-resource">Risorse</a></p>
<h3 id="c.100-seguire-la-stl-quando-si-definisce-un-contenitore"><a name="Rcon-stl"></a>C.100: Seguire la STL quando si definisce un contenitore</h3>
<h5 id="motivo-120">Motivo</h5>
<p>I contenitori della STL sono familiari alla maggior parte dei programmatori C++ e hanno un design fondamentalmente solido.</p>
<h5 id="note-142">Note</h5>
<p>Esistono, ovviamente, altri stili di progettazione e talvolta si discostano dallo stile della libreria standard, ma in assenza di un solido motivo per differenziarsi, è più semplice e più facile sia per gli implementa che per gli utenti seguire lo standard.</p>
<p>In particolare, <code>std::vector</code> e <code>std::map</code> costituiscono dei modelli utili relativamente semplici.</p>
<h5 id="esempio-107">Esempio</h5>
<pre><code>// semplificato (p.es., senza allocatori):

template&lt;typename T&gt;
class Sorted_vector {
using value_type = T;
// ... tipi di iteratori ...

Sorted_vector() = default;
Sorted_vector(initializer_list&lt;T&gt;);    // costruttore con l&#39;inizializzatore della lista: ordina e memorizza
Sorted_vector(const Sorted_vector&amp;) = default;
Sorted_vector(Sorted_vector&amp;&amp;) = default;
Sorted_vector&amp; operator=(const Sorted_vector&amp;) = default;   // assegnazione di copia
Sorted_vector&amp; operator=(Sorted_vector&amp;&amp;) = default;        // assegnazione di spostamento
~Sorted_vector() = default;

Sorted_vector(const std::vector&lt;T&gt;&amp; v);   // memorizza e ordina
Sorted_vector(std::vector&lt;T&gt;&amp;&amp; v);        // ordina e &quot;ruba la rappresentazione&quot;

const T&amp; operator[](int i) const { return rep[i]; }
// accesso diretto no non-const per preservare l&#39;ordine

void push_back(const T&amp;);   // inserisce nel posto giusto (non necessariamente sul retro)
void push_back(T&amp;&amp;);        // inserisce nel posto giusto (non necessariamente sul retro)

// ... cbegin(), cend() ...
private:
std::vector&lt;T&gt; rep;  // usa uno std::vector per contenere gli elementi
};

template&lt;typename T&gt; bool operator==(const Sorted_vector&lt;T&gt;&amp;, const Sorted_vector&lt;T&gt;&amp;);
template&lt;typename T&gt; bool operator!=(const Sorted_vector&lt;T&gt;&amp;, const Sorted_vector&lt;T&gt;&amp;);
// ...</code></pre>
<p>Qui viene seguito lo stile STL, ma in modo incompleto. Non è raro. Fornire solo le funzionalità che hanno senso per uno specifico contenitore. La chiave consiste nel definire i costruttori convenzionali, le assegnazioni, i distruttori e gli iteratori (come significativi per lo specifico contenitore) con la loro convenzionale semantica. Partendo da questa base, il contenitore può essere espanso secondo le necessità. Qui sono stati aggiunti degli speciali costruttori per <code>std::vector</code>.</p>
<h5 id="imposizione-113">Imposizione</h5>
<p>???</p>
<h3 id="c.101-fornire-una-semantica-di-valore-ad-un-contenitore"><a name="Rcon-val"></a>C.101: Fornire una semantica di valore ad un contenitore</h3>
<h5 id="motivo-121">Motivo</h5>
<p>Gli oggetti regolari sono più semplici da immaginare e gestire di quelli irregolari. Familiarità.</p>
<h5 id="note-143">Note</h5>
<p>Se ha senso, si crea un contenitore <code>Regolare</code> (il concetto). In particolare, ci si assicuri che un oggetto risulti uguale a se stesso da un’operazione di confronto.</p>
<h5 id="esempio-108">Esempio</h5>
<pre><code>void f(const Sorted_vector&lt;string&gt;&amp; v)
{
Sorted_vector&lt;string&gt; v2 {v};
if (v != v2)
cout &lt;&lt; &quot;regole folli!\n&quot;;
// ...
}</code></pre>
<h5 id="imposizione-114">Imposizione</h5>
<p>???</p>
<h3 id="c.102-fornire-ad-un-contenitore-le-operazioni-di-spostamento"><a name="Rcon-move"></a>C.102: Fornire ad un contenitore le operazioni di spostamento</h3>
<h5 id="motivo-122">Motivo</h5>
<p>I contenitori tendono a diventare grandi; senza un costruttore di spostamento ed uno di copia un oggetto può risultare costoso da spostare, inducendo così le persone a passare i puntatori per poi affrontare i problemi di gestione delle risorse.</p>
<h5 id="esempio-109">Esempio</h5>
<pre><code>Sorted_vector&lt;int&gt; read_sorted(istream&amp; is)
{
vector&lt;int&gt; v;
cin &gt;&gt; v;   // si suppone di avere un&#39;operazione di lettura per i vettori
Sorted_vector&lt;int&gt; sv = v;  // ordina
return sv;
}</code></pre>
<p>Un utente può ragionevolmente presumere che il ritorno da un contenitore di tipo standard sia economica.</p>
<h5 id="imposizione-115">Imposizione</h5>
<p>???</p>
<h3 id="c.103-fornire-ad-un-contenitore-un-costruttore-con-una-lista-inizializzatrice"><a name="Rcon-init"></a>C.103: Fornire ad un contenitore un costruttore con una lista inizializzatrice</h3>
<h5 id="motivo-123">Motivo</h5>
<p>Le persone si aspettano di essere in grado di inizializzare un contenitore con un set di valori. Familiarità.</p>
<h5 id="esempio-110">Esempio</h5>
<pre><code>Sorted_vector&lt;int&gt; sv {1, 3, -1, 7, 0, 0}; // Sorted_vector ordina gli elementi in base alle esigenze</code></pre>
<h5 id="imposizione-116">Imposizione</h5>
<p>???</p>
<h3 id="c.104-fornire-ad-un-contenitore-un-costruttore-di-default-che-lo-imposti-a-vuoto"><a name="Rcon-empty"></a>C.104: Fornire ad un contenitore un costruttore di default che lo imposti a vuoto</h3>
<h5 id="motivo-124">Motivo</h5>
<p>Renderlo <code>Regolare</code>.</p>
<h5 id="esempio-111">Esempio</h5>
<pre><code>vector&lt;Sorted_sequence&lt;string&gt;&gt; vs(100);    // 100 Sorted_sequences ciascuna col valore &quot;&quot;</code></pre>
<h5 id="imposizione-117">Imposizione</h5>
<p>???</p>
<h3 id="c.109-se-un-handle-di-risorsa-ha-una-semantica-di-puntatore-fornire-e--"><a name="Rcon-ptr"></a>C.109: Se un handle di risorsa ha una semantica di puntatore, fornire <code>*</code> e <code>-&gt;</code></h3>
<h5 id="motivo-125">Motivo</h5>
<p>Questo è quello che ci si aspetta dai puntatori. Familiarità.</p>
<h5 id="esempio-112">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="imposizione-118">Imposizione</h5>
<p>???</p>
<h2 id="c.lambdas-oggetti-funzione-e-lambda"><a name="SS-lambdas"></a>C.lambdas: Oggetti funzione e lambda</h2>
<p>Un oggetto funzione è un oggetto che fornisce un <code>()</code> [overloaded] in modo che lo si possa chiamare. Un’espressione lambda (colloquialmente spesso abbreviata in “una lambda”) è una notazione per generare un oggetto funzione. Gli oggetti funzione dovrebbero essere economici da copiare (e quindi <a href="#Rf-in">passati per valore</a>).</p>
<p>Sommario:</p>
<ul>
<li><a href="#Rf-capture-vs-overload">F.50: Usare una lambda quando una funzione non va (per acquisire le variabili locali o scrivere una funzione locale)</a></li>
<li><a href="#Rf-reference-capture">F.52: Preferire l’acquisizione per riferimento nelle lambda da usare localmente, compresi quelli passati agli algoritmi</a></li>
<li><a href="#Rf-value-capture">F.53: Evitare l’acquisizione per riferimento nelle lambdas che si non si useranno localmente, compresi quelli restituiti, memorizzati nell’heap o passati da un altro thread</a></li>
<li><a href="#Res-lambda-init">ES.28: Usare le lambda per delle inizializzazioni complesse, specialmente di variabili <code>const</code></a></li>
</ul>
<h2 id="c.hier-gerarchia-di-classi-oop"><a name="SS-hier"></a>C.hier: Gerarchia di classi (OOP)</h2>
<p>Una gerarchia di classi viene costruita per rappresentare (solo) un insieme concetti organizzati gerarchicamente. In genere le classi base fungono da interfacce. Esistono due usi principali delle gerarchie, spesso chiamati ereditarietà dell’implementazione e ereditarietà dell’interfaccia.</p>
<p>Sommario delle regole per le gerarchie di classi:</p>
<ul>
<li><a href="#Rh-domain">C.120: Usare le gerarchie di classi per rappresentare (solo) i concetti con una intrinseca struttura gerarchica</a></li>
<li><a href="#Rh-abstract">C.121: Se una classe base viene usata come interfaccia, crearla come classe astratta pura</a></li>
<li><a href="#Rh-separation">C.122: Usare le classi astratte come interfacce quando è necessaria una completa separazione tra l’interfaccia e l’implementazione</a></li>
</ul>
<p>Sommario delle regole di progettazione per le classi di una gerarchia:</p>
<ul>
<li><a href="#Rh-abstract-ctor">C.126: Una classe astratta, solitamente, non necessita di un costruttore</a></li>
<li><a href="#Rh-dtor">C.127: Una classe con una funzione virtuale dovrebbe avere un distruttore virtuale o protected</a></li>
<li><a href="#Rh-override">C.128: Le funzioni virtuali devono specificare esattamente un attributo tra <code>virtual</code>, <code>override</code> e <code>final</code></a></li>
<li><a href="#Rh-kind">C.129: Quando si progetta una gerarchia di classi, distinguere tra ereditarietà dell’implementazione e ereditarietà dell’interfaccia</a></li>
<li><a href="#Rh-copy">C.130: Per eseguire copie complete [deep] di classi polimorfiche preferire una funzione virtuale <code>clone</code> anziché un costruttore di copia/assegnazione</a></li>
<li><a href="#Rh-get">C.131: Evitare getter e setter banali</a></li>
<li><a href="#Rh-virtual">C.132: Non creare una funzione <code>virtual</code> senza motivo</a></li>
<li><a href="#Rh-protected">C.133: Evitare i dati <code>protected</code></a></li>
<li><a href="#Rh-public">C.134: Assicurarsi che tutti i dati membro non-<code>const</code> abbiano lo stesso livello di accesso</a></li>
<li><a href="#Rh-mi-interface">C.135: Utilizzare l’ereditarietà multipla per rappresentare più interfacce distinte</a></li>
<li><a href="#Rh-mi-implementation">C.136: Utilizzare l’ereditarietà multipla per rappresentare l’unione degli attributi di un’implementazione</a></li>
<li><a href="#Rh-vbase">C.137: Usare basi <code>virtual</code> per evitare troppe classi base generali</a></li>
<li><a href="#Rh-using">C.138: Creare un set di overload per una classe derivata e le sue basi con <code>using</code></a></li>
<li><a href="#Rh-final">C.139: Usare <code>final</code> con parsimonia</a></li>
<li><a href="#Rh-virtual-default-arg">C.140: Non fornire argomenti di default diversi a una funzione virtuale e a una sovrapposta [overrider]</a></li>
</ul>
<p>Sommario delle regole per l’accesso a oggetti in una gerarchia:</p>
<ul>
<li><a href="#Rh-poly">C.145: Accedere agli oggetti polimorfici tramite puntatori e riferimenti</a></li>
<li><a href="#Rh-dynamic_cast">C.146: Usare il <code>dynamic_cast</code> dove è inevitabile la navigazione della gerarchia della classe</a></li>
<li><a href="#Rh-ref-cast">C.147: Usare il <code>dynamic_cast</code> per un tipo di riferimento quando la non riuscita della ricerca della classe richiesta è considerata un errore</a></li>
<li><a href="#Rh-ptr-cast">C.148: Usare <code>dynamic_cast</code> per un tipo di puntatore quando la non riuscita della ricerca della classe richiesta è considerata una alternativa valida</a></li>
<li><a href="#Rh-smart">C.149: Usare <code>unique_ptr</code> o <code>shared_ptr</code> per evitare di dimenticarsi il <code>delete</code> degli oggetti creati con <code>new</code></a></li>
<li><a href="#Rh-make_unique">C.150: Usare <code>make_unique()</code> per costruire oggetti posseduti dagli <code>unique_ptr</code></a></li>
<li><a href="#Rh-make_shared">C.151: Usare <code>make_shared()</code> per costruire oggetti posseduti dagli <code>shared_ptr</code></a></li>
<li><a href="#Rh-array">C.152: Mai assegnare un puntatore ad un array di oggetti di classi derivate a un puntatore alla sua classe base</a></li>
<li><a href="#Rh-use-virtual">C.153: Preferire la funzione virtual al casting</a></li>
</ul>
<h3 id="c.120-usare-le-gerarchie-di-classi-per-rappresentare-solo-i-concetti-con-una-intrinseca-struttura-gerarchica"><a name="Rh-domain"></a>C.120: Usare le gerarchie di classi per rappresentare (solo) i concetti con una intrinseca struttura gerarchica</h3>
<h5 id="motivo-126">Motivo</h5>
<p>La diretta rappresentazione delle idee nel codice facilita la comprensione e la manutenzione. Assicurarsi che l’idea rappresentata nella classe base coincida esattamente con tutti i tipi derivati e che non esista un modo migliore per rappresentarla che usare l’accoppiamento stretto [tight coupling] dell’ereditarietà.</p>
<p><em>Non</em> usare l’ereditarietà quando basterà semplicemente avere un dato membro. In genere ciò significa che il tipo derivato deve sovrascrivere [override]una funzione base virtuale o deve accedere ad un membro protected.</p>
<h5 id="esempio-113">Esempio</h5>
<pre><code>class DrawableUIElement {
public:
virtual void render() const = 0;
// ...
};

class AbstractButton : public DrawableUIElement {
public:
virtual void onClick() = 0;
// ...
};

class PushButton : public AbstractButton {
void render() const override;
void onClick() override;
// ...
};

class Checkbox : public AbstractButton {
// ...
};</code></pre>
<h5 id="esempio-cattivo-50">Esempio, cattivo</h5>
<p><em>Non</em> rappresentare concetti in domini non-gerarchici con gerarchie di classi.</p>
<pre><code>template&lt;typename T&gt;
class Container {
public:
// list operations:
virtual T&amp; get() = 0;
virtual void put(T&amp;) = 0;
virtual void insert(Position) = 0;
// ...
// vector operations:
virtual T&amp; operator[](int) = 0;
virtual void sort() = 0;
// ...
// tree operations:
virtual void balance() = 0;
// ...
};</code></pre>
<p>Qui la maggior parte delle classi che si sovrascrivono [overriding] non possono implementare bene la maggior pare delle funzioni richieste nell’interfaccia. Pertanto la classe base diventa un onere di implementazione. Inoltre, l’utente di <code>Container</code> non può fare affidamento sulle funzioni membro che effettivamente eseguono operazioni significative in modo ragionevolmente efficiente; potrebbe sollevare, invece, un’eccezione. Pertanto gli utenti devono ricorrere ad un controllo a run-time e/o a non usare questa interfaccia (super)generale a favore di un’interfaccia particolare trovata a run-time interrogando il tipo (p.es., un <code>dynamic_cast</code>).</p>
<h5 id="imposizione-119">Imposizione</h5>
<ul>
<li>Cercare le classi con molti membri che non fanno altro che sollevare errori [throw].</li>
<li>Segnalare ogni utilizzo di una classe base non pubblica <code>B</code> dove la classe derivata <code>D</code> non sovrascrive [override] una funzione virtuale né accede a membri protetti in <code>B</code> e <code>B</code> non è nessuna delle seguenti: vuota, un parametro template o un pacchetto di parametri di <code>D</code>, una classe template specializzata con <code>D</code>.</li>
</ul>
<h3 id="c.121-se-una-classe-base-viene-usata-come-interfaccia-crearla-come-classe-astratta-pura"><a name="Rh-abstract"></a>C.121: Se una classe base viene usata come interfaccia, crearla come classe astratta pura</h3>
<h5 id="motivo-127">Motivo</h5>
<p>Una classe è più stabile (meno fragile) se non contiene dati. Le interfacce dovrebbero normalmente essere composte interamente da funzioni virtuali pure pubbliche e un distruttore virtuale di default/vuoto.</p>
<h5 id="esempio-114">Esempio</h5>
<pre><code>class My_interface {
public:
// ...qui solo funzioni virtuali pure ...
virtual ~My_interface() {}   // oppure =default
};</code></pre>
<h5 id="esempio-cattivo-51">Esempio, cattivo</h5>
<pre><code>class Goof {
public:
// ...qui solo funzioni virtuali pure ...
// nessun distruttore virtuale
};

class Derived : public Goof {
string s;
// ...
};

void use()
{
unique_ptr&lt;Goof&gt; p {new Derived{&quot;here we go&quot;}};
f(p.get()); // usa Derived tramite l&#39;interfaccia di Goof
g(p.get()); // usa Derived tramite l&#39;interfaccia di Goof
} // leak</code></pre>
<p>La <code>Derived</code> viene distrutta con <code>delete</code> tramite la sua interfaccia <code>Goof</code>, quindi la sua <code>string</code> si perde [leak]. Dando a <code>Goof</code> un distruttore virtuale tutto va bene.</p>
<h5 id="imposizione-120">Imposizione</h5>
<ul>
<li>Avvisare su qualsiasi classe che contiene dati membro e che abbia anche una funzione virtuale sovrascrivibile [overridable] (non-<code>final</code>) che non sia stata ereditata da una classe base.</li>
</ul>
<h3 id="c.122-usare-le-classi-astratte-come-interfacce-quando-è-necessaria-una-completa-separazione-tra-linterfaccia-e-limplementazione"><a name="Rh-separation"></a>C.122: Usare le classi astratte come interfacce quando è necessaria una completa separazione tra l’interfaccia e l’implementazione</h3>
<h5 id="motivo-128">Motivo</h5>
<p>Come all’interno del confine di un ABI [Application Binary Interface] (link).</p>
<h5 id="esempio-115">Esempio</h5>
<pre><code>struct Device {
virtual ~Device() = default;
virtual void write(span&lt;const char&gt; outbuf) = 0;
virtual void read(span&lt;char&gt; inbuf) = 0;
};

class D1 : public Device {
// ... dati ...

void write(span&lt;const char&gt; outbuf) override;
void read(span&lt;char&gt; inbuf) override;
};

class D2 : public Device {
// ... dati diversi ...

void write(span&lt;const char&gt; outbuf) override;
void read(span&lt;char&gt; inbuf) override;
};</code></pre>
<p>Un utente ora può utilizzare l’interfaccia di <code>D1</code> e di <code>D2</code> in modo intercambiabile attraverso l’interfaccia fornita da <code>Device</code>. Inoltre, si possono aggiornare <code>D1</code> e <code>D2</code> in modo che i file binari non siano compatibili con le versioni precedenti finché tutti gli accessi passano tramite <code>Device</code>.</p>
<h5 id="imposizione-121">Imposizione</h5>
<pre><code>???</code></pre>
<h2 id="c.hierclass-progettazioni-di-classi-in-una-gerarchia">C.hierclass: Progettazioni di classi in una gerarchia:</h2>
<h3 id="c.126-una-classe-astratta-solitamente-non-necessita-di-un-costruttore"><a name="Rh-abstract-ctor"></a>C.126: Una classe astratta, solitamente, non necessita di un costruttore</h3>
<h5 id="motivo-129">Motivo</h5>
<p>Una classe astratta in genere non ha dati da inizializzare in un costruttore.</p>
<h5 id="esempio-116">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="eccezione-23">Eccezione</h5>
<ul>
<li>Un costruttore di una classe base che, per esempio, registra un oggetto da qualche parte, potrebbe aver bisogno di un costruttore.</li>
<li>In casi estremamente rari, potrebbe essere ragionevole che una classe astratta abbia un po’ di dati condivisi da tutte le classi derivate (p.es., dati ad uso statistico, informazioni di debug, ecc.); tali classi tendono ad avere dei costruttori. Ma attenzione: Tali classi tendono anche ad essere propense a richiedere l’ereditarietà virtuale.</li>
</ul>
<h5 id="imposizione-122">Imposizione</h5>
<p>Segnalare le classi astratte con costruttori.</p>
<h3 id="c.127-una-classe-con-una-funzione-virtuale-dovrebbe-avere-un-distruttore-virtuale-o-protected"><a name="Rh-dtor"></a>C.127: Una classe con una funzione virtuale dovrebbe avere un distruttore virtuale o protected</h3>
<h5 id="motivo-130">Motivo</h5>
<p>Una classe con una funzione virtuale è solitamente (e in generale) utilizzata tramite un puntatore ad una classe base. Di solito, l’ultimo utente deve chiamare il delete su un puntatore alla base, spesso tramite uno smart pointer alla base, quindi il distruttore dovrebbe essere pubblico e virtuale. Meno spesso, se non si intende supportare la cancellazione tramite un puntatore a una base, il distruttore dovrebbe essere protected e non-virtuale; cfr. <a href="#Rc-dtor-virtual">C.35</a>.</p>
<h5 id="esempio-cattivo-52">Esempio, cattivo</h5>
<pre><code>struct B {
virtual int f() = 0;
// ...nessun distruttore scritto dall&#39;utente, i default a pubblici e non-virtuali ...
};

// bad: derivato da una classe senza un distruttore virtuale
struct D : B {
string s {&quot;default&quot;};
};

void use()
{
unique_ptr&lt;B&gt; p = make_unique&lt;D&gt;();
// ...
} // comportamento indefinito. Si può chiamare solo B::~B e perdere [leak] la stringa</code></pre>
<h5 id="note-144">Note</h5>
<p>Ci sono persone che non seguono questa regola perché intendono usare una classe solo attraverso un <code>shared_ptr</code>: <code>std::shared_ptr&lt;B&gt; p = std::make_shared&lt;D&gt;(args);</code> Qui, lo shared pointer si occuperà della cancellazione e quindi non avverrà alcun [leak] derivante da un inappropriato <code>delete</code> della base. Le persone che lo fanno in modo coerente possono ottenere un falso positivo, ma la regola è importante – cosa succede se uno viene allocato utilizzando <code>make_unique</code>? Non è sicuro a meno che l’autore di <code>B</code> assicuri che non possa mai essere utilizzato in modo improprio, ad esempio rendendo privati tutti i costruttori e fornendo una funzione factory per imporre l’allocazione con <code>make_shared</code>.</p>
<h5 id="imposizione-123">Imposizione</h5>
<ul>
<li>Una classe con una qualsiasi funzione virtuale dovrebbe avere un distruttore o pubblico o virtuale oppure protetto e non virtuale.</li>
<li>Segnalare il <code>delete</code> di una classe con una funzione virtuale ma senza un distruttore virtuale.</li>
</ul>
<h3 id="c.128-le-funzioni-virtuali-devono-specificare-esattamente-un-attributo-tra-virtual-override-e-final"><a name="Rh-override"></a>C.128: Le funzioni virtuali devono specificare esattamente un attributo tra <code>virtual</code>, <code>override</code>, e <code>final</code></h3>
<h5 id="motivo-131">Motivo</h5>
<p>Leggibilità. Rilevamento di errori. Scrivere un esplicito <code>virtual</code>, <code>override</code>, o <code>final</code> è auto-documentante e consente al compilatore di intercettare gli errori di tipi e/o di nomi tra le classi base e le derivate. Tuttavia, scrivere più di uno di questi tre è sia ridondante che una potenziale fonte di errori.</p>
<p>È semplice e chiaro:</p>
<ul>
<li><code>virtual</code> ignifica esattamente e solo “questa è una nuova funzione virtuale”.</li>
<li><code>override</code> significa esattamente e solo “questa è una funzione sovrapposta e non-final”.</li>
<li><code>final</code> significa esattamente e solo “questa è una funzione sovrapposta e finale”.</li>
</ul>
<h5 id="esempio-cattivo-53">Esempio, cattivo</h5>
<pre><code>struct B {
void f1(int);
virtual void f2(int) const;
virtual void f3(int);
// ...
};

struct D : B {
void f1(int);        // bad (si spera in un warning): D::f1() hides B::f1()
void f2(int) const;  // bad (ma convenzionale e valido): nessun override esplicito
void f3(double);     // bad (si spera in un warning): D::f3() nasconde B::f3()
// ...
};</code></pre>
<h5 id="esempio-buono-9">Esempio, buono</h5>
<pre><code>struct Better : B {
void f1(int) override;        // errore (rilevato): Better::f1() nasconde B::f1()
void f2(int) const override;
void f3(double) override;     // errore (rilevato): Better::f3() nasconde B::f3()
// ...
};</code></pre>
<h4 id="discussione-3">Discussione</h4>
<p>Vogliamo eliminare due particolari classi di errori:</p>
<ul>
<li><strong>virtual implicito</strong>: il programmatore voleva che la funzione fosse implicitamente virtuale ed è così (ma chi legge il codice non può saperlo); o il programmatore voleva che la funzione fosse implicitamente virtuale ma non lo è (p.es., a causa di una subdola discrepanza nell’elenco dei parametri); o il programmatore non voleva che la funzione fosse virtuale ma lo è (perché capita che abbia la stessa firma della funzione virtuale nella classe base)</li>
<li><strong>override implicito</strong>: il programmatore voleva che la funzione fosse implicitamente una sovrascrittura [overrider] e lo è (ma i lettori del codice non possono saperlo); o il programmatore voleva che la funzione fosse implicitamente una sovrascrittura [overrider] ma non lo è (p.es., a causa di una subdola discrepanza nell’elenco dei parametri); o il programmatore non voleva che la funzione fosse una sovrascrittura [overrider] ma lo è (perché capita che abbia la stessa firma di una funzione virtuale nella classe base – da notare che questo problema sorge indipendentemente dal fatto che la funzione sia esplicitamente dichiarata virtuale, perché il programmatore potrebbe aver voluto creare o una nuova funzione virtuale o una nuova funzione non-virtuale)</li>
</ul>
<h5 id="imposizione-124">Imposizione</h5>
<ul>
<li>Confrontare i nomi delle funzioni nelle classi base e derivare e segnalare l’uso dello stesso nome che non sovrascrive [override].</li>
<li>Segnalare gli [override] senza né <code>override</code> né <code>final</code>.</li>
<li>Segnalare le dichiarazioni di funzioni che usano più di uno tra <code>virtual</code>, <code>override</code>, e <code>final</code>.</li>
</ul>
<h3 id="c.129-quando-si-progetta-una-gerarchia-di-classi-distinguere-tra-ereditarietà-dellimplementazione-e-ereditarietà-dellinterfaccia"><a name="Rh-kind"></a>C.129: Quando si progetta una gerarchia di classi, distinguere tra ereditarietà dell’implementazione e ereditarietà dell’interfaccia</h3>
<h5 id="motivo-132">Motivo</h5>
<p>L’implementazione dei dettagli in un’interfaccia la rendono fragile; vale a dire, obbliga i suoi utenti a dover ricompilare dopo aver modificato l’implementazione. I dati in una classe base aumentano la complessità dell’implementazione della base e possono portare alla replicazione del codice.</p>
<h5 id="note-145">Note</h5>
<p>Definizione:</p>
<ul>
<li>l’ereditarietà dell’interfaccia è l’utilizzo dell’ereditarietà per separare gli utenti dalle implementazioni, in particolare consente dialle classi derivate di poter essere aggiunte e modificate senza influire sugli utenti delle classi base.</li>
<li>l’ereditarietà dell’implementazione è l’utilizzo dell’ereditarietà per semplificare l’implementazione di nuove strutture mettendo a disposizione nuove operazioni utili agli implementatori di nuove operazioni correlate (talvolta detto “programmazione per differenza”).</li>
</ul>
<p>Una classe interfaccia pura è semplicemente un insieme di funzioni virtuali pure; cfr. <a href="#Ri-abstract">I.25</a>.</p>
<p>All’inizio dell’OOP (p.es., negli anni ’80 e ’90), l’ereditarietà dell’implementazione e l’ereditarietà dell’interfaccia venivano spesso confuse e le cattive abitudini sono dure a morire. Anche adesso, la confusione non è rara nel vecchio codice e nel materiale didattico di vecchio stampo.</p>
<p>L’importanza di separare i due tipi di ereditarietà aumenta</p>
<ul>
<li>con la dimensione della gerarchia (p.es., decine di classi derivate),</li>
<li>col periodo tempo in cui viene usata la gerarchia (p.es., decenni), e</li>
<li>col numero di organizzazioni diverse in cui viene usata una gerarchia (p.es., può essere difficile distribuire un aggiornamento di una classe base)</li>
</ul>
<h5 id="esempio-cattivo-54">Esempio, cattivo</h5>
<pre><code>class Shape {   // BAD, si mischia l&#39;interfaccia con l&#39;implementazione
public:
Shape();
Shape(Point ce = {0, 0}, Color co = none): cent{ce}, col {co} { /* ... */}

Point center() const { return cent; }
Color color() const { return col; }

virtual void rotate(int) = 0;
virtual void move(Point p) { cent = p; redraw(); }

virtual void redraw();

// ...
private:
Point cent;
Color col;
};

class Circle : public Shape {
public:
Circle(Point c, int r) :Shape{c}, rad{r} { /* ... */ }

// ...
private:
int rad;
};

class Triangle : public Shape {
public:
Triangle(Point p1, Point p2, Point p3); // calcola il centro
// ...
};</code></pre>
<p>Problemi:</p>
<ul>
<li>Col crescere della gerarchia e con l’aggiunta di più dati a <code>Shape</code>, i costruttori diventano sempre più difficili da scrivere e manutenere.</li>
<li>Perché calcolare il centro di un <code>Triangle</code>? non lo si userà mai.</li>
<li>Aggiungendo un dato membro a <code>Shape</code> (p.es., lo stile di disegno o la lavagna) tutte le classi derivate da <code>Shape</code> e tutto il codice che usa <code>Shape</code> dovranno essere rivisti, forse cambiati e probabilmente ricompilati.</li>
</ul>
<p>L’implementazione di <code>Shape::move()</code> è un esempio di ereditarietà di implementazione: si è definito <code>move()</code> una volta e per tutte le classi derivate. Maggiore è il codice presente in queste implementazioni delle funzioni membro della classe base e più i dati vengono condivisi mettendoli nella base, più benefici si ottengono - e meno è stabile la gerarchia.</p>
<h5 id="esempio-117">Esempio</h5>
<p>Questa gerarchia di Shape può essere riscritta usando l’ereditarietà dell’interfaccia:</p>
<pre><code>class Shape {  // interfaccia pura
public:
virtual Point center() const = 0;
virtual Color color() const = 0;

virtual void rotate(int) = 0;
virtual void move(Point p) = 0;

virtual void redraw() = 0;

// ...
};</code></pre>
<p>Si noti che un’interfaccia pura ha raramente costruttori: non c’è niente da costruire.</p>
<pre><code>class Circle : public Shape {
public:
Circle(Point c, int r, Color c) :cent{c}, rad{r}, col{c} { /* ... */ }

Point center() const override { return cent; }
Color color() const override { return col; }

// ...
private:
Point cent;
int rad;
Color col;
};</code></pre>
<p>L’interfaccia ora è meno fragile, ma c’è più lavoro nell’implementazione delle funzioni membro. Per esempio, <code>center</code> deve essere implementato per ogni classe derivata da <code>Shape</code>.</p>
<h5 id="esempio-doppia-gerarchia">Esempio, doppia gerarchia</h5>
<p>Come possiamo avere i vantaggi di gerarchie stabili dalle gerarchie di implementazioni e i benefici del riutilizzo delle implementazioni con l’ereditarietà dell’implementazione? Una tecnica popolare è la doppia gerarchia. Ci sono molti modi per implementare l’idea delle doppie gerarchie; qui, useremo la variante dell’ereditarietà multipla.</p>
<p>Per prima cosa progettiamo una gerarchia di classi di interfacce:</p>
<pre><code>class Shape {   // interfaccia pura
public:
virtual Point center() const = 0;
virtual Color color() const = 0;

virtual void rotate(int) = 0;
virtual void move(Point p) = 0;

virtual void redraw() = 0;

// ...
};

class Circle : public virtual Shape {   // interfaccia pura
public:
virtual int radius() = 0;
// ...
};</code></pre>
<p>Per rendere utile questa interfaccia, si deve fornire l’implementazione delle classi (qui, chiamate equivalentemente, ma nel namespace <code>Impl</code>):</p>
<pre><code>class Impl::Shape : public virtual ::Shape { // implementazione
public:
// costruttori, distruttore
// ...
Point center() const override { /* ... */ }
Color color() const override { /* ... */ }

void rotate(int) override { /* ... */ }
void move(Point p) override { /* ... */ }

void redraw() override { /* ... */ }

// ...
};</code></pre>
<p>Ora <code>Shape</code> è un mediocre esempio di classe con un’implementazione, ma soprassediamo perché è solo un semplice esempio di una tecnica destinata a gerarchie più complesse.</p>
<pre><code>class Impl::Circle : public virtual ::Circle, public Impl::Shape {   // implementazione
public:
// costruttori, distruttore

int radius() override { /* ... */ }
// ...
};</code></pre>
<p>E si potrebbe estendere le gerarchie aggiungendo una classe Smiley (:-)):</p>
<pre><code>class Smiley : public virtual Circle { // interfaccia pura
public:
// ...
};

class Impl::Smiley : public virtual ::Smiley, public Impl::Circle {   // implementazione
public:
// costruttori, distruttore
// ...
}</code></pre>
<p>Ora ci sono due gerarchie:</p>
<ul>
<li>interfaccia: Smiley -&gt; Circle -&gt; Shape</li>
<li>implementazione: Impl::Smiley -&gt; Impl::Circle -&gt; Impl::Shape</li>
</ul>
<p>Dato che ciascuna implementazione è derivata dalla sua interfaccia e dalla sua implementazione della classe base si ottiene un Reticolo (Digrafo aciclico [Directed Acyclic Graph, DAG]):</p>
<pre><code>Smiley     -&gt;         Circle     -&gt;  Shape
^                     ^               ^
|                     |               |
Impl::Smiley -&gt; Impl::Circle -&gt; Impl::Shape</code></pre>
<p>Come accennato, questo è solo uno dei modi per costruire una doppia gerarchia.</p>
<p>La gerarchia di implementazione può essere utilizzata direttamente, piuttosto che attraverso l’interfaccia astratta.</p>
<pre><code>void work_with_shape(Shape&amp;);

int user()
{
Impl::Smiley my_smiley{ /* args */ };   // crea uno shape concreto
// ...
my_smiley.some_member();        // usa direttamente la classe di implementazione
// ...
work_with_shape(my_smiley);     // usa l&#39;implementazione tramite l&#39;interfaccia astratta
// ...
}</code></pre>
<p>Ciò può essere utile quando la classe di implementazione non ha membri nell’interfaccia astratta o se l’uso diretto di un membro offre un’opportunità di ottimizzazione (p.es., se una funzione membro dell’implementazione è <code>final</code>)</p>
<h5 id="note-146">Note</h5>
<p>Un’altra tecnica (correlata) per separare l’interfaccia e l’implementazione è la <a href="#Ri-pimpl">Pimpl [Pointer to implementation]</a>.</p>
<h5 id="note-147">Note</h5>
<p>Spesso c’è da scegliere tra l’offrire funzionalità comuni come funzioni della classe base (implementate) e funzioni a sé stanti (in un namespace di implementazione). Le classi base forniscono una notazione più breve ed un più facile accesso ai dati condivisi (nella classe base) col costo di avere le funzionalità disponibili solo agli utenti della gerarchia.</p>
<h5 id="imposizione-125">Imposizione</h5>
<ul>
<li>Segnalare una conversione derivata da una base verso una base con sia i dati che le funzioni virtuali (ad eccezione delle chiamate da un membro della classe derivata ad un membro della classe base)</li>
<li>???</li>
</ul>
<h3 id="c.130-per-eseguire-copie-complete-deep-di-classi-polimorfiche-preferire-una-funzione-virtuale-clone-anziché-un-costruttore-di-copiaassegnazione"><a name="Rh-copy"></a>C.130: Per eseguire copie complete [deep] di classi polimorfiche preferire una funzione virtuale <code>clone</code> anziché un costruttore di copia/assegnazione</h3>
<h5 id="motivo-133">Motivo</h5>
<p>La copia di una classe polimorfica è sconsigliata a causa dei problemi di spaccatura [slicing], cfr <a href="#Rc-copy-virtual">C.67</a>. Se c’è davvero bisogno della semantica della copia, si fa una copia completa [deeply]: Si fornisce una funzione <code>clone</code> virtuale che copierà l’effettivo tipo più-derivato e restituisce un puntatore che possiede i nuovo oggetto, poi, in una classe derivata restituisce il tipo derivato (si usa un tipo di ritorno covariante).</p>
<h5 id="esempio-118">Esempio</h5>
<pre><code>class B {
public:
virtual owner&lt;B*&gt; clone() = 0;
virtual ~B() = default;

B(const B&amp;) = delete;
B&amp; operator=(const B&amp;) = delete;
};

class D : public B {
public:
owner&lt;D*&gt; clone() override;
~D() override;
};</code></pre>
<p>In generale, si raccomanda di usare gli smart pointer per rappresentare il possesso (cfr. <a href="#Rr-owner">R.20</a>). Tuttavia, a causa delle regole del linguaggio, il tipo di ritorno covariante non può essere uno smart pointer: <code>D::clone</code> non può restituire un <code>unique_ptr&lt;D&gt;</code> mentre <code>B::clone</code> restituisce <code>unique_ptr&lt;B&gt;</code>. Pertanto, è necessario restituire in modo coerente <code>unique_ptr&lt;B&gt;</code> in tutti gli [override] o usare l’utility <code>owner&lt;&gt;</code> dalle <a href="#SS-views">Guidelines Support Library</a>.</p>
<h3 id="c.131-evitare-getter-e-setter-banali"><a name="Rh-get"></a>C.131: Evitare getter e setter banali</h3>
<h5 id="motivo-134">Motivo</h5>
<p>Un getter o un setter banale non aggiunge alcuna semantica del valore; l’elemento del dato potrebbe semplicemente anche essere <code>public</code>.</p>
<h5 id="esempio-119">Esempio</h5>
<pre><code>class Point {   // Bad: verboso
int x;
int y;
public:
Point(int xx, int yy) : x{xx}, y{yy} { }
int get_x() const { return x; }
void set_x(int xx) { x = xx; }
int get_y() const { return y; }
void set_y(int yy) { y = yy; }
// nessuna funzione membro comportamentale
};</code></pre>
<p>Si consideri di trasformare tale classe in una <code>struct</code> – ovvero, un gruppo di variabili senza comportamento, tutti dati pubblici e nessuna funzione membro.</p>
<pre><code>struct Point {
int x {0};
int y {0};
};</code></pre>
<p>Si noti che è possibile inserire degli inizializzatori di default sulle variabili membro: <a href="#Rc-initialize">C.49: Nei costruttori preferire l’inizializzazione alle assegnazioni</a>.</p>
<h5 id="note-148">Note</h5>
<p>La chiave di questa regola è se la semantica del getter/setter è banale. Anche se non è una definizione completa di “banale”, si consideri se ci potrebbero essere delle differenze, oltre alla sintassi, se il getter/setter fosse invece un dato membro pubblico. Esempi di semantiche non-banali sarebbero: mantenere una classe invariante o convertire tra un tipo interno e e un tipo dell’interfaccia.</p>
<h5 id="imposizione-126">Imposizione</h5>
<p>Segnalare funzioni membro <code>get</code> e <code>set</code> multiple che accedono semplicemente ad un membro senza una ulteriore semantica.</p>
<h3 id="c.132-non-creare-una-funzione-virtual-senza-motivo"><a name="Rh-virtual"></a>C.132: Non creare una funzione <code>virtual</code> senza motivo</h3>
<h5 id="motivo-135">Motivo</h5>
<p>Un ridondante <code>virtual</code> aumenta il la dimensione del run-time e del codice oggetto. Una funzione virtuale può essere sovrascritta [overridden] ed è quindi aperta ad errori in una classe derivata. Una funzione virtuale garantisce la replica del codice in una gerarchia basata sui template.</p>
<h5 id="esempio-cattivo-55">Esempio, cattivo</h5>
<pre><code>template&lt;class T&gt;
class Vector {
public:
// ...
virtual int size() const { return sz; }   // bad: a che serve una classe derivata?
private:
T* elem;   // gli elementi 
int sz;    // il numero degli elementi
};</code></pre>
<p>Questo tipo di “vector” non è pensato per essere usato come classe base.</p>
<h5 id="imposizione-127">Imposizione</h5>
<ul>
<li>Segnalare una classe con funzioni virtuali ma senza classi derivate.</li>
<li>Segnalare una classe dove tutte le funzioni membro sono virtuali ed hanno delle implementazioni.</li>
</ul>
<h3 id="c.133-evitare-dati-protected"><a name="Rh-protected"></a>C.133: Evitare dati <code>protected</code></h3>
<h5 id="motivo-136">Motivo</h5>
<p>I dati <code>protected</code> sono fonte di errori e complessità. I dati <code>protected</code> complicano le istruzioni degli invarianti. I dati <code>protected</code> violano intrinsecamente la direttiva contraria a mettere i dati nelle classi base, che solitamente porta a dover gestire anche l’ereditarietà virtuale.</p>
<h5 id="esempio-cattivo-56">Esempio, cattivo</h5>
<pre><code>class Shape {
public:
// ... funzioni di interfaccia ...
protected:
// dati da usare nelle classi derivate:
Color fill_color;
Color edge_color;
Style st;
};</code></pre>
<p>Ora tocca ad ogni <code>Shape</code> derivata gestire correttamente i dati protected. Questo è molto diffuso, ma è stato anche una grande fonte di problemi di manutenzione . In una grande gerarchia di classi, l’uso coerente di dati protetti è difficile da manutenere perché potrebbe esserci molto codice, sparpagliato tra molte classi. L’insieme delle classi che possono toccare quei dati è aperto: chiunque può derivare una nuova classe e cominciare a cambiare i dati protected. Capita spesso, che non sia possibile esaminare l’insieme completo delle classi, quindi qualsiasi modifica alla rappresentazione della classe diventa proibitiva. Non c’è alcuna invariante imposta per i dati protected; è molto simile ad un insieme di variabili globali. I dati protected sono di diventati fatto globali in moltissimi sorgenti.</p>
<h5 id="note-149">Note</h5>
<p>Spesso i dati protected sembrano allettanti per consentire innumerevoli miglioramenti tramite la derivazione. Spesso, quello che si ottiene sono modifiche ed errori inaspettati. <a href="#Rc-private">Preferire dati <code>private</code></a> con un’invariante ben specificato e ben rispettato. In alternativa, che è spesso è meglio, <a href="#Rh-abstract">tenere i dati all’esterno di qualsiasi classe usata come interfaccia</a>.</p>
<h5 id="note-150">Note</h5>
<p>La funzione membro protected può andar bene.</p>
<h5 id="imposizione-128">Imposizione</h5>
<p>Segnalare le classi con dati <code>protected</code>.</p>
<h3 id="c.134-assicurarsi-che-tutti-i-dati-membro-non-const-abbiano-lo-stesso-livello-di-accesso"><a name="Rh-public"></a>C.134: Assicurarsi che tutti i dati membro non-<code>const</code> abbiano lo stesso livello di accesso</h3>
<h5 id="motivo-137">Motivo</h5>
<p>Prevenire la confusione logica che porta ad errori. Se i dati membri non-<code>const</code> non hanno lo stesso livello di accesso, il tipo è confuso su ciò che si cerca di fare. È un tipo che mantiene un invariante o è semplicemente una raccolta di valori?</p>
<h5 id="discussione-4">Discussione</h5>
<p>La domanda principale è: Quale codice è responsabile della manutenzione di un valore significativo/corretto per quella variabile?</p>
<p>Esistono esattamente due tipi di dati membro:</p>
<ul>
<li>A: Quelli che non partecipano all’invariante dell’oggetto. Qualsiasi combinazione di valori per questi membri è valida.</li>
<li>B: Quelli che partecipano all’invariante dell’oggetto. Non tutte le combinazioni di valori sono significative (altrimenti non ci sarebbero invarianti). Pertanto, tutto il codice che ha l’accesso in scrittura su queste variabili deve conoscere l’invariante, conoscere la semantica e conoscere (e attivamente implementare e imporre) le regole per mantenere i valori corretti.</li>
</ul>
<p>I dati membro della categoria A devono essere <code>public</code> (o, più raramente, <code>protected</code> se si vuole solo che siano visibili dalle classi derivate). Non hanno bisogno di incapsulamento. Tutto il codice nel sistema potrebbe anche vederli e modificarli.</p>
<p>I dati membro della categoria B devono essere <code>private</code> o <code>const</code>. Questo perché l’incapsulamento è importante. Renderli non-<code>private</code> e non-<code>const</code> significherebbe che l’oggetto non può controllare il proprio stato: Una quantità illimitata di codice al di fuori della classe dovrebbe sapere dell’invariante e contribuire accuratamente alla sua manutenzione – se questi dati membro fossero <code>public</code>, sarebbe tutto il codice chiamante che utilizza l’oggetto; se fossero <code>protected</code>, sarebbe tutto il codice nelle classi derivate attuali e future. Questo porta a un codice fragile e strettamente accoppiato che diventa rapidamente un incubo da mantenere. Qualsiasi codice che imposta inavvertitamente i dati membro a una combinazione di valori invalida o inaspettata corromperà l’oggetto e tutti i suoi successivi usi.</p>
<p>La maggior parte delle classi sono tutte A o tutte B:</p>
<ul>
<li><em>Tutte public</em>: Se si sta scrivendo un blocco-di-variabili aggregato senza un invariante tra tali variabili, allora tutte le variabili dovrebbero essere <code>public</code>. <a href="#Rc-struct">Per convenzione, tali classi si dichiarano <code>struct</code> anziché <code>class</code></a></li>
<li><em>Tutte private</em>: Se si sta scrivendo un tipo che mantiene un invariante, allora tutte le variabili non-<code>const</code> dovrebbero essere private – esse dovrebbero essere incapsulate.</li>
</ul>
<h5 id="eccezione-24">Eccezione</h5>
<p>Occasionalmente le classi si mischiano tra A e B, solitamente per debug. Un oggetto incapsulato può contenere qualcosa di simile a una strumentazione di debug non-<code>const</code> che non fa parte dell’invariante e quindi rientra nella categoria A – in realtà non fa parte del valore dell’oggetto né dello stato osservabile significativo. In tal caso, le parti A devono essere trattate come A (rese <code>public</code>, o in rari casi <code>protected</code> se devono essere visibili solo alle classi derivate) e le parti B devono comunque essere trattate come B (<code>private</code> o <code>const</code>).</p>
<h5 id="imposizione-129">Imposizione</h5>
<p>Segnalare qualsiasi classe che abbia dati membro non-<code>const</code> con diversi livelli di accesso.</p>
<h3 id="c.135-utilizzare-lereditarietà-multipla-per-rappresentare-più-interfacce-distinte"><a name="Rh-mi-interface"></a>C.135: Utilizzare l’ereditarietà multipla per rappresentare più interfacce distinte</h3>
<h5 id="motivo-138">Motivo</h5>
<p>Non tutte le classi supporteranno necessariamente tutte le interfacce, e non tutti i chiamanti vorranno necessariamente gestire tutte le operazioni. Specialmente per suddividere le interfacce monolitiche in “aspetti” del comportamento supportati da una determinata classe derivata.</p>
<h5 id="esempio-120">Esempio</h5>
<pre><code>class iostream : public istream, public ostream {   // molto semplificata
// ...
};</code></pre>
<p><code>istream</code> fornisce l’interfaccia per le operazioni di input; <code>ostream</code> fornisce l’interfaccia per le operazioni di output. <code>iostream</code> fornisce l’unione delle interfacce di <code>istream</code> e <code>ostream</code> e la sincronizzazione necessaria affinché ci siano entrambe su un unico flusso.</p>
<h5 id="note-151">Note</h5>
<p>Questo è un uso molto comune dell’eredità perché è comune la necessità di avere più interfacce diverse per un’implementazione e tali interfacce risultano spesso non facilmente o naturalmente organizzate in una gerarchia con un’unica radice.</p>
<h5 id="note-152">Note</h5>
<p>Tali interfacce sono tipicamente classi astratte.</p>
<h5 id="imposizione-130">Imposizione</h5>
<p>???</p>
<h3 id="c.136-utilizzare-lereditarietà-multipla-per-rappresentare-lunione-degli-attributi-di-unimplementazione"><a name="Rh-mi-implementation"></a>C.136: Utilizzare l’ereditarietà multipla per rappresentare l’unione degli attributi di un’implementazione</h3>
<h5 id="motivo-139">Motivo</h5>
<p>Alcune forme di [mixin] (classi parziali) hanno uno stato e spesso operazioni su tale stato. Se le operazioni sono virtuali, l’uso dell’ereditarietà è necessario, se non si usa l’ereditarietà se non si usa l’ereditarietà si può evitare il codice ripetuto [boilerplate] e il [forwarding].</p>
<h5 id="esempio-121">Esempio</h5>
<pre><code>class iostream : public istream, public ostream {   // molto semplificata
// ...
};</code></pre>
<p><code>istream</code> fornisce l’interfaccia per le operazioni di input (ed alcuni dati); <code>ostream</code> fornisce l’interfaccia per le operazioni di output (ed alcuni dati). <code>iostream</code> fornisce l’unione delle interfacce di <code>istream</code> e <code>ostream</code> e la sincronizzazione necessaria affinché ci siano entrambe su un unico flusso.</p>
<h5 id="note-153">Note</h5>
<p>Questo è un uso relativamente raro perché l’implementazione può spesso essere organizzata in una gerarchia con un’unica radice.</p>
<h5 id="esempio-122">Esempio</h5>
<p>A volte, un “attributo di implementazione” è più simile ad un “mixin” che determina il comportamento di un’implementazione e inietta [inject] i membri per abilitare l’implementazione dei requisiti. Per esempio, si veda <code>std::enable_shared_from_this</code> o i vari pezzi di codice da boost.intrusive (p.es. <code>list_base_hook</code> o <code>intrusive_ref_counter</code>).</p>
<h5 id="imposizione-131">Imposizione</h5>
<p>???</p>
<h3 id="c.137-usare-basi-virtual-per-evitare-troppe-classi-base-generali"><a name="Rh-vbase"></a>C.137: Usare basi <code>virtual</code> per evitare troppe classi base generali</h3>
<h5 id="motivo-140">Motivo</h5>
<p>Consente la separazione di dati condivisi e l’interfaccia. Per evitare che tutti i dati condivisi vengano inseriti in un’unica classe base.</p>
<h5 id="esempio-123">Esempio</h5>
<pre><code>struct Interface {
virtual void f();
virtual int g();
// ... nessun dato qui ...
};

class Utility {  // con dei dati
void utility1();
virtual void utility2();    // punto di personalizzazione
public:
int x;
int y;
};

class Derive1 : public Interface, virtual protected Utility {
// funzioni di override dell&#39;Interfaccia
// Forse l&#39;override delle funzioni virtuali di Utility
// ...
};

class Derive2 : public Interface, virtual protected Utility {
// funzioni di override dell&#39;Interfaccia
// Forse l&#39;override delle funzioni virtuali di Utility
// ...
};</code></pre>
<p>Avere<code>Utility</code> a fattor comune ha senso se molte classi derivate condividono significativi “dettagli implementativi”.</p>
<h5 id="note-154">Note</h5>
<p>Ovviamente, l’esempio è troppo “teorico”, ma è difficile trovare un <em>piccolo</em> esempio realistico. <code>Interface</code> è la radice di una <a href="#Rh-abstract">gerarchia di interfaccia</a> e <code>Utility</code> è la radice di una <a href="#Rh-kind">gerarchia di implementazione</a>. Questo è un <a href="https://www.quora.com/What-are-the-uses-and-advantages-of-virtual-base-class-in-C%2B%2B/answer/Lance-Diduck">esempio leggermente più realistico</a> con una spiegazione.</p>
<h5 id="note-155">Note</h5>
<p>Spesso, la linearizzazione di una gerarchia costituisce una soluzione migliore.</p>
<h5 id="imposizione-132">Imposizione</h5>
<p>Segnalare gerarchie di interfacce mischiate a quelle di implementazioni.</p>
<h3 id="c.138-creare-un-set-di-overload-per-una-classe-derivata-e-le-sue-basi-con-using"><a name="Rh-using"></a>C.138: Creare un set di overload per una classe derivata e le sue basi con <code>using</code></h3>
<h5 id="motivo-141">Motivo</h5>
<p>Senza una dichiarazione ‘using’, le funzioni membro nella classe derivata nascondono tutto l’insieme di overload ereditato.</p>
<h5 id="esempio-cattivo-57">Esempio, cattivo</h5>
<pre><code>#include &lt;iostream&gt;
class B {
public:
virtual int f(int i) { std::cout &lt;&lt; &quot;f(int): &quot;; return i; }
virtual double f(double d) { std::cout &lt;&lt; &quot;f(double): &quot;; return d; }
virtual ~B() = default;
};
class D: public B {
public:
int f(int i) override { std::cout &lt;&lt; &quot;f(int): &quot;; return i + 1; }
};
int main()
{
D d;
std::cout &lt;&lt; d.f(2) &lt;&lt; &#39;\n&#39;;   // scrive &quot;f(int): 3&quot;
std::cout &lt;&lt; d.f(2.3) &lt;&lt; &#39;\n&#39;; // scrive &quot;f(int): 3&quot;
}</code></pre>
<h5 id="esempio-buono-10">Esempio, buono</h5>
<pre><code>class D: public B {
public:
int f(int i) override { std::cout &lt;&lt; &quot;f(int): &quot;; return i + 1; }
using B::f; // espone f(double)
};</code></pre>
<h5 id="note-156">Note</h5>
<p>Questo problema riguarda sia le funzioni membro virtuali che quelle non virtuali</p>
<p>Per le basi variadiche, il C++17 ha introdotto una forma variadica della dichiarazione ‘using’,</p>
<pre><code>template &lt;class... Ts&gt;
struct Overloader : Ts... {
using Ts::operator()...; // espone operator() da ogni base
};</code></pre>
<h5 id="imposizione-133">Imposizione</h5>
<p>Diagnosticane l’hiding dei nomi</p>
<h3 id="c.139-usare-final-con-parsimonia"><a name="Rh-final"></a>C.139: Usare <code>final</code> con parsimonia</h3>
<h5 id="motivo-142">Motivo</h5>
<p>Fermare una gerarchia con <code>final</code> è raramente necessario per ragioni logiche e può danneggiare l’estensibilità di una gerarchia.</p>
<h5 id="esempio-cattivo-58">Esempio, cattivo</h5>
<pre><code>class Widget { /* ... */ };

// nessuno vorrà mai migliorare My_widget (o almeno così si crede)
class My_widget final : public Widget { /* ... */ };

class My_improved_widget : public My_widget { /* ... */ };  // errore: non lo si può fare</code></pre>
<h5 id="note-157">Note</h5>
<p>Non tutte le classi sono pensate per essere classi base. La maggior parte delle classi della standard-library ne sono esempi (p.es., <code>std::vector</code> e <code>std::string</code> non sono progettate per derivarle). Questa regola riguarda l’utilizzo di <code>final</code> sulle classi con funzioni virtuali pensate per essere interfacce per una gerarchia di classi.</p>
<h5 id="note-158">Note</h5>
<p>Fermare una singola funzione virtuale con <code>final</code> va soggetto ad errori in quanto <code>final</code> può facilmente essere bypassare quando si definisce/sovrascrive un insieme di funzioni. Fortunatamente, il compilatore rileva questi errori: Non è possibile ri-dichiarare/ri-aprire un membro <code>final</code> in una classe derivata.</p>
<h5 id="note-159">Note</h5>
<p>Le richieste di miglioramenti delle prestazioni da <code>final</code> devono essere motivate. Troppo spesso, tali affermazioni si basano su congetture o esperienze con altri linguaggi.</p>
<p>Ci sono esempi in cui <code>final</code> può essere importante sia per motivi logici che prestazionali. Un esempio è la gerarchia performance-critical AST ([Abstract syntax tree] albero sintattico astratto) in un compilatore o uno strumento di analisi del linguaggio. Non tutti gli anni vengono aggiunte nuove classi derivate e solo dagli implementatori della libreria. Tuttavia, gli abusi sono (o almeno sono stati) molto più comuni.</p>
<h5 id="imposizione-134">Imposizione</h5>
<p>Segnalare l’uso di <code>final</code>.</p>
<h3 id="c.140-non-fornire-argomenti-di-default-diversi-a-una-funzione-virtuale-e-a-una-sovrapposta-overrider"><a name="Rh-virtual-default-arg"></a>C.140: Non fornire argomenti di default diversi a una funzione virtuale e a una sovrapposta [overrider]</h3>
<h5 id="motivo-143">Motivo</h5>
<p>Questo può confondere: Un [overrider] non eredita gli argomenti di default.</p>
<h5 id="esempio-cattivo-59">Esempio, cattivo</h5>
<pre><code>class Base {
public:
virtual int multiply(int value, int factor = 2) = 0;
virtual ~Base() = default;
};

class Derived : public Base {
public:
int multiply(int value, int factor = 10) override;
};

Derived d;
Base&amp; b = d;

b.multiply(10);  // queste due chiamate chiameranno la stessa funzione ma
d.multiply(10);  // con argomenti diversi e quindi risultati diversi</code></pre>
<h5 id="imposizione-135">Imposizione</h5>
<p>Segnalare gli argomenti di default delle funzioni virtuali se le dichiarazioni differiscono tra quelli della base e quelli della derivata.</p>
<h2 id="c.hier-access-accesso-agli-oggetti-di-una-gerarchia">C.hier-access: Accesso agli oggetti di una gerarchia</h2>
<h3 id="c.145-accedere-agli-oggetti-polimorfici-tramite-puntatori-e-riferimenti"><a name="Rh-poly"></a>C.145: Accedere agli oggetti polimorfici tramite puntatori e riferimenti</h3>
<h5 id="motivo-144">Motivo</h5>
<p>Se si ha una classe con una funzione virtuale, non si sa (in generale) da quale classe proviene la funzione da utilizzare.</p>
<h5 id="esempio-124">Esempio</h5>
<pre><code>struct B { int a; virtual int f(); virtual ~B() = default };
struct D : B { int b; int f() override; };

void use(B b)
{
D d;
B b2 = d;   // spaccatura [slice]
B b3 = b;
}

void use2()
{
D d;
use(d);   // spaccatura [slice]
}</code></pre>
<p>Entrambe le <code>d</code> vengono spaccate [sliced].</p>
<h5 id="eccezione-25">Eccezione</h5>
<p>Si può accedere con sicurezza ad un oggetto polimorfico nello scope della sua definizione, ma senza spaccarlo [slice].</p>
<pre><code>void use3()
{
D d;
d.f();   // OK
}</code></pre>
<h5 id="si-veda-anche-1">Si veda anche</h5>
<p><a href="#Rc-copy-virtual">Una classe polimorfica dovrebbe sopprimere la copia</a></p>
<h5 id="imposizione-136">Imposizione</h5>
<p>Segnalare tutte le spaccature [slicing].</p>
<h3 id="c.146-usare-il-dynamic_cast-dove-è-inevitabile-la-navigazione-della-gerarchia-della-classe"><a name="Rh-dynamic_cast"></a>C.146: Usare il <code>dynamic_cast</code> dove è inevitabile la navigazione della gerarchia della classe</h3>
<h5 id="motivo-145">Motivo</h5>
<p>Il <code>dynamic_cast</code> viene controllato a run time.</p>
<h5 id="esempio-125">Esempio</h5>
<pre><code>struct B {   // un&#39;interfaccia
virtual void f();
virtual void g();
virtual ~B();
};

struct D : B {   // un&#39;interfaccia più ampia
void f() override;
virtual void h();
};

void user(B* pb)
{
if (D* pd = dynamic_cast&lt;D*&gt;(pb)) {
// ... usa l&#39;interfaccia di D ...
}
else {
// ... si arrangia con l&#39;interfaccia di B ...
}
}</code></pre>
<p>L’uso degli altri cast può violare la sicurezza sul tipo e causare l’accesso del programma ad una variabile che in effetti è di tipo <code>X</code> come se fosse un tipo <code>Z</code> non correlato:</p>
<pre><code>void user2(B* pb)   // bad
{
D* pd = static_cast&lt;D*&gt;(pb);    // Lo so che pb in effetti punta a un D; fidatevi
// ... usa l&#39;interfaccia di D ...
}

void user3(B* pb)    // non sicuro
{
if (some_condition) {
D* pd = static_cast&lt;D*&gt;(pb);   // Lo so che pb in effetti punta a un D; credetemi
// ... usa l&#39;interfaccia di D ...
}
else {
// ... si accontenta dell&#39;interfaccia di B ...
}
}

void f()
{
B b;
user(&amp;b);   // OK
user2(&amp;b);  // cattivo errore
user3(&amp;b);  // OK *se* il programmatore ha il diritto di controllo su some_condition
}</code></pre>
<h5 id="note-160">Note</h5>
<p>Come per altri cast, si <code>dynamic_cast</code> se ne è abusato. <a href="#Rh-use-virtual">Preferire le funzioni virtuali al casting</a>. Preferire lo <a href="#???">static polymorphism</a> alla navigazione nella gerarchia dove possibile (non è necessaria alcuna risoluzione a run-time) e ragionevolmente conveniente.</p>
<h5 id="note-161">Note</h5>
<p>Alcune persone usano <code>dynamic_cast</code> dove sarebbe più appropriato un <code>typeid</code>; il <code>dynamic_cast</code> è un “tipo di operazione” generale per scoprire l’interfaccia migliore per un oggetto, mentre il <code>typeid</code> è un’operazione “dammi il tipo esatto di questo oggetto” operazione per scoprire l’effettivo tipo di un oggetto. Quest’ultima è un’operazione intrinsecamente più semplice dovrebbe essere più veloce. Quest’ultima (<code>typeid</code>) è facilmente realizzabile a mano se necessario (p.es., se si lavora su un sistema in cui l’RTTI (Run-Time Type Information) è - per qualche motivo – proibito -), la prima (<code>dynamic_cast</code>) è molto più difficile da implementare correttamente in generale.</p>
<p>Si consideri:</p>
<pre><code>struct B {
const char* name {&quot;B&quot;};
// Se pb1-&gt;id() == pb2-&gt;id() *pb1 è lo stesso tipo di *pb2
virtual const char* id() const { return name; }
// ...
};

struct D : B {
const char* name {&quot;D&quot;};
const char* id() const override { return name; }
// ...
};

void use()
{
B* pb1 = new B;
B* pb2 = new D;

cout &lt;&lt; pb1-&gt;id(); // &quot;B&quot;
cout &lt;&lt; pb2-&gt;id(); // &quot;D&quot;


if (pb1-&gt;id() == &quot;D&quot;) {         // looks innocent
D* pd = static_cast&lt;D*&gt;(pb1);
// ...
}
// ...
}</code></pre>
<p>Il risultato di <code>pb2-&gt;id() == "D"</code> è in effetti definito dall’implementazione. L’abbiamo aggiunto per porre l’accento sui pericoli dell’RTTI (Run-Time Type Information) fatto in casa. Questo codice potrebbe funzionare come previsto per anni, fallisce solo su una nuova macchina, un nuovo compilatore o un nuovo new linker che non unifica i caratteri letterali.</p>
<p>Se si implementa la propria RTTI, si faccia attenzione.</p>
<h5 id="eccezione-26">Eccezione</h5>
<p>Se la propria implementazione ha un <code>dynamic_cast</code> particolarmente lento, si potrebbe dover usare una soluzione alternativa. Tuttavia, tutte le soluzioni alternative che non possono essere risolte staticamente comportano il cast esplicito (solitamente <code>static_cast</code>) e sono soggette a errori. Fondamentalmente si realizzerà il proprio <code>dynamic_cast</code> speciale. Quindi, per prima cosa ci si assicura che il proprio <code>dynamic_cast</code> sia davvero lento come si suppone (ci sono un discreto numero di commenti non supportati a proposito) e che il proprio uso del <code>dynamic_cast</code> richieda realmente delle prestazioni elevate.</p>
<p>Riteniamo che le attuali implementazioni di <code>dynamic_cast</code> siano inutilmente lente. Ad esempio, in condizioni adeguate, è possibile eseguire un <code>dynamic_cast</code> in un <a href="http://www.stroustrup.com/fast_dynamic_casting.pdf">rapido tempo costante</a>. Tuttavia, la compatibilità rende difficili le modifiche anche se tutti concordano sul fatto che sarebbe utile uno sforzo per ottimizzare.</p>
<p>In rarissimi casi, se si è constatato un sensibile overhead del <code>dynamic_cast</code>, si hanno altri mezzi per garantire staticamente che un downcast abbia successo (p.es., usando attentamente il CRTP [Curiously Recurring Template Pattern]), e che non vi sia implicata nessuna ereditarietà virtuale, si consideri di ricorrere tatticamente ad uno <code>static_cast</code> con un evidente commento e disclaimer che riassuma questo paragrafo e che è necessaria una notevole attenzione umana per la manutenzione perché il sistema dei tpi non può verificare la correttezza. Anche così, nella nostra esperienza, queste situazioni tipo “Io so quello che faccio” restano fonti di errori.</p>
<h5 id="eccezione-27">Eccezione</h5>
<p>Si consideri:</p>
<pre><code>template&lt;typename B&gt;
class Dx : B {
// ...
};</code></pre>
<h5 id="imposizione-137">Imposizione</h5>
<ul>
<li>Segnalare tutti gli usi di <code>static_cast</code> per i downcast, compresi i cast C-style che eseguono uno <code>static_cast</code>.</li>
<li>Questa regola fa parte del <a href="#Pro-type-downcast">profilo di sicurezza del tipo</a>.</li>
</ul>
<h3 id="c.147-usare-il-dynamic_cast-per-un-tipo-di-riferimento-quando-la-non-riuscita-della-ricerca-della-classe-richiesta-è-considerata-un-errore"><a name="Rh-ref-cast"></a>C.147: Usare il <code>dynamic_cast</code> per un tipo di riferimento quando la non riuscita della ricerca della classe richiesta è considerata un errore</h3>
<h5 id="motivo-146">Motivo</h5>
<p>Il cast su un riferimento esprime l’intenzione di finire con un oggetto valido, quindi il cast deve avere successo. Il <code>dynamic_cast</code> solleverà un errore se fallirà.</p>
<h5 id="esempio-126">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="imposizione-138">Imposizione</h5>
<p>???</p>
<h3 id="c.148-usare-dynamic_cast-per-un-tipo-di-puntatore-quando-la-non-riuscita-della-ricerca-della-classe-richiesta-è-considerata-una-alternativa-valida"><a name="Rh-ptr-cast"></a>C.148: Usare <code>dynamic_cast</code> per un tipo di puntatore quando la non riuscita della ricerca della classe richiesta è considerata una alternativa valida</h3>
<h5 id="motivo-147">Motivo</h5>
<p>La conversione <code>dynamic_cast</code> consente di verificare se un puntatore punta ad un oggetto polimorfico che ha una determinata classe nella sua gerarchia. Dato che quando fallisce nel trovare la classe restituisce semplicemente un valore nullo, lo si può testare a run time. Questo consente di scrivere codice in grado di scegliere percorsi alternativi a seconda dei risultati.</p>
<p>In contrapposizione con la <a href="#Rh-ptr-cast">C.147</a>, dove il fallimento è un errore e non si si deve usare per l’esecuzione condizionale.</p>
<h5 id="esempio-127">Esempio</h5>
<p>L’esempio seguente descrive la funzione <code>add</code> di uno <code>Shape_owner</code> che diventa proprietario degli oggetti <code>Shape</code> costruiti. Gli oggetti vengono anche ordinati in viste, a seconda dei loro attributi geometrici. In questo esempio, <code>Shape</code> non eredita da <code>Geometric_attributes</code>. Lo fanno solo le sue sottoclassi.</p>
<pre><code>void add(Shape* const item)
{
// La proprietà viene sempre acquisita
owned_shapes.emplace_back(item);

// Controlla i Geometric_attributes ed aggiunge la shape a nessuna/una/qualche/tutte le viste

if (auto even = dynamic_cast&lt;Even_sided*&gt;(item))
{
view_of_evens.emplace_back(even);
}

if (auto trisym = dynamic_cast&lt;Trilaterally_symmetrical*&gt;(item))
{
view_of_trisyms.emplace_back(trisym);
}
}</code></pre>
<h5 id="note-162">Note</h5>
<p>Un fallimento nella ricerca della classe richiesta farà sì che <code>dynamic_cast</code> restituisca un valore nullo e la de-referenziazione di un puntatore null porterà ad un comportamento indefinito. Quindi, il risultato della <code>dynamic_cast</code> deve sempre essere trattato come se potesse contenere un valore nullo e testato.</p>
<h5 id="imposizione-139">Imposizione</h5>
<ul>
<li>(Complicato) A meno che non esista un test per il valore nullo del risultato di un <code>dynamic_cast</code> di un tipo di puntatore, avvisare in caso di de-referenziazione del puntatore.</li>
</ul>
<h3 id="c.149-usare-unique_ptr-o-shared_ptr-per-evitare-di-dimenticarsi-il-delete-degli-oggetti-creati-con-new"><a name="Rh-smart"></a>C.149: Usare <code>unique_ptr</code> o <code>shared_ptr</code> per evitare di dimenticarsi il <code>delete</code> degli oggetti creati con <code>new</code></h3>
<h5 id="motivo-148">Motivo</h5>
<p>Evitare perdite [leak] di risorse.</p>
<h5 id="esempio-128">Esempio</h5>
<pre><code>void use(int i)
{
auto p = new int {7};           // bad: inizializza i puntatori locali con new
auto q = make_unique&lt;int&gt;(9);   // ok: garantire il rilascio della memoria allocata per 9
if (0 &lt; i) return;              // forse ritorna e si ha un leak
delete p;                       // troppo tardi
}</code></pre>
<h5 id="imposizione-140">Imposizione</h5>
<ul>
<li>Segnalare l’inizializzazione di un puntatore ‘nudo’ [naked] col risultato di un <code>new</code></li>
<li>Segnalare il <code>delete</code> di variabili locali</li>
</ul>
<h3 id="c.150-usare-make_unique-per-costruire-oggetti-posseduti-dagli-unique_ptr"><a name="Rh-make_unique"></a>C.150: Usare <code>make_unique()</code> per costruire oggetti posseduti dagli <code>unique_ptr</code></h3>
<h5 id="motivo-149">Motivo</h5>
<p><code>make_unique</code> fornisce una dichiarazione più concisa della costruzione. Garantisce inoltre la sicurezza delle eccezioni in espressioni complesse.</p>
<h5 id="esempio-129">Esempio</h5>
<pre><code>unique_ptr&lt;Foo&gt; p {new Foo{7}};    // OK: ma ripetitivo

auto q = make_unique&lt;Foo&gt;(7);      // Meglio: nessuna ripetizione di Foo

// Non è exception-safe: il compilatore può intercalare i calcoli degli argomenti nel segue modo:
//
// 1. alloca memoria per Foo,
// 2. costruisce Foo,
// 3. chiama bar,
// 4. costruisce unique_ptr&lt;Foo&gt;.
//
// Se bar va in errore, Foo non verrà distrutto e la memoria allocata per esso verrà persa [leak].
f(unique_ptr&lt;Foo&gt;(new Foo()), bar());

// Exception-safe: le chiamate a funzioni non sono mai intercalate.
f(make_unique&lt;Foo&gt;(), bar());</code></pre>
<h5 id="imposizione-141">Imposizione</h5>
<ul>
<li>Segnalare l’uso ripetitivo di liste si specializzazioni di template <code>&lt;Foo&gt;</code></li>
<li>Segnalare le variabili dichiarate per essere <code>unique_ptr&lt;Foo&gt;</code></li>
</ul>
<h3 id="c.151-usare-make_shared-per-costruire-oggetti-posseduti-dagli-shared_ptr"><a name="Rh-make_shared"></a>C.151: Usare <code>make_shared()</code> per costruire oggetti posseduti dagli <code>shared_ptr</code></h3>
<h5 id="motivo-150">Motivo</h5>
<p><code>make_shared</code> fornisce un’istruzione più concisa della costruzione. Offre inoltre l’opportunità di eliminare un’allocazione separata per i conteggi dei riferimento, posizionando il conteggio di <code>shared_ptr</code> vicino al proprio oggetto.</p>
<h5 id="esempio-130">Esempio</h5>
<pre><code>void test() {
// OK: ma ripetitivo; e allocazioni separate per Bar e i conteggi di shared_ptr
shared_ptr&lt;Bar&gt; p {new Bar{7}};

auto q = make_shared&lt;Bar&gt;(7);   // Meglio: nessuna ripetizione di Bar; un solo oggetto
}</code></pre>
<h5 id="imposizione-142">Imposizione</h5>
<ul>
<li>Segnalare l’uso ripetitivo di liste si specializzazioni di template <code>&lt;Bar&gt;</code></li>
<li>Segnalare le variabili dichiarate per essere <code>shared_ptr&lt;Bar&gt;</code></li>
</ul>
<h3 id="c.152-mai-assegnare-un-puntatore-ad-un-array-di-oggetti-di-classi-derivate-a-un-puntatore-alla-sua-classe-base"><a name="Rh-array"></a>C.152: Mai assegnare un puntatore ad un array di oggetti di classi derivate a un puntatore alla sua classe base</h3>
<h5 id="motivo-151">Motivo</h5>
<p>Indicizzando [Subscripting] il puntatore base risultante porterà ad accedere ad un oggetto invalido e probabilmente alla corruzione della memoria.</p>
<h5 id="esempio-131">Esempio</h5>
<pre><code>struct B { int x; };
struct D : B { int y; };

void use(B*);

D a[] = {{1, 2}, {3, 4}, {5, 6}};
B* p = a;     // bad: a decade in &amp;a[0] che viene convertito in un B*
p[1].x = 7;   // sovrascrive D[0].y

use(a);       // bad: a decade in &amp;a[0] che è convertito in un B*</code></pre>
<h5 id="imposizione-143">Imposizione</h5>
<ul>
<li>Segnalare tutte le combinazioni di decadimenti e basi di array in conversioni derivate.</li>
<li>Si passa un array come uno <code>span</code> anziché un puntatore e non si lascia che il nome dell’array subisca una conversione derivata-dalla-base prima di accedere allo <code>span</code></li>
</ul>
<h3 id="c.153-preferire-la-funzione-virtual-al-casting"><a name="Rh-use-virtual"></a>C.153: Preferire la funzione virtual al casting</h3>
<h5 id="motivo-152">Motivo</h5>
<p>Una chiamata a una funzione virtuale è sicura, mentre il casting è soggetto a errori. Una chiamata a una funzione virtuale raggiunge le funzioni più derivate, mentre un cast può raggiungere una classe intermedia dando, quindi, un risultato sbagliato (specialmente durante la modifica per manutenzione di una gerarchia).</p>
<h5 id="esempio-132">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="imposizione-144">Imposizione</h5>
<p>Cfr. <a href="#Rh-dynamic_cast">C.146</a> e ???</p>
<h2 id="c.over-operatori-di-sovraccarico-overloading-e-sovraccaricati"><a name="SS-overload"></a>C.over: Operatori di sovraccarico [overloading] e sovraccaricati</h2>
<p>Si possono sovraccaricare le normali funzioni, le funzioni template e gli operatori. Non si possono sovraccaricare gli oggetti funzione.</p>
<p>Riepilogo delle regole dell’overloading:</p>
<ul>
<li><a href="#Ro-conventional">C.160: Definire gli operatori soprattutto per imitare l’uso convenzionale</a></li>
<li><a href="#Ro-symmetric">C.161: Utilizzare le funzioni non-membro per gli operatori simmetrici</a></li>
<li><a href="#Ro-equivalent">C.162: Sovraccaricare le operazioni che sono approssimativamente equivalenti</a></li>
<li><a href="#Ro-equivalent-2">C.163: Sovraccaricare solo le operazioni che sono approssimativamente equivalenti</a></li>
<li><a href="#Ro-conversion">C.164: Evitare la conversione implicita degli operatori</a></li>
<li><a href="#Ro-custom">C.165: Utilizzare <code>using</code> per i punti di personalizzazione</a></li>
<li><a href="#Ro-address-of">C.166: Eseguire l’overloading del <code>&amp;</code> unario solo come parte di un sistema di smart pointer e riferimenti</a></li>
<li><a href="#Ro-overload">C.167: Utilizzare un operatore per un’operazione con un significato convenzionale</a></li>
<li><a href="#Ro-namespace">C.168: Definire gli operatori sovraccaricati nel namespace dei loro operandi</a></li>
<li><a href="#Ro-lambda">C.170: Se si vuole sovraccaricare una lambda, si usi una lambda generica</a></li>
</ul>
<h3 id="c.160-definire-gli-operatori-principalmente-per-imitare-luso-convenzionale"><a name="Ro-conventional"></a>C.160: Definire gli operatori principalmente per imitare l’uso convenzionale</h3>
<h5 id="motivo-153">Motivo</h5>
<p>Ridurre le sorprese.</p>
<h5 id="esempio-133">Esempio</h5>
<pre><code>class X {
public:
// ...
X&amp; operator=(const X&amp;); // funzione membro che definisce l&#39;assegnazione
friend bool operator==(const X&amp;, const X&amp;); // == necessita dell&#39;accesso alla rappresentazione
// dopo a = b abbiamo a == b
// ...
};</code></pre>
<p>Qui viene mantenuta la semantica convenzionale: <a href="#SS-copy">Le copie sono uguali</a>.</p>
<h5 id="esempio-cattivo-60">Esempio, cattivo</h5>
<pre><code>X operator+(X a, X b) { return a.v - b.v; }   // bad: fa sì che + sottragga</code></pre>
<h5 id="note-163">Note</h5>
<p>Gli operatori non-membri devono essere definiti friend o definiti nello <a href="#Ro-namespace">stesso namespace dei loro operandi</a>. <a href="#Ro-symmetric">Gli operatori binari dovrebbero trattare i loro operandi in modo equivalente</a>.</p>
<h5 id="imposizione-145">Imposizione</h5>
<p>Forse impossibile.</p>
<h3 id="c.161-utilizzare-le-funzioni-non-membro-per-gli-operatori-simmetrici"><a name="Ro-symmetric"></a>C.161: Utilizzare le funzioni non-membro per gli operatori simmetrici</h3>
<h5 id="motivo-154">Motivo</h5>
<p>Se si usano le funzioni membro, ne servono due. A meno che non si usi una funzione non membro per (diciamo) <code>==</code>, <code>a == b</code> e <code>b == a</code> sarà leggermente diverso.</p>
<h5 id="esempio-134">Esempio</h5>
<pre><code>bool operator==(Point a, Point b) { return a.x == b.x &amp;&amp; a.y == b.y; }</code></pre>
<h5 id="imposizione-146">Imposizione</h5>
<p>Segnalare le funzioni operatore membro.</p>
<h3 id="c.162-sovraccaricare-le-operazioni-che-sono-approssimativamente-equivalenti"><a name="Ro-equivalent"></a>C.162: Sovraccaricare le operazioni che sono approssimativamente equivalenti</h3>
<h5 id="motivo-155">Motivo</h5>
<p>Avere dei nomi diversi per operazioni logicamente equivalenti su diversi tipi di argomenti confonde, induce alla codifica del tipo delle informazioni nei nomi delle funzioni e impedisce la programmazione generica.</p>
<h5 id="esempio-135">Esempio</h5>
<p>Si consideri:</p>
<pre><code>void print(int a);
void print(int a, int base);
void print(const string&amp;);</code></pre>
<p>Queste tre funzioni stampano (correttamente) i rispettivi argomenti. Al contrario:</p>
<pre><code>void print_int(int a);
void print_based(int a, int base);
void print_string(const string&amp;);</code></pre>
<p>Queste tre funzioni stampano (correttamente) i rispettivi argomenti. Le aggiunte ai nomi aggiungono verbosità ed impediscono un codice generico.</p>
<h5 id="imposizione-147">Imposizione</h5>
<p>???</p>
<h3 id="c.163-sovraccaricare-solo-le-operazioni-che-sono-approssimativamente-equivalenti"><a name="Ro-equivalent-2"></a>C.163: Sovraccaricare solo le operazioni che sono approssimativamente equivalenti</h3>
<h5 id="motivo-156">Motivo</h5>
<p>Avere lo stesso nome per funzioni logicamente diverse è fonte di confusione e causa errori durante l’uso della programmazione generica.</p>
<h5 id="esempio-136">Esempio</h5>
<p>Si consideri:</p>
<pre><code>void open_gate(Gate&amp; g);   // apre la porta del garage
void fopen(const char* name, const char* mode);   // apre un file</code></pre>
<p>Le due operazioni sono fondamentalmente diverse (e non correlate), quindi è bene che i loro nomi differiscano. Al contrario:</p>
<pre><code>void open(Gate&amp; g);   // apre la porta del garage
void open(const char* name, const char* mode =&quot;r&quot;);   // apre un file</code></pre>
<p>Le due operazioni continuano ad essere diverse (e non correlate) ma i nomi sono stati ridotti al minimo (comune), aprendo la strada alla confusione. Fortunatamente, il sistema dei tipi rileverà molti di questi errori.</p>
<h5 id="note-164">Note</h5>
<p>Porre particolare attenzione ai nomi comuni e popolari, come <code>open</code>, <code>move</code>, <code>+</code>, e <code>==</code>.</p>
<h5 id="imposizione-148">Imposizione</h5>
<p>???</p>
<h3 id="c.164-evitare-la-conversione-implicita-degli-operatori"><a name="Ro-conversion"></a>C.164: Evitare la conversione implicita degli operatori</h3>
<h5 id="motivo-157">Motivo</h5>
<p>Le conversioni implicite possono essere essenziali (p.es., da <code>double</code> a <code>int</code>) ma spesso causano sorprese (p.es., da <code>String</code> a stringhe C-style).</p>
<h5 id="note-165">Note</h5>
<p>Preferire le conversioni con un nome esplicito finché non appare una seria esigenza. Per “seria esigenza” si intende un motivo fondamentale e frequente nel dominio dell’applicazione (come una conversione di numeri interi in numeri complessi). Non introdurre conversioni implicite (tramite operatori di conversione o costruttori non-<code>espliciti</code>) solo per una minima comodità.</p>
<h5 id="esempio-137">Esempio</h5>
<pre><code>struct S1 {
string s;
// ...
operator char*() { return s.data(); }  // BAD, potrebbe causare sorprese
};

struct S2 {
string s;
// ...
explicit operator char*() { return s.data(); }
};

void f(S1 s1, S2 s2)
{
char* x1 = s1;     // OK, ma può causare sorprese in molti contesti
char* x2 = s2;     // errore (e di solito è una cosa buona)
char* x3 = static_cast&lt;char*&gt;(s2); // possiamo essere espliciti (se si è certi)
}</code></pre>
<p>Una conversione implicita inaspettata e potenzialmente dannosa può capitare in contesti arbitrariamente difficili da individuare, p.es.,</p>
<pre><code>S1 ff();

char* g()
{
return ff();
}</code></pre>
<p>La stringa restituita da <code>ff()</code> viene distrutta prima che che si possa utilizzare il puntatore restituito.</p>
<h5 id="imposizione-149">Imposizione</h5>
<p>Segnalare tutti gli operatori di conversione.</p>
<h3 id="c.165-utilizzare-using-per-i-punti-di-personalizzazione"><a name="Ro-custom"></a>C.165: Utilizzare <code>using</code> per i punti di personalizzazione</h3>
<h5 id="motivo-158">Motivo</h5>
<p>Per trovare oggetti funzione e funzioni definite in un diverso namespace per “personalizzare” una funzione in comune.</p>
<h5 id="esempio-138">Esempio</h5>
<p>Si consideri <code>swap</code>. È una funzione generica (libreria standard) con una definizione che funzionerà praticamente per qualsiasi tipo. Tuttavia, è preferibile definire degli <code>swap()</code> specifici per dei particolari tipi. Per esempio, la <code>swap()</code> generica, copierà gli elementi di due <code>vector</code> da scambiare, mentre una buona e specifica implementazione non copierà affatto gli elementi.</p>
<pre><code>namespace N {
My_type X { /* ... */ };
void swap(X&amp;, X&amp;);   // swap ottimizzato per N::X
// ...
}

void f1(N::X&amp; a, N::X&amp; b)
{
std::swap(a, b);   // probabilmente non è quello che si voleva: chiama std::swap()
}</code></pre>
<p>La <code>std::swap()</code> in <code>f1()</code> fa esattamente quello che le si chiede di fare: chiama la <code>swap()</code> nel namespace <code>std</code>. Sfortunatamente, è probabile che non sia ciò che si vuole. Come si può prendere in considerazione <code>N::X</code>?</p>
<pre><code>void f2(N::X&amp; a, N::X&amp; b)
{
swap(a, b);   // chiama N::swap
}</code></pre>
<p>Ma potrebbe non essere la cosa desiderata per il codice generico. Lì, in genere si vuole la funzione specifica, se esiste, altrimenti la funzione generica. Questo si ottiene includendo la funzione generale nella ricerca per la funzione:</p>
<pre><code>void f3(N::X&amp; a, N::X&amp; b)
{
using std::swap;  // mette a disposizione std::swap
swap(a, b);        // chiama N::swap se esiste altrimenti std::swap
}</code></pre>
<h5 id="imposizione-150">Imposizione</h5>
<p>Improbabile, ad eccezione dei punti di personalizzazione noti, come in <code>swap</code>. Il problema è che sono plausibili entrambe le versioni.</p>
<h3 id="c.166-eseguire-loverloading-del-unario-solo-come-parte-di-un-sistema-di-smart-pointer-e-riferimenti"><a name="Ro-address-of"></a>C.166: Eseguire l’overloading del <code>&amp;</code> unario solo come parte di un sistema di smart pointer e riferimenti</h3>
<h5 id="motivo-159">Motivo</h5>
<p>L’operatore <code>&amp;</code> è fondamentale in C++. Molte parti della semantica del C++ ne presuppongono il significato di default.</p>
<h5 id="esempio-139">Esempio</h5>
<pre><code>class Ptr { // uno smart pointer
Ptr(X* pp) :p(pp) { /* check */ }
X* operator-&gt;() { /* check */ return p; }
X operator[](int i);
X operator*();
private:
T* p;
};

class X {
Ptr operator&amp;() { return Ptr{this}; }
// ...
};</code></pre>
<h5 id="note-166">Note</h5>
<p>Se si “pasticcia” con l’operatore <code>&amp;</code> ci si assicuri che la sua definizione abbia dei significati corrispondenti per <code>-&gt;</code>, <code>[]</code>, <code>*</code>, e <code>.</code> sul tipo di risultato. Si noti che l’operatore <code>.</code> al momento non può essere sovraccaricato, quindi un sistema perfetto è impossibile. Speriamo di porre rimedio a questo: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf" class="uri">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf</a>. Si noti che <code>std::addressof()</code> produce sempre un puntatore built-in.</p>
<h5 id="imposizione-151">Imposizione</h5>
<p>Difficile. Avvertire se <code>&amp;</code> è definito dall’utente senza definire anche <code>-&gt;</code> per il tipo di risultato.</p>
<h3 id="c.167-utilizzare-un-operatore-per-unoperazione-con-un-significato-convenzionale"><a name="Ro-overload"></a>C.167: Utilizzare un operatore per un’operazione con un significato convenzionale</h3>
<h5 id="motivo-160">Motivo</h5>
<p>Leggibilità. Convenzione. Riusabilità. Supporto per la programmazione generica</p>
<h5 id="esempio-140">Esempio</h5>
<pre><code>void cout_my_class(const My_class&amp; c) // confuso, non convenzionale, non generico
{
std::cout &lt;&lt; /* qui i membri della classe */;
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const my_class&amp; c) // OK
{
return os &lt;&lt; /* qui i membri della classe */;
}</code></pre>
<p>Di per sé, <code>cout_my_class</code> sarebbe OK, ma non è utilizzabile/componibile col codice basato sulla convenzione di <code>&lt;&lt;</code> per l’output:</p>
<pre><code>My_class var { /* ... */ };
// ...
cout &lt;&lt; &quot;var = &quot; &lt;&lt; var &lt;&lt; &#39;\n&#39;;</code></pre>
<h5 id="note-167">Note</h5>
<p>Ci sono convenzioni forti e resistenti per il significato della maggior parte degli operatori, come ad esempio</p>
<ul>
<li>confronti (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, e <code>&gt;=</code>),</li>
<li>operazioni aritmetiche (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, e <code>%</code>)</li>
<li>operazioni di accesso (<code>.</code>, <code>-&gt;</code>, <code>*</code> unario, e <code>[]</code>)</li>
<li>assegnazione (<code>=</code>)</li>
</ul>
<p>Non definire questi in modo non convenzionale e non inventarsi altri nomi per loro.</p>
<h5 id="imposizione-152">Imposizione</h5>
<p>Difficile. Richiede un’analisi semantica.</p>
<h3 id="c.168-definire-gli-operatori-sovraccaricati-nel-namespace-dei-loro-operandi"><a name="Ro-namespace"></a>C.168: Definire gli operatori sovraccaricati nel namespace dei loro operandi</h3>
<h5 id="motivo-161">Motivo</h5>
<p>Leggibilità. Capacità di trovare gli operatori con l’ADL (Argument-dependent lookup). Evitare definizioni incoerenti nei diversi namespace</p>
<h5 id="esempio-141">Esempio</h5>
<pre><code>struct S { };
bool operator==(S, S);   // OK: nello stesso namespace di S, ed anche dopo S
S s;

bool x = (s == s);</code></pre>
<p>Questo è ciò che farebbe l’operatore <code>==</code> di default, se avessimo quei default.</p>
<h5 id="esempio-142">Esempio</h5>
<pre><code>namespace N {
struct S { };
bool operator==(S, S);   // OK: nello stesso namespace di S, ed anche dopo S
}

N::S s;

bool x = (s == s);  // cerca N::operator==() per l&#39;ADL</code></pre>
<h5 id="esempio-cattivo-61">Esempio, cattivo</h5>
<pre><code>struct S { };
S s;

namespace N {
S::operator!(S a) { return true; }
S not_s = !s;
}

namespace M {
S::operator!(S a) { return false; }
S not_s = !s;
}</code></pre>
<p>Qui , il significato di <code>!s</code> differisce tra <code>N</code> e <code>M</code>. Ciò può risultare molto confuso. Eliminando la definizione di <code>namespace M</code> la confusione si trasforma nella possibilità di commettere un errore.</p>
<h5 id="note-168">Note</h5>
<p>Se un operatore binario è definito per due tipi definiti diversamente in diversi namespace, non si può seguire questa regola. Per esempio:</p>
<pre><code>Vec::Vector operator*(const Vec::Vector&amp;, const Mat::Matrix&amp;);</code></pre>
<p>Potrebbe essere qualcosa da evitare.</p>
<h5 id="si-veda-anche-2">Si veda anche</h5>
<p>Questo è un caso speciale della regola secondo cui <a href="#Rc-helper">le funzioni helper dovrebbero essere definite nello stesso namespace delle loro classi</a>.</p>
<h5 id="imposizione-153">Imposizione</h5>
<ul>
<li>Segnalare le definizioni degli operatori che non stanno nello stesso namespace dei loro operandi</li>
</ul>
<h3 id="c.170-se-si-vuole-sovraccaricare-una-lambda-si-usi-una-lambda-generica"><a name="Ro-lambda"></a>C.170: Se si vuole sovraccaricare una lambda, si usi una lambda generica</h3>
<h5 id="motivo-162">Motivo</h5>
<p>Non si può eseguire l’overload definendo due lambda con lo stesso nome.</p>
<h5 id="esempio-143">Esempio</h5>
<pre><code>void f(int);
void f(double);
auto f = [](char);   // errore: non si può avere l&#39;overload della variabile e della funzione

auto g = [](int) { /* ... */ };
auto g = [](double) { /* ... */ };   // errore: non si può avere l&#39;overload di variabili

auto h = [](auto) { /* ... */ };   // OK</code></pre>
<h5 id="imposizione-154">Imposizione</h5>
<p>Il compilatore intercetta i tentativi di overload di una lambda.</p>
<h2 id="c.union-unioni"><a name="SS-union"></a>C.union: Unioni</h2>
<p>Una <code>union</code> è una <code>struct</code> dove tutti i membri iniziano nello stesso indirizzo e quindi potrà contenere un solo membro per volta. Una <code>union</code> non tiene traccia di quale sia il membro che contiene quindi dev’essere il programmatore a prelevare quello giusto; ciò è intrinsecamente soggetto ad errori, ma ci sono dei modi per compensare.</p>
<p>Un tipo che è una <code>union</code> più un qualcosa che segnali il membro attualmente contenuto è chiamato <em>tagged union</em>, <em>discriminated union</em>, o un <em>variant</em>.</p>
<p>Riepilogo delle regole sull’union:</p>
<ul>
<li><a href="#Ru-union">C.180: Usare le <code>union</code> per risparmiare Memoria</a></li>
<li><a href="#Ru-naked">C.181: Evitare <code>union</code>i “nude”</a></li>
<li><a href="#Ru-anonymous">C.182: Usare <code>union</code>i anonime per implementare le tagged union</a></li>
<li><a href="#Ru-pun">C.183: Non usare una <code>union</code> per il “type punning”</a></li>
<li>???</li>
</ul>
<h3 id="c.180-usare-le-union-per-risparmiare-memoria"><a name="Ru-union"></a>C.180: Usare le <code>union</code> per risparmiare memoria</h3>
<h5 id="motivo-163">Motivo</h5>
<p>Una <code>union</code> consente di utilizzare un singolo pezzo di memoria per diversi tipi di oggetti in tempi diversi. Di conseguenza, può essere utilizzato per risparmiare memoria quando si hanno diversi oggetti che non vengono mai utilizzati contemporaneamente.</p>
<h5 id="esempio-144">Esempio</h5>
<pre><code>union Value {
int x;
double d;
};

Value v = { 123 };  // ora v contiene un int
cout &lt;&lt; v.x &lt;&lt; &#39;\n&#39;;    // scrive 123
v.d = 987.654;  // ora v contiene un double
cout &lt;&lt; v.d &lt;&lt; &#39;\n&#39;;    // scrive 987.654</code></pre>
<p>Ma fare attenzione alla regola: <a href="#Ru-naked">Evitare <code>union</code>i “nude”</a></p>
<h5 id="esempio-145">Esempio</h5>
<pre><code>// Ottimizzazione di stringhe corte

constexpr size_t buffer_size = 16; // Leggermente più grande della dimensione di un puntatore

class Immutable_string {
public:
Immutable_string(const char* str) :
size(strlen(str))
{
if (size &lt; buffer_size)
strcpy_s(string_buffer, buffer_size, str);
else {
string_ptr = new char[size + 1];
strcpy_s(string_ptr, size + 1, str);
}
}

~Immutable_string()
{
if (size &gt;= buffer_size)
delete string_ptr;
}

const char* get_str() const
{
return (size &lt; buffer_size) ? string_buffer : string_ptr;
}

private:
// e la stringa è abbastanza corta, si memorizza la stringa stessa
// altrimenti un puntatore alla stringa.
union {
char* string_ptr;
char string_buffer[buffer_size];
};

const size_t size;
};</code></pre>
<h5 id="imposizione-155">Imposizione</h5>
<p>???</p>
<h3 id="c.181-evitare-unioni-nude"><a name="Ru-naked"></a>C.181: Evitare <code>union</code>i “nude”</h3>
<h5 id="motivo-164">Motivo</h5>
<p>Una <em>union nuda</em> è una union senza un indicatore associato di quale membro (se c’è) è contenuto, quindi dev’essere il programmatore a tenerne traccia. Le unioni nude sono fonti di errori sui tipi.</p>
<h5 id="esempio-cattivo-62">Esempio, cattivo</h5>
<pre><code>union Value {
int x;
double d;
};

Value v;
v.d = 987.654;  // v contiene un double</code></pre>
<p>Fin qui tutto bene, ma si può facilmente usare male la <code>union</code>:</p>
<pre><code>cout &lt;&lt; v.x &lt;&lt; &#39;\n&#39;;    // BAD, comportamento indefinito: v contiene un double, ma legge un int</code></pre>
<p>Si noti che l’errore sul tipo avviene senza alcun cast esplicito. Quando fu testato il programma l’ultimo valore che si ottenne fu <code>1683627180</code> che era il valore intero per la disposizione dei bit per <code>987.654</code>. Ciò che si ha qui è un “invisibile” errore sul tipo che sembra dare un risultato che potrebbe facilmente sembrare innocuo.</p>
<p>E, a proposito di “invisibile”, questo codice non produce niente in output:</p>
<pre><code>v.x = 123;
cout &lt;&lt; v.d &lt;&lt; &#39;\n&#39;;    // BAD: comportamento indefinito</code></pre>
<h5 id="alternativa-6">Alternativa</h5>
<p>Racchiudere una <code>union</code> in una classe assieme ad un campo sul tipo.</p>
<p>Il tipo <code>variant</code> del C++17 (presente in <code>&lt;variant&gt;</code>) fa al caso nostro:</p>
<pre><code>variant&lt;int, double&gt; v;
v = 123;        // v contiene un int
int x = get&lt;int&gt;(v);
v = 123.456;    // v contiene un double
w = get&lt;double&gt;(v);</code></pre>
<h5 id="imposizione-156">Imposizione</h5>
<p>???</p>
<h3 id="c.182-usare-unioni-anonime-per-implementare-le-tagged-union"><a name="Ru-anonymous"></a>C.182: Usare <code>union</code>i anonime per implementare le tagged union</h3>
<h5 id="motivo-165">Motivo</h5>
<p>Una “tagged union” ben progettata è “type safe”. Una union <em>anonima</em> semplifica la definizione di una classe con una coppia (tag, union).</p>
<h5 id="esempio-146">Esempio</h5>
<p>Questo esempio è preso in prestito da TC++PL4 pp216-218. Se ne può cercare lì una spiegazione.</p>
<p>Il codice è piuttosto elaborato. Gestire un tipo con assegnazione e distruttore definiti dall’utente è complicato.. Far risparmiare ai programmatori il dover scrivere questo codice è la ragione per includere il <code>variant</code> nello standard.</p>
<pre><code>class Value { // due alternative rappresentazioni realizzate con una union
private:
enum class Tag { number, text };
Tag type; // discriminante

union { // rappresentazione (nota: union anonima)
int i;
string s; // string ha di default il costruttore, le operazioni di copia e il distruttore
};
public:
struct Bad_entry { }; // usato per le eccezioni

~Value();
Value&amp; operator=(const Value&amp;);   // necessario a causa della variant stringa
Value(const Value&amp;);
// ...
int number() const;
string text() const;

void set_number(int n);
void set_text(const string&amp;);
// ...
};

int Value::number() const
{
if (type != Tag::number) throw Bad_entry{};
return i;
}

string Value::text() const
{
if (type != Tag::text) throw Bad_entry{};
return s;
}

void Value::set_number(int n)
{
if (type == Tag::text) {
s.~string();      // distrugge esplicitamente la stringa
type = Tag::number;
}
i = n;
}

void Value::set_text(const string&amp; ss)
{
if (type == Tag::text)
s = ss;
else {
new(&amp;s) string{ss};   // piazzamento di new: costruttore esplicito della stringa
type = Tag::text;
}
}

Value&amp; Value::operator=(const Value&amp; e)   // necessario a causa della variant stringa
{
if (type == Tag::text &amp;&amp; e.type == Tag::text) {
s = e.s;    // normale assegnazione a stringa
return *this;
}

if (type == Tag::text) s.~string(); // distruttore esplicito

switch (e.type) {
case Tag::number:
i = e.i;
break;
case Tag::text:
new(&amp;s) string(e.s);   // piazzamento di new: costruttore esplicito
}

type = e.type;
return *this;
}

Value::~Value()
{
if (type == Tag::text) s.~string(); // distruttore esplicito
}</code></pre>
<h5 id="imposizione-157">Imposizione</h5>
<p>???</p>
<h3 id="c.183-non-usare-una-union-per-il-type-punning"><a name="Ru-pun"></a>C.183: Non usare una <code>union</code> per il “type punning”</h3>
<h5 id="motivo-166">Motivo</h5>
<p>Si ha un comportamento indefinito nel leggere il membro di una <code>union</code> con un tipo diverso da quello con cui è stato scritto. Questo trucchetto è invisibile, o quanto meno più difficile da evidenziare rispetto al cast. Il “type punning” con una <code>union</code> è fonte di errori.</p>
<h5 id="esempio-cattivo-63">Esempio, cattivo</h5>
<pre><code>union Pun {
int x;
unsigned char c[sizeof(int)];
};</code></pre>
<p>L’idea di <code>Pun</code> è quella di essere in grado di vedere la rappresentazione in caratteri di un <code>int</code>.</p>
<pre><code>void bad(Pun&amp; u)
{
u.x = &#39;x&#39;;
cout &lt;&lt; u.c[0] &lt;&lt; &#39;\n&#39;;     // comportamento indefinito
}</code></pre>
<p>Se si vogliono vedere i byte di un <code>int</code>, si usa un (named) cast:</p>
<pre><code>void if_you_must_pun(int&amp; x)
{
auto p = reinterpret_cast&lt;unsigned char*&gt;(&amp;x);
cout &lt;&lt; p[0] &lt;&lt; &#39;\n&#39;;     // OK; meglio
// ...
}</code></pre>
<p>Accedere al risultato di un <code>reinterpret_cast</code> per un tipo diverso degli oggetti dichiarati è un comportamento definito (anche se <code>reinterpret_cast</code> è sconsigliato), ma almeno si può vedere che succede qualcosa di complicato.</p>
<h5 id="note-169">Note</h5>
<p>Sfortunatamente, le <code>union</code>i vengono comunemente usate per il “type punning”. Non si considera “a volte funziona come previsto” un argomento robusto.</p>
<p>Il C++17 ha introdotto un tipo diverso <code>std::byte</code> per facilitare le operazioni sulla rappresentazione grezza degli oggetti. Per queste operazioni si usi questo tipo invece di <code>unsigned char</code> o di <code>char</code>.</p>
<h5 id="imposizione-158">Imposizione</h5>
<p>???</p>
<h1 id="enum-enumerazioni"><a name="S-enum"></a>Enum: Enumerazioni</h1>
<p>Le enumerazioni si usano per definire insiemi di valori interi e per definire tipi di questi insiemi di valori. Ci sono due tipi di enumerazioni, “semplici” <code>enum</code> e <code>class enum</code>.</p>
<p>Riepilogo delle regole sulle enumerazioni:</p>
<ul>
<li><a href="#Renum-macro">Enum.1: Preferire le enumerazioni alle macro</a></li>
<li><a href="#Renum-set">Enum.2: Usare le enumerazioni per rappresentare insiemi di nomi di costanti correlate</a></li>
<li><a href="#Renum-class">Enum.3: Preferire le <code>enum class</code> alle “semplici” <code>enum</code></a></li>
<li><a href="#Renum-oper">Enum.4: Definire le operazioni sulle enumerazioni per un uso sicuro e semplice</a></li>
<li><a href="#Renum-caps">Enum.5: Non usare <code>TUTTO_IN_MAIUSCOLO</code> per gli enumeratori</a></li>
<li><a href="#Renum-unnamed">Enum.6: Evitare enumerazioni senza nome</a></li>
<li><a href="#Renum-underlying">Enum.7: Specificare il tipo sottostante di una enumerazione solo quando è necessario</a></li>
<li><a href="#Renum-value">Enum.8: Specificare i valori dell’enumeratore solo quando è necessario</a></li>
</ul>
<h3 id="enum.1-preferire-le-enumerazioni-alle-macro"><a name="Renum-macro"></a>Enum.1: Preferire le enumerazioni alle macro</h3>
<h5 id="motivo-167">Motivo</h5>
<p>Le macro non obbediscono alle regole dello scope e del tipo. Inoltre, i nomi delle macro vengono rimossi durante il preprocessing e quindi solitamente non appaiono in tool come i debugger.</p>
<h5 id="esempio-147">Esempio</h5>
<p>Un primo esempio di vecchio codice non buono:</p>
<pre><code>// webcolors.h (un header di terze parti)
#define RED   0xFF0000
#define GREEN 0x00FF00
#define BLUE  0x0000FF

// productinfo.h
// Quanto segue definisce i sottotipi di product in base al colore
#define RED    0
#define PURPLE 1
#define BLUE   2

int webby = BLUE;   // webby == 2; probabilmente non è quello desiderato</code></pre>
<p>Si usi invece un <code>enum</code>:</p>
<pre><code>enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
enum class Product_info { red = 0, purple = 1, blue = 2 };

int webby = blue;   // errore: si deve essere specifici
Web_color webby = Web_color::blue;</code></pre>
<p>Abbiamo usato un <code>enum class</code> per evitare il conflitto fra i nomi.</p>
<h5 id="imposizione-159">Imposizione</h5>
<p>Segnalare le macro che definiscono valori interi.</p>
<h3 id="enum.2-usare-le-enumerazioni-per-rappresentare-insiemi-di-nomi-di-costanti-correlate"><a name="Renum-set"></a>Enum.2: Usare le enumerazioni per rappresentare insiemi di nomi di costanti correlate</h3>
<h5 id="motivo-168">Motivo</h5>
<p>Un’enumerazione mostra la correlazione degli enumeratori e può essere un tipo con un nome.</p>
<h5 id="esempio-148">Esempio</h5>
<pre><code>enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };</code></pre>
<h5 id="note-170">Note</h5>
<p>Lo switch con una enumerazione è una cosa comune ed il compilatore può mettere in guardia da insoliti valori delle label di un case. Per esempio:</p>
<pre><code>enum class Product_info { red = 0, purple = 1, blue = 2 };

void print(Product_info inf)
{
switch (inf) {
case Product_info::red: cout &lt;&lt; &quot;red&quot;; break;
case Product_info::purple: cout &lt;&lt; &quot;purple&quot;; break;
}
}</code></pre>
<p>Questi <code>switch</code> con case mancanti sono spesso il risultato di un enumeratore aggiunto in seguito e un test insufficiente.</p>
<h5 id="imposizione-160">Imposizione</h5>
<ul>
<li>Segnalare le istruzioni <code>switch</code> dove i <code>case</code> non gestiscono tutti gli enumeratori di una enumerazione.</li>
<li>Segnalare le istruzioni <code>switch</code> dove i <code>case</code> gestiscono alcuni enumeratori di una enumerazione ma senza alcun caso di <code>default</code>.</li>
</ul>
<h3 id="enum.3-preferire-la-class-enum-alle-semplici-enum"><a name="Renum-class"></a>Enum.3: Preferire la class enum alle “semplici” enum</h3>
<h5 id="motivo-169">Motivo</h5>
<p>Per ridurre al minimo le sorprese: gli enum tradizionali vengono convertiti in int troppo rapidamente.</p>
<h5 id="esempio-149">Esempio</h5>
<pre><code>void Print_color(int color);

enum Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
enum Product_info { red = 0, purple = 1, blue = 2 };

Web_color webby = Web_color::blue;

// Chiaramente almeno una di queste chiamate è bacata.
Print_color(webby);
Print_color(Product_info::blue);</code></pre>
<p>Mentre usando una <code>enum class</code>:</p>
<pre><code>void Print_color(int color);

enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
enum class Product_info { red = 0, purple = 1, blue = 2 };

Web_color webby = Web_color::blue;
Print_color(webby);  // Errore: non si può convertire un Web_color in un int.
Print_color(Product_info::red);  // Errore: non si può convertire un Product_info in un int.</code></pre>
<h5 id="imposizione-161">Imposizione</h5>
<p>(Semplice) Avvisare di qualsiasi definizione non-class <code>enum</code>.</p>
<h3 id="enum.4-definire-le-operazioni-sulle-enumerazioni-per-un-uso-sicuro-e-semplice"><a name="Renum-oper"></a>Enum.4: Definire le operazioni sulle enumerazioni per un uso sicuro e semplice</h3>
<h5 id="motivo-170">Motivo</h5>
<p>Comodità d’uso e per evitare errori.</p>
<h5 id="esempio-150">Esempio</h5>
<pre><code>enum Day { mon, tue, wed, thu, fri, sat, sun };

Day&amp; operator++(Day&amp; d)
{
return d = (d == Day::sun) ? Day::mon : static_cast&lt;Day&gt;(static_cast&lt;int&gt;(d)+1);
}

Day today = Day::sat;
Day tomorrow = ++today;</code></pre>
<p>L’uso di uno <code>static_cast</code> non è carino, ma</p>
<pre><code>Day&amp; operator++(Day&amp; d)
{
return d = (d == Day::sun) ? Day::mon : Day{++d};    // errore
}</code></pre>
<p>è una ricorsione infinita e scrivendola senza un cast, con uno <code>switch</code> su tutti i casi è prolisso.</p>
<h5 id="imposizione-162">Imposizione</h5>
<p>Segnalare le espressioni ripetute di cast di nuovo verso una enumerazione.</p>
<h3 id="enum.5-non-usare-tutto_in_maiuscolo-per-gli-enumeratori"><a name="Renum-caps"></a>Enum.5: Non usare <code>TUTTO_IN_MAIUSCOLO</code> per gli enumeratori</h3>
<h5 id="motivo-171">Motivo</h5>
<p>Evitare conflitti con le macro.</p>
<h5 id="esempio-cattivo-64">Esempio, cattivo</h5>
<pre><code>// webcolors.h (un header di terze parti)
#define RED   0xFF0000
#define GREEN 0x00FF00
#define BLUE  0x0000FF

// productinfo.h
// Quanto segue definisce i sottotipi di product in base al colore

enum class Product_info { RED, PURPLE, BLUE };   // errore di sintassi</code></pre>
<h5 id="imposizione-163">Imposizione</h5>
<p>Segnalare gli enumeratori TUTTO_IN_MAIUSCOLO.</p>
<h3 id="enum.6-evitare-enumerazioni-senza-nome"><a name="Renum-unnamed"></a>Enum.6: Evitare enumerazioni senza nome</h3>
<h5 id="motivo-172">Motivo</h5>
<p>Se non si dà un nome ad un’enumerazione, i valori non vengono correlati</p>
<h5 id="esempio-cattivo-65">Esempio, cattivo</h5>
<pre><code>enum { red = 0xFF0000, scale = 4, is_signed = 1 };</code></pre>
<p>Questo codice non è raro nel codice scritto prima che esistessero alternative convenienti per indicare delle costanti intere.</p>
<h5 id="alternativa-7">Alternativa</h5>
<p>Usare invece i valori <code>constexpr</code>. Per esempio:</p>
<pre><code>constexpr int red = 0xFF0000;
constexpr short scale = 4;
constexpr bool is_signed = true;</code></pre>
<h5 id="imposizione-164">Imposizione</h5>
<p>Segnalare le enumerazioni senza nome.</p>
<h3 id="enum.7-specificare-il-tipo-sottostante-di-una-enumerazione-solo-quando-è-necessario"><a name="Renum-underlying"></a>Enum.7: Specificare il tipo sottostante di una enumerazione solo quando è necessario</h3>
<h5 id="motivo-173">Motivo</h5>
<p>Il default è più facile da leggere e da scrivere. <code>int</code> è il tipo intero di default. <code>int</code> è compatibile con gli <code>enum</code> del C.</p>
<h5 id="esempio-151">Esempio</h5>
<pre><code>enum class Direction : char { n, s, e, w,
ne, nw, se, sw };  // il tipo sottostante risparmia spazio

enum class Web_color : int32_t { red   = 0xFF0000,
green = 0x00FF00,
blue  = 0x0000FF };  // il tipo sottostante è ridondante</code></pre>
<h5 id="note-171">Note</h5>
<p>È necessario specificare il tipo sottostante nelle dichiarazioni “forward” [in avanti] delle enumerazioni:</p>
<pre><code>enum Flags : char;

void f(Flags);

// ....

enum flags : char { /* ... */ };</code></pre>
<h5 id="imposizione-165">Imposizione</h5>
<p>????</p>
<h3 id="enum.8-specificare-i-valori-dellenumeratore-solo-quando-è-necessario"><a name="Renum-value"></a>Enum.8: Specificare i valori dell’enumeratore solo quando è necessario</h3>
<h5 id="motivo-174">Motivo</h5>
<p>È il più semplice. Evita i valori duplicati dell’enumeratore. Col default s ha un insieme consecutivo dei valori ed è un bene per l’implementazione delle istruzioni <code>switch</code>.</p>
<h5 id="esempio-152">Esempio</h5>
<pre><code>enum class Col1 { red, yellow, blue };
enum class Col2 { red = 1, yellow = 2, blue = 2 }; // tipo
enum class Month { jan = 1, feb, mar, apr, may, jun,
jul, august, sep, oct, nov, dec }; // iniziare con 1 è convenzionale
enum class Base_flag { dec = 1, oct = dec &lt;&lt; 1, hex = dec &lt;&lt; 2 }; // insieme di bit</code></pre>
<p>È necessario specificare i valori per far corrispondere i valori convenzionali (p.es., <code>Month</code>) e dove non si desiderano valori consecutivi (p.es., per avere bit separati come in in <code>Base_flag</code>).</p>
<h5 id="imposizione-166">Imposizione</h5>
<ul>
<li>Segnalare i vluri duplicati degli enumeratori</li>
<li>Segnalare valori consecutivi esplicitamente specificati degli enumeratori</li>
</ul>
<h1 id="r-gestione-delle-risorse"><a name="S-resource"></a>R: Gestione delle risorse</h1>
<p>Questa sezione contiene regole relative alle risorse. Una risorsa è tutto ciò che deve essere acquisito e (esplicitamente o implicitamente) rilasciato, come la memoria, gli handle dei file, i socket e i lock. Il motivo per cui deve essere rilasciata è in genere che può essere scarseggiante, quindi anche un rilascio ritardato può provocare danni. L’obiettivo fondamentale è garantire che non ci siano perdite di risorse e che non si trattenga una risorsa più a lungo del necessario. Un’entità responsabile del rilascio di una risorsa è chiamata owner [proprietario].</p>
<p>Ci sono alcuni casi in cui le perdite [leaks] possono essere accettabili o addirittura ottimali: Se si sta scrivendo un programma che produce semplicemente un output basato su un input e la quantità di memoria necessaria è proporzionale alla dimensione dell’input, la strategia ottimale (per le prestazioni e la facilità di programmazione) è talvolta quella di semplicemente mai cancellare niente. Se si ha memoria sufficiente per gestire il proprio input più grande, si ha una perdita [leak], ma ci si assicuri di dare un buon messaggio di errore se si sbaglia. Qui, non teniamo conto di questi casi.</p>
<ul>
<li><p>Riepilogo delle regole sulla gestione delle risorse:</p>
<ul>
<li><a href="#Rr-raii">R.1: Gestire automaticamente le risorse utilizzando gli handle e il RAII (Resource Acquisition Is Initialization)</a></li>
<li><a href="#Rr-use-ptr">R.2: Nelle interfacce, usare puntatori semplici [raw] per denotare (solo) i singoli oggetti</a></li>
<li><a href="#Rr-ptr">R.3: Un puntatore semplice [raw] (un <code>T*</code>) non è proprietario</a></li>
<li><a href="#Rr-ref">R.4: Un riferimento [raw] (un <code>T&amp;</code>) non è proprietario</a></li>
<li><a href="#Rr-scoped">R.5: Preferire oggetti con scope, non allocare sull’heap se non necessario</a></li>
<li><a href="#Rr-global">R.6: Evitare le variabili globali non-<code>const</code></a></li>
</ul></li>
<li><p>Riepilogo delle regole di allocazione e de-allocazione:</p>
<ul>
<li><a href="#Rr-mallocfree">R.10: Evitare <code>malloc()</code> e <code>free()</code></a></li>
<li><a href="#Rr-newdelete">R.11: Evitare di chiamare esplicitamente <code>new</code> e <code>delete</code></a></li>
<li><a href="#Rr-immediate-alloc">R.12: Fornire immediatamente il risultato dell’allocazione di una risorsa ad un oggetto gestore</a></li>
<li><a href="#Rr-single-alloc">R.13: Eseguire al massimo una allocazione di risorsa esplicita in una singola istruzione</a></li>
<li><a href="#Rr-ap">R.14: Evitare parametri <code>[]</code>, preferire <code>span</code></a></li>
<li><a href="#Rr-pair">R.15: Eseguire sempre l’overload dell’accoppiata allocazione/de-allocazione</a></li>
</ul></li>
<li><p><a name="Rr-summary-smartptrs"></a>Riepilogo delle regole sugli smart pointer:</p>
<ul>
<li><a href="#Rr-owner">R.20: Utilizzare <code>unique_ptr</code> e <code>shared_ptr</code> per rappresentare il possesso</a></li>
<li><a href="#Rr-unique">R.21: Preferire <code>unique_ptr</code> a <code>shared_ptr</code> a meno che non sia necessario condividere il possesso</a></li>
<li><a href="#Rr-make_shared">R.22: Usare <code>make_shared()</code> per creare gli <code>shared_ptr</code></a></li>
<li><a href="#Rr-make_unique">R.23: Usare <code>make_unique()</code> per creare gli <code>unique_ptr</code></a></li>
<li><a href="#Rr-weak_ptr">R.24: Usare <code>std::weak_ptr</code> per interrompere i cicli di <code>shared_ptr</code></a></li>
<li><a href="#Rr-smartptrparam">R.30: Prendere gli smart pointer come parametri solo per esprimere esplicitamente la semantica della durata [lifetime]</a></li>
<li><a href="#Rr-smart">R.31: Se si hanno smart pointer non-<code>std</code>, seguire il modello base di <code>std</code></a></li>
<li><a href="#Rr-uniqueptrparam">R.32: Prendere un parametro <code>unique_ptr&lt;widget&gt;</code> per esprimere che una funzione assume la proprietà di un <code>widget</code></a></li>
<li><a href="#Rr-reseat">R.33: Prendere un parametro <code>unique_ptr&lt;widget&gt;&amp;</code> per esprimere che una funzione riposizione/restituisce [reseat] il <code>widget</code></a></li>
<li><a href="#Rr-sharedptrparam-owner">R.34: Prendere un parametro <code>shared_ptr&lt;widget&gt;</code> per esprimere che una funzione è comproprietaria</a></li>
<li><a href="#Rr-sharedptrparam">R.35: Prendere un parametro <code>shared_ptr&lt;widget&gt;&amp;</code> per esprimere che una funzione può riposizionare [reseat] lo shared pointer</a></li>
<li><a href="#Rr-sharedptrparam-const">R.36: Prendere un parametro <code>const shared_ptr&lt;widget&gt;&amp;</code> per esprimere che potrebbe conservare un conteggio dei riferimenti all’oggetto ???</a></li>
<li><a href="#Rr-smartptrget">R.37: Non passare un puntatore o un riferimento ottenuti da un alias di uno smart pointer</a></li>
</ul></li>
</ul>
<h3 id="r.1-gestire-automaticamente-le-risorse-utilizzando-gli-handle-e-il-raii-resource-acquisition-is-initialization"><a name="Rr-raii"></a>R.1: Gestire automaticamente le risorse utilizzando gli handle e il RAII (Resource Acquisition Is Initialization)</h3>
<h5 id="motivo-175">Motivo</h5>
<p>Per evitare leak [perdite] e la complessità di una gestione manuale delle risorse. La simmetria obbligata del costruttore/distruttore del linguaggio C++ rispecchia quella derivante dalle coppie di funzioni per acquisire/rilasciare le risorse come <code>fopen</code>/<code>fclose</code>, <code>lock</code>/<code>unlock</code>, e <code>new</code>/<code>delete</code>. Quando si ha a che fare con una risorsa che necessita la chiamata alla coppia di funzioni acquisisci/rilascia, si incapsula tale risorsa in un oggetto che gestisca autonomamente tale accoppiata – acquisisce la risorsa nel costruttore e la rilascia nel suo distruttore.</p>
<h5 id="esempio-cattivo-66">Esempio, cattivo</h5>
<p>Si consideri:</p>
<pre><code>void send(X* x, cstring_span destination)
{
auto port = open_port(destination);
my_mutex.lock();
// ...
send(port, x);
// ...
my_mutex.unlock();
close_port(port);
delete x;
}</code></pre>
<p>In questo codice ci si deve ricordare di <code>unlock</code>, <code>close_port</code>, e <code>delete</code> in ogni diramazione del fluss di codice, e farlo esattamente una sola volta. Inoltre, se una qualsiasi parte del codice segnalato con <code>...</code> genera un’eccezione, allora <code>x</code> viene perso e <code>my_mutex</code> resta bloccato [locked].</p>
<h5 id="esempio-153">Esempio</h5>
<p>Si consideri:</p>
<pre><code>void send(unique_ptr&lt;X&gt; x, cstring_span destination)  // x possiede X
{
Port port{destination};            // port possiede PortHandle
lock_guard&lt;mutex&gt; guard{my_mutex}; // guard possiede lock
// ...
send(port, x);
// ...
} // automaticamente sblocca my_mutex ed esegue il delete del puntatore in x</code></pre>
<p>Ora la pulizia di tutte le risorse è automatica, eseguita una sola volta su tutte le diramazioni che vadano o meno in errore. Come bonus, ora la funzione dichiara che assume la proprietà del puntatore.</p>
<p>Che cos’è <code>Port</code>? Un comodo involucro [wrapper] che incapsula la risorsa:</p>
<pre><code>class Port {
PortHandle port;
public:
Port(cstring_span destination) : port{open_port(destination)} { }
~Port() { close_port(port); }
operator PortHandle() { return port; }

// gli handle di port di solito non possono essere clonati, quindi se necessario si disabilita la copia e l&#39;assegnazione
Port(const Port&amp;) = delete;
Port&amp; operator=(const Port&amp;) = delete;
};</code></pre>
<h5 id="note-172">Note</h5>
<p>Laddove una risorsa abbia “strani comportamenti” perché non è rappresentata come una classe con un distruttore, la si racchiude in una classe o si usa <a href="#Re-finally"><code>finally</code></a></p>
<p><strong>Si veda anche</strong>: <a href="#Rr-raii">RAII</a></p>
<h3 id="r.2-nelle-interfacce-usare-puntatori-semplici-raw-per-denotare-solo-i-singoli-oggetti"><a name="Rr-use-ptr"></a>R.2: Nelle interfacce, usare puntatori semplici [raw] per denotare (solo) i singoli oggetti</h3>
<h5 id="motivo-176">Motivo</h5>
<p>Gli array si rappresentano meglio con un tipo di contenitore (p.es., <code>vector</code> (proprietario)) o uno <code>span</code> (non-proprietario). Questi contenitori e viste contengono sufficienti informazioni per poter eseguire un controllo sul range.</p>
<h5 id="esempio-cattivo-67">Esempio, cattivo</h5>
<pre><code>void f(int* p, int n)   // n è il numero di elementi in p[]
{
// ...
p[2] = 7;   // bad: puntatore fuori portata [subscript]
// ...
}</code></pre>
<p>Il compilatore non legge i commenti e senza leggere altro codice non si sa se <code>p</code> punta effettivamente a <code>n</code> elementi. Si usi invece <code>span</code>.</p>
<h5 id="esempio-154">Esempio</h5>
<pre><code>void g(int* p, int fmt)   // scrive *p col formato #fmt
{
// ... usa solo *p e p[0] ...
}</code></pre>
<h5 id="eccezione-28">Eccezione</h5>
<p>Le stringhe C-style vengono passate come singoli puntatori a sequenze di caratteri terminanti con zero. Si usi <code>zstring</code> invece di <code>char*</code> per indicare che ci si affida a questa convenzione.</p>
<h5 id="note-173">Note</h5>
<p>Attualmente molte volte che si usa un puntatore ad un singolo elemento si potrebbe usare un riferimento. Tuttavia, dove <code>nullptr</code> è un valore possibile, un riferimento non è ragionevolmente un’alternativa.</p>
<h5 id="imposizione-167">Imposizione</h5>
<ul>
<li>Segnalare l’aritmetica di un puntatore (compreso <code>++</code>) su un puntatore che non faccia parte di un contenitore, una vista o un iteratore. Questa regola genererebbe un numero enorme di falsi positivi se applicata a un codice più vecchio.</li>
<li>Segnalare i nomi di array passati come puntatori semplici</li>
</ul>
<h3 id="r.3-un-puntatore-semplice-raw-un-t-non-è-proprietario"><a name="Rr-ptr"></a>R.3: Un puntatore semplice [raw] (un <code>T*</code>) non è proprietario</h3>
<h5 id="motivo-177">Motivo</h5>
<p>Non c’è nulla (nello standard del C++e nella maggior parte del codice) per dire il contrario e la maggior parte dei puntatori semplici non sono proprietari. Si vogliono identificare i puntatori proprietari in modo da gestire efficientemente il delete degli oggetti puntati dai puntatori proprietari.</p>
<h5 id="esempio-155">Esempio</h5>
<pre><code>void f()
{
int* p1 = new int{7};           // bad: puntatore semplice proprietario
auto p2 = make_unique&lt;int&gt;(7);  // OK: l&#39;int è posseduto da un puntatore unique
// ...
}</code></pre>
<p>Lo <code>unique_ptr</code> protegge dai leak garantendo la cancellazione del suo oggetto (anche in presenza di eccezioni). Il <code>T*</code> non lo fa.</p>
<h5 id="esempio-156">Esempio</h5>
<pre><code>template&lt;typename T&gt;
class X {
public:
T* p;   // bad: non è chiaro se p possegga o meno 
T* q;   // bad: non è chiaro se q possegga o meno
// ...
};</code></pre>
<p>Si può risolvere il problema esplicitando il possesso:</p>
<pre><code>template&lt;typename T&gt;
class X2 {
public:
owner&lt;T*&gt; p;  // OK: p è proprietario
T* q;         // OK: q non è proprietario
// ...
};</code></pre>
<h5 id="eccezione-29">Eccezione</h5>
<p>Una delle maggiori tipologie di eccezione è il codice legacy, specialmente il codice che deve restare compilabile come C o interfacciarsi col C o il C++ C-style tramite le ABI Il fatto che ci siano miliardi di righe di codice che violano questa regola contro il possesso dei <code>T*</code> non può essere ignorato. Ci piacerebbe vedere dei tool che trasformino i programmi con vecchio codice “legacy” di 20 anni fa in un chiaro codice moderno, incoraggiamo lo sviluppo, la distribuzione e l’uso di questi strumenti, speriamo che le linee-guida aiutino lo sviluppo di questi tool e che abbiano anche contribuito (e contribuiscano) alla ricerca e allo sviluppo in questo settore. Tuttavia, ci vorrà del tempo: il “codice legacy” viene generato più velocemente di quanto si possa rinnovare il vecchio codice, e così sarà per qualche anno.</p>
<p>Questo codice non può essere riscritto (anche assumendo un buon software di trasformazione del codice), comunque non presto. Questo problema non può essere risolto (su vasta scala) trasformando tutti i puntatori proprietari in <code>unique_ptr</code> e <code>shared_ptr</code>, in parte perché abbiamo bisogno di usare anche dei “puntatori raw” proprietari così come i semplici puntatori nell’implementazione degli handle delle risorse fondamentali. Per esempio, le comuni implementazioni di <code>vector</code> hanno un puntatore proprietario e due puntatori non-proprietari. Molte ABI (ed essenzialmente tutte le interfacce al codice C) usano i <code>T*</code>, alcuni di questi sono proprietari. Alcune interfacce non possono essere semplicemente annotate con <code>owner</code> perché devono restare compilabili come C (anche se questo sarebbe un raro buon uso per una macro, che si espanderebbe in <code>owner</code>solo in C++).</p>
<h5 id="note-174">Note</h5>
<p><code>owner&lt;T*&gt;</code> non ha una semantica di default oltre a <code>T*</code>. Esso può essere utilizzato senza modificare alcun codice utilizzandolo e senza influire sulle ABI. È semplicemente un indicatore per programmatori e strumenti di analisi. Per esempio, se un <code>owner&lt;T*&gt;</code> è un membro di una classe, è meglio che quella classe abbia un distruttore che ne esegua un <code>delete</code>.</p>
<h5 id="esempio-cattivo-68">Esempio, cattivo</h5>
<p>La restituzione di un puntatore (semplice [raw]), genera nel chiamante un’incertezza sulla gestione del suo ciclo di vita; ovvero, che cancella l’oggetto a cui si punta?</p>
<pre><code>Gadget* make_gadget(int n)
{
auto p = new Gadget{n};
// ...
return p;
}

void caller(int n)
{
auto p = make_gadget(n);   // ricorda di cancellare p
// ...
delete p;
}</code></pre>
<p>Oltre a subire del problema del <a href="#???">leak</a>, ciò aggiunge un’allocazione spuria e un’operazione di de-allocazione, ed è inutilmente prolissa. Se Gadget è economico da spostare al di fuori di una funzione (ovvero, è piccolo o ha un’efficiente operazione di spostamento), basta restituirlo “per valore” (si veda <a href="#Rf-out">“out” dei valori di ritorno</a>):</p>
<pre><code>Gadget make_gadget(int n)
{
Gadget g{n};
// ...
return g;
}</code></pre>
<h5 id="note-175">Note</h5>
<p>Questa regola si applica alle funzioni factory.</p>
<h5 id="note-176">Note</h5>
<p>Se è richiesta la semantica dei puntatori (p. es., perché il tipo restituito deve deve far riferimento ad una classe base della gerarchia (un’interfaccia)), restituire uno “smart pointer.”</p>
<h5 id="imposizione-168">Imposizione</h5>
<ul>
<li>(Semplice) Un warning su un <code>delete</code> di un puntatore semplice che non sia un <code>owner&lt;T&gt;</code>.</li>
<li>(Moderato) Un warning sia sul fallimento di un <code>reset</code> che su un esplicito <code>delete</code> di un puntatore a <code>owner&lt;T&gt;</code> su ogni percorso del codice.</li>
<li>(Semplice) Avvisa se il valore di ritorno di <code>new</code> è assegnato ad un puntatore semplice.</li>
<li>(Semplice) Avvisa se una funzione restituisce un oggetto che sia stato allocato nella funzione ma che abbia un costruttore di spostamento. Suggerisce, invece, di restituirlo per valore.</li>
</ul>
<h3 id="r.4-un-riferimento-raw-un-t-non-è-proprietario"><a name="Rr-ref"></a>R.4: Un riferimento [raw] (un <code>T&amp;</code>) non è proprietario</h3>
<h5 id="motivo-178">Motivo</h5>
<p>Non c’è nulla (nello standard del C++ nella maggior parte del codice) che dica diversamente e la maggior parte dei riferimenti sono non-proprietari. Vogliamo che i proprietari siano identificati in modo da poter affidabilmente ed efficientemente eseguire il delete degli oggetti puntati dai puntatori proprietari.</p>
<h5 id="esempio-157">Esempio</h5>
<pre><code>void f()
{
int&amp; r = *new int{7};  // bad: riferimento semplice proprietario
// ...
delete &amp;r;             // bad: viola la regola della cancellazione dei puntatori semplici
}</code></pre>
<p><strong>Si veda anche</strong>: <a href="#Rr-ptr">La regola del puntatore semplice</a></p>
<h5 id="imposizione-169">Imposizione</h5>
<p>Si veda <a href="#Rr-ptr">la regola del puntatore semplice</a></p>
<h3 id="r.5-preferire-oggetti-con-scope-non-allocare-sullheap-se-non-necessario"><a name="Rr-scoped"></a>R.5: Preferire oggetti con scope, non allocare sull’heap se non necessario</h3>
<h5 id="motivo-179">Motivo</h5>
<p>Un oggetto con scope è un oggetto locale, un oggetto globale o un membro. Ciò implica che non vi sono costi aggiuntivi diversi per l’allocazione e la de-allocazione oltre a quello già usato per lo scope contenitore o l’oggetto. I membri di un oggetto con scope sono essi stessi con scope e il costruttore e il distruttore dell’oggetto gestiscono il ciclo di vita dei membri.</p>
<h5 id="esempio-158">Esempio</h5>
<p>L’esempio seguente è inefficiente (perché presenta un’allocazione e una de-allocazione non necessarie), vulnerabile al ritorno da eccezioni generate nella parte <code>...</code> (che porta a leak), ed è prolisso:</p>
<pre><code>void f(int n)
{
auto p = new Gadget{n};
// ...
delete p;
}</code></pre>
<p>Utilizzare invece una variabile locale:</p>
<pre><code>void f(int n)
{
Gadget g{n};
// ...
}</code></pre>
<h5 id="imposizione-170">Imposizione</h5>
<ul>
<li>(Moderato) Avvisa se un oggetto è allocato e poi de-allocato su tutte le diramazioni all’interno di una funzione. Suggerisce, invece, di usare una oggetto variabile locale <code>auto</code> sullo stack.</li>
<li>(Semplice) Avverte se un locale <code>Unique_pointer</code> o uno <code>Shared_pointer</code> non viene spostato, copiato, ri-assegnato o <code>reset</code>tato prima della fine del suo ciclo di vita.</li>
</ul>
<h3 id="r.6-vitare-le-variabili-globali-non-const"><a name="Rr-global"></a>R.6: vitare le variabili globali non-<code>const</code></h3>
<p>Cfr. <a href="#Ri-global">I.2</a></p>
<h2 id="r.alloc-allocazione-e-de-allocazione"><a name="SS-alloc"></a>R.alloc: Allocazione e de-allocazione</h2>
<h3 id="r.10-evitare-malloc-e-free"><a name="Rr-mallocfree"></a>R.10: Evitare <code>malloc()</code> e <code>free()</code></h3>
<h5 id="motivo-180">Motivo</h5>
<p><code>malloc()</code> e <code>free()</code> non supportano la costruzione e la distruzione e non si collegano bene con <code>new</code> e <code>delete</code>.</p>
<h5 id="esempio-159">Esempio</h5>
<pre><code>class Record {
int id;
string name;
// ...
};

void use()
{
// p1 può essere nullptr
// *p1 non viene inizializzato; in particolare,
// quella stringa non è una stringa ma un pacchetto di bit delle dimensioni di una stringa
Record* p1 = static_cast&lt;Record*&gt;(malloc(sizeof(Record)));

auto p2 = new Record;

// a meno che non venga generata un&#39;eccezione, *p2 è inizializzato al suo default
auto p3 = new(nothrow) Record;
// p3 potrebbe essere nullptr; se non lo è, *p3 è inizializzato al suo default

// ...

delete p1;    // errore: non si può fare il delete di un oggetto allocato da malloc()
free(p2);    // errore: non si può eseguire free() su un oggetto allocato da new
}</code></pre>
<p>In alcune implementazioni quel <code>delete</code> e quel <code>free()</code> potrebbero funzionare, o potrebbero causare errori a run-time.</p>
<h5 id="eccezione-30">Eccezione</h5>
<p>Esistono applicazioni e sezioni di codice in cui le eccezioni non sono accettabili. Alcuni dei migliori esempi di questo tipo sono nel codice ‘life-critical’ e hard-real-time. Attenzione che molti divieti sull’uso delle eccezioni si basano sulla superstizione (che è un male) o hanno a che fare con codice più vecchio con una gestione delle risorse non sistematica (sfortunatamente, ma a volte necessaria). In questi casi si considerino le versioni <code>nothrow</code> di <code>new</code>.</p>
<h5 id="imposizione-171">Imposizione</h5>
<p>Segnalare l’uso esplicito di <code>malloc</code> o <code>free</code>.</p>
<h3 id="r.11-evitare-di-chiamare-esplicitamente-new-e-delete-explicitly"><a name="Rr-newdelete"></a>R.11: Evitare di chiamare esplicitamente <code>new</code> e <code>delete</code> explicitly</h3>
<h5 id="motivo-181">Motivo</h5>
<p>Il puntatore restituito da <code>new</code> dovrebbe appartenere ad un gestore di risorse (che potrebbe chiamare <code>delete</code>). Se il puntatore restituito da <code>new</code> viene assegnato ad un semplice puntatore, l’oggetto può generare un leak.</p>
<h5 id="note-177">Note</h5>
<p>In un programma di grandi dimensioni, un semplice <code>delete</code> (ovvero un <code>delete</code> nel codice dell’applicazione, anziché nella parte di codice dedicata alla gestione delle risorse) è un probabile bug: se si hanno N <code>delete</code>, come si può essere sicuri che non ne servano N+1 o N-1? l bug potrebbe essere latente: potrebbe emergere solo durante la manutenzione. Se si ha un semplice <code>new</code>, probabilmente ci vorrà un semplice <code>delete</code> da qualche parte, quindi probabilmente si avrà un bug.</p>
<h5 id="imposizione-172">Imposizione</h5>
<p>(Semplice) Avvisare di qualsiasi uso esplicito di <code>new</code> e di <code>delete</code>. Suggerire, invece, l’uso di <code>make_unique</code>.</p>
<h3 id="r.12-fornire-immediatamente-il-risultato-dellallocazione-di-una-risorsa-ad-un-oggetto-gestore"><a name="Rr-immediate-alloc"></a>R.12: Fornire immediatamente il risultato dell’allocazione di una risorsa ad un oggetto gestore</h3>
<h5 id="motivo-182">Motivo</h5>
<p>In caso contrario, un’eccezione o un return possono causare un leak.</p>
<h5 id="esempio-cattivo-69">Esempio, cattivo</h5>
<pre><code>void f(const string&amp; name)
{
FILE* f = fopen(name, &quot;r&quot;);            // apre il file
vector&lt;char&gt; buf(1024);
auto _ = finally([f] { fclose(f); });  // ricorda di chiudere il file
// ...
}</code></pre>
<p>L’allocazione di <code>buf</code> potrebbe fallire e produrre un leak dell’handle del file.</p>
<h5 id="esempio-160">Esempio</h5>
<pre><code>void f(const string&amp; name)
{
ifstream f{name};   // apre il file
vector&lt;char&gt; buf(1024);
// ...
}</code></pre>
<p>L’utilizzo dell’handle de file (in <code>ifstream</code>) è semplice, efficiente e sicuro.</p>
<h5 id="imposizione-173">Imposizione</h5>
<ul>
<li>Segnalare le allocazioni esplicite usate per inizializzare i puntatori (problema: quante allocazioni di risorse dirette si possono riconoscere?)</li>
</ul>
<h3 id="r.13-eseguire-al-massimo-una-allocazione-di-risorsa-esplicita-in-una-singola-istruzione"><a name="Rr-single-alloc"></a>R.13: Eseguire al massimo una allocazione di risorsa esplicita in una singola istruzione</h3>
<h5 id="motivo-183">Motivo</h5>
<p>Se si eseguono due allocazioni di risorse esplicite in un’unica istruzione, si può avere un leak delle risorse perché l’ordine di valutazione di molte sotto-espressioni, compresi gli argomenti delle funzioni, non è specificato.</p>
<h5 id="esempio-161">Esempio</h5>
<pre><code>void fun(shared_ptr&lt;Widget&gt; sp1, shared_ptr&lt;Widget&gt; sp2);</code></pre>
<p>Questa <code>fun</code> si può chiamare così:</p>
<pre><code>// BAD: potenziale leak
fun(shared_ptr&lt;Widget&gt;(new Widget(a, b)), shared_ptr&lt;Widget&gt;(new Widget(c, d)));</code></pre>
<p>Questo non è exception-safe perché il compilatore può riordinare le due espressioni nel costruire i due argomenti della funzione. In particolare, il compilatore può intercalare l’esecuzione delle due espressioni: L’allocazione della memoria (chiamando <code>operator new</code>) può essere fatta, per entrambi gli oggetti, prima, seguita poi dai tentativi di richiamare i due costruttori <code>Widget</code>. Se uno dei costruttori genera un’eccezione, allora la memoria dell’altro oggetto non verrà mai rilasciata!</p>
<p>Questo subdolo problema ha una semplice soluzione: Mai eseguire più di una allocazione esplicita di una risorsa in una sola istruzione. Per esempio:</p>
<pre><code>shared_ptr&lt;Widget&gt; sp1(new Widget(a, b)); // Meglio, ma disordinato
fun(sp1, new Widget(c, d));</code></pre>
<p>La soluzione migliore consiste nell’evitare totalmente l’allocazione esplicita utilizzando le funzioni factory che restituiscono gli oggetti posseduti:</p>
<pre><code>fun(make_shared&lt;Widget&gt;(a, b), make_shared&lt;Widget&gt;(c, d)); // La cosa migliore</code></pre>
<p>Se non ce n’è uno scriversi il proprio factory wrapper.</p>
<h5 id="imposizione-174">Imposizione</h5>
<ul>
<li>Segnalare le espressioni con più allocazioni esplicite di risorse (problema: quante allocazioni di risorse dirette si possono riconoscere?)</li>
</ul>
<h3 id="r.14-evitare-parametri-preferire-span"><a name="Rr-ap"></a>R.14: Evitare parametri <code>[]</code>, preferire <code>span</code></h3>
<h5 id="motivo-184">Motivo</h5>
<p>Un array si riduce ad un puntatore, perdend così la propria dimensione, aprendo la possibilità di errori sul range. Usare <code>span</code> per preservare l’informazione sulla dimensione.</p>
<h5 id="esempio-162">Esempio</h5>
<pre><code>void f(int[]);          // non raccomandato

void f(int*);           // non raccomandato per oggetti multipli
// (un puntatore dovrebbe puntare ad un solo oggetto, senza un indice)

void f(gsl::span&lt;int&gt;); // buono, raccomandato</code></pre>
<h5 id="imposizione-175">Imposizione</h5>
<p>Segnalare i parametri <code>[]</code>. Usare, invece, <code>span</code>.</p>
<h3 id="r.15-eseguire-sempre-loverload-dellaccoppiata-allocazionede-allocazione"><a name="Rr-pair"></a>R.15: Eseguire sempre l’overload dell’accoppiata allocazione/de-allocazione</h3>
<h5 id="motivo-185">Motivo</h5>
<p>Altrimenti si ottengono operazioni disaccoppiate e caos.</p>
<h5 id="esempio-163">Esempio</h5>
<pre><code>class X {
// ...
void* operator new(size_t s);
void operator delete(void*);
// ...
};</code></pre>
<h5 id="note-178">Note</h5>
<p>Se si vuole che non venga de-allocata la memoria, si aggiunge <code>=delete</code> all’operazione di de-allocazione. Non lasciarla senza dichiarazione.</p>
<h5 id="imposizione-176">Imposizione</h5>
<p>Segnalare le accoppiate incomplete.</p>
<h2 id="r.smart-i-puntatori-smart"><a name="SS-smart"></a>R.smart: I puntatori smart</h2>
<h3 id="r.20-utilizzare-unique_ptr-e-shared_ptr-per-rappresentare-il-possesso"><a name="Rr-owner"></a>R.20: Utilizzare <code>unique_ptr</code> e <code>shared_ptr</code> per rappresentare il possesso</h3>
<h5 id="motivo-186">Motivo</h5>
<p>Si possono prevenire i leak della risorse.</p>
<h5 id="esempio-164">Esempio</h5>
<p>Si consideri:</p>
<pre><code>void f()
{
X x;
X* p1 { new X };              // si veda anche ???
unique_ptr&lt;T&gt; p2 { new X };   // proprietà unica; si veda anche ???
shared_ptr&lt;T&gt; p3 { new X };   // proprietà condivisa; si veda anche ???
auto p4 = make_unique&lt;X&gt;();   // proprietà unica, preferibile all&#39;uso esplicito di &quot;new&quot;
auto p5 = make_shared&lt;X&gt;();   // proprietà condivisa, preferibile all&#39;uso esplicito di &quot;new&quot;
}</code></pre>
<p>Con ciò si avrà un leak dell’oggetto usato per inizializzare <code>p1</code> (solamente).</p>
<h5 id="imposizione-177">Imposizione</h5>
<p>(Semplice) Avvisare se il valore di ritorno di <code>new</code>, o di una chiamata a una funzione che restituisce un tipo di puntatore, viene assegnato ad un puntatore semplice.</p>
<h3 id="r.21-preferire-unique_ptr-a-shared_ptr-a-meno-che-non-sia-necessario-condividere-il-possesso"><a name="Rr-unique"></a>R.21: Preferire <code>unique_ptr</code> a <code>shared_ptr</code> a meno che non sia necessario condividere il possesso</h3>
<h5 id="motivo-187">Motivo</h5>
<p>Un <code>unique_ptr</code> è concettualmente più semplice e prevedibile (si sa quando viene distrutto) e più veloce (non mantiene implicitamente un conteggio sull’utilizzo).</p>
<h5 id="esempio-cattivo-70">Esempio, cattivo</h5>
<p>Questo aggiunge e mantiene inutilmente un conteggio dei riferimenti..</p>
<pre><code>void f()
{
shared_ptr&lt;Base&gt; base = make_shared&lt;Derived&gt;();
// usa la base localmente, senza copiarla -- refcount non va mai oltre l&#39;1
} // distrugge la base</code></pre>
<h5 id="esempio-165">Esempio</h5>
<p>Questo è più efficiente:</p>
<pre><code>void f()
{
unique_ptr&lt;Base&gt; base = make_unique&lt;Derived&gt;();
// usa la base localmente
} // distrugge la base</code></pre>
<h5 id="imposizione-178">Imposizione</h5>
<p>(Semplice) Avvisa se una funzione usa uno <code>Shared_pointer</code> con un oggetto allocato nella funzione, ma non restituisce mai lo <code>Shared_pointer</code> né lo passa ad una funzione che richiede uno <code>Shared_pointer&amp;</code>. Suggerire, invece, l’uso di <code>unique_ptr</code>.</p>
<h3 id="r.22-usare-make_shared-per-creare-gli-shared_ptrs"><a name="Rr-make_shared"></a>R.22: Usare <code>make_shared()</code> per creare gli <code>shared_ptr</code>s</h3>
<h5 id="motivo-188">Motivo</h5>
<p>un oggetto e poi lo si da ad un costruttore di uno <code>shared_ptr</code>, si farà (molto probabilmente) una ulteriore allocazione (e poi una de-allocazione)rispetto a quando si usa <code>make_shared()</code> perché i contatori dei riferimenti devono essere allocati separatamente dall’oggetto.</p>
<h5 id="esempio-166">Esempio</h5>
<p>Si consideri:</p>
<pre><code>shared_ptr&lt;X&gt; p1 { new X{2} }; // male
auto p = make_shared&lt;X&gt;(2);    // bene</code></pre>
<p>La versione <code>make_shared()</code> indica <code>X</code> una sola volta, quindi è solitamente più breve (oltre che più veloce) della versione col <code>new</code> esplicito.</p>
<h5 id="imposizione-179">Imposizione</h5>
<p>(Semplice) Avvisa se uno <code>shared_ptr</code> è costruito partendo dal risultato di un <code>new</code> anziché da <code>make_shared</code>.</p>
<h3 id="r.23-usare-make_unique-per-creare-gli-unique_ptr"><a name="Rr-make_unique"></a>R.23: Usare <code>make_unique()</code> per creare gli <code>unique_ptr</code></h3>
<h5 id="motivo-189">Motivo</h5>
<p>Per comodità e coerenza con lo <code>shared_ptr</code>.</p>
<h5 id="note-179">Note</h5>
<p><code>make_unique()</code> è del C++14, ma ampiamente disponibile (oltre che semplice da scrivere).</p>
<h5 id="imposizione-180">Imposizione</h5>
<p>(Semplice) Avvisa se uno <code>unique_ptr</code> è costruito partendo dal risultato di un <code>new</code> anziché da <code>make_unique</code>.</p>
<h3 id="r.24-usare-stdweak_ptr-per-interrompere-i-cicli-di-shared_ptr"><a name="Rr-weak_ptr"></a>R.24: Usare <code>std::weak_ptr</code> per interrompere i cicli di <code>shared_ptr</code></h3>
<h5 id="motivo-190">Motivo</h5>
<p>Gli <code>shared_ptr</code> si basano sul conteggio degli usi e sull’uso dei conteggi per una struttura ciclica che non va mai a zero, c’è quindi bisogno di un meccanismo per sapere quando distruggere una struttura ciclica.</p>
<h5 id="esempio-167">Esempio</h5>
<pre><code>#include &lt;memory&gt;

class bar;

class foo
{
public:
explicit foo(const std::shared_ptr&lt;bar&gt;&amp; forward_reference)
: forward_reference_(forward_reference)
{ }
private:
std::shared_ptr&lt;bar&gt; forward_reference_;
};

class bar
{
public:
explicit bar(const std::weak_ptr&lt;foo&gt;&amp; back_reference)
: back_reference_(back_reference)
{ }
void do_something()
{
if (auto shared_back_reference = back_reference_.lock()) {
// Usa *shared_back_reference
}
}
private:
std::weak_ptr&lt;foo&gt; back_reference_;
};</code></pre>
<h5 id="note-180">Note</h5>
<p>??? (HS: Molte persone dicono “interrompere cicli”, mentre io penso che “proprietà condivisa [shared ownership] temporanea” sia più pertinente). ???(BS: Interrompere cicli è quello che si deve fare; condividere temporaneamente la proprietà è come farlo. Si può “temporaneamente condividere la proprietà” semplicemente usando un altro <code>shared_ptr</code>.)</p>
<h5 id="imposizione-181">Imposizione</h5>
<p>??? probabilmente impossibile. Se potessimo rilevare staticamente i cicli, non avremmo bisogno di <code>weak_ptr</code></p>
<h3 id="r.30-prendere-gli-smart-pointer-come-parametri-solo-per-esprimere-esplicitamente-la-semantica-della-durata-lifetime"><a name="Rr-smartptrparam"></a>R.30: Prendere gli smart pointer come parametri solo per esprimere esplicitamente la semantica della durata [lifetime]</h3>
<h5 id="motivo-191">Motivo</h5>
<p>Accettare un puntatore smart ad un <code>widget</code> è sbagliato se la funzione necessita del <code>widget</code>. Dovrebbe essere in grado di accettare qualsiasi oggetto <code>widget</code>, non solo quelli il cui ciclo di vita è gestito da un particolare tipo di puntatore smart. Una funzione che non gestisce il ciclo di vita dovrebbe, invece, accettare dei puntatori semplici o dei riferimenti.</p>
<h5 id="esempio-cattivo-71">Esempio, cattivo</h5>
<pre><code>// chiamato
void f(shared_ptr&lt;widget&gt;&amp; w)
{
// ...
use(*w); // usa solo w -- il ciclo-di-vita non viene usato affatto
// ...
};

// chiamante
shared_ptr&lt;widget&gt; my_widget = /* ... */;
f(my_widget);

widget stack_widget;
f(stack_widget); // errore</code></pre>
<h5 id="esempio-buono-11">Esempio, buono</h5>
<pre><code>// chiamato
void f(widget&amp; w)
{
// ...
use(w);
// ...
};

// chiamante
shared_ptr&lt;widget&gt; my_widget = /* ... */;
f(*my_widget);

widget stack_widget;
f(stack_widget); // ok -- ora questo funziona</code></pre>
<h5 id="imposizione-182">Imposizione</h5>
<ul>
<li>(Semplice) Avvisa se una funzione accetta come parametro un tipo di puntatore intelligente (che sovraccarica [overload] <code>operator-&gt;</code> o <code>operator*</code>) che è copiabile ma la funzione chiama solo uno tra: <code>operator*</code>, <code>operator-&gt;</code> o <code>get()</code>. Suggerisce, invece, di usare <code>T*</code> o <code>T&amp;</code>.</li>
<li>Segnala un parametro di tipo smart pointer (un tipo che sovraccarica [overload] <code>operator-&gt;</code> o <code>operator*</code>) che è copiabile/spostabile ma non viene mai copiato/spostato nel corpo della funzione, e che non viene mai modificato, e che non viene passato ad un’altra funzione che potrebbe farlo. Questo vuol dire che non viene usata la semantica della proprietà [ownership]. Suggerisce, invece, di usare <code>T*</code> o <code>T&amp;</code>.</li>
</ul>
<h3 id="r.31-se-si-hanno-smart-pointer-non-std-seguire-il-modello-base-di-std"><a name="Rr-smart"></a>R.31: Se si hanno smart pointer non-<code>std</code>, seguire il modello base di <code>std</code></h3>
<h5 id="motivo-192">Motivo</h5>
<p>Le regole nella sezione seguente funzionano anche per altri tipi di puntatori intelligenti personalizzati e di terze parti e sono molto utili per diagnosticare errori comuni dei puntatori intelligenti che causano problemi di prestazioni e correttezza. Si vuole che le regole funzionino per tutti gli smart pointer che si usano.</p>
<p>Qualsiasi tipo (compreso il template primario e la specializzazione) che sovraccarica [overload] il <code>*</code> unario e il <code>-&gt;</code> è considerato uno smart pointer:</p>
<ul>
<li>Se è copiabile, è riconosciuto come uno <code>shared_ptr</code> reference-counted [a conteggio dei riferimenti].</li>
<li>Se non è copiabile, lo si riconosce come un <code>unique_ptr</code> unico.</li>
</ul>
<h5 id="esempio-168">Esempio</h5>
<pre><code>// usa il intrusive_ptr delle Boost
#include &lt;boost/intrusive_ptr.hpp&gt;
void f(boost::intrusive_ptr&lt;widget&gt; p)  // errore sotto la regola &#39;sharedptrparam&#39;
{
p-&gt;foo();
}

// usa il CComPtr di Microsoft
#include &lt;atlbase.h&gt;
void f(CComPtr&lt;widget&gt; p)               // errore sotto la regola &#39;sharedptrparam&#39;
{
p-&gt;foo();
}</code></pre>
<p>Entrambi i casi sono errori per la <a href="#Rr-smartptrparam">linea-guida <code>sharedptrparam</code></a>: <code>p</code> è uno <code>Shared_pointer</code>, ma qui niente della sua condivisibilità viene usato o passato per valore in un tacito peggioramento; queste funzioni dovrebbero accettare uno smart pointer solo se devono partecipare alla gestione del ciclo di vita del widget. Altrimenti dovrebbero accettare un <code>widget*</code>, se può essere <code>nullptr</code>. Altrimenti, ed idealmente, la funzione dovrebbe accettare un <code>widget&amp;</code>. Questi puntatori intelligenti corrispondono al concetto <code>Shared_pointer</code>, quindi queste regole per applicare le linee-guida funzionano su di essi “fuori-dagli-schemi” [out of the box] e li espongono ad un comune peggioramento.</p>
<h3 id="r.32-prendere-un-parametro-unique_ptrwidget-per-esprimere-che-una-funzione-assume-la-proprietà-di-un-widget"><a name="Rr-uniqueptrparam"></a>R.32: Prendere un parametro <code>unique_ptr&lt;widget&gt;</code> per esprimere che una funzione assume la proprietà di un <code>widget</code></h3>
<h5 id="motivo-193">Motivo</h5>
<p>Usando <code>unique_ptr</code> in questo modo si documenta e si rafforza il trasferimento della proprietà della chiamata di funzione.</p>
<h5 id="esempio-169">Esempio</h5>
<pre><code>void sink(unique_ptr&lt;widget&gt;); // diventa proprietario del widget

void uses(widget*);            // semplicemente usa il widget</code></pre>
<h5 id="esempio-cattivo-72">Esempio, cattivo</h5>
<pre><code>void thinko(const unique_ptr&lt;widget&gt;&amp;); // solitamente non è ciò che si vuole</code></pre>
<h5 id="imposizione-183">Imposizione</h5>
<ul>
<li>(Semplice) Avvisa se una funzione prende un parametro <code>Unique_pointer&lt;T&gt;</code> per riferimento lvalue e non assegna ad esso né ci chiama <code>reset()</code> in almeno un ramo del codice. Suggerisce, invece, di prendere un <code>T*</code> o un <code>T&amp;</code>.</li>
<li>(Sempice) ((Foundation)) Avvisa se una funzione accetta un parametro <code>Unique_pointer&lt;T&gt;</code> per riferimento a <code>const</code>. Suggerisce, invece, di prendere un<code>const T*</code> o un <code>const T&amp;</code>.</li>
</ul>
<h3 id="r.33-prendere-un-parametro-unique_ptrwidget-per-esprimere-che-una-funzione-riposizionerestituisce-reseat-ilwidget"><a name="Rr-reseat"></a>R.33: Prendere un parametro <code>unique_ptr&lt;widget&gt;&amp;</code> per esprimere che una funzione riposizione/restituisce [reseat] il<code>widget</code></h3>
<h5 id="motivo-194">Motivo</h5>
<p>Usando <code>unique_ptr</code> in questo modo si documenta e si rafforza la semantica del [reseating] della chiamata.</p>
<h5 id="note-181">Note</h5>
<p>“reseat” significa “fare in modo che un puntatore o un puntatore intelligente si riferiscano a un oggetto diverso”.</p>
<h5 id="esempio-170">Esempio</h5>
<pre><code>void reseat(unique_ptr&lt;widget&gt;&amp;); // &quot;potrà&quot; o &quot;potrebbe&quot; eseguire il reseat di un puntatore</code></pre>
<h5 id="esempio-cattivo-73">Esempio, cattivo</h5>
<pre><code>void thinko(const unique_ptr&lt;widget&gt;&amp;); // solitamente non è ciò che si vuole</code></pre>
<h5 id="imposizione-184">Imposizione</h5>
<ul>
<li>(Semplice) Avvisa se una funzione prende un parametro <code>Unique_pointer&lt;T&gt;</code> per riferimento lvalue e non assegna ad esso né ci chiama <code>reset()</code> in almeno un ramo del codice. Suggerisce, invece, di prendere un <code>T*</code> o un <code>T&amp;</code>.</li>
<li>(Sempice) ((Foundation)) Avvisa se una funzione accetta un parametro <code>Unique_pointer&lt;T&gt;</code> per riferimento a <code>const</code>. Suggerisce, invece, di prendere un<code>const T*</code> o un <code>const T&amp;</code>.</li>
</ul>
<h3 id="r.34-prendere-un-parametro-shared_ptrwidget-per-esprimere-che-una-funzione-è-comproprietaria"><a name="Rr-sharedptrparam-owner"></a>R.34: Prendere un parametro <code>shared_ptr&lt;widget&gt;</code> per esprimere che una funzione è comproprietaria</h3>
<h5 id="motivo-195">Motivo</h5>
<p>Ciò rende esplicita la condivisione della proprietà della funzione.</p>
<h5 id="esempio-buono-12">Esempio, buono</h5>
<pre><code>void share(shared_ptr&lt;widget&gt;);            // share -- &quot;manterrà&quot; refcount

void may_share(const shared_ptr&lt;widget&gt;&amp;); // &quot;potrebbe&quot; mantenere refcount

void reseat(shared_ptr&lt;widget&gt;&amp;);          // &quot;potrebbe&quot; eseguire il reseat di ptr</code></pre>
<h5 id="imposizione-185">Imposizione</h5>
<ul>
<li>(Semplice) Avvisa se una funzione prende un parametro <code>Shared_pointer&lt;T&gt;</code> per riferimento lvalue e non lo assegna né ci chiama il <code>reset()</code> in almeno un ramo del codice. Suggerisce, invece, di prendere un <code>T*</code> o un <code>T&amp;</code>.</li>
<li>(Semplice) ((Foundation)) Avvisa se una funzione prende un <code>Shared_pointer&lt;T&gt;</code> per valore o per riferimento a <code>const</code> e non lo copia né lo sposta [move] verso un altro <code>Shared_pointer</code> in almeno un ramo del codice. Suggerisce, invece, di prendere un <code>T*</code> o un <code>T&amp;</code>.</li>
<li>(Semplice) ((Foundation)) Avvisa se una funzione accetta un parametro <code>Shared_pointer&lt;T&gt;</code> per riferimento rvalue. Si suggerisce, invece, di passare per valore.</li>
</ul>
<h3 id="r.35-prendere-un-parametro-shared_ptrwidget-per-esprimere-che-una-funzione-può-riposizionare-reseat-lo-shared-pointer"><a name="Rr-sharedptrparam"></a>R.35: Prendere un parametro <code>shared_ptr&lt;widget&gt;&amp;</code> per esprimere che una funzione può riposizionare [reseat] lo shared pointer</h3>
<h5 id="motivo-196">Motivo</h5>
<p>Ciò rende esplicito il reseat della funzione.</p>
<h5 id="note-182">Note</h5>
<p>Eseguire un “reseat” significa “fare in modo che un puntatore o un puntatore intelligente si riferiscano a un oggetto diverso”.</p>
<h5 id="esempio-buono-13">Esempio, buono</h5>
<pre><code>void share(shared_ptr&lt;widget&gt;);            // share -- &quot;manterrà&quot; il refcount

void reseat(shared_ptr&lt;widget&gt;&amp;);          // &quot;potrebbe&quot; eseguire il reseat di ptr

void may_share(const shared_ptr&lt;widget&gt;&amp;); // &quot;potrebbe&quot; mantenere il refcount</code></pre>
<h5 id="imposizione-186">Imposizione</h5>
<ul>
<li>(Semplice) Avvisa se una funzione prende un parametro <code>Shared_pointer&lt;T&gt;</code> per riferimento lvalue e non lo assegna né ci chiama il <code>reset()</code> in almeno un ramo del codice. Suggerisce, invece, di prendere un <code>T*</code> o un <code>T&amp;</code>.</li>
<li>(Semplice) ((Foundation)) Avvisa se una funzione prende un <code>Shared_pointer&lt;T&gt;</code> per valore o per riferimento a <code>const</code> e non lo copia né lo sposta [move] verso un altro <code>Shared_pointer</code> in almeno un ramo del codice. Suggerisce, invece, di prendere un <code>T*</code> o un <code>T&amp;</code>.</li>
<li>(Semplice) ((Foundation)) Avvisa se una funzione accetta un parametro <code>Shared_pointer&lt;T&gt;</code> per riferimento rvalue. Si suggerisce, invece, di passare per valore.</li>
</ul>
<h3 id="r.36-prendere-un-parametro-const-shared_ptrwidget-per-esprimere-che-potrebbe-conservare-un-conteggio-dei-riferimenti-alloggetto"><a name="Rr-sharedptrparam-const"></a>R.36: Prendere un parametro <code>const shared_ptr&lt;widget&gt;&amp;</code> per esprimere che potrebbe conservare un conteggio dei riferimenti all’oggetto ???</h3>
<h5 id="motivo-197">Motivo</h5>
<p>Questo rende la funzione ??? esplicita.</p>
<h5 id="esempio-buono-14">Esempio, buono</h5>
<pre><code>void share(shared_ptr&lt;widget&gt;);            // share -- &quot;manterrà&quot; il refcount

void reseat(shared_ptr&lt;widget&gt;&amp;);          // &quot;potrebbe&quot; eseguire il reseat di ptr

void may_share(const shared_ptr&lt;widget&gt;&amp;); // &quot;potrebbe&quot; mantenere il refcount</code></pre>
<h5 id="imposizione-187">Imposizione</h5>
<ul>
<li>(Semplice) Avvisa se una funzione prende un parametro <code>Shared_pointer&lt;T&gt;</code> per riferimento lvalue e non lo assegna né ci chiama il <code>reset()</code> in almeno un ramo del codice. Suggerisce, invece, di prendere un <code>T*</code> o un <code>T&amp;</code>.</li>
<li>(Semplice) ((Foundation)) Avvisa se una funzione prende un <code>Shared_pointer&lt;T&gt;</code> per valore o per riferimento a <code>const</code> e non lo copia né lo sposta [move] verso un altro <code>Shared_pointer</code> in almeno un ramo del codice. Suggerisce, invece, di prendere un <code>T*</code> o un <code>T&amp;</code>.</li>
<li>(Semplice) ((Foundation)) Avvisa se una funzione accetta un parametro <code>Shared_pointer&lt;T&gt;</code> per riferimento rvalue. Si suggerisce, invece, di passare per valore.</li>
</ul>
<h3 id="r.37-non-passare-un-puntatore-o-un-riferimento-ottenuti-da-un-alias-di-uno-smart-pointer"><a name="Rr-smartptrget"></a>R.37: Non passare un puntatore o un riferimento ottenuti da un alias di uno smart pointer</h3>
<h5 id="motivo-198">Motivo</h5>
<p>La violazione di questa regola è la causa numero uno della perdita del conteggio dei riferimenti e del ritrovarsi con un puntatore appeso. Le funzioni dovrebbero preferire passare i puntatori semplici e i riferimenti lunga la catena delle chiamate. Nella parte iniziale dell’albero delle chiamate dove si ottiene il puntatore semplice o il riferimento da uno puntatore intelligente che mantiene in vita l’oggetto. È necessario assicurarsi che il puntatore intelligente non possa essere inavvertitamente ripristinato o riassegnato nel resto della catena delle chiamate.</p>
<h5 id="note-183">Note</h5>
<p>Per fare ciò, a volte è necessario tenere una copia locale di un puntatore intelligente, che mantiene saldamente in vita l’oggetto per la durata della funzione e della sequenza delle chiamate.</p>
<h5 id="esempio-171">Esempio</h5>
<p>Si consideri questo codice:</p>
<pre><code>// globale (static o sull&#39;heap), o un alias locale ...
shared_ptr&lt;widget&gt; g_p = ...;

void f(widget&amp; w)
{
g();
use(w);  // A
}

void g()
{
g_p = ...; // oops, se questo è stato l&#39;ultimo shared_ptr q quel widget, distrugge il widget
}</code></pre>
<p>Quanto segue non deve superare la revisione del codice:</p>
<pre><code>void my_code()
{
// BAD: passaggio del puntatore o del riferimento ottenuto da un puntatore intelligente non locale
//      che potrebbe essere inavvertitamente ripristinato da qualche parte all&#39;interno di f o dachi richiama
f(*g_p);

// BAD: stessa ragione, basta passarlo come un puntatore &quot;this&quot;
g_p-&gt;func();
}</code></pre>
<p>La correzione è semplice – si prende una copia locale del puntatore per “mantenere un ref count” per la propria catena delle chiamate:</p>
<pre><code>void my_code()
{
// economico: 1 incremento copre l&#39;intera funzione e tutta la successiva catena delle chiamate
auto pin = g_p;

// GOOD: passaggio del puntatore o del riferimento ottenuto da un puntatore intelligente locale senza un alias
f(*pin);

// GOOD: stesso motivo
pin-&gt;func();
}</code></pre>
<h5 id="imposizione-188">Imposizione</h5>
<ul>
<li>(Semplice) Avvisa se un puntatore o un riferimento ottenuto da una variabile smart pointer (<code>Unique_pointer</code> o <code>Shared_pointer</code>) che non sia locale, o che sia locale ma potenzialmente un alias, venga utilizzato nella chiamata di una funzione. Se il puntatore intelligente è uno <code>Shared_pointer</code> allora suggerisce, invece, di prendere una copia locale dello smart pointer per ottenerne un puntatore o un riferimento.</li>
</ul>
<h1 id="es-espressioni-e-istruzioni"><a name="S-expr"></a>ES: Espressioni e istruzioni</h1>
<p>Le espressioni e le istruzioni sono il modo più semplice e diretto per esprimere azioni e calcoli. Le dichiarazioni in uno scope locale sono istruzioni.</p>
<p>Per le regole sula nomenclatura, sui commenti e l’indentazione, cfr.<a href="#S-naming">NL: Nomenclatura e layout</a>.</p>
<p>Regole generali:</p>
<ul>
<li><a href="#Res-lib">ES.1: Preferire la libreria standard alle altre librerie e al “codice artigianale”</a></li>
<li><a href="#Res-abstr">ES.2: Preferire astrazioni adatte all’uso diretto delle funzionalità del linguaggio</a></li>
</ul>
<p>Regole sulle dichiarazioni:</p>
<ul>
<li><a href="#Res-scope">ES.5: Tenere gli scope piccoli</a></li>
<li><a href="#Res-cond">ES.6: Dichiarare i nomi negli inizializzatori delle istruzioni-for e nelle condizioni per limitarne lo scope</a></li>
<li><a href="#Res-name-length">ES.7: Mantenere brevi i nomi comuni e locali e quelli meno comuni e non locali più lunghi</a></li>
<li><a href="#Res-name-similar">ES.8: Evitare similitudini tra i nomi</a></li>
<li><a href="#Res-not-CAPS">ES.9: Evitare nomi <code>TUTTO_IN_MAIUSCOLO</code></a></li>
<li><a href="#Res-name-one">ES.10: Dichiarare un (solo) nome per ogni dichiarazione</a></li>
<li><a href="#Res-auto">ES.11: Usare <code>auto</code> per evitare la ripetizione ridondante del nome dei tipi</a></li>
<li><a href="#Res-reuse">ES.12: Non riutilizzare i nomi all’interno di scope annidati</a></li>
<li><a href="#Res-always">ES.20: Inizializzare sempre un oggetto</a></li>
<li><a href="#Res-introduce">ES.21: Non introdurre una variabile (o una costante) prima che ne sia necessario l’uso</a></li>
<li><a href="#Res-init">ES.22: Non dichiarare una variabile fin quando non si abbia un valore con cui inizializzarla</a></li>
<li><a href="#Res-list">ES.23: Preferire la sintassi di inizializzazione <code>{}</code></a></li>
<li><a href="#Res-unique">ES.24: Usare un <code>unique_ptr&lt;T&gt;</code> per contenere i puntatori</a></li>
<li><a href="#Res-const">ES.25: Dichiarare un oggetto <code>const</code> o <code>constexpr</code> a meno che non se ne voglia, in seguito, modificarne il valore</a></li>
<li><a href="#Res-recycle">ES.26: Non usare una variabile per due usi non correlati</a></li>
<li><a href="#Res-stack">ES.27: Usare <code>std::array</code> o <code>stack_array</code> per gli array sullo stack</a></li>
<li><a href="#Res-lambda-init">ES.28: Usare le lambda per delle inizializzazioni complesse, specialmente di variabili <code>const</code></a></li>
<li><a href="#Res-macros">ES.30: Non usare le macro per manipolare il testo del programma</a></li>
<li><a href="#Res-macros2">ES.31: Non usare le macro per le costanti o le “funzioni”</a></li>
<li><a href="#Res-ALL_CAPS">ES.32: Usare il <code>TUTTO_IN_MAIUSCOLO</code> per tutti i nomi delle macro</a></li>
<li><a href="#Res-MACROS">ES.33: Se è necessario usare le macro, dargli dei nomi univoci</a></li>
<li><a href="#Res-ellipses">ES.34: Non definire una funzione variadica (C-style)</a></li>
</ul>
<p>Regole sulle espressioni:</p>
<ul>
<li><a href="#Res-complicated">ES.40: Evitare espressioni complicate</a></li>
<li><a href="#Res-parens">ES.41: In caso di dubbio sulla precedenza degli operatori, usare le parentesi</a></li>
<li><a href="#Res-ptr">ES.42: Usare in modo semplice e diretto i puntatori</a></li>
<li><a href="#Res-order">ES.43: Evitare espressioni con un ordine di valutazione incerto</a></li>
<li><a href="#Res-order-fct">ES.44: Non dipendere dall’ordine di valutazione degli argomenti di una funzione</a></li>
<li><a href="#Res-magic">ES.45: Evitare “costanti magiche”; utilizzare costanti simboliche</a></li>
<li><a href="#Res-narrowing">ES.46: Evitare le conversioni “narrowing”</a></li>
<li><a href="#Res-nullptr">ES.47: Usare <code>nullptr</code> anziché <code>0</code> o <code>NULL</code></a></li>
<li><a href="#Res-casts">ES.48: Evitare i cast</a></li>
<li><a href="#Res-casts-named">ES.49: Se si deve usare un cast, si utilizzi un “named cast”</a></li>
<li><a href="#Res-casts-const">ES.50: Non eseguire il cast da un <code>const</code></a></li>
<li><a href="#Res-range-checking">ES.55: Evitare la necessità di controllare i range</a></li>
<li><a href="#Res-move">ES.56: Scrivere <code>std::move()</code> solo quando è necessario spostare esplicitamente un oggetto in un altro scope</a></li>
<li><a href="#Res-new">ES.60: Evitare <code>new</code> e <code>delete</code> al di fuori delle funzioni di gestione delle risorse</a></li>
<li><a href="#Res-del">ES.61: Eseguire il delete degli array con <code>delete[]</code> e usando <code>delete</code> per il resto</a></li>
<li><a href="#Res-arr2">ES.62: Non confrontare i puntatori in diversi array</a></li>
<li><a href="#Res-slice">ES.63: Non provocare “slice”</a></li>
<li><a href="#Res-construct">ES.64: Usare la notazione <code>T{e}</code> per la costruzione</a></li>
<li><a href="#Res-deref">ES.65: Non de-referenziare un puntatore non valido</a></li>
</ul>
<p>Regole sulle istruzioni:</p>
<ul>
<li><a href="#Res-switch-if">ES.70: Preferire l’istruzione <code>switch</code> all’istruzione <code>if</code> potendo scegliere</a></li>
<li><a href="#Res-for-range">ES.71: Preferire un’istruzione range-<code>for</code> ad un’istruzione <code>for</code> potendo scegliere</a></li>
<li><a href="#Res-for-while">ES.72: Preferire un’istruzione <code>for</code> ad un’istruzione <code>while</code> quando c’è un’ovvia variabile del ciclo</a></li>
<li><a href="#Res-while-for">ES.73: Preferire un’istruzione <code>while</code> ad un’istruzione <code>for</code> quando non è ovvia la variabile del ciclo</a></li>
<li><a href="#Res-for-init">ES.74: Preferire dichiarare una variabile del ciclo nella parte dell’inizializzatore di un’istruzione <code>for</code></a></li>
<li><a href="#Res-do">ES.75: Evitare l’istruzione <code>do</code></a></li>
<li><a href="#Res-goto">ES.76: Evitare il <code>goto</code></a></li>
<li><a href="#Res-continue">ES.77: Minimizzare l’uso di <code>break</code> e <code>continue</code> nei cicli</a></li>
<li><a href="#Res-break">ES.78: Non fare affidamento ai proseguimenti impliciti nelle istruzioni <code>switch</code></a></li>
<li><a href="#Res-default">ES.79: Usare <code>default</code> per gestire i (soli) casi comuni</a></li>
<li><a href="#Res-noname">ES.84: Non tentare di dichiarare una variabile locale senza nome</a></li>
<li><a href="#Res-empty">ES.85: Rendere visibili le istruzioni vuote</a></li>
<li><a href="#Res-loop-counter">ES.86: Evitare di modificare le variabili di controllo dei cicli nel corpo dei cicli for</a></li>
<li><a href="#Res-if">ES.87: Non aggiungere dei ridondanti <code>==</code> o <code>!=</code> alle condizioni</a></li>
</ul>
<p>Regole sull’aritmetica:</p>
<ul>
<li><a href="#Res-mix">ES.100: Non mischiare l’aritmetica con segno con quella senza segno</a></li>
<li><a href="#Res-unsigned">ES.101: Usare i tipi unsigned per la gestione dei bit</a></li>
<li><a href="#Res-signed">ES.102: Usare i tipi con segno per l’aritmetica</a></li>
<li><a href="#Res-overflow">ES.103: Evitare l’overflow</a></li>
<li><a href="#Res-underflow">ES.104: Evitare l’underflow</a></li>
<li><a href="#Res-zero">ES.105: Evitare la divisione per zero</a></li>
<li><a href="#Res-nonnegative">ES.106: Non tentare di evitare i valori negativi utilizzando <code>unsigned</code></a></li>
<li><a href="#Res-subscripts">ES.107: Non usare <code>unsigned</code> per l’indicizzazione, preferire <code>gsl::index</code></a></li>
</ul>
<h3 id="es.1-preferire-la-libreria-standard-alle-altre-librerie-e-al-codice-artigianale"><a name="Res-lib"></a>ES.1: Preferire la libreria standard alle altre librerie e al “codice artigianale”</h3>
<h5 id="motivo-199">Motivo</h5>
<p>Il codice che usa una libreria può risultare molto più facile da scrivere rispetto al codice che funziona direttamente con le funzionalità del linguaggio, molto più breve, tende ad avere un livello di astrazione più alto, inoltre il codice della libreria è presumibilmente già testato. La ISO C++ Standard Library è tra le librerie più conosciute e meglio testate. È disponibile come parte di tutte le implementazioni del C++.</p>
<h5 id="esempio-172">Esempio</h5>
<pre><code>auto sum = accumulate(begin(a), end(a), 0.0);   // buono</code></pre>
<p>una versione “range” di <code>accumulate</code> sarebbe ancora meglio:</p>
<pre><code>auto sum = accumulate(v, 0.0); // meglio</code></pre>
<p>ma non codificare a mano un algoritmo ben noto:</p>
<pre><code>int max = v.size();   // bad: prolisso, uso non dichiarato
double sum = 0.0;
for (int i = 0; i &lt; max; ++i)
sum = sum + v[i];</code></pre>
<h5 id="eccezione-31">Eccezione</h5>
<p>Grandi parti della libreria standard si basano sull’allocazione dinamica (free store). Tali parti, in particolare i contenitori ma non gli algoritmi, non sono idonee per alcune applicazioni fortemente real-time ed embedded. In questi casi, si prenda in considerazione la possibilità di fornire/usare delle strutture simili, p.es., un contenitore simile alla libreria standard implementato con un “pool allocator” [in memoria].</p>
<h5 id="imposizione-189">Imposizione</h5>
<p>Non facile. ??? Cerca loop disordinati, nidificati, funzioni lunghe, assenza di chiamate a funzioni, mancanza dell’utilizzo dei tipi non-built-in. Complessità ciclomatica?</p>
<h3 id="es.2-preferire-astrazioni-adatte-alluso-diretto-delle-funzionalità-del-linguaggio"><a name="Res-abstr"></a>ES.2: Preferire astrazioni adatte all’uso diretto delle funzionalità del linguaggio</h3>
<h5 id="motivo-200">Motivo</h5>
<p>Una “astrazione adatta” (p.es., libreria o classe) è più vicina ai concetti dell’applicazione che al semplice linguaggio, porta ad un codice più breve e più chiaro ed è probabilmente testato meglio.</p>
<h5 id="esempio-173">Esempio</h5>
<pre><code>vector&lt;string&gt; read1(istream&amp; is)   // good
{
vector&lt;string&gt; res;
for (string s; is &gt;&gt; s;)
res.push_back(s);
return res;
}</code></pre>
<p>Quello equivalente più tradizionale e a livello più basso è più lungo, più disordinato, difficile da correggere, e probabilmente più lento:</p>
<pre><code>char** read2(istream&amp; is, int maxelem, int maxstring, int* nread)   // bad: prolisso e incompleto
{
auto res = new char*[maxelem];
int elemcount = 0;
while (is &amp;&amp; elemcount &lt; maxelem) {
auto s = new char[maxstring];
is.read(s, maxstring);
res[elemcount++] = s;
}
nread = &amp;elemcount;
return res;
}</code></pre>
<p>Una volta aggiunto il controllo per l’overflow e la gestione degli errori questo codice diventa piuttosto disordinato e si verifica il problema di ricordarsi di eseguire il <code>delete</code> del puntatore restituito e delle stringhe C-style che l’array contiene.</p>
<h5 id="imposizione-190">Imposizione</h5>
<p>Non facile. ??? Cerca loop disordinati, nidificati, funzioni lunghe, assenza di chiamate a funzioni, mancanza dell’utilizzo dei tipi non-built-in. Complessità ciclomatica?</p>
<h2 id="es.dcl-dichiarazioni">ES.dcl: Dichiarazioni</h2>
<p>Una dichiarazione è un’istruzione. Una dichiarazione introduce un nome in uno scope e può causare la costruzione di un oggetto.</p>
<h3 id="es.5-tenere-gli-scope-piccoli"><a name="Res-scope"></a>ES.5: Tenere gli scope piccoli</h3>
<h5 id="motivo-201">Motivo</h5>
<p>Leggibilità. Minimizzare la ritenzione delle risorse. Evitare l’abuso accidentale del valore.</p>
<p><strong>Formulazione alternativa</strong>: Non dichiarare inutilmente un nome in un grande scope.</p>
<h5 id="esempio-174">Esempio</h5>
<pre><code>void use()
{
int i;    // bad: i è inutilmente accessibile dopo il loop
for (i = 0; i &lt; 20; ++i) { /* ... */ }
// qui, nessun uso previsto di i
for (int i = 0; i &lt; 20; ++i) { /* ... */ }  // good: i è locale al ciclo for

if (auto pc = dynamic_cast&lt;Circle*&gt;(ps)) {  // good: pc è locale all&#39;istruzione if
// ... gestione di Circle ...
}
else {
// ... gestione degli errori ...
}
}</code></pre>
<h5 id="esempio-cattivo-74">Esempio, cattivo</h5>
<pre><code>void use(const string&amp; name)
{
string fn = name + &quot;.txt&quot;;
ifstream is {fn};
Record r;
is &gt;&gt; r;
// ... 200 righe di codice senza utilizzare fn né is ...
}</code></pre>
<p>Questa funzione è comunque troppo lunga, ma il punto è che le risorse utilizzate da <code>fn</code> e l’handle del file tenuto da <code>is</code> vengono conservati per molto più tempo del necessario e quell’uso imprevisto di <code>is</code> e <code>fn</code> potrebbe avvenire in seguito nella funzione. In questo caso, potrebbe essere una buona idea prendere in considerazione la lettura:</p>
<pre><code>Record load_record(const string&amp; name)
{
string fn = name + &quot;.txt&quot;;
ifstream is {fn};
Record r;
is &gt;&gt; r;
return r;
}

void use(const string&amp; name)
{
Record r = load_record(name);
// ... 200 righe di codice ...
}</code></pre>
<h5 id="imposizione-191">Imposizione</h5>
<ul>
<li>Segnala una variabile del ciclo dichiarata al di fuori del ciclo e non usata dopo di esso</li>
<li>Segnala quando le risorse costose, come gli handle dei fie e i lock nn vengono usati per N-righe (con un N adatto</li>
</ul>
<h3 id="es.6-dichiarare-i-nomi-negli-inizializzatori-delle-istruzioni-for-e-nelle-condizioni-per-limitarne-lo-scope"><a name="Res-cond"></a>ES.6: Dichiarare i nomi negli inizializzatori delle istruzioni-for e nelle condizioni per limitarne lo scope</h3>
<h5 id="motivo-202">Motivo</h5>
<p>Leggibilità. Minimizzare la ritenzione delle risorse.</p>
<h5 id="esempio-175">Esempio</h5>
<pre><code>void use()
{
for (string s; cin &gt;&gt; s;)
v.push_back(s);

for (int i = 0; i &lt; 20; ++i) {   // good: i è locale al ciclo for
// ...
}

if (auto pc = dynamic_cast&lt;Circle*&gt;(ps)) {   // good: pc è locale all&#39;istruzione if
// ... usa  Circle ...
}
else {
// ... gestione dell&#39;errore ...
}
}</code></pre>
<h5 id="imposizione-192">Imposizione</h5>
<ul>
<li>Segnala le variabili dei loop dichiarate prima del ciclo e nn usate dopo di esso</li>
<li>(difficile) Segnala le variabili dei loop dichiarate prima del ciclo ed usate dopo di esso per un uso non correlato.</li>
</ul>
<h5 id="esempio-c17-e-c20">Esempio C++17 e C++20</h5>
<p>Nota: C++17 e C++20 hanno anche gli inizializzatori per le istruzioni <code>if</code>, <code>switch</code>, e range-<code>for</code>. Questi richiedono il supporto del C++17 e del C++20.</p>
<pre><code>map&lt;int, string&gt; mymap;

if (auto result = mymap.insert(value); result.second) {
// l&#39;inserimento è riuscito e il risultato è valido per questo blocco
use(result.first);  // ok
// ...
} // qui il risultato è distrutto</code></pre>
<h5 id="imposizione-c17-e-c20-se-si-usa-un-compilatore-c17-o-c20">Imposizione C++17 e C++20 (se si usa un compilatore C++17 o C++20)</h5>
<ul>
<li>Segnala variabili di selezione/loop dichiarate prima del body e non usate dopo</li>
<li>(difficile) Seleziona le variabili di selezione/loop dichiarate prima del body ed usate dopo il body per un uso non correlato.</li>
</ul>
<h3 id="es.7-mantenere-brevi-i-nomi-comuni-e-locali-e-quelli-meno-comuni-e-non-locali-più-lunghi"><a name="Res-name-length"></a>ES.7: Mantenere brevi i nomi comuni e locali e quelli meno comuni e non locali più lunghi</h3>
<h5 id="motivo-203">Motivo</h5>
<p>Leggibilità. Ridurre la possibilità di scontri tra nomi non locali non correlati.</p>
<h5 id="esempio-176">Esempio</h5>
<p>Nomi locali brevi aumentano la leggibilità:</p>
<pre><code>template&lt;typename T&gt;    // good
void print(ostream&amp; os, const vector&lt;T&gt;&amp; v)
{
for (gsl::index i = 0; i &lt; v.size(); ++i)
os &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;;
}</code></pre>
<p>Un indice è convenzionalmente chiamato <code>i</code> e non c’è alcun indizio sul significato del vettore in questa generica funzione, quindi <code>v</code> è un nome buono come un altro. Da confrontare con</p>
<pre><code>template&lt;typename Element_type&gt;   // bad: prolisso, difficile da leggere
void print(ostream&amp; target_stream, const vector&lt;Element_type&gt;&amp; current_vector)
{
for (gsl::index current_element_index = 0;
current_element_index &lt; current_vector.size();
++current_element_index
)
target_stream &lt;&lt; current_vector[current_element_index] &lt;&lt; &#39;\n&#39;;
}</code></pre>
<p>Sì, è una caricatura, ma c’è di peggio.</p>
<h5 id="esempio-177">Esempio</h5>
<p>Nomi non-locali corti e non convenzionali codice criptico:</p>
<pre><code>void use1(const string&amp; s)
{
// ...
tt(s);   // bad: che cos&#39;è tt()?
// ...
}</code></pre>
<p>Meglio, ci sono nomi leggibili di entità non-locali:</p>
<pre><code>void use1(const string&amp; s)
{
// ...
trim_tail(s);   // meglio
// ...
}</code></pre>
<p>Qui, c’è la possibilità che il lettore sappia cosa significa <code>trim_tail</code> e che possa ricordarlo dopo averlo cercato.</p>
<h5 id="esempio-cattivo-75">Esempio, cattivo</h5>
<p>I nomi degli argomenti di grandi funzioni sono ‘de facto’ non locali e dovrebbero essere significativi:</p>
<pre><code>void complicated_algorithm(vector&lt;Record&gt;&amp; vr, const vector&lt;int&gt;&amp; vi, map&lt;string, int&gt;&amp; out)
// legge dagli eventi in vr (segnando i Record usati) secondo gli indici in
// vi mettendo le coppie (nome, indice) in out
{
// ... 500 righe di codice utilizzando vr, vi, e out ...
}</code></pre>
<p>Si raccomanda di mantenere brevi le funzioni, ma quella regola non è universalmente rispettata e la nomenclatura lo dovrebbe rispecchiare.</p>
<h5 id="imposizione-193">Imposizione</h5>
<p>Controllare la lunghezza dei nomi locali e non. Tenere conto anche della lunghezza della funzione.</p>
<h3 id="es.8-evitare-similitudini-tra-i-nomi"><a name="Res-name-similar"></a>ES.8: Evitare similitudini tra i nomi</h3>
<h5 id="motivo-204">Motivo</h5>
<p>Chiarezza e leggibilità del codice. Nomi troppo simili rallentano la comprensione e aumentano la probabilità di errori.</p>
<h5 id="esempio-cattivo-76">Esempio, cattivo</h5>
<pre><code>if (readable(i1 + l1 + ol + o1 + o0 + ol + o1 + I0 + l0)) surprise();</code></pre>
<h5 id="esempio-cattivo-77">Esempio, cattivo</h5>
<p>Non dichiarare un non-tipo con lo stesso nome di un tipo nello stesso scope. Ciò elimina la necessità di chiarire le ambiguità con una parola chiave come <code>struct</code> o <code>enum</code>. Rimuove anche una fonte di errori, poiché <code>struct X</code> può dichiarare implicitamente <code>X</code> se fallisce la ricerca [lookup].</p>
<pre><code>struct foo { int n; };
struct foo foo();       // BAD, foo è un tipo già presente nello scope
struct foo x = foo();   // richiede una disambiguazione</code></pre>
<h5 id="eccezione-32">Eccezione</h5>
<p>I file header più antichi potrebbero dichiarare non tipi e tipi con lo stesso nome nello stesso scope.</p>
<h5 id="imposizione-194">Imposizione</h5>
<ul>
<li>Controlla i nomi in un elenco di note combinazioni di lettere e numeri.</li>
<li>Segnala una dichiarazione di una variabile, una funzione, o un enumeratore che nasconde una classe o una enumerazione dichiarata nello stesso scope.</li>
</ul>
<h3 id="es.9-evitare-nomi-tutto_in_maiuscolo"><a name="Res-not-CAPS"></a>ES.9: Evitare nomi <code>TUTTO_IN_MAIUSCOLO</code></h3>
<h5 id="motivo-205">Motivo</h5>
<p>Tali nomi sono comunemente usati per le macro. Quindi, i nomi <code>TUTTO_IN_MAIUSCOLO</code> sono vulnerabili alla sostituzione non intenzionale delle macro.</p>
<h5 id="esempio-178">Esempio</h5>
<pre><code>// da qualche parte in qualche header:
#define NE !=

// altrove in qualche altro header:
enum Coord { N, NE, NW, S, SE, SW, E, W };

// da qualche parte in un .cpp di un povero programmatore:
switch (direction) {
case N:
// ...
case NE:
// ...
// ...
}</code></pre>
<h5 id="note-184">Note</h5>
<p>Non usare il <code>TUTTO_IN_MAIUSCOLO</code> per le costanti solo perché le macro venivano usate per le costanti.</p>
<h5 id="imposizione-195">Imposizione</h5>
<p>Segnalare gli usi del TUTTO_IN_MAIUSCOLO. Per il codice più vecchio, accettare il TUTTO_IN_MAIUSCOLO per i nomi delle macro e segnalare i nomi delle macro non in TUTTO_IN_MAIUSCOLO.</p>
<h3 id="es.10-dichiarare-un-solo-nome-per-ogni-dichiarazione"><a name="Res-name-one"></a>ES.10: Dichiarare un (solo) nome per ogni dichiarazione</h3>
<h5 id="motivo-206">Motivo</h5>
<p>Una dichiarazione per ogni riga aumenta la leggibilità ed evita errori relativi alla grammatica C/C++. Inoltre, lascia spazio a un commento di fine riga più descrittivo.</p>
<h5 id="esempio-cattivo-78">Esempio, cattivo</h5>
<pre><code>char *p, c, a[7], *pp[7], **aa[10];   // che schifo!</code></pre>
<h5 id="eccezione-33">Eccezione</h5>
<p>Una dichiarazione di funzione può contenere diverse dichiarazioni di argomenti di funzione.</p>
<h5 id="eccezione-34">Eccezione</h5>
<p>Un’associazione strutturata [structured binding] (C++17) è specificamente progettata per introdurre diverse variabili:</p>
<pre><code>auto [iter, inserted] = m.insert_or_assign(k, val);
if (inserted) { /* è stata inserita una nuova voce */ }</code></pre>
<h5 id="esempio-179">Esempio</h5>
<pre><code>template &lt;class InputIterator, class Predicate&gt;
bool any_of(InputIterator first, InputIterator last, Predicate pred);</code></pre>
<p>o meglio usando i concetti:</p>
<pre><code>bool any_of(InputIterator first, InputIterator last, Predicate pred);</code></pre>
<h5 id="esempio-180">Esempio</h5>
<pre><code>double scalbn(double x, int n);   // OK: x * pow(FLT_RADIX, n); di solito FLT_RADIX è 2</code></pre>
<p>o:</p>
<pre><code>double scalbn(    // meglio: x * pow(FLT_RADIX, n); di solito FLT_RADIX è 2
double x,     // valore della base
int n         // esponente
);</code></pre>
<p>o:</p>
<pre><code>// meglio: base * pow(FLT_RADIX, exponent); di solito FLT_RADIX è 2
double scalbn(double base, int exponent);</code></pre>
<h5 id="esempio-181">Esempio</h5>
<pre><code>int a = 7, b = 9, c, d = 10, e = 3;</code></pre>
<p>In un lungo elenco di dichiaratori, è facile trascurare una variabile non inizializzata.</p>
<h5 id="imposizione-196">Imposizione</h5>
<p>Segnalare le dichiarazioni di variabili o costanti con dichiaratori multipli (p.es., <code>int* p, q;</code>)</p>
<h3 id="es.11-usare-auto-per-evitare-la-ripetizione-ridondante-del-nome-dei-tipi"><a name="Res-auto"></a>ES.11: Usare <code>auto</code> per evitare la ripetizione ridondante del nome dei tipi</h3>
<h5 id="motivo-207">Motivo</h5>
<ul>
<li>La semplice ripetizione è noiosa e soggetta a errori.</li>
<li>Quando si usa <code>auto</code>, il nome dell’entità dichiarata si trova in una posizione fissa nella dichiarazione, aumentando la leggibilità..</li>
<li>In una dichiarazione di una funzione template il tipo di ritorno può essere un tipo membro.</li>
</ul>
<h5 id="esempio-182">Esempio</h5>
<p>Si consideri:</p>
<pre><code>auto p = v.begin();   // vector&lt;int&gt;::iterator
auto h = t.future();
auto q = make_unique&lt;int[]&gt;(s);
auto f = [](int x){ return x + 10; };</code></pre>
<p>In ciascun caso, ci si risparmia la scrittura di un tipo lungo e difficile da ricordare che il compilatore già conosce ma che un programmatore potrebbe scrivere in modo sbagliato.</p>
<h5 id="esempio-183">Esempio</h5>
<pre><code>template&lt;class T&gt;
auto Container&lt;T&gt;::first() -&gt; Iterator;   // Container&lt;T&gt;::Iterator</code></pre>
<h5 id="eccezione-35">Eccezione</h5>
<p>Evitare <code>auto</code> per gli elenchi di inizializzatori e nei casi in cui si conosce esattamente quale tipo si vuole e dove un inizializzatore potrebbe richiedere una conversione.</p>
<h5 id="esempio-184">Esempio</h5>
<pre><code>auto lst = { 1, 2, 3 };   // lst è un elenco di inizializzatori
auto x{1};   // x è un int (in C++17; initializer_list in C++11)</code></pre>
<h5 id="note-185">Note</h5>
<p>Quando i concetti diventano disponibili, possiamo (e dovremmo) essere più specifici sul tipo che si sta deducendo:</p>
<pre><code>// ...
ForwardIterator p = algo(x, y, z);</code></pre>
<h5 id="esempio-c17">Esempio (C++17)</h5>
<pre><code>auto [ quotient, remainder ] = div(123456, 73);   // suddivide i membri del risultato div_t</code></pre>
<h5 id="imposizione-197">Imposizione</h5>
<p>Segnala la ripetizione ridondante dei nomi dei tipi in una dichiarazione.</p>
<h3 id="es.12-non-riutilizzare-i-nomi-allinterno-di-scope-annidati"><a name="Res-reuse"></a>ES.12: Non riutilizzare i nomi all’interno di scope annidati</h3>
<h5 id="motivo-208">Motivo</h5>
<p>È facile confondersi su quale variabile venga utilizzata. Può causare problemi di manutenzione.</p>
<h5 id="esempio-cattivo-79">Esempio, cattivo</h5>
<pre><code>int d = 0;
// ...
if (cond) {
// ...
d = 9;
// ...
}
else {
// ...
int d = 7;
// ...
d = value_to_be_returned;
// ...
}

return d;</code></pre>
<p>Se questa è una grande istruzione <code>if</code>, è facile trascurare il fatto che una nuova <code>d</code> è stata introdotta nello scope più interno. Questa è una nota fonte di bug. Talvolta tale riutilizzo di un nome in uno scope interno è detto “shadowing”.</p>
<h5 id="note-186">Note</h5>
<p>Lo shadowing è un problema principalmente quando le funzioni sono troppo grandi e troppo complesse.</p>
<h5 id="esempio-185">Esempio</h5>
<p>Lo shadowing degli argomenti di una funzione nel blocco più esterno è impedito dal linguaggio:</p>
<pre><code>void f(int x)
{
int x = 4;  // errore: riutilizzo del nome dell&#39;argomento della funzione

if (x) {
int x = 7;  // consentito, ma pessimo
// ...
}
}</code></pre>
<h5 id="esempio-cattivo-80">Esempio, cattivo</h5>
<p>Anche il riutilizzo del nome di un membro come una variabile locale può essere un problema:</p>
<pre><code>struct S {
int m;
void f(int x);
};

void S::f(int x)
{
m = 7;    // assegna al membro
if (x) {
int m = 9;
// ...
m = 99; // assegna alla variabile locale
// ...
}
}</code></pre>
<h5 id="eccezione-36">Eccezione</h5>
<p>Spesso si riutilizzano i nomi delle funzioni di una classe base in una classe derivata:</p>
<pre><code>struct B {
void f(int);
};

struct D : B {
void f(double);
using B::f;
};</code></pre>
<p>Questo è fonte di errori. Ad esempio, se avessimo dimenticato la dichiarazione di di using, una chiamata a <code>d.f(1)</code> non avrebbe trovato la versione <code>int</code> di <code>f</code>.</p>
<p>??? C’è la necessità di una regola specifica per lo shadowing/hiding nelle gerarchie delle classi?</p>
<h5 id="imposizione-198">Imposizione</h5>
<ul>
<li>Segnalare il riutilizzo di un nome negli scope locali nidificati</li>
<li>Segnalare il riutilizzo di un nome di un membro come variabile locale in una funzione membro</li>
<li>Segnalare il riutilizzo di un nome globale come variabile locale o il nome di un membro</li>
<li>Segnalare il riutilizzo di un nome di un membro di una classe base in una classe derivata (ad eccezione dei nomi delle funzioni)</li>
</ul>
<h3 id="es.20-inizializzare-sempre-un-oggetto"><a name="Res-always"></a>ES.20: Inizializzare sempre un oggetto</h3>
<h5 id="motivo-209">Motivo</h5>
<p>Evitare errori usato-prima-della-assegnazione e l’associato comportamento indefinito. -evitare i problemi di comprensione di una inizializzazione complessa. Semplifica il refactoring.</p>
<h5 id="esempio-186">Esempio</h5>
<pre><code>void use(int arg)
{
int i;   // bad: variabile non inizializzata
// ...
i = 7;   // inizializza i
}</code></pre>
<p>No, <code>i = 7</code> non inizializza <code>i</code>; lo assegna. Inoltre, <code>i</code> può essere letta nella parte <code>...</code>. Meglio:</p>
<pre><code>void use(int arg)   // OK
{
int i = 7;   // OK: inizializzato
string s;    // OK: inizializzato col default
// ...
}</code></pre>
<h5 id="note-187">Note</h5>
<p>La regola <em>inizializzare sempre</em> è deliberatamente più forte della regola del linguaggio <em>un oggetto deve essere inizializzato prima di essere usato</em>. Quest’ultima regola, più rilassata, rileva i bug tecnici, ma:</p>
<ul>
<li>Porta a un codice meno leggibile</li>
<li>Incoraggia a dichiarare i nomi in scope più ampi del necessario</li>
<li>Porta ad una più difficile lettura del codice</li>
<li>Porta a bug logici incoraggiando un codice complesso</li>
<li>Ostacola il refactoring</li>
</ul>
<p>La regola <em>inizializzare sempre</em>è una regola di stile volta a migliorare la manutenibilità, nonché è una regola che protegge dagli errori usato-prima-della-assegnazione.</p>
<h5 id="esempio-187">Esempio</h5>
<p>Ecco un esempio che viene spesso considerato per dimostrare la necessità di una regola più rilassata per l’inizializzazione</p>
<pre><code>widget i;    // &quot;widget&quot; un tipo che è costoso da inizializzare, forse un grande POD [Plain Old Data]
widget j;

if (cond) {  // bad: i e j vengono inizializzati &quot;in ritardo&quot;
i = f1();
j = f2();
}
else {
i = f3();
j = f4();
}</code></pre>
<p>Questo non può essere banalmente riscritto per inizializzare <code>i</code> e <code>j</code> con gli inizializzatori. Si noti che per i tipi con un costruttore di default, il tentativo di posticipare l’inizializzazione porta semplicemente a una inizializzazione di default seguita da una assegnazione. Una popolare motivazione per questi esempi è “l’efficienza”, ma un compilatore che possa rilevare se si è incappati in un errore usato-prima-della-assegnazione può anche eliminare ogni ridondante inizializzazione duplicata.</p>
<p>Supponendo che vi sia una connessione logica tra <code>i</code> e <code>j</code>, tale connessione dovrebbe probabilmente essere espressa nel codice:</p>
<pre><code>pair&lt;widget, widget&gt; make_related_widgets(bool x)
{
return (x) ? {f1(), f2()} : {f3(), f4() };
}

auto [i, j] = make_related_widgets(cond);    // C++17</code></pre>
<p>Se la funzione <code>make_related_widgets</code> è altrimenti ridondante, possiamo eliminarla usando una lambda <a href="#Res-lambda-init">ES.28</a>:</p>
<pre><code>auto [i, j] = [x]{ return (x) ? pair{f1(), f2()} : pair{f3(), f4()} }();    // C++17</code></pre>
<p>L’uso di un valore che rappresenta il “non-inizializzato” è un sintomo di un problema e non una soluzione:</p>
<pre><code>widget i = uninit;  // bad
widget j = uninit;

// ...
use(i);         // forse usato prima di essere impostato
// ...

if (cond) {     // bad: i e j vengono inizializzati &quot;in ritardo&quot;
i = f1();
j = f2();
}
else {
i = f3();
j = f4();
}</code></pre>
<p>Ora il compilatore non può nemmeno semplicemente rilevare un usato-prima-della-assegnazione. Inoltre, abbiamo introdotto una complessità nello spazio degli stati per il widget: quali operazioni sono valide su un widget <code>uninit</code> e quali no?</p>
<h5 id="note-188">Note</h5>
<p>L’inizializzazione complessa è stata popolare per decenni con i programmatori intelligenti. È stata anche una delle principali fonti di errori e complessità. Molti di questi errori vengono introdotti durante gli anni di manutenzione dopo l’implementazione iniziale.</p>
<h5 id="esempio-188">Esempio</h5>
<p>Questa regola copre le variabili membro.</p>
<pre><code>class X {
public:
X(int i, int ci) : m2{i}, cm2{ci} {}
// ...

private:
int m1 = 7;
int m2;
int m3;

const int cm1 = 7;
const int cm2;
const int cm3;
};</code></pre>
<p>Il compilatore segnala il <code>cm3</code> non inizializzato perché è un <code>const</code>, ma non rileva l’assenza di inizializzazione di <code>m3</code>. Di solito, una rara inizializzazione del membro spurio giustifica l’assenza di errori dalla mancanza di inizializzazione e spesso un ottimizzatore può eliminare un’inizializzazione ridondante (p.es., un’inizializzazione che si verifica immediatamente prima di un’assegnazione).</p>
<h5 id="eccezione-37">Eccezione</h5>
<p>Se si sta dichiarando un oggetto che sta per essere inizializzato dall’input, l’inizializzazione causerebbe una doppia inizializzazione. Tuttavia, si tenga presente che ciò potrebbe lasciare dati non inizializzati dopo l’input – e che è stata una fertile fonte di errori e violazioni della sicurezza:</p>
<pre><code>constexpr int max = 8 * 1024;
int buf[max];         // OK, ma sospetto: non inizializzato
f.read(buf, max);</code></pre>
<p>Il costo di inizializzazione di tale array potrebbe essere significativo in alcune situazioni. Tuttavia, tali esempi tendono a lasciare accessibili le variabili non inizializzate, quindi dovrebbero essere trattate con sospetto.</p>
<pre><code>constexpr int max = 8 * 1024;
int buf[max] = {};   // azzera tutti gli elementi; meglio in alcune situazioni
f.read(buf, max);</code></pre>
<p>A causa delle regole di inizializzazione restrittive per gli array e <code>std::array</code>, offrono gli esempi più convincenti della necessità di questa eccezione.</p>
<p>Se possibile, utilizzare una funzione di libreria nota per non andare in overflow. Per esempio:</p>
<pre><code>string s;   // s è inizializzata per default a &quot;&quot;
cin &gt;&gt; s;   // s si espande per contenere la stringa</code></pre>
<p>Non considerare le variabili semplici che sono oggetto delle operazioni di input come eccezioni a questa regola:</p>
<pre><code>int i;   // bad
// ...
cin &gt;&gt; i;</code></pre>
<p>Nel caso non raro in cui gli oggetti dell’input e le operazioni di input sono separate (come non dovrebbero essere) sorge la possibilità dell’usato-prima-della-assegnazione.</p>
<pre><code>int i2 = 0;   // meglio, supponendo che lo zero sia un valore accettabile per i2
// ...
cin &gt;&gt; i2;</code></pre>
<p>Un buon ottimizzatore dovrebbe conoscere le operazioni di input ed eliminare l’operazione ridondante.</p>
<h5 id="note-189">Note</h5>
<p>A volte, una lambda può essere utilizzata come inizializzatore per evitare una variabile non inizializzata:</p>
<pre><code>error_code ec;
Value v = [&amp;] {
auto p = get_value();   // get_value() restituisce un pair&lt;error_code, Value&gt;
ec = p.first;
return p.second;
}();</code></pre>
<p>o forse:</p>
<pre><code>Value v = [] {
auto p = get_value();   // get_value() restituisce un pair&lt;error_code, Value&gt;
if (p.first) throw Bad_value{p.first};
return p.second;
}();</code></pre>
<p><strong>Si veda anche</strong>: <a href="#Res-lambda-init">ES.28</a></p>
<h5 id="imposizione-199">Imposizione</h5>
<ul>
<li>Segnalare ogni variabile non inizializzata. Non segnalare le variabili dei tipi user-defined con costruttori di default.</li>
<li>Controllare che un buffer non inizializzato venga scritto <em>immediatamente</em> dopo la dichiarazione. Il passaggio di una variabile non inizializzata come riferimento ad un argomento non-<code>const</code> può essere considerato come una scrittura nella variabile.</li>
</ul>
<h3 id="es.21-non-introdurre-una-variabile-o-una-costante-prima-che-ne-sia-necessario-luso"><a name="Res-introduce"></a>ES.21: Non introdurre una variabile (o una costante) prima che ne sia necessario l’uso</h3>
<h5 id="motivo-210">Motivo</h5>
<p>Leggibilità. Per limitare lo scope in cui si può usare la variabile.</p>
<h5 id="esempio-189">Esempio</h5>
<pre><code>int x = 7;
// ... qui nessun uso di x ...
++x;</code></pre>
<h5 id="imposizione-200">Imposizione</h5>
<p>Segnalare le dichiarazioni che sono distanti dal loro primo utilizzo.</p>
<h3 id="es.22-non-dichiarare-una-variabile-fin-quando-non-si-abbia-un-valore-con-cui-inizializzarla"><a name="Res-init"></a>ES.22: Non dichiarare una variabile fin quando non si abbia un valore con cui inizializzarla</h3>
<h5 id="motivo-211">Motivo</h5>
<p>Leggibilità. Limitare lo scope in cui sia possibile usare una variabile. Per non rischiare l’usato-prima-della-assegnazione. L’inizializzazione è spesso più efficiente dell’assegnazione.</p>
<h5 id="esempio-cattivo-81">Esempio, cattivo</h5>
<pre><code>string s;
// ... qui nessun uso di s ...
s = &quot;che spreco&quot;;</code></pre>
<h5 id="esempio-cattivo-82">Esempio, cattivo</h5>
<pre><code>SomeLargeType var;   // un brutto CaMeLcAsEvArIaBlE

if (cond)   // delle condizioni non banali
Set(&amp;var);
else if (cond2 || !cond3) {
var = Set2(3.14);
}
else {
var = 0;
for (auto&amp; e : something)
var += e;
}

// usa var; che non venga fatto troppo spesso può essere imposto staticamente colo colo controllo del flusso</code></pre>
<p>Questo andrebbe bene se ci fosse un’inizializzazione di default per <code>SomeLargeType</code> che non fosse troppo costosa. Altrimenti, un programmatore potrebbe benissimo chiedersi se sia stato coperto ogni possibile percorso attraverso la rete delle condizioni. In caso contrario, abbiamo un bug “usato-prima-della-assegnazione”. Questa è una trappola per la manutenzione.</p>
<p>Per gli inizializzatori di moderata complessità, comprese le variabili <code>const</code>, si prenda in considerazione l’uso di una lambda per definire l’inizializzatore; cfr. <a href="#Res-lambda-init">ES.28</a>.</p>
<h5 id="imposizione-201">Imposizione</h5>
<ul>
<li>Segnalare le dichiarazioni con inizializzazione di default che vengono assegnate prima di essere lette.</li>
<li>Segnalare qualsiasi calcolo complicato dopo una variabile non inizializzata e prima che sia usata.</li>
</ul>
<h3 id="es.23-preferire-la-sintassi-di-inizializzazione"><a name="Res-list"></a>ES.23: Preferire la sintassi di inizializzazione <code>{}</code></h3>
<h5 id="motivo-212">Motivo</h5>
<p>Preferire <code>{}</code>. Le regole per l’inizializzazione <code>{}</code> sono più semplici, più generali, meno ambigue e più sicure delle altre forme di inizializzazione.</p>
<p>Usare <code>=</code> solo quando si è sicuri che non ci possano essere conversioni “narrowing”. Per i tipi aritmetici nativi, usare <code>=</code> solo con <code>auto</code>.</p>
<p>Evitare l’inizializzazione <code>()</code>, che da adito ad ambiguità nel parser.</p>
<h5 id="esempio-190">Esempio</h5>
<pre><code>int x {f(99)};
int y = x;
vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6};</code></pre>
<h5 id="eccezione-38">Eccezione</h5>
<p>Per i contenitori, esiste una tradizione sull’uso di <code>{...}</code> per un elenco di elementi e <code>(...)</code> per le dimensioni:</p>
<pre><code>vector&lt;int&gt; v1(10);    // vettore di 10 elementi con il valore di default a 0
vector&lt;int&gt; v2{10};    // vettore di 1 elemento con il valore 10

vector&lt;int&gt; v3(1, 2);  // vettore di 1 elemento con il valore 2
vector&lt;int&gt; v4{1, 2};  // vettore di 2 elementi con i valori 1 e 2</code></pre>
<h5 id="note-190">Note</h5>
<p>Gli inizializzatori <code>{}</code> non consentono le conversioni “narrowing” (e questo di solito è una cosa buona) e consentono i costruttori espliciti (il che va bene, si sta inizializzando intenzionalmente una nuova variabile).</p>
<h5 id="esempio-191">Esempio</h5>
<pre><code>int x {7.9};   // errore: &quot;narrowing&quot;
int y = 7.9;   // OK: y diventa 7. Si spera in un warning del compilatore
int z = gsl::narrow_cast&lt;int&gt;(7.9);  // OK: è richiesto</code></pre>
<h5 id="note-191">Note</h5>
<p>L’inizializzazione <code>{}</code> si può usare per quasi tutte le inizializzazioni; non le altre forme di inizializzazione:</p>
<pre><code>auto p = new vector&lt;int&gt; {1, 2, 3, 4, 5};   // vettore inizializzato
D::D(int a, int b) :m{a, b} {   // inizializzatore membro (p.es., m potrebbe essere una coppia)
// ...
};
X var {};   // inizializza var come vuota
struct S {
int m {7};   // inizializzatore di default per un membro
// ...
};</code></pre>
<p>Per questo motivo, l’inizializzazione <code>{}</code> è spesso chiamata “inizializzazione uniforme” (sebbene purtroppo siano rimaste alcune irregolarità).</p>
<h5 id="note-192">Note</h5>
<p>L’inizializzazione di una variabile dichiarata usando <code>auto</code> con un singolo valore, ad esempio, <code>{v}</code>, ha avuto risultati a sorpresa fino al C++17. Le regole del C++17 sono meno aleatorie:</p>
<pre><code>auto x1 {7};        // x1 è un int col valore 7
auto x2 = {7};      // x2 è una initializer_list&lt;int&gt; con un elemento 7

auto x11 {7, 8};    // errore: due inizializzatori
auto x22 = {7, 8};  // x22 è una initializer_list&lt;int&gt; con gli elementi 7 e 8</code></pre>
<p>Usare <code>={...}</code> se si vuole veramente una <code>initializer_list&lt;T&gt;</code></p>
<pre><code>auto fib10 = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55};   // fib10 è una lista</code></pre>
<h5 id="note-193">Note</h5>
<p><code>={}</code> dà un’inizializzazione copia mentre <code>{}</code> dà un’inizializzazione diretta. Similmente alla stessa distinzione tra l’inizializzazione-copia e l’inizializzazione-diretta, ciò può portare a delle sorprese. <code>{}</code> accetta costruttori <code>explicit</code>; <code>={}</code> no. Per esempio:</p>
<pre><code>struct Z { explicit Z() {} };

Z z1{};     // OK: inizializzazione diretta, quindi si usa il costruttore esplicito
Z z2 = {};  // errore: inizializzazione copia, quindi non possiamo usare il costruttore esplicito</code></pre>
<p>Usare la semplice inizializzazione-<code>{}</code> a meno che non si desideri disabilitare esplicitamente i costruttori.</p>
<h5 id="esempio-192">Esempio</h5>
<pre><code>template&lt;typename T&gt;
void f()
{
T x1(1);    // T inizializzato con 1
T x0();     // bad: dichiarazione di funzione (spesso un errore)

T y1 {1};   // T inizializzato con 1
T y0 {};    // inizializzato col default T
// ...
}</code></pre>
<p><strong>Si veda anche la </strong>: <a href="#???">Discussione</a></p>
<h5 id="imposizione-202">Imposizione</h5>
<ul>
<li>Segnalare l’uso di <code>=</code> per inizializzare i tipi aritmetici in cui si verifica il “narrowing”.</li>
<li>Segnalare gli usi della sintassi di inizializzazione <code>()</code> che sono in realtà delle dichiarazioni. (Molti compilatori dovrebbero già evidenziarlo).</li>
</ul>
<h3 id="es.24-usare-un-unique_ptrt-per-contenere-i-puntatori"><a name="Res-unique"></a>ES.24: Usare un <code>unique_ptr&lt;T&gt;</code> per contenere i puntatori</h3>
<h5 id="motivo-213">Motivo</h5>
<p>L’uso di <code>std::unique_ptr</code> è il modo più semplice per evirare “leak”. È affidabile, fa sì che il sistema di tipi faccia gran parte del lavoro per convalidare la sicurezza della proprietà [ownership], aumenta la leggibilità e ha costi a runtime pari a zero o quasi zero.</p>
<h5 id="esempio-193">Esempio</h5>
<pre><code>void use(bool leak)
{
auto p1 = make_unique&lt;int&gt;(7);   // OK
int* p2 = new int{7};            // bad: potrebbe essere un leak
// ... nessuna assegnazione a p2 ...
if (leak) return;
// ... nessuna assegnazione a p2 ...
vector&lt;int&gt; v(7);
v.at(7) = 0;                    // eccezione generata
// ...
}</code></pre>
<p>Se <code>leak == true</code> l’oggetto puntato da <code>p2</code> è perso [leak] e l’oggetto puntato da <code>p1</code> non lo è. Lo stesso vale quando <code>at()</code> solleva un errore.</p>
<h5 id="imposizione-203">Imposizione</h5>
<p>Si cercano i puntatori che siano destinatari di <code>new</code>, <code>malloc()</code>, o le funzioni che possano restituire tali puntatori.</p>
<h3 id="es.25-dichiarare-un-oggetto-const-o-constexpr-a-meno-che-non-se-ne-voglia-in-seguito-modificarne-il-valore"><a name="Res-const"></a>ES.25: Dichiarare un oggetto <code>const</code> o <code>constexpr</code> a meno che non se ne voglia, in seguito, modificarne il valore</h3>
<h5 id="motivo-214">Motivo</h5>
<p>In questo modo non è possibile modificare il valore per errore. In questo modo può offrire l’opportunità di un’ottimizzazione del compilatore.</p>
<h5 id="esempio-194">Esempio</h5>
<pre><code>void f(int n)
{
const int bufmax = 2 * n + 2;  // good: non possiamo cambiare bufmax per caso
int xmax = n;                  // sospetto: xmax è destinato a cambiare?
// ...
}</code></pre>
<h5 id="imposizione-204">Imposizione</h5>
<p>Cerca se una variabile viene effettivamente mutata e la segnala se non lo è. Sfortunatamente, potrebbe essere impossibile rilevare quando una non-<code>const</code> non era <em>destinata</em> a cambiare (rispetto a quando semplicemente non è stata variata).</p>
<h3 id="es.26-non-usare-una-variabile-per-due-usi-non-correlati"><a name="Res-recycle"></a>ES.26: Non usare una variabile per due usi non correlati</h3>
<h5 id="motivo-215">Motivo</h5>
<p>Leggibilità e sicurezza.</p>
<h5 id="esempio-cattivo-83">Esempio, cattivo</h5>
<pre><code>void use()
{
int i;
for (i = 0; i &lt; 20; ++i) { /* ... */ }
for (i = 0; i &lt; 200; ++i) { /* ... */ } // bad: i è stata riciclata
}</code></pre>
<h5 id="note-194">Note</h5>
<p>Come ottimizzazione, si può voler ri-usare un buffer come un block-notes, ma anche in questo caso si preferisca limitare lo ‘scope’ della variabile il più possibile e si faccia attenzione a non provocare bug dai dati lasciati in un buffer riciclato in quanto questa è una comune sorgente di bug sulla sicurezza.</p>
<pre><code>void write_to_file() {
std::string buffer;             // per evitare le riallocazioni su ogni iterazione del ciclo
for (auto&amp; o : objects)
{
// Prima parte del lavoro.
generate_first_string(buffer, o);
write_to_file(buffer);

// Seconda parte del lavoro.
generate_second_string(buffer, o);
write_to_file(buffer);

// ecc...
}
}</code></pre>
<h5 id="imposizione-205">Imposizione</h5>
<p>Segnalare le variabili riciclate.</p>
<h3 id="es.27-usare-stdarray-o-stack_array-per-gli-array-sullo-stack"><a name="Res-stack"></a>ES.27: Usare <code>std::array</code> o <code>stack_array</code> per gli array sullo stack</h3>
<h5 id="motivo-216">Motivo</h5>
<p>Sono leggibili e non implicitamente convertiti in puntatori. Non vengono confusi con le estensioni non-standard degli array nativi [built-in].</p>
<h5 id="esempio-cattivo-84">Esempio, cattivo</h5>
<pre><code>const int n = 7;
int m = 9;

void f()
{
int a1[n];
int a2[m];   // errore: non è C++ ISO
// ...
}</code></pre>
<h5 id="note-195">Note</h5>
<p>La definizione di <code>a1</code> è C++ legale e c’è sempre stata. C’è molto codice come questo. Tuttavia, è soggetto a errori, soprattutto quando la dimensione [bound] non è locale.. Inoltre, è una fonte “popolare” di errori (overflow del buffer, puntatori dalla conversione [decay] degli array, ecc.). La definizione di <code>a2</code> è C ma non C++ ed è considerato un rischio per la sicurezza</p>
<h5 id="esempio-195">Esempio</h5>
<pre><code>const int n = 7;
int m = 9;

void f()
{
array&lt;int, n&gt; a1;
stack_array&lt;int&gt; a2(m);
// ...
}</code></pre>
<h5 id="imposizione-206">Imposizione</h5>
<ul>
<li>Segnalare gli array con dimensioni [bound] non-costanti (VLA [Variable Lenght Array] del C)</li>
<li>Segnala gli array con dimensioni costanti non-locali</li>
</ul>
<h3 id="es.28-usare-le-lambda-per-delle-inizializzazioni-complesse-specialmente-di-variabili-const"><a name="Res-lambda-init"></a>ES.28: Usare le lambda per delle inizializzazioni complesse, specialmente di variabili <code>const</code></h3>
<h5 id="motivo-217">Motivo</h5>
<p>Incapsula bene l’inizializzazione locale, inclusa la pulizia delle variabili necessaria solo per l’inizializzazione, senza la necessità di creare una funzione non locale e non riutilizzabile. Funziona anche con variabili che dovrebbero essere <code>const</code> ma solo dopo alcune operazioni di inizializzazione.</p>
<h5 id="esempio-cattivo-85">Esempio, cattivo</h5>
<pre><code>widget x;   // dovrebbe essere const, ma:
for (auto i = 2; i &lt;= N; ++i) {          // questo potrebbe essere un 
x += some_obj.do_something_with(i);  // codice arbitrariamente lungo
}                                        // necessario per inizializzare x
// da qui, x dovrebbe essere const, ma non possiamo dirlo con questo stile del codice</code></pre>
<h5 id="esempio-buono-15">Esempio, buono</h5>
<pre><code>const widget x = [&amp;]{
widget val;                                // si suppone che widget abbia un costruttore di default
for (auto i = 2; i &lt;= N; ++i) {            // questo potrebbe essere un
val += some_obj.do_something_with(i);  // codice arbitrariamente lungo
}                                          // necessario per inizializzare x
return val;
}();</code></pre>
<h5 id="esempio-196">Esempio</h5>
<pre><code>string var = [&amp;]{
if (!in) return &quot;&quot;;   // il default
string s;
for (char c : in &gt;&gt; c)
s += toupper(c);
return s;
}(); // notare ()</code></pre>
<p>Se possibile, si riducano le condizioni ad un semplice insieme di alternative (p.es., un <code>enum</code>) e non si confonda la selezione con l’inizializzazione.</p>
<h5 id="imposizione-207">Imposizione</h5>
<p>Difficile. Nel migliore dei casi è una euristica. Cerca una variabile non inizializzata seguita da un ciclo in cui si assegnano.</p>
<h3 id="es.30-non-usare-le-macro-per-manipolare-il-testo-del-programma"><a name="Res-macros"></a>ES.30: Non usare le macro per manipolare il testo del programma</h3>
<h5 id="motivo-218">Motivo</h5>
<p>Le macro sono una delle principali fonti di bug. Le macro non obbediscono alle normali regole di scope e dei tipi. Le macro fanno sì che il lettore umano veda qualcosa di diverso da ciò che vede il compilatore. Le macro complicano gli strumenti di building.</p>
<h5 id="esempio-cattivo-86">Esempio, cattivo</h5>
<pre><code>#define Case break; case   /* BAD */</code></pre>
<p>Questa macro dall’aspetto innocuo trasforma un singolo <code>c</code> minuscolo anziché <code>C</code> in un brutto bug sul controllo del flusso.</p>
<h5 id="note-196">Note</h5>
<p>Questa regola non vieta l’uso delle macro per il “controllo della configurazione” usato negli <code>#ifdef</code>, ecc.</p>
<p>In futuro, è probabile che i moduli eliminino la necessità di macro nel controllo della configurazione.</p>
<h5 id="note-197">Note</h5>
<p>Questa regola ha lo scopo di scoraggiare anche l’uso di <code>#</code> per la “stringification” e di <code>##</code> per la concatenazione. Come è solito per le macro, ci sono usi “per lo più innocui”, ma anche questi possono creare problemi ai tool, come i completatori automatici, gli analizzatori statici, e i debugger. Spesso il desiderio di utilizzare macro fantasiose è un segno di un design troppo complesso. Inoltre, <code>#</code> e <code>##</code> incoraggiano la definizione e l’uso delle macro:</p>
<pre><code>#define CAT(a, b) a ## b
#define STRINGIFY(a) #a

void f(int x, int y)
{
string CAT(x, y) = &quot;asdf&quot;;   // BAD: difficile da gestire per i tool (e brutto)
string sx2 = STRINGIFY(x);
// ...
}</code></pre>
<p>Esistono soluzioni alternative per la gestione delle stringhe di basso livello utilizzando le macro. Per esempio:</p>
<pre><code>string s = &quot;asdf&quot; &quot;lkjh&quot;;   // ordinaria concatenazione letterale della stringa

enum E { a, b };

template&lt;int x&gt;
constexpr const char* stringify()
{
switch (x) {
case a: return &quot;a&quot;;
case b: return &quot;b&quot;;
}
}

void f(int x, int y)
{
string sx = stringify&lt;x&gt;();
// ...
}</code></pre>
<p>Questo non è conveniente come una macro da definire, ma altrettanto facile da usare, ha zero overhead ed è tipizzato e ha uno scope.</p>
<p>In futuro, è probabile che la riflessione statica elimini gli ultimi bisogni del preprocessore per la manipolazione del testo del programma.</p>
<h5 id="imposizione-208">Imposizione</h5>
<p>Ci si allarmi quando si vede una macro che non sia usata per il controllo del sorgente (p.es., <code>#ifdef</code>)</p>
<h3 id="es.31-non-usare-le-macro-per-le-costanti-o-le-funzioni"><a name="Res-macros2"></a>ES.31: Non usare le macro per le costanti o le “funzioni”</h3>
<h5 id="motivo-219">Motivo</h5>
<p>Le macro sono una delle principali fonti di bug. Le macro non obbediscono alle normali regole di scope e dei tipi. Le macro non obbediscono alle solite regole per il passaggio degli argomenti. Le macro fanno sì che il lettore umano veda qualcosa di diverso da ciò che vede il compilatore. Le macro complicano gli strumenti di building.</p>
<h5 id="esempio-cattivo-87">Esempio, cattivo</h5>
<pre><code>#define PI 3.14
#define SQUARE(a, b) (a * b)</code></pre>
<p>Anche se non avessimo lasciato un ben noto bug in <code>SQUARE</code> ci sono corrette alternative molto migliori; per esempio:</p>
<pre><code>constexpr double pi = 3.14;
template&lt;typename T&gt; T square(T a, T b) { return a * b; }</code></pre>
<h5 id="imposizione-209">Imposizione</h5>
<p>Ci si allarmi quando si vede una macro che non sia usata per il controllo del sorgente (p.es., <code>#ifdef</code>)</p>
<h3 id="es.32-usare-il-tutto_in_maiuscolo-per-tutti-i-nomi-delle-macro"><a name="Res-ALL_CAPS"></a>ES.32: Usare il <code>TUTTO_IN_MAIUSCOLO</code> per tutti i nomi delle macro</h3>
<h5 id="motivo-220">Motivo</h5>
<p>Convenzione. Leggibilità. Distinzione delle macro.</p>
<h5 id="esempio-197">Esempio</h5>
<pre><code>#define forever for (;;)   /* PESSIMO */

#define FOREVER for (;;)   /* Resta diabolico, ma almeno visibile agli umani */</code></pre>
<h5 id="imposizione-210">Imposizione</h5>
<p>Ci si allarmi quando si vede una macro in minuscolo.</p>
<h3 id="es.33-se-è-necessario-usare-le-macro-dargli-dei-nomi-univoci"><a name="Res-MACROS"></a>ES.33: Se è necessario usare le macro, dargli dei nomi univoci</h3>
<h5 id="motivo-221">Motivo</h5>
<p>Le macro non obbediscono alle regole dello scope.</p>
<h5 id="esempio-198">Esempio</h5>
<pre><code>#define MYCHAR        /* BAD, alla fine ci si scontrerà con qualche altro MYCHAR*/

#define ZCORP_CHAR    /* Resta diabolico, ma meno prono a conflitti */</code></pre>
<h5 id="note-198">Note</h5>
<p>Evitare le macro se possibile: <a href="#Res-macros">ES.30</a>, <a href="#Res-macros2">ES.31</a> e <a href="#Res-ALL_CAPS">ES.32</a>. Tuttavia, ci sono miliardi di righe di codice disseminate di macro e una lunga tradizione sull’uso e sull’abuso delle macro. Se si è costretti a utilizzare le macro, si utilizzino nomi lunghi e prefissi possibilmente univoci (ad esempio, il nome della propria organizzazione) per ridurre la probabilità di un conflitto.</p>
<h5 id="imposizione-211">Imposizione</h5>
<p>Emettere un warning sui nomi di macro troppo brevi.</p>
<h3 id="es.34-non-definire-una-funzione-variadica-c-style"><a name="Res-ellipses"></a> ES.34: Non definire una funzione variadica (C-style)</h3>
<h5 id="motivo-222">Motivo</h5>
<p>Non “type safe”. Richiede un codice disordinato per il-cast-e-pieno-di-macro per funzionare correttamente.</p>
<h5 id="esempio-199">Esempio</h5>
<pre><code>#include &lt;cstdarg&gt;

// &quot;severity&quot; seguita da una lista di char* terminati con zero; scrive le stringhe in stile C in cerr
void error(int severity ...)
{
va_list ap;             // un tipo magico per contenere gli argomenti
va_start(ap, severity); // avvio di arg: &quot;severity&quot; è il primo argomento di error()

for (;;) {
// considera la successiva var come un char*; senza controllare: un cast sotto mentite spoglie
char* p = va_arg(ap, char*);
if (!p) break;
cerr &lt;&lt; p &lt;&lt; &#39; &#39;;
}

va_end(ap);             // pulizia di arg (da non dimenticare)

cerr &lt;&lt; &#39;\n&#39;;
if (severity) exit(severity);
}

void use()
{
error(7, &quot;this&quot;, &quot;is&quot;, &quot;an&quot;, &quot;error&quot;, nullptr);
error(7); // crash
error(7, &quot;this&quot;, &quot;is&quot;, &quot;an&quot;, &quot;error&quot;);  // crash
const char* is = &quot;is&quot;;
string an = &quot;an&quot;;
error(7, &quot;this&quot;, &quot;is&quot;, an, &quot;error&quot;); // crash
}</code></pre>
<p><strong>Alternativa</strong>: L’overloading. I template. I template variadici.</p>
<pre><code>#include &lt;iostream&gt;

void error(int severity)
{
std::cerr &lt;&lt; &#39;\n&#39;;
std::exit(severity);
}

template &lt;typename T, typename... Ts&gt;
constexpr void error(int severity, T head, Ts... tail)
{
std::cerr &lt;&lt; head;
error(severity, tail...);
}

void use()
{
error(7); // No crash!
error(5, &quot;this&quot;, &quot;is&quot;, &quot;not&quot;, &quot;an&quot;, &quot;error&quot;); // Nessun crash!

std::string an = &quot;an&quot;;
error(7, &quot;this&quot;, &quot;is&quot;, &quot;not&quot;, an, &quot;error&quot;); // Nessun crash!

error(5, &quot;oh&quot;, &quot;no&quot;, nullptr); // Errore di compilazione! Non c&#39;è bisogno del nullptr.
}</code></pre>
<h5 id="note-199">Note</h5>
<p>Questo è fondamentalmente il modo in cui è implementato <code>printf</code>.</p>
<h5 id="imposizione-212">Imposizione</h5>
<ul>
<li>Segnalare le definizioni in stile C delle funzioni variadiche.</li>
<li>Segnalare <code>#include &lt;cstdarg&gt;</code> e <code>#include &lt;stdarg.h&gt;</code></li>
</ul>
<h2 id="es.expr-espressioni">ES.expr: Espressioni</h2>
<p>Le espressioni cambiano i valori.</p>
<h3 id="es.40-evitare-espressioni-complicate"><a name="Res-complicated"></a>ES.40: Evitare espressioni complicate</h3>
<h5 id="motivo-223">Motivo</h5>
<p>Le espressioni complicate sono soggette a errori.</p>
<h5 id="esempio-200">Esempio</h5>
<pre><code>// bad: assegnazione nascosta nella sottoespressione
while ((c = getc()) != -1)

// bad: due variabili non locali assegnate in sottoespressioni
while ((cin &gt;&gt; c1, cin &gt;&gt; c2), c1 == c2)

// meglio, ma forse ancora troppo complicato
for (char c1, c2; cin &gt;&gt; c1 &gt;&gt; c2 &amp;&amp; c1 == c2;)

// OK: se i e j non sono alias
int x = ++i + ++j;

// OK: se i != j e i != k
v[i] = v[j] + v[k];

// bad: assegnazioni multiple &quot;nascoste&quot; nelle sottoespressioni
x = a + (b = f()) + (c = g()) * 7;

// bad: si basa su regole di precedenza comunemente fraintese
x = a &amp; b + c * d &amp;&amp; e ^ f == 7;

// bad: comportamento indefinito
x = x++ + x++ + ++x;</code></pre>
<p>Alcune di queste espressioni sono incondizionatamente cattive (p.es., si basano su comportamenti indefiniti). Altre sono semplicemente così complicate e/o insolite che persino i bravi programmatori potrebbero fraintenderle o trascurare un problema nella fretta.</p>
<h5 id="note-200">Note</h5>
<p>Il C++17 inasprisce le regole per l’ordine di valutazione (da sinistra a destra, tranne da destra a sinistra nelle assegnazioni, e l’ordine di valutazione degli argomenti della funzione non è specificato; <a href="#Res-order">cfr. ES.43</a>), ma ciò non cambia il fatto che le espressioni complicate sono potenzialmente confuse.</p>
<h5 id="note-201">Note</h5>
<p>Un programmatore dovrebbe conoscere e utilizzare le regole di base per le espressioni.</p>
<h5 id="esempio-201">Esempio</h5>
<pre><code>x = k * y + z;             // OK

auto t1 = k * y;           // bad: inutilmente dettagliato
x = t1 + z;

if (0 &lt;= x &amp;&amp; x &lt; max)   // OK

auto t1 = 0 &lt;= x;        // bad: inutilmente dettagliato
auto t2 = x &lt; max;
if (t1 &amp;&amp; t2)            // ...</code></pre>
<h5 id="imposizione-213">Imposizione</h5>
<p>Difficile. Quanto complicata deve essere un’espressione per essere considerata complicata? Anche scrivere calcoli come dichiarazioni con una sola operazione è fonte di confusione. Cose da considerare:</p>
<ul>
<li>effetti collaterali: gli effetti collaterali su più variabili non locali (per qualche definizioni di non locale) possono insospettire, specialmente se gli effetti collaterali sono in sottoespressioni separate</li>
<li>scrive su variabili con alias [aliased]</li>
<li>più di N operatori (e quanto dovrebbe valere N?)</li>
<li>dipendenza da sottili regole di precedenza</li>
<li>usa un comportamento indefinito (possiamo capire tutto il comportamento indefinito?)</li>
<li>comportamento definito dall’implementazione?</li>
<li>???</li>
</ul>
<h3 id="es.41-in-caso-di-dubbio-sulla-precedenza-degli-operatori-usare-le-parentesi"><a name="Res-parens"></a>ES.41: In caso di dubbio sulla precedenza degli operatori, usare le parentesi</h3>
<h5 id="motivo-224">Motivo</h5>
<p>Evitare errori. Leggibilità. Non tutti ricordano a memoria la tabella degli operatori.</p>
<h5 id="esempio-202">Esempio</h5>
<pre><code>const unsigned int flag = 2;
unsigned int a = flag;

if (a &amp; flag != 0)  // bad: significa a&amp;(flag != 0)</code></pre>
<p>Nota: Si raccomanda ai programmatori di prendere visione della tabella delle precedenze per le operazioni aritmetiche, quella delle operazioni logiche, ma si prenda in considerazione di mescolare le operazioni logiche bit a bit con gli altri operatori che necessitano le parentesi.</p>
<pre><code>if ((a &amp; flag) != 0)  // OK: funziona come previsto</code></pre>
<h5 id="note-202">Note</h5>
<p>Si dovrebbe essere abbastanza esperti da non aver bisogno delle parentesi per:</p>
<pre><code>if (a &lt; 0 || a &lt;= max) {
// ...
}</code></pre>
<h5 id="imposizione-214">Imposizione</h5>
<ul>
<li>Segnalare le combinazioni di operazioni logiche con altri operatori.</li>
<li>Segnalare gli operatori di assegnazioni non come operatore all’estrema sinistra.</li>
<li>???</li>
</ul>
<h3 id="es.42-usare-in-modo-semplice-e-diretto-i-puntatori"><a name="Res-ptr"></a>ES.42: Usare in modo semplice e diretto i puntatori</h3>
<h5 id="motivo-225">Motivo</h5>
<p>La gestione dei puntatori complicati è una delle principali fonti di errori.</p>
<h5 id="note-203">Note</h5>
<p>Usare, invece, <code>gsl::span</code>. I puntatori dovrebbero <a href="#Ri-array">fare riferimento solo a singoli oggetti</a>. L’aritmetica dei puntatori è fragile e facile da sbagliare, la fonte di molti, molti bug e violazioni della sicurezza. <code>span</code> è un tipo sicuro, controllato dai limiti [bounds-checked], per l’accesso ai dati degli array. L’accesso a un array con limiti noti che utilizza una costante come indice può essere convalidato dal compilatore.</p>
<h5 id="esempio-cattivo-88">Esempio, cattivo</h5>
<pre><code>void f(int* p, int count)
{
if (count &lt; 2) return;

int* q = p + 1;    // BAD

ptrdiff_t d;
int n;
d = (p - &amp;n);      // OK
d = (q - p);       // OK

int n = *p++;      // BAD

if (count &lt; 6) return;

p[4] = 1;          // BAD

p[count - 1] = 2;  // BAD

use(&amp;p[0], 3);     // BAD
}</code></pre>
<h5 id="esempio-buono-16">Esempio, buono</h5>
<pre><code>void f(span&lt;int&gt; a) // BETTER: usa span nella dichiarazione della funzione
{
if (a.size() &lt; 2) return;

int n = a[0];      // OK

span&lt;int&gt; q = a.subspan(1); // OK

if (a.size() &lt; 6) return;

a[4] = 1;          // OK

a[a.size() - 1] = 2;  // OK

use(a.data(), 3);  // OK
}</code></pre>
<h5 id="note-204">Note</h5>
<p>L’indicizzazione tramite una variabile è difficile da convalidare sia per i tool che per gli umani. <code>span</code> è un tipo sicuro, controllato dai limiti [bounds-checked], per l’accesso ai dati degli array. <code>at()</code> è un’ulteriore alternativa che garantisce che i singoli accessi controllino i limiti. Se sono necessari iteratori per accedere a un array, utilizzare gli iteratori da uno <code>span</code> costruito sull’array.</p>
<h5 id="esempio-cattivo-89">Esempio, cattivo</h5>
<pre><code>void f(array&lt;int, 10&gt; a, int pos)
{
a[pos / 2] = 1; // BAD
a[pos - 1] = 2; // BAD
a[-1] = 3;    // BAD (ma facilmente intercettato dai tool) -- nessuna sostituzione, basta non farlo
a[10] = 4;    // BAD (ma facilmente intercettato dai tool) -- nessuna sostituzione, basta non farlo
}</code></pre>
<h5 id="esempio-buono-17">Esempio, buono</h5>
<p>Usare uno <code>span</code>:</p>
<pre><code>void f1(span&lt;int, 10&gt; a, int pos) // A1: Cambia il tipo di parametro per utilizzare lo span
{
a[pos / 2] = 1; // OK
a[pos - 1] = 2; // OK
}

void f2(array&lt;int, 10&gt; arr, int pos) // A2: Aggiungere uno span locale e usarlo
{
span&lt;int&gt; a = {arr.data(), pos};
a[pos / 2] = 1; // OK
a[pos - 1] = 2; // OK
}</code></pre>
<p>Usare <code>at()</code>:</p>
<pre><code>void f3(array&lt;int, 10&gt; a, int pos) // ALTERNATIVA B: Usare at() per l&#39;accesso
{
at(a, pos / 2) = 1; // OK
at(a, pos - 1) = 2; // OK
}</code></pre>
<h5 id="esempio-cattivo-90">Esempio, cattivo</h5>
<pre><code>void f()
{
int arr[COUNT];
for (int i = 0; i &lt; COUNT; ++i)
arr[i] = i; // BAD, non si può usare un indice non-costante
}</code></pre>
<h5 id="esempio-buono-18">Esempio, buono</h5>
<p>Usare uno <code>span</code>:</p>
<pre><code>void f1()
{
int arr[COUNT];
span&lt;int&gt; av = arr;
for (int i = 0; i &lt; COUNT; ++i)
av[i] = i;
}</code></pre>
<p>Usare uno <code>span</code> e range-<code>for</code>:</p>
<pre><code>void f1a()
{
int arr[COUNT];
span&lt;int, COUNT&gt; av = arr;
int i = 0;
for (auto&amp; e : av)
e = i++;
}</code></pre>
<p>Usare <code>at()</code> per l’accesso:</p>
<pre><code>void f2()
{
int arr[COUNT];
for (int i = 0; i &lt; COUNT; ++i)
at(arr, i) = i;
}</code></pre>
<p>Usare un range-<code>for</code>:</p>
<pre><code>void f3()
{
int arr[COUNT];
int i = 0;
for (auto&amp; e : arr)
e = i++;
}</code></pre>
<h5 id="note-205">Note</h5>
<p>I tool possono proporre una riscrittura degli accessi agli array che implichi, invece, l’uso di espressioni di indici dinamici <code>at()</code>:</p>
<pre><code>static int a[10];

void f(int i, int j)
{
a[i + j] = 12;      // BAD, potrebbe essere riscritto come ...
at(a, i + j) = 12;  // OK -- i limiti vengono controllati [bounds-checked]
}</code></pre>
<h5 id="esempio-203">Esempio</h5>
<p>Trasformare un array in un puntatore (come essenzialmente fa sempre il linguaggio) toglie la possibilità di controllare i limiti, quindi lo si eviti</p>
<pre><code>void g(int* p);

void f()
{
int a[5];
g(a);        // BAD: si sta tentando di passare un array?
g(&amp;a[0]);    // OK: si passa un oggetto
}</code></pre>
<p>Se si vuole passare un array, diciamo:</p>
<pre><code>void g(int* p, size_t length);  // vecchio codice (pericoloso)

void g1(span&lt;int&gt; av); // MEGLIO: cambiato get g().

void f2()
{
int a[5];
span&lt;int&gt; av = a;

g(av.data(), av.size());   // OK, se non c&#39;è scelta
g1(a);                     // OK -- qui nessun decadimento, usa invece un ctor implicito di span
}</code></pre>
<h5 id="imposizione-215">Imposizione</h5>
<ul>
<li>Segnalare qualsiasi operazione aritmetica su un’espressione di tipo puntatore che dia come risultato un valore di tipo puntatore.</li>
<li>Segnalare qualsiasi espressione di indicizzazione su un’espressione o una variabile di tipo array (sia un array statico che uno <code>std::array</code>) in cui l’indicizzatore non è un’espressione costante in fase di compilazione con un valore compreso tra <code>0</code> e il limite superiore dell’array.</li>
<li>Segnalare qualsiasi espressione che si baserebbe sulla conversione implicita di un array in un puntatore.</li>
</ul>
<p>Questa regola fa parte del <a href="#SS-bounds">profilo di sicurezza dei limiti</a>.</p>
<h3 id="es.43-evitare-espressioni-con-un-ordine-di-valutazione-incerto"><a name="Res-order"></a>ES.43: Evitare espressioni con un ordine di valutazione incerto</h3>
<h5 id="motivo-226">Motivo</h5>
<p>Non si ha alcuna idea di cosa faccia questo codice. Portabilità. Anche se sembra fare qualcosa di ragionevole, potrebbe fare altro su un altro compilatore (p.es., la successiva release del proprio compilatore) o con un diverso settaggio dell’ottimizzatore.</p>
<h5 id="note-206">Note</h5>
<p>Il C++17 inasprisce le regole per l’ordine di valutazione: da-sinistra-a-destra, tranne da destra a sinistra nelle assegnazioni, e l’ordine di valutazione degli argomenti della funzione non è specificato.</p>
<p>Tuttavia, si ricordi che il proprio codice potrebbe essere compilato con un compilatore pre-C++17 (p.es., tramite il taglia-incolla) quindi non comportarsi troppo da esperti.</p>
<h5 id="esempio-204">Esempio</h5>
<pre><code>v[i] = ++i;   //  il risultato è indefinito</code></pre>
<p>Una buona regola empirica è che non si dovrebbe leggere due volte un valore in un’espressione che si sta scrivendo.</p>
<h5 id="imposizione-216">Imposizione</h5>
<p>Può essere rilevato da un buon analizzatore.</p>
<h3 id="es.44-non-dipendere-dallordine-di-valutazione-degli-argomenti-di-una-funzione"><a name="Res-order-fct"></a>ES.44: Non dipendere dall’ordine di valutazione degli argomenti di una funzione</h3>
<h5 id="motivo-227">Motivo</h5>
<p>Perché quell’ordine non è specificato.</p>
<h5 id="note-207">Note</h5>
<p>Il C++17 inasprisce le regole per l’ordine di valutazione, ma l’ordine di valutazione degli argomenti della funzione non è ancora specificato.</p>
<h5 id="esempio-205">Esempio</h5>
<pre><code>int i = 0;
f(++i, ++i);</code></pre>
<p>Molto probabilmente la chiamata sarà <code>f(0, 1)</code> o <code>f(1, 0)</code>, ma non si sa quale. Tecnicamente, il risultato è indefinito. Nel C++17, questo codice non ha un comportamento indefinito, ma non è ancora specificato quale argomento viene valutato per primo.</p>
<h5 id="esempio-206">Esempio</h5>
<p>Gli operatori sovraccaricati [overload] possono portare a problemi con l’ordine di valutazione:</p>
<pre><code>f1()-&gt;m(f2());          // m(f1(), f2())
cout &lt;&lt; f1() &lt;&lt; f2();   // operator&lt;&lt;(operator&lt;&lt;(cout, f1()), f2())</code></pre>
<p>In C++17, questi esempi funzionano come previsto (da sinistra a destra) e le assegnazioni vengono valutate da destra a sinistra (proprio come gli = lo sono da destra a sinistra)</p>
<pre><code>f1() = f2();    // comportamento indefinito in C++14; in C++17, f2() viene valutato prima di f1()</code></pre>
<h5 id="imposizione-217">Imposizione</h5>
<p>Può essere rilevato da un buon analizzatore.</p>
<h3 id="es.45-evitare-costanti-magiche-utilizzare-costanti-simboliche"><a name="Res-magic"></a>ES.45: Evitare “costanti magiche”; utilizzare costanti simboliche</h3>
<h5 id="motivo-228">Motivo</h5>
<p>Le costanti senza nome incluse in espressioni vengono facilmente trascurate e spesso difficili da capire:</p>
<h5 id="esempio-207">Esempio</h5>
<pre><code>for (int m = 1; m &lt;= 12; ++m)   // da non fare: costante magica 12
cout &lt;&lt; month[m] &lt;&lt; &#39;\n&#39;;</code></pre>
<p>No, non tutti sanno che ci sono 12 mesi, in un anno, numerati 1..12. Meglio:</p>
<pre><code>// i mesi sono indicizzati 1..12
constexpr int first_month = 1;
constexpr int last_month = 12;

for (int m = first_month; m &lt;= last_month; ++m)   // better
cout &lt;&lt; month[m] &lt;&lt; &#39;\n&#39;;</code></pre>
<p>Ancora meglio, non esporre le costanti:</p>
<pre><code>for (auto m : month)
cout &lt;&lt; m &lt;&lt; &#39;\n&#39;;</code></pre>
<h5 id="imposizione-218">Imposizione</h5>
<p>Segnalare i valori letterali nel codice. Far passare <code>0</code>, <code>1</code>, <code>nullptr</code>, <code>\n</code>, <code>""</code>, ed altri in un elenco di valori ammessi.</p>
<h3 id="es.46-evitare-conversioni-aritmetiche-con-perdita-narrowing-troncamenti"><a name="Res-narrowing"></a>ES.46: Evitare conversioni aritmetiche con perdita (narrowing, troncamenti)</h3>
<h5 id="motivo-229">Motivo</h5>
<p>Una conversione narrowing distrugge l’informazione, spesso in modo inaspettato.</p>
<h5 id="esempio-cattivo-91">Esempio, cattivo</h5>
<p>Un esempio chiave è il narrowing semplice:</p>
<pre><code>double d = 7.9;
int i = d;    // bad: narrowing: i diventa 7
i = (int) d;  // bad: si sta affermando che questo non è ancora abbastanza esplicito

void f(int x, long y, double d)
{
char c1 = x;   // bad: narrowing
char c2 = y;   // bad: narrowing
char c3 = d;   // bad: narrowing
}</code></pre>
<h5 id="note-208">Note</h5>
<p>La libreria di supporto delle linee guida offre un’operazione <code>narrow_cast</code> per specificare che il narrowing è accettabile e un <code>narrow</code> (“narrow if”) che genera un’eccezione se un troncamento butta via delle informazioni:</p>
<pre><code>i = narrow_cast&lt;int&gt;(d);   // OK (lo si è chiesto): narrowing: i becomes 7
i = narrow&lt;int&gt;(d);        // OK: solleva un narrowing_error</code></pre>
<p>Includiamo anche i cast aritmetici con perdita, come ad esempio da un tipo a virgola mobile negativo a un tipo intero senza segno:</p>
<pre><code>double d = -7.9;
unsigned u = 0;

u = d;                          // BAD
u = narrow_cast&lt;unsigned&gt;(d);   // OK (lo si è chiesto): u diventa 4294967289
u = narrow&lt;unsigned&gt;(d);        // OK: solleva un narrowing_error</code></pre>
<h5 id="imposizione-219">Imposizione</h5>
<p>Un buon analizzatore può rilevare tutte le conversioni narrowing. Tuttavia, segnalare tutte le conversioni narrowing porterà a molti falsi positivi. Suggerimenti:</p>
<ul>
<li>Segnalare tutte le conversioni da virgola-mobile a intero (forse solo <code>float</code>-&gt;<code>char</code> e <code>double</code>-&gt;<code>int</code>. Questo è un punto oscuro! c’è bisogno di dati).</li>
<li>Segnalare tutti i <code>long</code>-&gt;<code>char</code> (Si sopetta che <code>int</code>-&gt;<code>char</code> sia molto comune. Questo è un punto oscuro! c’è bisogno di dati).</li>
<li>Considerare specialmente sospette le conversioni narrowing per gli argomenti delle funzioni.</li>
</ul>
<h3 id="es.47-usare-nullptr-anziché-0-o-null"><a name="Res-nullptr"></a>ES.47: Usare <code>nullptr</code> anziché <code>0</code> o <code>NULL</code></h3>
<h5 id="motivo-230">Motivo</h5>
<p>Leggibilità. Ridurre al minimo le sorprese: <code>nullptr</code> non può confondersi con un <code>int</code>. <code>nullptr</code> ha anche un tipo ben specificato (molto restrittivo), e quindi funziona in più scenari in cui la deduzione del tipo potrebbe fare la cosa sbagliata con <code>NULL</code> o <code>0</code>.</p>
<h5 id="esempio-208">Esempio</h5>
<p>Si consideri:</p>
<pre><code>void f(int);
void f(char*);
f(0);         // chiama f(int)
f(nullptr);   // chiama f(char*)</code></pre>
<h5 id="imposizione-220">Imposizione</h5>
<p>Segnalare l’uso di <code>0</code> e <code>NULL</code> per i puntatori. La trasformazione può essere aiutata da una semplice trasformazione del programma.</p>
<h3 id="es.48-evitare-i-cast"><a name="Res-casts"></a>ES.48: Evitare i cast</h3>
<h5 id="motivo-231">Motivo</h5>
<p>I cast sono una fonte ben nota di errori. Rende alcune ottimizzazioni inaffidabili.</p>
<h5 id="esempio-cattivo-92">Esempio, cattivo</h5>
<pre><code>double d = 2;
auto p = (long*)&amp;d;
auto q = (long long*)&amp;d;
cout &lt;&lt; d &lt;&lt; &#39; &#39; &lt;&lt; *p &lt;&lt; &#39; &#39; &lt;&lt; *q &lt;&lt; &#39;\n&#39;;</code></pre>
<p>Cosa credete che questo frammento stampi? Il risultato è definito nella migliore delle ipotesi. Io ho ottenuto</p>
<pre><code>2 0 4611686018427387904</code></pre>
<p>Aggiungendo</p>
<pre><code>*q = 666;
cout &lt;&lt; d &lt;&lt; &#39; &#39; &lt;&lt; *p &lt;&lt; &#39; &#39; &lt;&lt; *q &lt;&lt; &#39;\n&#39;;</code></pre>
<p>Io ho ottenuto</p>
<pre><code>3.29048e-321 666 666</code></pre>
<p>Sorpresi? Sono contento che il programma non vada in crash.</p>
<h5 id="note-209">Note</h5>
<p>I programmatori che scrivono cast in genere presumono di sapere cosa stanno facendo o che scrivere un cast rende il programma “più facile da leggere”. Infatti, spesso disabilitano le regole generali sull’uso dei valori. La risoluzione dell’overload è l’istanziazione dei template solitamente sceglie la funzione giusta [right] se c’è una funzione [right] giusta da selezionare. Se non c’è, forse dovrebbe esserci, piuttosto che applicare una correzione locale (cast).</p>
<h5 id="note-210">Note</h5>
<p>I cast sono necessari in un linguaggio di programmazione di sistemi. Ad esempio, come altrimenti si potrebbe ottenere l’indirizzo del registro di un dispositivo in un puntatore? Tuttavia, dei cast se ne abusa gravemente, nonché sono una delle principali fonti di errori.</p>
<h5 id="note-211">Note</h5>
<p>Se si sente la necessità di parecchi cast, potrebbe essere un fondamentale problema progettuale.</p>
<h5 id="eccezione-39">Eccezione</h5>
<p>I cast a <code>(void)</code> è il modo Standard per disattivare i warning <code>[[nodiscard]]</code>. Se si chiama una funzione con un return <code>[[nodiscard]]</code> e si vuole deliberatamente scartare [discard] il risultato, si rifletta bene sul fatto che sia effettivamente una buona idea (solitamente c’è un buon motivo per cui l’autore della funzione o del tipo restituito ha usato <code>[[nodiscard]]</code>), ma se si ritiene ancora che sia appropriato e se il revisore del codice è d’accordo, si può scrivere <code>(void)</code> per disabilitare il warning.</p>
<h5 id="alternative-1">Alternative</h5>
<p>I cast sono ampiamente (ab) usati. Il C++ moderno ha delle regole e dei costrutti che eliminano la necessità di cast in molti contesti, come</p>
<ul>
<li>Nell’uso dei template</li>
<li>Nell’uso di <code>std::variant</code></li>
<li>Nell’affidarsi a conversioni implicite ben definite e sicure tra i i tipi di puntatori</li>
</ul>
<h5 id="imposizione-221">Imposizione</h5>
<ul>
<li>Forzare l’eliminazione dei cast in stile C, tranne per una funzione con un ritorno <code>[[nodiscard]]</code>.</li>
<li>Segnalare se ci sono molti cast di stile funzionale (c’è un ovvio problema nella quantificazione di ‘molti’).</li>
<li>Il <a href="#Pro-type-reinterpretcast">profilo del tipo</a> vieta il <code>reinterpret_cast</code>.</li>
<li>Mettere in guardia contro i <a href="#Pro-type-identitycast">cast di identità</a> tra puntatori, dove i tipi di origine e quelli di destinazione sono gli stessi (#Pro-type-identitycast).</li>
<li>Avvisare se un cast di un puntatore potrebbe essere <a href="#Pro-type-implicitpointercast">implicito</a>.</li>
</ul>
<h3 id="es.49-se-si-deve-usare-un-cast-si-utilizzi-un-named-cast"><a name="Res-casts-named"></a>ES.49: Se si deve usare un cast, si utilizzi un “named cast”</h3>
<h5 id="motivo-232">Motivo</h5>
<p>Leggibilità. Evitare errori. I “named cast” sono più specifici di un cast di tipo C o di un cast funzionale, consentendo al compilatore di rilevare alcuni errori.</p>
<p>I “named cast” sono:</p>
<ul>
<li><code>static_cast</code></li>
<li><code>const_cast</code></li>
<li><code>reinterpret_cast</code></li>
<li><code>dynamic_cast</code></li>
<li><code>std::move</code> // <code>move(x)</code> è un riferimento rvalue a <code>x</code></li>
<li><code>std::forward</code> // <code>forward&lt;T&gt;(x)</code> è un riferimento rvalue o uno lvalue a <code>x</code> a seconda di <code>T</code></li>
<li><code>gsl::narrow_cast</code> // <code>narrow_cast&lt;T&gt;(x)</code> è uno <code>static_cast&lt;T&gt;(x)</code></li>
<li><code>gsl::narrow</code> // <code>narrow&lt;T&gt;(x)</code> è uno <code>static_cast&lt;T&gt;(x)</code> se <code>static_cast&lt;T&gt;(x) == x</code> o solleva un <code>narrowing_error</code></li>
</ul>
<h5 id="esempio-209">Esempio</h5>
<pre><code>class B { /* ... */ };
class D { /* ... */ };

template&lt;typename D&gt; D* upcast(B* pb)
{
D* pd0 = pb;                        // errore: nessuna conversione implicita da B* a D*
D* pd1 = (D*)pb;                    // legale, ma cosa è stato fatto?
D* pd2 = static_cast&lt;D*&gt;(pb);       // errore: D non viene derivato da B
D* pd3 = reinterpret_cast&lt;D*&gt;(pb);  // OK: ce ne si assume la responsabilità!
D* pd4 = dynamic_cast&lt;D*&gt;(pb);      // OK: ritorna nullptr
// ...
}</code></pre>
<p>L’esempio è stato sintetizzato da un vero bug in cui <code>D</code> era derivato da <code>B</code>, ma qualcuno ha eseguito il refactorng della gerarchia. Il cast in stile C è pericoloso perché può fare qualsiasi tipo di conversione, privandoci da qualsiasi protezione dagli errori (ora e in futuro).</p>
<h5 id="note-212">Note</h5>
<p>Invece, quando si converte danza perdita di informazioni (p.es. da <code>float</code> a <code>double</code> o in <code>int64</code> da <code>int32</code>), si può usare l’inizializzazione tra parenesi graffe.</p>
<pre><code>double d {some_float};
int64_t i {some_int32};</code></pre>
<p>Ciò rende chiaro che la conversione del tipo era prevista e impedisce anche le conversioni tra tipi che potrebbero comportare una perdita di precisione. (È un errore di compilazione tentare di inizializzare un <code>float</code> da un <code>double</code> in questo modo, per esempio).</p>
<h5 id="note-213">Note</h5>
<p><code>reinterpret_cast</code> può essere essenziale, ma gli usi essenziali (p.es., trasformare un indirizzo macchina in un puntatore) non sono sicuri:</p>
<pre><code>auto p = reinterpret_cast&lt;Device_register&gt;(0x800);  // intrinsecamente pericoloso</code></pre>
<h5 id="imposizione-222">Imposizione</h5>
<ul>
<li>Segnalare i cast in stile C e i cast funzionali.</li>
<li>Il <a href="#Pro-type-reinterpretcast">profilo del tipo</a> vieta il <code>reinterpret_cast</code>.</li>
<li>Il <a href="#Pro-type-arithmeticcast">profilo del tipo</a> mette in guardia sull’uso di uno <code>static_cast</code> tra i tipi aritmetici.</li>
</ul>
<h3 id="es.50-non-eseguire-il-cast-da-un-const"><a name="Res-casts-const"></a>ES.50: Non eseguire il cast da un <code>const</code></h3>
<h5 id="motivo-233">Motivo</h5>
<p>Contraddice il <code>const</code>. Se la variabile è effettivamente dichiarata <code>const</code>, la modifica porta ad un comportamento indefinito.</p>
<h5 id="esempio-cattivo-93">Esempio, cattivo</h5>
<pre><code>void f(const int&amp; x)
{
const_cast&lt;int&amp;&gt;(x) = 42;   // BAD
}

static int i = 0;
static const int j = 0;

f(i); // effetto collaterale silente
f(j); // comportamento incerto</code></pre>
<h5 id="esempio-210">Esempio</h5>
<p>Talvolta, si può essere tentati di ricorrere a <code>const_cast</code> per evitare la duplicazione del codice, ad esempio quando si hanno due funzioni di accesso che differiscono solo per un <code>const</code> ma con implementazioni simili. Per esempio:</p>
<pre><code>class Bar;

class Foo {
public:
// BAD, logica duplicata
Bar&amp; get_bar() {
/* logica complessa per ottenere un riferimento non-const a my_bar */
}

const Bar&amp; get_bar() const {
/* stessa logica complessa per ottenere un riferimento const a my_bar */
}
private:
Bar my_bar;
};</code></pre>
<p>Preferire, invece, la condivisione delle implementazioni. Normalmente, si può solo avere la funzione non-<code>const</code> che chiama la funzione <code>const</code>. Tuttavia, quando esiste una logica complessa, ciò può portare al seguente pattern che ricorre ancora a un <code>const_cast</code>:</p>
<pre><code>class Foo {
public:
// non eccezionale, non-const chiama la versione const ma ricorre a const_cast
Bar&amp; get_bar() {
return const_cast&lt;Bar&amp;&gt;(static_cast&lt;const Foo&amp;&gt;(*this).get_bar());
}
const Bar&amp; get_bar() const {
/* la logica complessa per ottenere un riferimento const a my_bar */
}
private:
Bar my_bar;
};</code></pre>
<p>ebbene questo modello sia sicuro quando applicato correttamente, poiché il chiamante deve avere avuto un oggetto non-<code>const</code> per cominciare, non è l’ideale perché la sicurezza è difficile ottenersi automaticamente come regola di un checker.</p>
<p>Preferire, invece, mettere il codice comune in una funzione helper comune – e trasformarlo in un template in modo da dedurre il <code>const</code>. Questo non usa affatto alcun <code>const_cast</code>:</p>
<pre><code>class Foo {
public:                         // buono
Bar&amp; get_bar()       { return get_bar_impl(*this); }
const Bar&amp; get_bar() const { return get_bar_impl(*this); }
private:
Bar my_bar;

template&lt;class T&gt;           // buono, deduce se T è const o non-const
static auto get_bar_impl(T&amp; t) -&gt; decltype(t.get_bar())
{ /* la complessa logica attorno alla quale si ottiene un riferimento a my_bar forse const */ }
};</code></pre>
<h5 id="eccezione-40">Eccezione</h5>
<p>Potrebbe essere necessario eliminare <code>const</code> chiamando funzioni con un incorretto <code>const</code>. È preferibile racchiudere queste funzioni inline correttamente <code>const</code> con dei wrapper per incapsulare in un unico posto il cast.</p>
<h5 id="esempio-211">Esempio</h5>
<p>A volte, “eliminare il <code>const</code>” è per consentire l’aggiornamento di alcune informazioni transitorie su di un oggetto altrimenti immutabile. Esempi sono il caching, la memoizzazione e il pre-calcolo. Tali esempi spesso gestiti anche o meglio usando <code>mutable</code> o una indirezione anziché una <code>const_cast</code>.</p>
<p>Si prenda in considerazione la possibilità di memorizzare i risultati calcolati in precedenza di un’operazione costosa:</p>
<pre><code>int compute(int x); // calcola un valore per x; supponendo che sia oneroso

class Cache {   // qualche tipo che implementi una cache per un&#39;operazione int-&gt;int
public:
pair&lt;bool, int&gt; find(int x) const;   // c&#39;è un valore per x?
void set(int x, int v);             // crea un valore per x
// ...
private:
// ...
};

class X {
public:
int get_val(int x)
{
auto p = cache.find(x);
if (p.first) return p.second;
int val = compute(x);
cache.set(x, val); // insert value for x
return val;
}
// ...
private:
Cache cache;
};</code></pre>
<p>Qui, <code>get_val()</code> è logicamente costante, quindi lo si vorrebbe rendere un membro <code>const</code>. Per fare ciò si deve ancora mutare <code>cache</code>, quindi a volte si ricorre ad un <code>const_cast</code>:</p>
<pre><code>class X {   // Soluzione sospetta basata sul casting
public:
int get_val(int x) const
{
auto p = cache.find(x);
if (p.first) return p.second;
int val = compute(x);
const_cast&lt;Cache&amp;&gt;(cache).set(x, val);   // brutto
return val;
}
// ...
private:
Cache cache;
};</code></pre>
<p>Fortunatamente, esiste una soluzione migliore: Si indica che <code>cache</code> è mutabile anche per un oggetto <code>const</code>:</p>
<pre><code>class X {   // soluzione migliore
public:
int get_val(int x) const
{
auto p = cache.find(x);
if (p.first) return p.second;
int val = compute(x);
cache.set(x, val);
return val;
}
// ...
private:
mutable Cache cache;
};</code></pre>
<p>Una soluzione alternativa sarebbe quella di memorizzare un puntatore alla <code>cache</code>:</p>
<pre><code>class X {   // OK, ma è una soluzione leggermente più disordinata
public:
int get_val(int x) const
{
auto p = cache-&gt;find(x);
if (p.first) return p.second;
int val = compute(x);
cache-&gt;set(x, val);
return val;
}
// ...
private:
unique_ptr&lt;Cache&gt; cache;
};</code></pre>
<p>Questa soluzione è la più flessibile, ma richiede la costruzione e la distruzione esplicite di <code>*cache</code> (molto probabilmente nel costruttore e distruttore di <code>X</code>).</p>
<p>In ogni variant, cci si deve proteggere contro i conflitti sui dati [data race] sulla <code>cache</code> nel codice multi-threaded code, forse utilizzando un <code>std::mutex</code>.</p>
<h5 id="imposizione-223">Imposizione</h5>
<ul>
<li>Segnalare i <code>const_cast</code>.</li>
<li>Questa regola fa parte del <a href="#Pro-type-constcast">profilo di sicurezza del tipo</a> per il relativo Profilo.</li>
</ul>
<h3 id="es.55-evitare-la-necessità-di-controllare-i-range"><a name="Res-range-checking"></a>ES.55: Evitare la necessità di controllare i range</h3>
<h5 id="motivo-234">Motivo</h5>
<p>I costrutti che non possono andare in overflow non lo fanno (e solitamente funzionano più velocemente):</p>
<h5 id="esempio-212">Esempio</h5>
<pre><code>for (auto&amp; x : v)      // scrive tutti gli elementi di v
cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;

auto p = find(v, x);   // cerca x in v</code></pre>
<h5 id="imposizione-224">Imposizione</h5>
<p>Cercare i controlli espliciti sui range suggerendo euristicamente delle alternative.</p>
<h3 id="es.56-scrivere-stdmove-solo-quando-è-necessario-spostare-esplicitamente-un-oggetto-in-un-altro-scope"><a name="Res-move"></a>ES.56: Scrivere <code>std::move()</code> solo quando è necessario spostare esplicitamente un oggetto in un altro scope</h3>
<h5 id="motivo-235">Motivo</h5>
<p>Solitamente si sposta anziché copiare, per evitare duplicazioni e per migliorare le prestazioni.</p>
<p>Uno spostamento [move] solitamente lascia dietro di sé un oggetto vuoto (<a href="#Rc-move-semantic">C.64</a>), che può sorprendere e persino essere pericoloso, quindi si cerca di evitare lo spostamento dagli lvalues (vi si potrà accedere in seguito).</p>
<h5 id="note-214">Note</h5>
<p>Lo spostamento viene fatto implicitamente quando l’origine è un rvalue (p.es., il valore nella gestione di un <code>return</code>o il risultato di una funzione), quindi non si complichi inutilmente il codice, in questi casi, scrivendo esplicitamente <code>move</code>. Si scrivano, invece, brevi funzioni che restituiscano valori, e sia il ritorno della funzione che l’accettazione del ritorno da parte del chiamante saranno naturalmente ottimizzati.</p>
<p>In generale, seguire le linee-guide in questo documento (incluso il non rendere gli scope delle variabili inutilmente ampi, scrivendo funzioni brevi che restituiscono valori, restituendo variabili locali) aiuta ad eliminare il più possibile la necessità dei <code>std::move</code> espliciti.</p>
<p>Il <code>move</code> esplicito è necessario per spostare [move] esplicitamente un oggetto in un altro scope, in particolare per passarlo a una funzione “sink” e nelle stesse implementazioni delle operazioni di move (costruttore di move, operatore di assegnazione del move) e nell’operazione di swap.</p>
<h5 id="esempio-cattivo-94">Esempio, cattivo</h5>
<pre><code>void sink(X&amp;&amp; x);   // sink diventa proprietario di x

void user()
{
X x;
// errore: è impossibile il bind di un lvalue ad un riferimento di rvalue
sink(x);
// OK: sink prende il contenuto di x, ora x de deve considerare vuoto
sink(std::move(x));

// ...

// probabilmente un errore
use(x);
}</code></pre>
<p>Solitamente, viene usato un <code>std::move()</code> come argomento di un parametro <code>&amp;&amp;</code>. E dopo averlo fatto, si suppone che l’oggetto sia stato spostato via (cfr. <a href="#Rc-move-semantic">C.64</a>) e che non se ne debba leggere lo stato finché non lo si imposti ad un nuovo valore.</p>
<pre><code>void f() {
string s1 = &quot;supercalifragilisticexpialidocious&quot;;

string s2 = s1;             // ok, prende una copia
assert(s1 == &quot;supercalifragilisticexpialidocious&quot;);  // ok

// non buono, se si desidera continuare a utilizzare il valore di s1
string s3 = move(s1);

// non buono, l&#39;asserzione probabilmente fallirà, s1 probabilmente è cambiato
assert(s1 == &quot;supercalifragilisticexpialidocious&quot;);
}</code></pre>
<h5 id="esempio-213">Esempio</h5>
<pre><code>void sink(unique_ptr&lt;widget&gt; p);  // passa la proprietà di p a sink()

void f() {
auto w = make_unique&lt;widget&gt;();
// ...
sink(std::move(w));               // ok, si da a sink()
// ...
sink(w);    // Errore: unique_ptr è stato attentamente progettato in modo da non poterlo copiare
}</code></pre>
<h5 id="note-215">Note</h5>
<p><code>std::move()</code> è un cast a <code>&amp;&amp;</code> sotto mentite spoglie; di per sé non sposta nulla, ma contrassegna un oggetto nominato come candidato allo spostamento. Il linguaggio conosce già i casi comuni dove è possibile spostare gli oggetti, specialmente quando si restituiscono i valori delle funzioni, quindi non si complichi il codice con un ridondante <code>std::move()</code>.</p>
<p>Non scrivere mai <code>std::move()</code> solo perché qualcuno ha detto che “è più efficiente”. In generale, non si deve credere alle affermazioni sulla “efficienza” senza dati (???). In generale, non complicare il proprio codice senza motivo (??). Mai scrivere <code>std::move()</code> per un oggetto const, esso viene silenziosamente trasformato in una copia (cfr. Item 23 in <a href="#Meyers15">Meyers15</a>)</p>
<h5 id="esempio-cattivo-95">Esempio, cattivo</h5>
<pre><code>vector&lt;int&gt; make_vector() {
vector&lt;int&gt; result;
// ... carica i dati in result
return std::move(result);       // non buono; basta scrivere &quot;return result;&quot;
}</code></pre>
<p>Mai scrivere <code>return move(local_variable);</code>, perché il linguaggio già sa che la variabile è un candidato per il move. Scrivere <code>move</code> in questo codice non aiuta e può in effetti essere dannoso perché su alcuni compilatori interferisce col RVO (l’ottimizzazione del valore di ritorno) creando un’ulteriore alias di riferimento alla variabile locale.</p>
<h5 id="esempio-cattivo-96">Esempio, cattivo</h5>
<pre><code>vector&lt;int&gt; v = std::move(make_vector());   // non buono; std::move è completamente ridondante</code></pre>
<p>Mai scrivere <code>move</code> per un valore di ritorno come <code>x = move(f());</code> dove <code>f</code> ritorna per valore. Il linguaggio già sa che un valore restituito è un oggetto temporaneo che può essere trasferito [moved].</p>
<h5 id="esempio-214">Esempio</h5>
<pre><code>void mover(X&amp;&amp; x) {
call_something(std::move(x));         // ok
call_something(std::forward&lt;X&gt;(x));   // non buono, non eseguire un std::forward di un riferimento a un rvalue
call_something(x);                    // sospetto, perché non usare std::move?
}

template&lt;class T&gt;
void forwarder(T&amp;&amp; t) {
call_something(std::move(t));         // non buono, non eseguire un std::move del forwarding di un riferimento
call_something(std::forward&lt;T&gt;(t));   // ok
call_something(t);                    // sospetto, perché non usare std::forward?
}</code></pre>
<h5 id="imposizione-225">Imposizione</h5>
<ul>
<li>Segnalare l’uso di <code>std::move(x)</code> dove <code>x</code> è un rvalue o il linguaggio lo tratterà già come un rvalue, compreso <code>return std::move(local_variable);</code> e <code>std::move(f())</code> su una funzione che restituisce per valore.</li>
<li>Segnalare le funzioni che prendono un parametro <code>S&amp;&amp;</code> se non c’è alcun overload <code>const S&amp;</code> per prendersi cura degli lvalue.</li>
<li>Segnala uno <code>std::move</code> dell’argomento passato ad un parametro, tranne quando il tipo del parametro è un riferimento rvalue <code>X&amp;&amp;</code> o il tipo è “move-only” ed il parametro viene passato per valore.</li>
<li>Segnalare quando <code>std::move</code> viene applicato ad un “forwarding” del riferimento (<code>T&amp;&amp;</code> dove <code>T</code> è un tipo di parametro template). Usare, invece, <code>std::forward</code>.</li>
<li>Segnalare quando <code>std::move</code> viene applicato ad un valore diverso da un riferimento rvalue a un non-const. (Un caso più generale della regola precedente per coprire i casi non-forwarding).</li>
<li>Segnalare quando <code>std::forward</code> viene applicato ad un riferimento rvalue (<code>X&amp;&amp;</code> dove <code>X</code> è un tipo concreto). Usare, invece, <code>std::move</code>.</li>
<li>Segnalare quando <code>std::forward</code> viene applicato ad un riferimenro diverso dal forwarding. (Un caso più generale della regola precedente per coprire i casi non-moving).</li>
<li>Segnalare quando un oggetto viene potenzialmente spostato [moved] e la successiva operazione è un’operazione <code>const</code>; dovrebbe esserci prima un’operazione non-<code>const</code>, idealmente un’assegnazione, per resettare subito il valore dell’oggetto.</li>
</ul>
<h3 id="es.60-evitare-new-e-delete-al-di-fuori-delle-funzioni-di-gestione-delle-risorse"><a name="Res-new"></a>ES.60: Evitare <code>new</code> e <code>delete</code> al di fuori delle funzioni di gestione delle risorse</h3>
<h5 id="motivo-236">Motivo</h5>
<p>La gestione diretta delle risorse nel codice di un’applicazione è soggetta ad errori e noiosa.</p>
<h5 id="note-216">Note</h5>
<p>Questa è anche nota come la regola del “Nessun semplice [naked] <code>new</code>!”</p>
<h5 id="esempio-cattivo-97">Esempio, cattivo</h5>
<pre><code>void f(int n)
{
auto p = new X[n];   // n X costruiti col default
// ...
delete[] p;
}</code></pre>
<p>Può esserci del codice nella parte <code>...</code> che non esegue mai il <code>delete</code>.</p>
<p><strong>Si veda anche </strong>: <a href="#S-resource">R: Gestione delle risorse</a></p>
<h5 id="imposizione-226">Imposizione</h5>
<p>Segnalare i [naked] <code>new</code> e i [naked]<code>delete</code>.</p>
<h3 id="es.61-eseguire-il-delete-degli-array-con-delete-e-usando-delete-per-il-resto"><a name="Res-del"></a>ES.61: Eseguire il delete degli array con <code>delete[]</code> e usando <code>delete</code> per il resto</h3>
<h5 id="motivo-237">Motivo</h5>
<p>Questo è ciò che richiede il linguaggio e gli errori possono portare ad errori nel rilascio delle risorse e/o corrompere la memoria.</p>
<h5 id="esempio-cattivo-98">Esempio, cattivo</h5>
<pre><code>void f(int n)
{
auto p = new X[n];   // n X costruiti col default
// ...
delete p;   // errore: basta il delete dell&#39;oggetto p, anziché il delete dell&#39;array p[]
}</code></pre>
<h5 id="note-217">Note</h5>
<p>Questo esempio non solo viola la <a href="#Res-new">regola di nessun <code>new</code> [naked]</a> come nel precedente esempio, ma presenta molti altri problemi.</p>
<h5 id="imposizione-227">Imposizione</h5>
<ul>
<li>Se il <code>new</code> e il <code>delete</code> stanno nello stesso scope, si possono segnalare gli errori.</li>
<li>Se il <code>new</code> e il <code>delete</code> stanno in una coppia costruttore/distruttore, si possono segnalare gli errori.</li>
</ul>
<h3 id="es.62-non-confrontare-i-puntatori-in-diversi-array"><a name="Res-arr2"></a>ES.62: Non confrontare i puntatori in diversi array</h3>
<h5 id="motivo-238">Motivo</h5>
<p>Il risultato è indefinito.</p>
<h5 id="esempio-cattivo-99">Esempio, cattivo</h5>
<pre><code>void f()
{
int a1[7];
int a2[9];
if (&amp;a1[5] &lt; &amp;a2[7]) {}       // non buono: indefinito
if (0 &lt; &amp;a1[5] - &amp;a2[7]) {}   // non buono: indefinito
}</code></pre>
<h5 id="note-218">Note</h5>
<p>Questo esempio presenta molti più problemi.</p>
<h5 id="imposizione-228">Imposizione</h5>
<p>???</p>
<h3 id="es.63-non-provocare-slice"><a name="Res-slice"></a>ES.63: Non provocare “slice”</h3>
<h5 id="motivo-239">Motivo</h5>
<p>Lo slicing – ovvero la copia di solo una parte di un oggetto tramite l’assegnazione o l’inizializzazione – molto spesso porta a errori perché l’oggetto doveva essere considerato nella sua interezza. Nei rari casi in cui lo slicing è voluto, il codice può sorprendere.</p>
<h5 id="esempio-215">Esempio</h5>
<pre><code>class Shape { /* ... */ };
class Circle : public Shape { /* ... */ Point c; int r; };

Circle c {{0, 0}, 42};
Shape s {c};    // la copia costruisce solo la parte Shape di Circle
s = c;          // o l&#39;assegnazione copia solo la parte Shape di Circle

void assign(const Shape&amp; src, Shape&amp; dest) {
dest = src;
}
Circle c2 {{1, 1}, 43};
assign(c, c2);   // oops, non viene trasferito tutto lo stato
assert(c == c2); // se si fornisce la copia, si deve anche fornire il confronto,
// ma questo probabilmente restituirà false</code></pre>
<p>Il risultato sarà privo di significato perché il centro e il raggio non verranno copiati da <code>c</code> in <code>s</code>. La prima difesa contro questo è <a href="#Rc-copy-virtual">definire la classe base <code>Shape</code> in modo che non lo consenta</a>.</p>
<h5 id="alternativa-8">Alternativa</h5>
<p>Se si intende eseguire lo slice, se ne definisca un’operazione esplicita. Ciò evita al lettore un po’ di confusione. Per esempio:</p>
<pre><code>class Smiley : public Circle {
public:
Circle copy_circle();
// ...
};

Smiley sm { /* ... */ };
Circle c1 {sm};  // idealmente impedito dalla definizione di Circle
Circle c2 {sm.copy_circle()};</code></pre>
<h5 id="imposizione-229">Imposizione</h5>
<p>Emettere un warning contro lo slicing.</p>
<h3 id="es.64-usare-la-notazione-teper-la-costruzione"><a name="Res-construct"></a>ES.64: Usare la notazione <code>T{e}</code>per la costruzione</h3>
<h5 id="motivo-240">Motivo</h5>
<p>La sintassi per la costruzione <code>T{e}</code> rende esplicito che si desidera la costruzione. La sintassi della costruzione <code>T{e}</code> non consente il [narrowing]. <code>T{e}</code> è l’unica espressione generale sicura per la costruzione di un valore di tipo <code>T</code> da un’espressione <code>e</code>. Le notazioni dei cast <code>T(e)</code> e <code>(T)e</code> non sono né sicure né generali.</p>
<h5 id="esempio-216">Esempio</h5>
<p>Per i tipi nativi, la notazione per la costruzione protegge dal narrowing e dalla reinterpretazione</p>
<pre><code>void use(char ch, int i, double d, char* p, long long lng)
{
int x1 = int{ch};     // OK, ma ridondante
int x2 = int{d};      // errore: narrowing double-&gt;int; usare un cast se lo si deve fare
int x3 = int{p};      // errore: puntatore a-&gt;int; usare un reinterpret_cast se lo si vuole veramente
int x4 = int{lng};    // errore: narrowing long long-&gt;int; usare un cast se lo si vuole fare

int y1 = int(ch);     // OK, ma ridondante
int y2 = int(d);      // non buono: narrowing double-&gt;int; usare un cast se lo si vuole fare
int y3 = int(p);      // non buono: puntatore a-&gt;int; usare un reinterpret_cast se lo si vuole fare veramente
int y4 = int(lng);    // non buono: narrowing long long-&gt;int; usare un cast se lo si vuole fare

int z1 = (int)ch;     // OK, ma ridondante
int z2 = (int)d;      // non buono: narrowing double-&gt;int; usare un cast se lo si vuole fare
int z3 = (int)p;      // non buono: puntatore a-&gt;int; usare un reinterpret_cast se lo si vuole veramente fare
int z4 = (int)lng;    // non buono: narrowing long long-&gt;int; usare un cast se lo si vuole fare
}</code></pre>
<p>Le conversioni intere in/da puntatori sono definite delle implementazioni quando si usano le notazioni <code>T(e)</code> o <code>(T)e</code>, e non portabili tra le piattaforme con dimensioni diverse degli interi e dei puntatori.</p>
<h5 id="note-219">Note</h5>
<p><a href="#Res-casts">Evitare i cast</a> (conversione esplicita del tipo) e se lo si deve fare<a href="#Res-casts-named">preferire i “named cast”</a>.</p>
<h5 id="note-220">Note</h5>
<p>Se non è ambiguo, la <code>T</code> può essere lasciata fuori da <code>T{e}</code>.</p>
<pre><code>complex&lt;double&gt; f(complex&lt;double&gt;);

auto z = f({2*pi, 1});</code></pre>
<h5 id="note-221">Note</h5>
<p>La notazione della costruzione è la più generale <a href="#Res-list">notazione dell’inizializzatore</a>.</p>
<h5 id="eccezione-41">Eccezione</h5>
<p><code>std::vector</code> ed altri contenitori sono stati definiti prima di avere <code>{}</code> come notazione per la costruzione. Si consideri:</p>
<pre><code>vector&lt;string&gt; vs {10};                           // dieci stringhe vuote
vector&lt;int&gt; vi1 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  // dieci elementi 1..10
vector&lt;int&gt; vi2 {10};                             // un elemento col valore 10</code></pre>
<p>Come si ottiene un <code>vector</code> di 10 <code>int</code> inizializzati col default?</p>
<pre><code>vector&lt;int&gt; v3(10); // dieci elementi col valore 0</code></pre>
<p>L’uso di <code>()</code> anziché di <code>{}</code> per il numero degli elementi è convenzionale (risalente ai primi anni ’80), difficile da cambiare, ma resta un errore di progetto: per un contenitore dove il tipo dell’elemento si può confondere col numero degli elementi, si ha un’ambiguità da risolvere. La soluzione convenzionale consiste nell’interpretare <code>{10}</code> come un elenco di un elemento ed usare <code>(10)</code> per distinguere una dimensione.</p>
<p>Non c’è bisogno si ripetere questo errore nel nuovo codice. Si può definire un tipo per rappresentare il numero degli elementi:</p>
<pre><code>struct Count { int n; };

template&lt;typename T&gt;
class Vector {
public:
Vector(Count n);                     // n elementi inizializzati col default
Vector(initializer_list&lt;T&gt; init);    // init.size() elementi
// ...
};

Vector&lt;int&gt; v1{10};
Vector&lt;int&gt; v2{Count{10}};
Vector&lt;Count&gt; v3{Count{10}};    // sì, c&#39;è ancora un problema molto piccolo</code></pre>
<p>Il principale problema lasciato è quello di trovare un nome adatto per <code>Count</code>.</p>
<h5 id="imposizione-230">Imposizione</h5>
<p>Segnalare i cast di tipo C <code>(T)e</code> e in stile funzionale <code>T(e)</code>.</p>
<h3 id="es.65-non-de-referenziare-un-puntatore-non-valido"><a name="Res-deref"></a>ES.65: Non de-referenziare un puntatore non valido</h3>
<h5 id="motivo-241">Motivo</h5>
<p>Dereferenziare un puntatore non valido, come <code>nullptr</code>, è un comportamento indefinito, che di solito porta ad arresti anomali immediati, risultati errati o corruzione della memoria.</p>
<h5 id="note-222">Note</h5>
<p>Questa è una regola ovvia e ben conosciuta del linguaggio, ma può essere ben difficile da seguire. Sono necessari un buon stile di codifica, una libreria di supporto e l’analisi statica per eliminare le violazioni senza un ulteriore lavoro. uesta è una parte importante della discussione sul <a href="#Stroustrup15">modello del C++ per la sicurezza dei tipi e delle risorse</a>.</p>
<p><strong>Si veda anche</strong>:</p>
<ul>
<li>Usare <a href="#Rr-raii">RAII</a> per evitare i problemi a vita.</li>
<li>Usare <a href="#Rf-unique_ptr">unique_ptr</a> per evitare i problemi a vita.</li>
<li>Usare <a href="#Rf-shared_ptr">shared_ptr</a> per evitare i problemi a vita.</li>
<li>Usare i <a href="#Rf-ptr-ref">riferimenti</a> quando non è possibile <code>nullptr</code>.</li>
<li>Usare <a href="#Rf-not_null">not_null</a> per rilevare in anticipo un inatteso <code>nullptr</code>.</li>
<li>Usare il <a href="#SS-bounds">profilo dei [bound]</a> per evitare gli errori sui range.</li>
</ul>
<h5 id="esempio-217">Esempio</h5>
<pre><code>void f()
{
int x = 0;
int* p = &amp;x;

if (condition()) {
int y = 0;
p = &amp;y;
} // invalida p

*p = 42;            // NON BUONO, p può essere non valido se si esegue il ramo dell&#39;if
}</code></pre>
<p>Per risolvere il problema, o si prolunga la durata dell’oggetto a cui si intende fare riferimento col puntatore, o ridurre òa durata del puntatore (spostare la dereferenza prima che finisca la durata dell’oggetto puntato).</p>
<pre><code>void f1()
{
int x = 0;
int* p = &amp;x;

int y = 0;
if (condition()) {
p = &amp;y;
}

*p = 42;            // OK, p punta a x or a y ed entrambi sono ancora nello scope
}</code></pre>
<p>Sfortunatamente, la maggior parte dei problemi sui puntatori non validi sono più difficili da individuare e più difficili da risolvere.</p>
<h5 id="esempio-218">Esempio</h5>
<pre><code>void f(int* p)
{
int x = *p; // NON BUONO: come sappiamo che p è valido?
}</code></pre>
<p>Esiste un’enorme quantità di codice simile. La maggior parte funziona – dopo molti test – ma isolatamente è impossibile dire se <code>p</code> potrebbe essere <code>nullptr</code>. Di conseguenza, questa è anche una delle principali fonti di errori. Esistono molti approcci per affrontare questo potenziale problema:</p>
<pre><code>void f1(int* p) // avere a che fare con nullptr
{
if (!p) {
// avere a che fare con nullptr (allocazione, return, errori, fare in modo che p punti a qualcosa, qualsiasi cosa
}
int x = *p;
}</code></pre>
<p>o due potenziali problemi con il test per il <code>nullptr</code>:</p>
<ul>
<li>non è sempre ovvio su cosa fare se si trova <code>nullptr</code></li>
<li>il test può essere ridondante e/o relativamente costoso</li>
<li>non è ovvio se il test deve proteggere da una violazione o parte della logica richiesta.</li>
</ul>
<!-- comment needed for code block after list -->
<pre><code>void f2(int* p) // dice che p non si suppone possa essere nullptr
{
assert(p);
int x = *p;
}</code></pre>
<p>Ciò comporterebbe un costo solo quando viene abilitato il controllo dell’asserzione e fornisce informazioni utili a un compilatore/analizzatore. Funzionerebbe ancora meglio se/quando il C++ avesse un supporto diretto per i contratti [contract]:</p>
<pre><code>void f3(int* p) // dice che p non si suppone possa essere nullptr
[[expects: p]]
{
int x = *p;
}</code></pre>
<p>In alternativa, si potrebbe usare <code>gsl::not_null</code> per assicurarsi che <code>p</code> non sia <code>nullptr</code>.</p>
<pre><code>void f(not_null&lt;int*&gt; p)
{
int x = *p;
}</code></pre>
<p>Questi rimedi si occupano solo di <code>nullptr</code>. Si tenga presente che esistono altri modi per ottenere un puntatore invalido.</p>
<h5 id="esempio-219">Esempio</h5>
<pre><code>void f(int* p)  // codice vecchio, non usa la proprietà [owner]
{
delete p;
}

void g()        // codice vecchio: usa il semplice [naked] new
{
auto q = new int{7};
f(q);
int x = *q; // NON BUONO: dereferenza di un puntatore invalido
}</code></pre>
<h5 id="esempio-220">Esempio</h5>
<pre><code>void f()
{
vector&lt;int&gt; v(10);
int* p = &amp;v[5];
v.push_back(99); // potrebbe riallocare gli elementi di v
int x = *p; // NN BUONO: dereferanza di un puntatore potenzialmente invalido
}</code></pre>
<h5 id="imposizione-231">Imposizione</h5>
<p>Questa regola fa parte del <a href="#SS-lifetime">profilo di sicurezza a vita [lifetime safety]</a></p>
<ul>
<li>Segnalare una dereferenza di un puntatore che punta ad un oggetto che è uscito dallo scope</li>
<li>Segnalare una dereferenza di un puntatore che può essere stato invalidato da un’assegnazione con <code>nullptr</code></li>
<li>Segnalare una dereferenza di un puntatore che può essere stato invalidato da un <code>delete</code></li>
<li>Segnalare una dereferenza di un puntatore a un elemento di un contenitore che può essere stato invalidato per dereferenza</li>
</ul>
<h2 id="es.stmt-istruzioni">ES.stmt: Istruzioni</h2>
<p>Le istruzioni controllano il flusso di controllo (ad eccezione delle chiamate alla funzione e gli errori, che sono espressioni).</p>
<h3 id="es.70-preferire-listruzione-switch-allistruzione-if-potendo-scegliere"><a name="Res-switch-if"></a>ES.70: Preferire l’istruzione <code>switch</code> all’istruzione <code>if</code> potendo scegliere</h3>
<h5 id="motivo-242">Motivo</h5>
<ul>
<li>Leggibilità.</li>
<li>Efficienza: Uno <code>switch</code> effettua un confronto tra costanti ed è solitamente più ottimizzato di una serie di test con una sequenza di <code>if</code>-<code>then</code>-<code>else</code>.</li>
<li>Uno <code>switch</code> consente di effettuare un controllo euristico della consistenza. Per esempio, sono stati considerati tutti i valori di una <code>enum</code>? Se no, c’è un’istruzione <code>default</code>?</li>
</ul>
<h5 id="esempio-221">Esempio</h5>
<pre><code>void use(int n)
{
switch (n) {   // buono
case 0:
// ...
break;
case 7:
// ...
break;
default:
// ...
break;
}
}</code></pre>
<p>anziché:</p>
<pre><code>void use2(int n)
{
if (n == 0)   // non buono: una sequenza di if-then-else per confrontare un insieme di costanti
// ...
else if (n == 7)
// ...
}</code></pre>
<h5 id="imposizione-232">Imposizione</h5>
<p>Segnalare le sequenze di <code>if</code>-<code>then</code>-<code>else</code> che confrontano (solo) con costanti.</p>
<h3 id="es.71-preferire-unistruzione-range-for-ad-unistruzione-for-potendo-scegliere"><a name="Res-for-range"></a>ES.71: Preferire un’istruzione range-<code>for</code> ad un’istruzione <code>for</code> potendo scegliere</h3>
<h5 id="motivo-243">Motivo</h5>
<p>Leggibilità. Prevenzione degli errori. Efficienza.</p>
<h5 id="esempio-222">Esempio</h5>
<pre><code>for (gsl::index i = 0; i &lt; v.size(); ++i)   // non buono
cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;;

for (auto p = v.begin(); p != v.end(); ++p)   // non buono
cout &lt;&lt; *p &lt;&lt; &#39;\n&#39;;

for (auto&amp; x : v)    // OK
cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;

for (gsl::index i = 1; i &lt; v.size(); ++i) // tocca due elementi: non può essere un range-for
cout &lt;&lt; v[i] + v[i - 1] &lt;&lt; &#39;\n&#39;;

for (gsl::index i = 0; i &lt; v.size(); ++i) // possibile effetto collaterale: non può essere un range-for
cout &lt;&lt; f(v, &amp;v[i]) &lt;&lt; &#39;\n&#39;;

for (gsl::index i = 0; i &lt; v.size(); ++i) { // nel body si scombussola la variabile del loop: non può essere un range-for
if (i % 2 == 0)
continue;   // salta gli elementi pari
else
cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;;
}</code></pre>
<p>Un umano o un buon analizzatore statico può determinare che non ci sono effetti collaterali su <code>v</code> in <code>f(v, &amp;v[i])</code> in modo che si possa riscrivere il loop.</p>
<p>In genere è meglio evitare di “scombussolare la variabile del loop” nel suo body.</p>
<h5 id="note-223">Note</h5>
<p>Non usare costose copie della variabile del loop in un ciclo range-<code>for</code>:</p>
<pre><code>for (string s : vs) // ...</code></pre>
<p>Questo copierà ogni elemento di <code>vs</code> in <code>s</code>. Meglio:</p>
<pre><code>for (string&amp; s : vs) // ...</code></pre>
<p>Meglio ancora, se la variabile del loop non viene modificata o copiata:</p>
<pre><code>for (const string&amp; s : vs) // ...</code></pre>
<h5 id="imposizione-233">Imposizione</h5>
<p>Look at loops, se un tradizionale ciclo cerca solamente ogni elemento di una sequenza e non ci sono effetti collaterali su quello che fa con gli elementi, si riscriva il loop utilizzando un range-<code>for</code>.</p>
<h3 id="es.72-preferire-unistruzione-for-ad-unistruzione-while-quando-cè-unovvia-variabile-del-ciclo"><a name="Res-for-while"></a>ES.72: Preferire un’istruzione <code>for</code> ad un’istruzione <code>while</code> quando c’è un’ovvia variabile del ciclo</h3>
<h5 id="motivo-244">Motivo</h5>
<p>Leggibilità: si ha “davanti” tutta la logica del ciclo. Lo scope della variabile del loop può essere limitato.</p>
<h5 id="esempio-223">Esempio</h5>
<pre><code>for (gsl::index i = 0; i &lt; vec.size(); i++) {
// funziona
}</code></pre>
<h5 id="esempio-cattivo-100">Esempio, cattivo</h5>
<pre><code>int i = 0;
while (i &lt; vec.size()) {
// funziona
i++;
}</code></pre>
<h5 id="imposizione-234">Imposizione</h5>
<p>???</p>
<h3 id="es.73-preferire-unistruzione-while-ad-unistruzione-for-quando-non-è-ovvia-la-variabile-del-ciclo"><a name="Res-while-for"></a>ES.73: Preferire un’istruzione <code>while</code> ad un’istruzione <code>for</code> quando non è ovvia la variabile del ciclo</h3>
<h5 id="motivo-245">Motivo</h5>
<p>Leggibilità.</p>
<h5 id="esempio-224">Esempio</h5>
<pre><code>int events = 0;
for (; wait_for_event(); ++events) {  // non buono, confuso
// ...
}</code></pre>
<p>Il “ciclo event” è fuorviante perché il contatore degli eventi, <code>events</code>, non ha niente a che fare con la condizione del loop (<code>wait_for_event()</code>). Meglio</p>
<pre><code>int events = 0;
while (wait_for_event()) {      // meglio
++events;
// ...
}</code></pre>
<h5 id="imposizione-235">Imposizione</h5>
<p>Segnalare le azioni negli inizializzatori dei <code>for</code> e negli incrementi dei <code>for</code> che non sono in relazione con la condizione del <code>for</code>.</p>
<h3 id="es.74-preferire-dichiarare-una-variabile-del-ciclo-nella-parte-dellinizializzatore-di-unistruzione-for"><a name="Res-for-init"></a>ES.74: Preferire dichiarare una variabile del ciclo nella parte dell’inizializzatore di un’istruzione <code>for</code></h3>
<h5 id="motivo-246">Motivo</h5>
<p>Limitare la visibilità della variabile allo scope del loop. Evitare di utilizzare la variabile del loop per altri usi dopo il ciclo.</p>
<h5 id="esempio-225">Esempio</h5>
<pre><code>for (int i = 0; i &lt; 100; ++i) {   // BENE: i è visibile solo all&#39;interno del loop
// ...
}</code></pre>
<h5 id="esempio-da-non-fare-2">Esempio, da non fare</h5>
<pre><code>int j;                            // BAD: j è visibile all&#39;esterno del loop
for (j = 0; j &lt; 100; ++j) {
// ...
}
// j è ancora visibile qui e non è necessario</code></pre>
<p><strong>Si veda anche</strong>: <a href="#Res-recycle">Non usare una variabile per due usi non correlati</a></p>
<h5 id="esempio-226">Esempio</h5>
<pre><code>for (string s; cin &gt;&gt; s; ) {
cout &lt;&lt; s &lt;&lt; &#39;\n&#39;;
}</code></pre>
<h5 id="imposizione-236">Imposizione</h5>
<p>Avvisare quando una modificata in un’istruzione <code>for</code> è dichiarata esternamente al loop e non viene usata esternamente al ciclo.</p>
<p><strong>Discussione</strong>: Racchiudere la variabile del loop nello scope del body del loop aiuta molto gli ottimizzatori. Riconoscere che imporre che la variabile sia accessibile solamente all’interno del body del loop sblocca alcune ottimizzazioni quali l’hoisting [spostare le variabili all’inizio], strength reduction [sostituzione di operazioni onerose con altre più economiche], loop-invariant code motion [spostare istruzioni al di fuori del loop], ecc.</p>
<h3 id="es.75-evitare-listruzione-do"><a name="Res-do"></a>ES.75: Evitare l’istruzione <code>do</code></h3>
<h5 id="motivo-247">Motivo</h5>
<p>Leggibilità, prevenzione degli errori. La condizione per terminare sta alla fine (dove non si può ignorare) e la condizione non è verificata al primo passaggio.</p>
<h5 id="esempio-227">Esempio</h5>
<pre><code>int x;
do {
cin &gt;&gt; x;
// ...
} while (x &lt; 0);</code></pre>
<h5 id="note-224">Note</h5>
<p>Sì, ci sono buoni esempi in cui un’istruzione <code>do</code> risulta una soluzione chiara, ma anche molti errori.</p>
<h5 id="imposizione-237">Imposizione</h5>
<p>Segnalare le istruzioni <code>do</code>.</p>
<h3 id="es.76-evitare-il-goto"><a name="Res-goto"></a>ES.76: Evitare il <code>goto</code></h3>
<h5 id="motivo-248">Motivo</h5>
<p>Leggibilità, prevenzione degli errori. Esistono strutture di controllo migliori per gli umani; il <code>goto</code> è per il codice generato dalla macchina.</p>
<h5 id="eccezione-42">Eccezione</h5>
<p>Uscire da un ciclo annidato. In questo caso, saltare sempre in avanti.</p>
<pre><code>for (int i = 0; i &lt; imax; ++i)
for (int j = 0; j &lt; jmax; ++j) {
if (a[i][j] &gt; elem_max) goto finished;
// ...
}
finished:
// ...</code></pre>
<h5 id="esempio-cattivo-101">Esempio, cattivo</h5>
<p>Cè un largo uso del blocco goto-exit del C:</p>
<pre><code>void f()
{
// ...
goto exit;
// ...
goto exit;
// ...
exit:
// ... codice in comune per la pulizia ...
}</code></pre>
<p>Questa è una simulazione ad-hoc dei distruttori. Si dichiarino le proprie risorse con gli handle con i distruttori che ripuliscono tutto. Se per qualche motivo non si può gestire la ripulitura delle variabili usate con i distruttori, si prenda in considerazione <code>gsl::finally()</code> come un’alternativa di pulizia più leggibile al <code>goto exit</code></p>
<h5 id="imposizione-238">Imposizione</h5>
<ul>
<li>Segnalare i <code>goto</code>. Maglio ancora segnalare tutti i <code>goto</code> che non saltano da un ciclo nidificato all’istruzione immediatamente al ciclo più esterno.</li>
</ul>
<h3 id="es.77-minimizzare-luso-di-break-e-continue-nei-cicli"><a name="Res-continue"></a>ES.77: Minimizzare l’uso di <code>break</code> e <code>continue</code> nei cicli</h3>
<h5 id="motivo-249">Motivo</h5>
<p>Nel body di un ciclo un po’ più complesso, è facile tralasciare un <code>break</code> o un <code>continue</code>.</p>
<p>Un <code>break</code> in un ciclo ha un significato terribilmente diverso da un <code>break</code> in un’istruzione <code>switch</code> (e si possono avere istruzioni <code>switch</code> in un ciclo e un ciclo in un ‘case’ di uno <code>switch</code>).</p>
<h5 id="esempio-228">Esempio</h5>
<pre><code>switch(x){
case 1 :
while(/* alcune condizioni */){
//...
break;
} //Oops! si intende interrompere lo switch o il while?
case 2 :
//...
break;
}</code></pre>
<h5 id="alternativa-9">Alternativa</h5>
<p>Spesso, un loop che richiede un <code>break</code> è un buon candidato per una funzione (algoritmo), nel qual caso il <code>break</code> diventa un <code>return</code>.</p>
<pre><code>//Codice originale: un break all&#39;interno di un ciclo
void use1(){
std::vector&lt;T&gt; vec = {/* inizializzato con qualche valore */};
T value;
for(const T item : vec){
if(/* qualche condizione */){
value = item;
break;
}
}
/* quindi fa qualcosa con value */
}

//MEGLIO: si crea una funzione e si torna nel loop
T search(const std::vector&lt;T&gt; &amp;vec){
for(const T &amp;item : vec){
if(/* qualche condizione*/) return item;
}
return T(); //il valore di default
}

void use2(){
std::vector&lt;T&gt; vec = {/* inizializzato con qualche valore */};
T value = search(vec);
/* quindi fa qualcosa con value */
}</code></pre>
<p>Spesso, un ciclo che usa il <code>continue</code> può essere equivalentemente e chiaramente espresso da un’istruzione <code>if</code>.</p>
<pre><code>for(int item : vec){ //NON BUONO
if(item%2 == 0) continue;
if(item == 5) continue;
if(item &gt; 10) continue;
/* fa qualcosa con item */
}

for(int item : vec){ //BUONO
if(item%2 != 0 &amp;&amp; item != 5 &amp;&amp; item &lt;= 10){
/* fa qualcosa con item */
}
}</code></pre>
<h5 id="note-225">Note</h5>
<p>Se è davvero necessario interrompere un loop, un <code>break</code> è in generale la migliore delle alternative al <a href="#Res-loop-counter">modificare la variabile del loop</a> o al <a href="#Res-goto"><code>goto</code></a>:</p>
<h5 id="imposizione-239">Imposizione</h5>
<p>???</p>
<h3 id="es.78-non-fare-affidamento-ai-proseguimenti-impliciti-nelle-istruzioni-switch"><a name="Res-break"></a>ES.78: Non fare affidamento ai proseguimenti impliciti nelle istruzioni <code>switch</code></h3>
<h5 id="motivo-250">Motivo</h5>
<p>Finire sempre un <code>case</code> non vuoto con un <code>break</code>. Tralasciare accidentalmente un <code>break</code> è un bug abbastanza comune. Affidarsi deliberatamente al proseguimento implicito può rappresentare un pericolo per la manutenzione e dovrebbe essere un fatto raro ed esplicito.</p>
<h5 id="esempio-229">Esempio</h5>
<pre><code>switch (eventType) {
case Information:
update_status_bar();
break;
case Warning:
write_event_log();
// Bad - proseguimento implicito
case Error:
display_error_window();
break;
}</code></pre>
<p>Label di casi multipli di una singola istruzione è OK:</p>
<pre><code>switch (x) {
case &#39;a&#39;:
case &#39;b&#39;:
case &#39;f&#39;:
do_something(x);
break;
}</code></pre>
<p>Va bene anche l’istruzione return nei vari case: switch (x) { case ‘a’: return 1; case ‘b’: return 2; case ‘c’: return 3; }</p>
<h5 id="eccezioni-1">Eccezioni</h5>
<p>In rari casi se si ritiene opportuno il proseguimento implicito, si dev’essere espliciti ed usare la notazione <code>[[fallthrough]]</code>:</p>
<pre><code>switch (eventType) {
case Information:
update_status_bar();
break;
case Warning:
write_event_log();
[[fallthrough]];
case Error:
display_error_window();
break;
}</code></pre>
<h5 id="note-226">Note</h5>
<h5 id="imposizione-240">Imposizione</h5>
<p>Segnalare tutti i proseguimenti [fallthrough] impliciti nei <code>case</code> non vuoti.</p>
<h3 id="es.79-usare-default-per-gestire-i-soli-casi-comuni"><a name="Res-default"></a>ES.79: Usare <code>default</code> per gestire i (soli) casi comuni</h3>
<h5 id="motivo-251">Motivo</h5>
<p>Chiarezza del codice. Migliori opportunità per il rilevamento degli errori.</p>
<h5 id="esempio-230">Esempio</h5>
<pre><code>enum E { a, b, c , d };

void f1(E x)
{
switch (x) {
case a:
do_something();
break;
case b:
do_something_else();
break;
default:
take_the_default_action();
break;
}
}</code></pre>
<p>Qui è chiaro che esiste un’azione di default e che i casi <code>a</code> e <code>b</code> sono speciali.</p>
<h5 id="esempio-231">Esempio</h5>
<p>Ma cosa succede se non c’è un’azione di default e si vogliono gestire solo casi specifici? In tal caso, si inserisca un default vuoto o altrimenti sarà impossibile sapere se si intendeva gestire tutti i casi:</p>
<pre><code>void f2(E x)
{
switch (x) {
case a:
do_something();
break;
case b:
do_something_else();
break;
default:
// non fa nulla per i restanti casi
break;
}
}</code></pre>
<p>Omettendo il <code>default</code>, un manutentore e/o un compilatore potrebbe ragionevolmente presumere che si intendano gestire tutti i casi:</p>
<pre><code>void f2(E x)
{
switch (x) {
case a:
do_something();
break;
case b:
case c:
do_something_else();
break;
}
}</code></pre>
<p>È stato dimenticato il case <code>d</code> o lo si è deliberatamente tralasciato? La dimenticanza di un case solitamente avviene quando viene aggiunto un elemento ad un enumerazione e chi lo ha fatto non è riuscito a inserilo in tutti gli switch che usano quell’enumeratore.</p>
<h5 id="imposizione-241">Imposizione</h5>
<p>Segnalare le istruzioni <code>switch</code> basate su una enumerazione che non gestiscono tutte le enumerazioni e non hanno un <code>default</code>. Questo potrebbe produrre troppi falsi positivi in certi tipi di codice; in tal caso, segnalare solo gli <code>switch</code> che gestiscono la maggior parte ma non tutti (questa era la strategia dei primissimo compilatore C++).</p>
<h3 id="es.84-non-tentare-di-dichiarare-una-variabile-locale-senza-nome"><a name="Res-noname"></a>ES.84: Non tentare di dichiarare una variabile locale senza nome</h3>
<h5 id="motivo-252">Motivo</h5>
<p>Non c’è nulla di simile. Quello che ad un umano appare come una variabile senza un nome per un compilatore è un’istruzione che consiste in un temporaneo che subito esce dallo scope.</p>
<h5 id="esempio-cattivo-102">Esempio, cattivo</h5>
<pre><code>void f()
{
lock&lt;mutex&gt;{mx};   // Non buono
// ...
}</code></pre>
<p>Questo dichiara un oggetto <code>lock</code> senza nome che esce immediatamente dallo scope al punto e virgola. Non è un errore insolito. In particolare, questo esempio può portare a conflitti difficili da trovare.</p>
<h5 id="note-227">Note</h5>
<p>Gli argomenti di funzioni senza nome vanno bene.</p>
<h5 id="imposizione-242">Imposizione</h5>
<p>Segnalare le istruzioni che sono solo temporanee.</p>
<h3 id="es.85-rendere-visibili-le-istruzioni-vuote"><a name="Res-empty"></a>ES.85: Rendere visibili le istruzioni vuote</h3>
<h5 id="motivo-253">Motivo</h5>
<p>Leggibilità.</p>
<h5 id="esempio-232">Esempio</h5>
<pre><code>for (i = 0; i &lt; max; ++i);   // NON BUONO: l&#39;istruzione vuota viene facilmente ignorata (non vista)
v[i] = f(v[i]);

for (auto x : v) {           // meglio
// niente
}
v[i] = f(v[i]);</code></pre>
<h5 id="imposizione-243">Imposizione</h5>
<p>Segnalare le istruzioni vuote che non sono blocchi e non contengono commenti.</p>
<h3 id="es.86-evitare-di-modificare-le-variabili-di-controllo-dei-cicli-nel-corpo-dei-cicli-for"><a name="Res-loop-counter"></a>ES.86: Evitare di modificare le variabili di controllo dei cicli nel corpo dei cicli for</h3>
<h5 id="motivo-254">Motivo</h5>
<p>Il controllo del loop dovrebbe consentire il corretto ragionamento su quello che avviene all’interno del ciclo. Modificare i contatori dei loop sia nell’espressione dell’iterazione che nel corpo del loop è una perenne fonte di sorprese e bug.</p>
<h5 id="esempio-233">Esempio</h5>
<pre><code>for (int i = 0; i &lt; 10; ++i) {
// nessun aggiornamento di i -- ok
}

for (int i = 0; i &lt; 10; ++i) {
//
if (/* qualcosa */) ++i; // NON BENE
//
}

bool skip = false;
for (int i = 0; i &lt; 10; ++i) {
if (skip) { skip = false; continue; }
//
if (/* qualcosa */) skip = true;  // Meglio: si usano due variabili per due concetti.
//
}</code></pre>
<h5 id="imposizione-244">Imposizione</h5>
<p>Segnalare le variabili che vengono potenzialmente aggiornate (hanno un uso non-<code>const</code>) sia nel controllo dell’iterazione del loop che nel suo body.</p>
<h3 id="es.87-non-aggiungere-dei-ridondanti-o-alle-condizioni"><a name="Res-if"></a>ES.87: Non aggiungere dei ridondanti <code>==</code> o <code>!=</code> alle condizioni</h3>
<h5 id="motivo-255">Motivo</h5>
<p>Questo evita la prolissità ed elimina delle opportunità per sbagliare. Aiuta a rendere lo stile coerente e convenzionale.</p>
<h5 id="esempio-234">Esempio</h5>
<p>Per definizione, una condizione in un’istruzione <code>if</code>, <code>while</code>, o un <code>for</code> sceglie tra <code>true</code> e <code>false</code>. Un valore numerico viene confrontato con <code>0</code> e il valore di un puntatore con <code>nullptr</code>.</p>
<pre><code>// Tutti questi significano &quot;se `p` non è `nullptr`&quot;
if (p) { ... }            // buono
if (p != 0) { ... }       // ridondante `!=0`; non buono: non usare 0 per i puntatori
if (p != nullptr) { ... } // ridondante `!=nullptr`, non raccomandato</code></pre>
<p>Spesso, <code>if (p)</code> viene letto come “se <code>p</code> è valido” che è una diretta espressione dell’intento dei programmatori, mentre <code>if (p != nullptr)</code> sarebbe una soluzione prolissa.</p>
<h5 id="esempio-235">Esempio</h5>
<p>Questa regola è particolarmente utile quando una dichiarazione viene utilizzata come condizione</p>
<pre><code>if (auto pc = dynamic_cast&lt;Circle&gt;(ps)) { ... } // eseguito se ps punta ad un tipo di Circle, bene

if (auto pc = dynamic_cast&lt;Circle&gt;(ps); pc != nullptr) { ... } // non raccomandato</code></pre>
<h5 id="esempio-236">Esempio</h5>
<p>Si noti che, nelle condizioni, sono applicate le conversioni implicite in bool. Per esempio:</p>
<pre><code>for (string s; cin &gt;&gt; s; ) v.push_back(s);</code></pre>
<p>Ciò richiama, di <code>istream</code>, <code>operator bool()</code>.</p>
<h5 id="note-228">Note</h5>
<p>Il confronto esplicito di un numero intero con <code>0</code> non è generalmente ridondante. Il motivo è che (al contrario di puntatori e dei booleani) un numero intero ha spesso più di due valori ragionevoli. Inoltre <code>0</code> (zero) viene spesso utilizzato per indicare un successo. Di conseguenza, è meglio essere specifici sul confronto.</p>
<pre><code>void f(int i)
{
if (i)            // sospetto
// ...
if (i == success) // forse meglio
// ...
}</code></pre>
<p>Si ricorsi sempre che un intero può avere più di due valori.</p>
<h5 id="esempio-cattivo-103">Esempio, cattivo</h5>
<p>È stato notato che</p>
<pre><code>if(strcmp(p1, p2)) { ... }   // sono le due stringhe in stile C uguali? (errore!)</code></pre>
<p>è un comune errore da principianti. Se si usano stringhe in stile C, si devono conoscere bene le funzioni <code>&lt;cstring&gt;</code>. Essere prolisso scrivendo</p>
<pre><code>if(strcmp(p1, p2) != 0) { ... }   // sono le due stringhe in stile C uguali? (errore!)</code></pre>
<p>non basterebbe a salvare la situazione.</p>
<h5 id="note-229">Note</h5>
<p>La condizione opposta viene espressa più facilmente con una negazione:</p>
<pre><code>// Tutti questi significano &quot;se `p` è `nullptr`&quot;
if (!p) { ... }           // buono
if (p == 0) { ... }       // ridondante `== 0`; non buono: non usare `0` per i puntatori
if (p == nullptr) { ... } // ridondante `== nullptr`, non raccomandato</code></pre>
<h5 id="imposizione-245">Imposizione</h5>
<p>Semplice, basta controllare l’uso ridondante di <code>!=</code> e <code>==</code> nelle condizioni.</p>
<h2 id="aritmetica"><a name="SS-numbers"></a>Aritmetica</h2>
<h3 id="es.100-non-mischiare-laritmetica-con-segno-con-quella-senza-segno"><a name="Res-mix"></a>ES.100: Non mischiare l’aritmetica con segno con quella senza segno</h3>
<h5 id="motivo-256">Motivo</h5>
<p>Evita risultati errati.</p>
<h5 id="esempio-237">Esempio</h5>
<pre><code>int x = -3;
unsigned int y = 7;

cout &lt;&lt; x - y &lt;&lt; &#39;\n&#39;;  // risultato unsigned, probabilmente 4294967286
cout &lt;&lt; x + y &lt;&lt; &#39;\n&#39;;  // risultato unsigned: 4
cout &lt;&lt; x * y &lt;&lt; &#39;\n&#39;;  // risultato unsigned, probabilmente 4294967275</code></pre>
<p>È più difficile individuare il problema in esempi più realistici.</p>
<h5 id="note-230">Note</h5>
<p>Sfortunatamente, il C++ usa interi con segno per gli indici degli array e la libreria standard usa interi senza segno per gli indici dei contenitori. Questo preclude la coerenza. Usare <code>gsl::index</code> per gli indici; <a href="#Res-subscripts">cfr. ES.107</a>.</p>
<h5 id="imposizione-246">Imposizione</h5>
<ul>
<li>I compilatori già lo sanno e talvolta emettono dei warning.</li>
<li>(Per evitare confusione) Non segnalare un confronto tra signed/unsigned dove uno degli argomenti è <code>sizeof</code> o una chiamata alla <code>.size()</code> di un container e l’altro è <code>ptrdiff_t</code>.</li>
</ul>
<h3 id="es.101-usare-i-tipi-unsigned-per-la-gestione-dei-bit"><a name="Res-unsigned"></a>ES.101: Usare i tipi unsigned per la gestione dei bit</h3>
<h5 id="motivo-257">Motivo</h5>
<p>I tipi senza segno supportano la gestione dei bit senza le sorprese del bit del segno.</p>
<h5 id="esempio-238">Esempio</h5>
<pre><code>unsigned char x = 0b1010&#39;1010;
unsigned char y = ~x;   // y == 0b0101&#39;0101;</code></pre>
<h5 id="note-231">Note</h5>
<p>I tipi senza segno possono anche essere utili per l’aritmetica del modulo. Tuttavia, se si vuole l’aritmetica modulare, si aggiungano i commenti necessari, evidenziando il comportamento ‘arrotolato’, in quanto questo codice può meravigliare alcuni programmatori.</p>
<h5 id="imposizione-247">Imposizione</h5>
<ul>
<li>Quasi impossibile in generale a causa dell’utilizzo di indici unsigned nella libreria standard</li>
<li>???</li>
</ul>
<h3 id="es.102-usare-i-tipi-con-segno-per-laritmetica"><a name="Res-signed"></a>ES.102: Usare i tipi con segno per l’aritmetica</h3>
<h5 id="motivo-258">Motivo</h5>
<p>Perché la maggior parte dell’aritmetica è considerata avere un segno; <code>x - y</code> restituisce un numero negativo quando <code>y &gt; x</code> tranne nei rari casi in cui si vuole veramente l’aritmetica modulare.</p>
<h5 id="esempio-239">Esempio</h5>
<p>L’aritmetica senza segno può dare risultati sorprendenti se non ce lo si aspetta. Ciò è ancora più vero per l’aritmetica mista signed e unsigned.</p>
<pre><code>template&lt;typename T, typename T2&gt;
T subtract(T x, T2 y)
{
return x - y;
}

void test()
{
int s = 5;
unsigned int us = 5;
cout &lt;&lt; subtract(s, 7) &lt;&lt; &#39;\n&#39;;       // -2
cout &lt;&lt; subtract(us, 7u) &lt;&lt; &#39;\n&#39;;     // 4294967294
cout &lt;&lt; subtract(s, 7u) &lt;&lt; &#39;\n&#39;;      // -2
cout &lt;&lt; subtract(us, 7) &lt;&lt; &#39;\n&#39;;      // 4294967294
cout &lt;&lt; subtract(s, us + 2) &lt;&lt; &#39;\n&#39;;  // -2
cout &lt;&lt; subtract(us, s + 2) &lt;&lt; &#39;\n&#39;;  // 4294967294
}</code></pre>
<p>Qui siamo stati molto espliciti su ciò che sta accadendo, ma se si fosse visto <code>us - (s + 2)</code> o <code>s += 2; ...; us - s</code>, si avrebbe giustamente sospettato che il risultato stampato sarebbe stato <code>4294967294</code>?</p>
<h5 id="eccezione-43">Eccezione</h5>
<p>Usare i tipi unsigned se si vuole veramente l’aritmetica del modulo - aggiungere i commenti opportuni evidenziando il comportamento ‘arrotolato’, in quanto questo codice può meravigliare alcuni programmatori.</p>
<h5 id="esempio-240">Esempio</h5>
<p>La libreria standard usa i tipi unsigned per gli indici. L’array nativo usa i tipi signed per gli indici. Ciò genera inevitabili sorprese (e bug).</p>
<pre><code>int a[10];
for (int i = 0; i &lt; 10; ++i) a[i] = i;
vector&lt;int&gt; v(10);
// confronta signed con unsigned; alcuni compilatori avvisano, ma non lo si dovrebbe fare
for (gsl::index i = 0; i &lt; v.size(); ++i) v[i] = i;

int a2[-2];         // errore: dimensione negativa

// OK, ma il numero degli int (4294967294) è così grande che si dovrebbe sollevare un&#39;eccezione
vector&lt;int&gt; v2(-2);</code></pre>
<p>Usare <code>gsl::index</code> per gli indici; <a href="#Res-subscripts">cfr. ES.107</a>.</p>
<h5 id="imposizione-248">Imposizione</h5>
<ul>
<li>Segnalare l’aritmetica tra signed e unsigned</li>
<li>Segnalare i risultati dell’aritmetica unsigned assegnati o stampati come signed.</li>
<li>Segnalare i letterali negativi (p.es. <code>-2</code>) usati come indici per i container.</li>
<li>(Per evitare confusione) Non segnalare un confronto tra signed/unsigned dove uno degli argomenti è <code>sizeof</code> o una chiamata alla <code>.size()</code> di un container e l’altro è <code>ptrdiff_t</code>.</li>
</ul>
<h3 id="es.103-evitare-loverflow"><a name="Res-overflow"></a>ES.103: Evitare l’overflow</h3>
<h5 id="motivo-259">Motivo</h5>
<p>Solitamente l’overflow rende l’algoritmo numerico senza senso. Incrementando un valore oltre il suo valore massimo può corrompere la memoria e a un comportamento indefinito.</p>
<h5 id="esempio-cattivo-104">Esempio, cattivo</h5>
<pre><code>int a[10];
a[10] = 7;   // non buono

int n = 0;
while (n++ &lt; 10)
a[n - 1] = 9; // non buono (doppiamente)</code></pre>
<h5 id="esempio-cattivo-105">Esempio, cattivo</h5>
<pre><code>int n = numeric_limits&lt;int&gt;::max();
int m = n + 1;   // non buono</code></pre>
<h5 id="esempio-cattivo-106">Esempio, cattivo</h5>
<pre><code>int area(int h, int w) { return h * w; }

auto a = area(10&#39;000&#39;000, 100&#39;000&#39;000);   // non buono</code></pre>
<h5 id="eccezione-44">Eccezione</h5>
<p>Usare i tipi unsigned se si vuole veramente l’aritmetica modulare.</p>
<p><strong>Alternativa</strong>: Per le applicazioni critiche dove possono capitare degli overhead, usare un tipo intero [range-checked] e/o un floating-point.</p>
<h5 id="imposizione-249">Imposizione</h5>
<p>???</p>
<h3 id="es.104-evitare-lunderflow"><a name="Res-underflow"></a>ES.104: Evitare l’underflow</h3>
<h5 id="motivo-260">Motivo</h5>
<p>Decrementando un valore oltre il suo valore minimo può portare alla corruzione della memoria e a comportamenti indefiniti.</p>
<h5 id="esempio-cattivo-107">Esempio, cattivo</h5>
<pre><code>int a[10];
a[-2] = 7;   // non buono

int n = 101;
while (n--)
a[n - 1] = 9;   // non buono (doppiamente)</code></pre>
<h5 id="eccezione-45">Eccezione</h5>
<p>Usare i tipi unsigned se si vuole veramente l’aritmetica modulare.</p>
<h5 id="imposizione-250">Imposizione</h5>
<p>???</p>
<h3 id="es.105-evitare-la-divisione-per-zero"><a name="Res-zero"></a>ES.105: Evitare la divisione per zero</h3>
<h5 id="motivo-261">Motivo</h5>
<p>Il risultato è indefinito e probabilmente si ha un crash.</p>
<h5 id="note-232">Note</h5>
<p>Questo vale anche per <code>%</code>.</p>
<h5 id="esempio-cattivo-108">Esempio, cattivo</h5>
<pre><code>double divide(int a, int b) {
// NON BUONO, si dovrebbe controllare (p.es., in una precondizione)
return a / b;
}</code></pre>
<h5 id="esempio-buono-19">Esempio, buono</h5>
<pre><code>double divide(int a, int b) {
// bene, fatto tramite una precondizione (e da sostituire con i contratti appena saranno introdotti nel C++)
Expects(b != 0);
return a / b;
}

double divide(int a, int b) {
// bene, fatto tramite un check
return b ? a / b : quiet_NaN&lt;double&gt;();
}</code></pre>
<p><strong>Alternativa</strong>: Per le applicazioni critiche dove possono capitare degli overhead, usare un tipo intero [range-checked] e/o un floating-point.</p>
<h5 id="imposizione-251">Imposizione</h5>
<ul>
<li>Segnalare la divisione per un valore intero che possa valere zero</li>
</ul>
<h3 id="es.106-non-tentare-di-evitare-i-valori-negativi-utilizzando-unsigned"><a name="Res-nonnegative"></a>ES.106: Non tentare di evitare i valori negativi utilizzando <code>unsigned</code></h3>
<h5 id="motivo-262">Motivo</h5>
<p>Scegliere un <code>unsigned</code> implica molti cambiamenti al solito funzionamento degli interi, compresa l’aritmetica modulare, può sopprimere i warning riguardanti l’overflow, ed aprire la porta agli errori sui mix signed/unsigned. L’uso di <code>unsigned</code> in realtà non elimina la possibilità di valori negativi.</p>
<h5 id="esempio-241">Esempio</h5>
<pre><code>unsigned int u1 = -2;   // Valido: il valore di u1 è 4294967294
int i1 = -2;
unsigned int u2 = i1;   // Valido: il valore di u2 è 4294967294
int i2 = u2;            // Valido: il valore di i2 è -2</code></pre>
<p>I problemi con questi costrutti (perfettamente legali) sono difficili da evidenziare nel codice reale e sono la fonte di molti errori del mondo reale. Si consideri:</p>
<pre><code>unsigned area(unsigned height, unsigned width) { return height*width; } // [si veda anche](#Ri-expects)
// ...
int height;
cin &gt;&gt; height;
auto a = area(height, 2);   // se l&#39;input è -2 a diventa 4294967292</code></pre>
<p>Si ricordi che <code>-1</code> quando viene assegnato ad un <code>unsigned int</code> diventa il più grande numero <code>unsigned int</code>. Inoltre, poiché l’aritmetica senza segno è l’aritmetica del modulo, la moltiplicazione non genera overflow, ma si ‘arrotola’.</p>
<h5 id="esempio-242">Esempio</h5>
<pre><code>unsigned max = 100000;    // &quot;errore accidentale&quot;, Si intendeva 10&#39;000
unsigned short x = 100;
while (x &lt; max) x += 100; // loop infinito</code></pre>
<p>Se <code>x</code> fosse stato un signed <code>short</code>, avremmo potuto avvertire del comportamento indefinito dovuto all’overflow.</p>
<h5 id="alternative-2">Alternative</h5>
<ul>
<li>usare interi signed e controllare che <code>x &gt;= 0</code></li>
<li>usare un tipo intero positivo</li>
<li>usare un sotto-indice [subrange] di tipo intero</li>
<li><code>Assert(-1 &lt; x)</code></li>
</ul>
<p>Per esempio</p>
<pre><code>struct Positive {
int val;
Positive(int x) :val{x} { Assert(0 &lt; x); }
operator int() { return val; }
};

int f(Positive arg) { return arg; }

int r1 = f(2);
int r2 = f(-2);  // genera errore</code></pre>
<h5 id="note-233">Note</h5>
<p>???</p>
<h5 id="imposizione-252">Imposizione</h5>
<p>Cfr. le imposizioni di ES.100.</p>
<h3 id="es.107-non-usare-unsigned-per-lindicizzazione-preferire-gslindex"><a name="Res-subscripts"></a>ES.107: Non usare <code>unsigned</code> per l’indicizzazione, preferire <code>gsl::index</code></h3>
<h5 id="motivo-263">Motivo</h5>
<p>Per evitare la confusione tra signed e unsigned. Per consentire una migliore ottimizzazione. Per consentire un migliore rilevamento degli errori. Per evitare le insidie ​​con <code>auto</code> e <code>int</code>.</p>
<h5 id="esempio-cattivo-109">Esempio, cattivo</h5>
<pre><code>vector&lt;int&gt; vec = /*...*/;

for (int i = 0; i &lt; vec.size(); i += 2)                    // potrebbe non essere abbastanza grande
cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (unsigned i = 0; i &lt; vec.size(); i += 2)               // rischio di &#39;avvolgimento&#39; [wraparound]
cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (auto i = 0; i &lt; vec.size(); i += 2)                   // potrebbe non essere abbastanza grande
cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (vector&lt;int&gt;::size_type i = 0; i &lt; vec.size(); i += 2) // prolisso
cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (auto i = vec.size()-1; i &gt;= 0; i -= 2)                // bug
cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (int i = vec.size()-1; i &gt;= 0; i -= 2)                 // potrebbe non essere abbastanza grande
cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;</code></pre>
<h5 id="esempio-buono-20">Esempio, buono</h5>
<pre><code>vector&lt;int&gt; vec = /*...*/;

for (gsl::index i = 0; i &lt; vec.size(); i += 2)             // ok
cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (gsl::index i = vec.size()-1; i &gt;= 0; i -= 2)          // ok
cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;</code></pre>
<h5 id="note-234">Note</h5>
<p>L’array nativo usa indici signed. I container della libreria standard usano indici unsigned. Pertanto, non è possibile alcuna soluzione perfetta e pienamente compatibile (a meno che e fin quando i container della libreria standard non modificheranno l’odierno uso degli indici signed in futuro). Dati i noti problemi con i mix tra signed e unsigned, è meglio attenersi agli interi (signed) di dimensioni sufficienti, che è garantito da <code>gsl::index</code>.</p>
<h5 id="esempio-243">Esempio</h5>
<pre><code>template&lt;typename T&gt;
struct My_container {
public:
// ...
T&amp; operator[](gsl::index i);    // non unsigned
// ...
};</code></pre>
<h5 id="esempio-244">Esempio</h5>
<pre><code>??? dimostrare una migliore generazione del codice e un potenziale per il rilevamento degli errori ???</code></pre>
<h5 id="alternative-3">Alternative</h5>
<p>Alternative per gli utenti</p>
<ul>
<li>usare gli algoritmi</li>
<li>usare il range-for</li>
<li>usare iteratori/puntatori</li>
</ul>
<h5 id="imposizione-253">Imposizione</h5>
<ul>
<li>Molto complicato, fin quando i container della libreria standard sbagliano.</li>
<li>(Per evitare confusione) Non segnalare un confronto tra signed/unsigned dove uno degli argomenti è <code>sizeof</code> o una chiamata alla <code>.size()</code> di un container e l’altro è <code>ptrdiff_t</code>.</li>
</ul>
<h1 id="per-prestazione"><a name="S-performance"></a>Per: Prestazione</h1>
<p>??? questa sezione dovrebbe stare nella guida principale???</p>
<p>Questa sezione contiene le regole per le persone che necessitano di prestazioni elevate e una bassa latenza. Cioè, queste sono regole che riguardano come utilizzare il minor tempo e il minor numero possibile di risorse per realizzare un’attività in un tempo prevedibilmente breve. Le regole in questa sezione sono più restrittive ed intrusive di quelle necessarie per molte (la maggior parte) delle applicazioni. Non cercare di seguirle ciecamente nel codice generico: raggiungere gli obiettivi di bassa latenza richiede un lavoro extra.</p>
<p>Riepilogo sulle regole per le prestazioni:</p>
<ul>
<li><a href="#Rper-reason">Per.1: Non ottimizzare senza motivo</a></li>
<li><a href="#Rper-Knuth">Per.2: Non ottimizzare prematuramente</a></li>
<li><a href="#Rper-critical">Per.3: Non ottimizzare qualcosa che non è critico per le prestazioni</a></li>
<li><a href="#Rper-simple">Per.4: Non dare per scontato che il codice complicato sia necessariamente più veloce del codice semplice</a></li>
<li><a href="#Rper-low">Per.5: Non dare per scontato che il codice di basso livello sia necessariamente più veloce di quello ad alto livello</a></li>
<li><a href="#Rper-measure">Per.6: Non fare affermazioni sulle prestazioni senza fare misurazioni</a></li>
<li><a href="#Rper-efficiency">Per.7: Progettare per consentire l’ottimizzazione</a></li>
<li><a href="#Rper-type">Per.10: Affidarsi al sistema di tipo statico</a></li>
<li><a href="#Rper-Comp">Per.11: Spostare il calcolo dal run-time alla compilazione</a></li>
<li><a href="#Rper-alias">Per.12: Eliminare gli alias ridondanti</a></li>
<li><a href="#Rper-indirect">Per.13: Eliminare le indirezioni ridondanti</a></li>
<li><a href="#Rper-alloc">Per.14: Minimizzare il numero di allocazioni e de-allocazioni</a></li>
<li><a href="#Rper-alloc0">Per.15: Non allocare su un ramo critico</a></li>
<li><a href="#Rper-compact">Per.16: Usare strutture dati compatte</a></li>
<li><a href="#Rper-struct">Per.17: Dichiarare per primi i membri più usati di una struct time-critical</a></li>
<li><a href="#Rper-space">Per.18: Lo spazio è tempo</a></li>
<li><a href="#Rper-access">Per.19: Accesso prevedibile alla memoria</a></li>
<li><a href="#Rper-context">Per.30: Evitare i [context switch] sui percorsi [path] critici</a></li>
</ul>
<h3 id="per.1-non-ottimizzare-senza-motivo"><a name="Rper-reason"></a>Per.1: Non ottimizzare senza motivo</h3>
<h5 id="motivo-264">Motivo</h5>
<p>Se non è necessaria alcuna ottimizzazione, il principale risultato saranno più errori e costi di manutenzione più elevati.</p>
<h5 id="note-235">Note</h5>
<p>Alcuni ottimizzano per abitudine o perché è divertente.</p>
<p>???</p>
<h3 id="per.2-non-ottimizzare-prematuramente"><a name="Rper-Knuth"></a>Per.2: Non ottimizzare prematuramente</h3>
<h5 id="motivo-265">Motivo</h5>
<p>Il codice ottimizzato in modo elaborato è in genere più grande e più difficile da modificare rispetto a quello non ottimizzato.</p>
<p>???</p>
<h3 id="per.3-non-ottimizzare-qualcosa-che-non-è-critico-per-le-prestazioni"><a name="Rper-critical"></a>Per.3: Non ottimizzare qualcosa che non è critico per le prestazioni</h3>
<h5 id="motivo-266">Motivo</h5>
<p>L’ottimizzazione di una parte non critica per le prestazioni di un programma non ha alcun effetto sulle prestazioni del sistema.</p>
<h5 id="note-236">Note</h5>
<p>Se il proprio programma trascorre la maggior parte del tempo ad aspettare il web o un essere umano, l’ottimizzazione del calcolo in memoria è probabilmente inutile.</p>
<p>In altre parole: Se il programma impiega il 4% del suo tempo di elaborazione facendo il calcolo A e il 40% del tempo per il calcolo B, un miglioramento del 50% su A impatta quanto un miglioramento del 5% su B. (Se non si sa quanto tempo impiega A e B, cfr. <a href="#Rper-reason">Per.1</a> e <a
href="#Rper-Knuth">Per.2</a>.)</p>
<h3 id="per.4-non-dare-per-scontato-che-il-codice-complicato-sia-necessariamente-più-veloce-del-codice-semplice"><a name="Rper-simple"></a>Per.4: Non dare per scontato che il codice complicato sia necessariamente più veloce del codice semplice</h3>
<h5 id="motivo-267">Motivo</h5>
<p>Il codice semplice può essere molto veloce. Gli ottimizzatori a volte fanno meraviglie con un codice semplice</p>
<h5 id="esempio-buono-21">Esempio, buono</h5>
<pre><code>// una chiara espressione dell&#39;intento, una veloce esecuzione

vector&lt;uint8_t&gt; v(100000);

for (auto&amp; c : v)
c = ~c;</code></pre>
<h5 id="esempio-cattivo-110">Esempio, cattivo</h5>
<pre><code>// inteso per essere più veloce, ma spesso è più lento

vector&lt;uint8_t&gt; v(100000);

for (size_t i = 0; i &lt; v.size(); i += sizeof(uint64_t))
{
uint64_t&amp; quad_word = *reinterpret_cast&lt;uint64_t*&gt;(&amp;v[i]);
quad_word = ~quad_word;
}</code></pre>
<h5 id="note-237">Note</h5>
<p>???</p>
<p>???</p>
<h3 id="per.5-non-dare-per-scontato-che-il-codice-di-basso-livello-sia-necessariamente-più-veloce-di-quello-ad-alto-livello"><a name="Rper-low"></a>Per.5: Non dare per scontato che il codice di basso livello sia necessariamente più veloce di quello ad alto livello</h3>
<h5 id="motivo-268">Motivo</h5>
<p>Il codice di basso livello talvolta inibisce le ottimizzazioni. Gli ottimizzatori a volte fanno meraviglie con un codice di alto livello.</p>
<h5 id="note-238">Note</h5>
<p>???</p>
<p>???</p>
<h3 id="per.6-non-fare-affermazioni-sulle-prestazioni-senza-fare-misurazioni"><a name="Rper-measure"></a>Per.6: Non fare affermazioni sulle prestazioni senza fare misurazioni</h3>
<h5 id="motivo-269">Motivo</h5>
<p>Quello delle performance è un campo disseminato di falsi miti e folclore. I moderni hardware ed ottimizzatori sfidano ingenui assunti; anche gli esperti vengono regolarmente sorpresi.</p>
<h5 id="note-239">Note</h5>
<p>Ottenere buone misurazioni delle prestazioni può risultare difficile e richiedere strumenti specializzati.</p>
<h5 id="note-240">Note</h5>
<p>Alcuni semplici micro-benchmark che usano il <code>time</code> di Unix o il <code>&lt;chrono&gt;</code> della libreria standard possono aiutare a dissipare i miti più ovvi. Se non si riesce a misurare accuratamente tutto il sistema, si provi almeno a misurare alcune delle operazioni e algoritmi chiave. Un profiler può aiutare a capire quali parti del sistema sono critiche per le prestazioni. Spesso, ci si sorprenderà.</p>
<p>???</p>
<h3 id="per.7-progettare-per-consentire-lottimizzazione"><a name="Rper-efficiency"></a>Per.7: Progettare per consentire l’ottimizzazione</h3>
<h5 id="motivo-270">Motivo</h5>
<p>Perché spesso si deve ottimizzare il progetto iniziale. Perché un progetto che ignora la possibilità di un successivo miglioramento è difficile da modificare.</p>
<h5 id="esempio-245">Esempio</h5>
<p>Dal C (e dal C++) standard:</p>
<pre><code>void qsort (void* base, size_t num, size_t size, int (*compar)(const void*, const void*));</code></pre>
<p>Quando c’è stato bisogno di ordinare la memoria? In realtà, si ordinano sequenze di elementi, in genere memorizzati in contenitori. Una chiamata a <code>qsort</code> elimina molte informazioni utili (p.es., il tipo degli elementi), costringe l’utente a ripetere le informazioni già note (p.es., la dimensione degli elementi), ed obbliga a scrivere altro codice (p.es., una funzione per confrontare i <code>double</code>). Ciò implica un lavoro aggiuntivo per il programmatore, è soggetto a errori e priva il compilatore delle informazioni necessarie per l’ottimizzazione.</p>
<pre><code>double data[100];
// ... riempie ...

// 100 blocchi di memoria di sizeof(double) cominciando
// all&#39;indirizzo data usando l&#39;ordine definito da compare_doubles
qsort(data, 100, sizeof(double), compare_doubles);</code></pre>
<p>Dal punto di vista della progettazione dell’interfaccia c’è che<code>qsort</code> getta via informazioni utili.</p>
<p>Si può fare di meglio (nel C++98)</p>
<pre><code>template&lt;typename Iter&gt;
void sort(Iter b, Iter e);  // sort [b:e)

sort(data, data + 100);</code></pre>
<p>Qui, si usano le conoscenze del compilatore sulla dimensione dell’array, il tipo degli elementi e su come confrontare i <code>double</code>.</p>
<p>Col C++11 più i <a href="#SS-concepts">concetti</a>, si può fare ancora meglio</p>
<pre><code>// Sortable indica che c deve essere una
// sequenza ad accesso random di elementi confrontabili con &lt;
void sort(Sortable&amp; c);

sort(c);</code></pre>
<p>La chiave è passare informazioni sufficienti per scegliere una buona implementazione. In questo, le interfacce <code>sort</code> mostrate qui un ulteriore punto debole: Si basano implicitamente sul tipo di elemento che abbia definito il “minore di” (<code>&lt;</code>). Per completare l’interfaccia, è necessaria una seconda versione che accetti un criterio di confronto:</p>
<pre><code>// confronta gli elementi di c usando p
void sort(Sortable&amp; c, Predicate&lt;Value_type&lt;Sortable&gt;&gt; p);</code></pre>
<p>Le specifiche della libreria standard per <code>sort</code> offrono queste due versioni, ma la semantica è espressa in inglese anziché nel codice utilizzando i concetti.</p>
<h5 id="note-241">Note</h5>
<p>Si dice che l’ottimizzazione prematura sia <a href="#Rper-Knuth">la fonte di tutti i mali</a>, ma questo non è un motivo per disdegnare le prestazioni. Non è mai prematuro considerare ciò che rende un progetto migliorabile e migliorare le prestazioni è un miglioramento comunemente desiderato. Si cerchi di creare un insieme di abitudini che per default si traduca in un codice efficiente, gestibile e ottimizzabile. In particolare, quando si scrive una funzione che non sia un dettaglio di implementazione una tantum, considerare</p>
<ul>
<li>Passaggio delle informazioni: Preferire delle semplici <a href="#S-interfaces">interfacce</a> che trasportino abbastanza informazioni per un successivo miglioramento dell’implementazione. Si noti che le informazioni fluiscono dentro e fuori da un’implementazione attraverso le interfacce che si forniscono.</li>
<li>Dati compatti: Per default, <a href="#Rper-compact">usare dati compatti</a>, come in <code>std::vector</code> e <a href="#Rper-access">accedervi in modo sistematico</a>. Se si ritiene di aver bisogno di una struttura collegata, provare a creare l’interfaccia in modo che questa struttura non venga vista dagli utenti.</li>
<li>Argomenti passati e restituiti dalla funzione: Distinguere tra dati mutabili e non-mutabili. Non imporre l’onere di una gestione delle risorse ai propri utenti. Non imporre false indirezione a run-time ai propri clienti. Usare <a href="#Rf-conventional">modi convenzionali</a> per passare le informazioni attraverso l’interfaccia; modi non convenzionali e/o modi “ottimizzati” per il passaggio dei dati possono seriamente complicare le successive ottimizzazioni.</li>
<li>Astrazione: Non generalizzare eccessivamente; un progetto che cerca di soddisfare ogni possibile uso (ed abuso) e che rifiuta ogni decisione progettuale successiva (utilizzando indirezioni alla compilazione o a run-time) è solitamente un pasticcio complicato, rigonfio e difficile da capire. Generalizzare da esempi concreti, preservando le prestazioni. Non generalizzare basandosi su mere speculazioni sulle future necessità. L’ideale è una generalizzazione “zero-overhead”.</li>
<li>Librerie: Usare librerie con delle buone interfacce. Se non è disponibile una libreria se ne crei una imitando lo stile dell’interfaccia di una buona libreria. La <a href="#S-stdlib">libreria standard</a> è il primo buon posto per ispirarsi.</li>
<li>Isolamento: Isolare il proprio codice da quello disordinato e/o vecchio stile fornendo un’interfaccia adatta. Questo è talvolta detto “fornire un wrapper” per il codice utile/necessario ma disordinato. Non lasciare che i cattivi progetti “si insinuino” nel proprio codice.</li>
</ul>
<h5 id="esempio-246">Esempio</h5>
<p>Si consideri:</p>
<pre><code>template &lt;class ForwardIterator, class T&gt;
bool binary_search(ForwardIterator first, ForwardIterator last, const T&amp; val);</code></pre>
<p><code>binary_search(begin(c), end(c), 7)</code> dirà se <code>7</code> è in <code>c</code> oppure no. Tuttavia, non dirà dove si trova sia quel <code>7</code> e se ci sono più di un <code>7</code>.</p>
<p>A volte, è sufficiente restituire la minima quantità di informazioni (qui, <code>true</code> o <code>false</code>), ma una buona interfaccia restituisce le informazioni necessarie al chiamante. Quindi, la libreria standard offre anche</p>
<pre><code>template &lt;class ForwardIterator, class T&gt;
ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T&amp; val);</code></pre>
<p><code>lower_bound</code> restituisce un iteratore alla prima corrispondenza se c’è, altrimenti al primo elemento maggiore di <code>val</code>, o <code>last</code> se nessun elemento è stato trovato.</p>
<p>Tuttavia, <code>lower_bound</code> non restituisce ancora informazioni sufficienti per tutti gli usi, quindi la libreria standard propone anche</p>
<pre><code>template &lt;class ForwardIterator, class T&gt;
pair&lt;ForwardIterator, ForwardIterator&gt;
equal_range(ForwardIterator first, ForwardIterator last, const T&amp; val);</code></pre>
<p><code>equal_range</code> restituisce una <code>pair</code> [coppia] di iteratori il primo e uno oltre l’ultima corrispondenza.</p>
<pre><code>auto r = equal_range(begin(c), end(c), 7);
for (auto p = r.first; p != r.second; ++p)
cout &lt;&lt; *p &lt;&lt; &#39;\n&#39;;</code></pre>
<p>Ovviamente, queste tre interfacce sono implementate dallo stesso codice di base. Sono semplicemente tre modi per presentare agli utenti l’algoritmo di ricerca binaria di base, che vanno da quelle che restituiscono le informazioni più semplici (“semplifica le cose semplici!”) a quelle più complete, ma non sempre necessarie, (“non nascondere informazioni utili”). Naturalmente, la creazione di un tale set di interfacce richiede esperienza e conoscenza del dominio.</p>
<h5 id="note-242">Note</h5>
<p>Non creare banalmente l’interfaccia in modo che corrisponda alla prima implementazione e al primo caso d’uso a cui pensa. Una volta completata l’implementazione iniziale, la si esamini; una volta distribuita, sarà difficile porre rimedio agli errori.</p>
<h5 id="note-243">Note</h5>
<p>Una necessità di efficienza non implica una necessità di <a href="#Rper-low">codice a basso-livello</a>. Un codice di alto livello non implica lentezza e prolissità.</p>
<h5 id="note-244">Note</h5>
<p>Le cose hanno dei costi. Non si dev’essere paranoici sui costi (i moderni computer sono veramente molto veloci), ma si deve avere un’idea approssimativa dell’ordine di grandezza del costo di quello che si usa. Per esempio, avere idea del costo di un accesso alla memoria, una chiamata a una funzione, il confronto tra stringhe, una chiamata di sistema, una accesso al disco, e un messaggio tramite la rete.</p>
<h5 id="note-245">Note</h5>
<p>Se si riesce a pensare a una sola implementazione, probabilmente non si ha qualcosa per cui poter escogitare un’interfaccia stabile. Forse, è solo un dettaglio implementativo - non tutte le parti del codice hanno bisogno di un’interfaccia stabile - ma si faccia una pausa e si prenda in considerazione. Una domanda che può essere utile è “quale interfaccia sarebbe necessaria se questa operazione dovesse essere implementata usando più thread? essere vettorizzata?”</p>
<h5 id="note-246">Note</h5>
<p>Questa regola non contraddice la regola <a href="#Rper-Knuth">Non ottimizzare prematuramente</a>. Essa la completa e incoraggia gli sviluppatori a permettere una successiva - appropriata e non-prematura - ottimizzazione, se e dove necessario.</p>
<h5 id="imposizione-254">Imposizione</h5>
<p>Difficile. Forse cercando gli argomenti della funzione <code>void*</code> si troveranno esempi di interfacce che ostacolano la successiva ottimizzazione.</p>
<h3 id="per.10-affidarsi-al-sistema-di-tipo-statico"><a name="Rper-type"></a>Per.10: Affidarsi al sistema di tipo statico</h3>
<h5 id="motivo-271">Motivo</h5>
<p>Le violazioni dei tipi, i tipi deboli (p.es. i <code>void*</code>), e il codice a basso-livello (p.es., manipolazione di sequenze come singoli byte) rendono il lavoro dell’ottimizzatore molto più difficile. Il cdice semplice spesso si ottimizza meglio del codice complicato fatto a mano.</p>
<p>???</p>
<h3 id="per.11-spostare-il-calcolo-dal-run-time-alla-compilazione"><a name="Rper-Comp"></a>Per.11: Spostare il calcolo dal run-time alla compilazione</h3>
<h5 id="motivo-272">Motivo</h5>
<p>Per ridurre la dimensione del codice e il tempo di esecuzione. Per evitare i conflitti dei dati [data race] utilizzando le costanti. Per rilevare gli errori in fase di compilazione (eliminando così la necessità di un codice per la gestione degli errori).</p>
<h5 id="esempio-247">Esempio</h5>
<pre><code>double square(double d) { return d*d; }
static double s2 = square(2);    // vecchio stile: inizializzazione dinamica

constexpr double ntimes(double d, int n)   // si suppone 0 &lt;= n
{
double m = 1;
while (n--) m *= d;
return m;
}
constexpr double s3 {ntimes(2, 3)};  // stile moderno: inizializzazione durante la compilazione</code></pre>
<p>Il codice come l’inizializzazione di <code>s2</code> non è raro, specialmente per un’inizializzazione che sia un po’ più complicata di <code>square()</code>. Tuttavia, rispetto all’inizializzazione di <code>s3</code> ci sono due problemi:</p>
<ul>
<li>si subisce l’overhead di una chiamata durante l’esecuzione</li>
<li>un altro thread potrebbe accedere a <code>s2</code> prima che avvenga l’inizializzazione.</li>
</ul>
<p>Note: non si può avere un conflitto su una costante.</p>
<h5 id="esempio-248">Esempio</h5>
<p>Si prenda in considerazione una popolare tecnica per fornire un handle per memorizzare piccoli oggetti nell’handle stesso e quelli più grandi sull’heap.</p>
<pre><code>constexpr int on_stack_max = 20;

template&lt;typename T&gt;
struct Scoped {     // memorizza un T in Scoped
// ...
T obj;
};

template&lt;typename T&gt;
struct On_heap {    // memorizza un T sull&#39;heap [free store]
// ...
T* objp;
};

template&lt;typename T&gt;
using Handle = typename std::conditional&lt;(sizeof(T) &lt;= on_stack_max),
Scoped&lt;T&gt;,      // prima alternativa
On_heap&lt;T&gt;      // seconda alternativa
&gt;::type;

void f()
{
Handle&lt;double&gt; v1;                   // il double va sullo stack
Handle&lt;std::array&lt;double, 200&gt;&gt; v2;  // l&#39;array va sul free store
// ...
}</code></pre>
<p>Si supponga che <code>Scoped</code> e <code>On_heap</code> abbiano delle interfaccia utente compatibili. Qui si calca il tipo ottimale da utilizzare in fase di compilazione. Esistono tecniche simili per selezionare la funzione ottimale da chiamare.</p>
<h5 id="note-247">Note</h5>
<p>L’ideale {non} è il tentare di eseguire tutto durante la compilazione. Ovviamente, la maggior parte dei calcoli dipende dagli input, quindi non si possono spostare al tempo della compilazione, ma al di là di questo vincolo logico c’è il fatto che un calcolo complesso in fase di compilazione può aumentare seriamente i tempi di compilazione e complicare il debug. È anche possibile che si rallenti il codice mediante il calcolo in fase di compilazione. Questo è certamente raro, ma suddividendo un calcolo generico in diversi sotto-calcoli ottimali è possibile rendere meno efficace la cache delle istruzioni.</p>
<h5 id="imposizione-255">Imposizione</h5>
<ul>
<li>Cercare le funzioni più semplici che potrebbero essere constexpr (ma non lo sono).</li>
<li>Cercare le funzioni chiamate con tutti gli argomenti con espressioni costanti.</li>
<li>Cercare le macro che potrebbero essere constexpr.</li>
</ul>
<h3 id="per.12-eliminare-gli-alias-ridondanti"><a name="Rper-alias"></a>Per.12: Eliminare gli alias ridondanti</h3>
<p>???</p>
<h3 id="per.13-eliminare-le-indirezioni-ridondanti"><a name="Rper-indirect"></a>Per.13: Eliminare le indirezioni ridondanti</h3>
<p>???</p>
<h3 id="per.14-minimizzare-il-numero-di-allocazioni-e-de-allocazioni"><a name="Rper-alloc"></a>Per.14: Minimizzare il numero di allocazioni e de-allocazioni</h3>
<p>???</p>
<h3 id="per.15-non-allocare-su-un-ramo-critico"><a name="Rper-alloc0"></a>Per.15: Non allocare su un ramo critico</h3>
<p>???</p>
<h3 id="per.16-usare-strutture-dati-compatte"><a name="Rper-compact"></a>Per.16: Usare strutture dati compatte</h3>
<h5 id="motivo-273">Motivo</h5>
<p>Le prestazioni sono solitamente dominate dai tempi di accesso alla memoria.</p>
<p>???</p>
<h3 id="per.17-dichiarare-per-primi-i-membri-più-usati-di-una-struct-time-critical"><a name="Rper-struct"></a>Per.17: Dichiarare per primi i membri più usati di una struct time-critical</h3>
<p>???</p>
<h3 id="per.18-lo-spazio-è-tempo"><a name="Rper-space"></a>Per.18: Lo spazio è tempo</h3>
<h5 id="motivo-274">Motivo</h5>
<p>Le prestazioni sono solitamente dominate dai tempi di accesso alla memoria.</p>
<p>???</p>
<h3 id="per.19-accesso-prevedibile-alla-memoria"><a name="Rper-access"></a>Per.19: Accesso prevedibile alla memoria</h3>
<h5 id="motivo-275">Motivo</h5>
<p>Le prestazioni sono molto sensibili alle prestazioni della cache e gli algoritmi della cache favoriscono un accesso semplice (generalmente lineare) ai dati adiacenti.</p>
<h5 id="esempio-249">Esempio</h5>
<pre><code>int matrix[rows][cols];

// non buono
for (int c = 0; c &lt; cols; ++c)
for (int r = 0; r &lt; rows; ++r)
sum += matrix[r][c];

// buono
for (int r = 0; r &lt; rows; ++r)
for (int c = 0; c &lt; cols; ++c)
sum += matrix[r][c];</code></pre>
<h3 id="per.30-evitare-i-context-switch-sui-percorsi-path-critici"><a name="Rper-context"></a>Per.30: Evitare i [context switch] sui percorsi [path] critici</h3>
<p>???</p>
<h1 id="cp-concorrenza-e-parallelismo"><a name="S-concurrency"></a>CP: Concorrenza e parallelismo</h1>
<p>Spesso si vuole che i computer facciano molte cose contemporaneamente (o almeno che sembrino eseguirle nello stesso tempo). I motivi per volerlo sono vari (p.es., aspettare molti eventi con un singolo processore, elaborare molti flussi di dati simultaneamente o utilizzare tante infrastrutture hardware) e questo lo fanno delle strutture basilari per espletare la concorrenza e il parallelismo. Qui, si parla di alcuni principi e regole per usare le strutture del C++ standard ISO C++ per espletare la concorrenza e il parallelismo.</p>
<p>I thread sono le fondamenta a livello macchina per la programmazione concorrente e parallela. I thread consentono l’esecuzione di più sezioni di un programma indipendentemente, condividendo la stessa memoria. La programmazione concorrente è complicata, perché proteggere i dati condivisi tra i thread è più facile a dirsi che a farsi. Eseguire un codice single-threaded esistente concorrentemente può risultare banale come aggiungere strategicamente <code>std::async</code> o <code>std::thread</code>, o può essere necessario riscrivere tutto, a seconda che il codice originale sia stato scritto in modo thread-friendly.</p>
<p>Le regole della concorrenza/parallelismo in questo documento sono progettate tenendo tre obiettivi in mente:</p>
<ul>
<li>Aiutare a scrivere codice utilizzabile in un ambiente con thread</li>
<li>Illustrare un modo pulito, sicuro per utilizzare le primitive del threading fornite dalla libreria standard</li>
<li>Offrire indicazioni su cosa fare quando la concorrenza e il parallelismo non raggiungono le prestazioni necessarie</li>
</ul>
<p>È anche importante notare che la concorrenza in C++ è una storia incompiuta. Il C++11 ha introdotto molte primitive centrali per la concorrenza, il C++14 e il C++17 le hanno migliorate, e c’è molto interesse nel semplificare la scrittura di programmi concorrenti in C++. Si prevede che alcune di queste linee-guida relative alla libreria cambieranno significativamente nel tempo.</p>
<p>Questa sezione richiede molto lavoro (ovviamente). Si noti che si inizia con le regole riguardanti i non esperti. I veri esperti devono aspettare un po’; i contributi sono ben accetti, ma per favore, si pensi alla maggior parte dei programmatori che stanno lottando per far funzionare correttamente e performanti i loro programmi concorrenti.</p>
<p>Riepilogo delle regole sul parallelismo e la concorrenza:</p>
<ul>
<li><a href="#Rconc-multi">CP.1: Si assuma che il proprio codice girerà come parte di un programma multi-threaded</a></li>
<li><a href="#Rconc-races">CP.2: Evitare i conflitti dei dati [data race]</a></li>
<li><a href="#Rconc-data">CP.3: Minimizzare la condivisione esplicita dei dati scrivibili</a></li>
<li><a href="#Rconc-task">CP.4: Pensare in termini di task, anziché di thread</a></li>
<li><a href="#Rconc-volatile">CP.8: Non cercare di usare <code>volatile</code> per la sincronizzazione</a></li>
<li><a href="#Rconc-tools">CP.9: Quando possibile utilizzare i tool per validare il proprio codice concorrente</a></li>
</ul>
<p><strong>Si veda anche</strong>:</p>
<ul>
<li><a href="#SScp-con">CP.con: Concorrenza</a></li>
<li><a href="#SScp-par">CP.par: Parallelismo</a></li>
<li><a href="#SScp-mess">CP.mess: Passaggio dei messaggi</a></li>
<li><a href="#SScp-vec">CP.vec: Vettorizzazione</a></li>
<li><a href="#SScp-free">CP.free: Programmazione senza lock</a></li>
<li><a href="#SScp-etc">CP.etc: Ecc. regole della concorrenza</a></li>
</ul>
<h3 id="cp.1-si-assuma-che-il-proprio-codice-girerà-come-parte-di-un-programma-multi-threaded"><a name="Rconc-multi"></a>CP.1: Si assuma che il proprio codice girerà come parte di un programma multi-threaded</h3>
<h5 id="motivo-276">Motivo</h5>
<p>È difficile essere certi che la concorrenza non sia utilizzata ora e che non verrà utilizzata in futuro. Il codice si riutilizza. Le librerie che non utilizzano i thread possono essere utilizzate da un’altra parte di un programma che utilizza i thread. Si noti che questa regola si applica subito al codice della libreria e meno urgentemente alle applicazioni singole. Tuttavia, nel tempo, pezzi di codice possono apparire in luoghi inaspettati.</p>
<h5 id="esempio-cattivo-111">Esempio, cattivo</h5>
<pre><code>double cached_computation(double x)
{
// bad: questi due static provocano conflitti [data race] se usati in multi-thread
static double cached_x = 0.0;
static double cached_result = COMPUTATION_OF_ZERO;
double result;

if (cached_x == x)
return cached_result;
result = computation(x);
cached_x = x;
cached_result = result;
return result;
}</code></pre>
<p>Sebbene <code>cached_computation</code> funziona perfettamente in un ambiente single-threaded, in uno multi-threaded le due variabili <code>static</code> provocano conflitti e quindi un comportamento indefinito.</p>
<p>Ci sono diversi modi per rendere questo esempio sicuro per un ambiente multi-threaded:</p>
<ul>
<li>Delegare i problemi sulla concorrenza al chiamante.</li>
<li>Segnalare le variabili <code>static</code> come <code>thread_local</code> (che potrebbe rendere meno efficace l’uso della cache).</li>
<li>Implementare il controllo della concorrenza, per esempio, proteggendo le due variabili <code>static</code> con un lock <code>static</code> (che potrebbe ridurre le prestazioni).</li>
<li>Si deve chiedere al chiamante di fornire la memoria da usare per la cache, delegando in tal modo al chiamante sia l’allocazione della memoria che i problemi sulla concorrenza.</li>
<li>Rifiutare di compilare e/o eseguire in un ambiente multi-thread.</li>
<li>Fornire due implementazioni, una da usarsi negli ambienti single-thread e l’altra in quelli multi-threaded.</li>
</ul>
<h5 id="eccezione-46">Eccezione</h5>
<p>Il codice che non viene mai eseguito in un ambiente multi-thread.</p>
<p>Fare attenzione: ci sono molti esempi in cui il codice “riconosciuto” che non girava in un programma multi-thread è stato inserito in un programma multi-thread, spesso dopo anni. Solitamente, questi programmi portano ad un penoso lavoro per rimuovere i conflitti. Pertanto, il codice che non dovrebbe mai essere eseguito in un ambiente multi-thread dovrebbe essere chiaramente etichettato come tale e idealmente dotato di meccanismi, durante la compilazione o a run-time, per rilevare tempestivamente i bug di utilizzo.</p>
<h3 id="cp.2-evitare-i-conflitti-dei-dati-data-race"><a name="Rconc-races"></a>CP.2: Evitare i conflitti dei dati [data race]</h3>
<h5 id="motivo-277">Motivo</h5>
<p>Se non lo si fa, niente garantisce il funzionamento e persistono dei subdoli errori.</p>
<h5 id="note-248">Note</h5>
<p>In breve, se due thread possono accedere contemporaneamente allo stesso oggetto (senza sincronizzazione), e almeno uno scrive (eseguendo un’operazione non-<code>const</code>), si ha un conflitto [data race]. Per ulteriori informazioni su come utilizzare bene la sincronizzazione per eliminare i conflitti, si consulti un buon libro sulla concorrenza.</p>
<h5 id="esempio-cattivo-112">Esempio, cattivo</h5>
<p>Esistono molti esempi di conflitti, alcuni dei quali girano in software di produzione in questo preciso momento. Un semplicissimo esempio:</p>
<pre><code>int get_id() {
static int id = 1;
return id++;
}</code></pre>
<p>L’incremento qui è un esempio di conflitto [data race]. Questo può andar male in molti modi, tra cui:</p>
<ul>
<li>Il thread A carica il valore di <code>id</code>, Il contesto del sistema operativo disattiva A per un po’, curante il quale altri thread creano centinaia di ID. Quando torna in esecuzione il thread A, <code>id</code> viene riscritto col valore di <code>id</code> letto da A più uno.</li>
<li>I thread A e B caricano <code>id</code> e lo incrementano simultaneamente. Entrambi ottengono lo stesso ID.</li>
</ul>
<p>Le variabili static locali sono una comune fonte di conflitti [data race].</p>
<h5 id="esempio-cattivo-113">Esempio, cattivo:</h5>
<pre><code>void f(fstream&amp;  fs, regex pattern)
{
array&lt;double, max&gt; buf;
int sz = read_vec(fs, buf, max);            // legge da fs in buf
gsl::span&lt;double&gt; s {buf};
// ...
auto h1 = async([&amp;]{ sort(std::execution::par, s); });     // produce [spawn] un task per ordinare [sort]
// ...
auto h2 = async([&amp;]{ return find_all(buf, sz, pattern); });   // produce [spawn] un task per trovare le corrispondenze
// ...
}</code></pre>
<p>Qui, si ha un (brutto) conflitto tra gli elementi di <code>buf</code> (<code>sort</code> leggerà e scriverà). Tutti i conflitti [data race] sono brutti. Qui, si è riusciti ad avere un conflitto tra i dati sullo stack. Non tutti i conflitti sono facili da evidenziare come questo.</p>
<h5 id="esempio-cattivo-114">Esempio, cattivo:</h5>
<pre><code>// codice non controllato da un lock

unsigned val;

if (val &lt; 5) {
// ... qui altri thread possono modificare val ...
switch (val) {
case 0: // ...
case 1: // ...
case 2: // ...
case 3: // ...
case 4: // ...
}
}</code></pre>
<p>Ora, un compilatore che non sa che <code>val</code> può cambiare, molto probabilmente implementerà quello <code>switch</code> usando una tabella dei salti con cinque voci. Quindi, un <code>val</code> al di fuori dell’intervallo <code>[0..4]</code> provocherà un salto ad un indirizzo che può puntare ovunque nel programma e l’esecuzione proseguirà da lì. Davvero, “tutto può accadere” se si ha un conflitto. In realtà, può capitare di peggio: guardando il codice generato si potrebbe essere in grado di determinare dove salterà per un dato valore; questo può essere un rischio per la sicurezza.</p>
<h5 id="imposizione-256">Imposizione</h5>
<p>Se possibile, fare almeno qualcosa. Ci sono tool commerciali ed open-source che cercano di risolvere questo problema, ma si tenga presente che le soluzioni hanno un costo e dei punti ignoti. I tool statici spesso hanno molti falsi positivi mentre i tool a run-time tools spesso hanno un costo elevato. Si spera in strumenti migliori. Utilizzando più tool si possono rilevare più problemi che con uno solo.</p>
<p>Ci sono altri modi per attenuare la possibilità di conflitti:</p>
<ul>
<li>Evitare i dati globali</li>
<li>Evitare le variabili <code>static</code></li>
<li>Usare più tipi di valori sullo stack (e non passare troppi puntatori in giro)</li>
<li>Usare di più dati immutabili (letterali, <code>constexpr</code>, e <code>const</code>)</li>
</ul>
<h3 id="cp.3-minimizzare-la-condivisione-esplicita-dei-dati-scrivibili"><a name="Rconc-data"></a>CP.3: Minimizzare la condivisione esplicita dei dati scrivibili</h3>
<h5 id="motivo-278">Motivo</h5>
<p>Se non si condividono dati scrivibili, non si hanno conflitti. Meno condivisione si fa, minori possibilità si hanno di dimenticare di sincronizzare l’accesso (ottenendo conflitti). Meno condivisione si fa, minori possibilità si hanno d aspettare per un lock (migliorando le prestazioni).</p>
<h5 id="esempio-250">Esempio</h5>
<pre><code>bool validate(const vector&lt;Reading&gt;&amp;);
Graph&lt;Temp_node&gt; temperature_gradiants(const vector&lt;Reading&gt;&amp;);
Image altitude_map(const vector&lt;Reading&gt;&amp;);
// ...

void process_readings(const vector&lt;Reading&gt;&amp; surface_readings)
{
auto h1 = async([&amp;] { if (!validate(surface_readings)) throw Invalid_data{}; });
auto h2 = async([&amp;] { return temperature_gradiants(surface_readings); });
auto h3 = async([&amp;] { return altitude_map(surface_readings); });
// ...
h1.get();
auto v2 = h2.get();
auto v3 = h3.get();
// ...
}</code></pre>
<p>Senza quelle <code>const</code>, si dovrebbe rivedere ogni funzione richiamata modo asincrono per un potenziale conflitto su <code>surface_readings</code>. Rendere <code>surface_readings</code> per essere <code>const</code> (rispetto a questa funzione) consente il ragionamento utilizzando solo il corpo della funzione.</p>
<h5 id="note-249">Note</h5>
<p>I dati immutabii si possono condividere i modo sicuro ed efficientemente. Non è necessario alcun lock: Non si può avere un conflitto su una costante. Si veda anche <a href="#SScp-mess">CP.mess: Passaggio dei Parametri</a> e <a href="#Rconc-data-by-value">CP.31: preferire il passaggio per valore</a>.</p>
<h5 id="imposizione-257">Imposizione</h5>
<p>???</p>
<h3 id="cp.4-pensare-in-termini-di-task-anziché-di-thread"><a name="Rconc-task"></a>CP.4: Pensare in termini di task, anziché di thread</h3>
<h5 id="motivo-279">Motivo</h5>
<p>Un <code>thread</code> è l’implementazione di un concetto, un modo di pensare alla macchina. Un task è una nozione di applicazione, qualcosa che ci piacerebbe fare, preferibilmente contemporaneamente ad altre attività. I concetti dell’applicazione sono più facili da immaginare.</p>
<h5 id="esempio-251">Esempio</h5>
<pre><code>void some_fun() {
std::string msg, msg2;
std::thread publisher([&amp;] { msg = &quot;Hello&quot;; });       // bad: meno espressivo
//      e più soggetto a errori
auto pubtask = std::async([&amp;] { msg2 = &quot;Hello&quot;; });  // OK
// ...
publisher.join();
}</code></pre>
<h5 id="note-250">Note</h5>
<p>Ad eccezione di <code>async()</code>, le funzioni della libreria standard sono low-level, machine-oriented, a livello di thread-e-lock. Questa è un fondamento necessario, ma si deve cercare di aumentare il livello di astrazione: per produttività, per affidabilità e per prestazione. Questo è un potente argomento per usare librerie a più alto livello, più orientate alle applicazioni (possibilmente, basate sulle funzioni della libreria standard).</p>
<h5 id="imposizione-258">Imposizione</h5>
<p>???</p>
<h3 id="cp.8-non-cercare-di-usare-volatile-per-la-sincronizzazione"><a name="Rconc-volatile"></a>CP.8: Non cercare di usare <code>volatile</code> per la sincronizzazione</h3>
<h5 id="motivo-280">Motivo</h5>
<p>In C++, diversamente da altri linguaggi, <code>volatile</code> non fornisce l’atomicità, non sincronizza tra i thread, e non impedisce il riordino delle istruzioni (né il compilatore né l’hardware). Semplicemente non ha nulla a che fare con la concorrenza.</p>
<h5 id="esempio-cattivo-115">Esempio, cattivo:</h5>
<pre><code>int free_slots = max_slots; // attuale fonte di memoria per gli oggetti

Pool* use()
{
if (int n = free_slots--) return &amp;pool[n];
}</code></pre>
<p>Qui c’è un problema: Questo è un codice perfettamente valido in un programma a thread singolo, ma due thread che lo eseguono e c’è una condizione di conflitto su <code>free_slots</code> in cui due i thread possono ottenere lo stesso valore [] e <code>free_slots</code>. Questo è (ovviamente) un brutto conflitto, è gli esperti di altri linguaggi potrebbero cercare di risolvere in questo modo:</p>
<pre><code>volatile int free_slots = max_slots; // attuale fonte di memoria per gli oggetti

Pool* use()
{
if (int n = free_slots--) return &amp;pool[n];
}</code></pre>
<p>Questo non ha alcun effetto sulla sincronizzazione: Il conflitto resta!</p>
<p>Il meccanismo del C++ per questo è scrivere <code>atomic</code>:</p>
<pre><code>atomic&lt;int&gt; free_slots = max_slots; // attuale fonte di memoria per gli oggetti

Pool* use()
{
if (int n = free_slots--) return &amp;pool[n];
}</code></pre>
<p>Ora l’operazione <code>--</code> è atomica, anziché una sequenza leggi-incrementa-scrivi dove un altro thread potrebbe inserirsi tra le operazioni.</p>
<h5 id="alternativa-10">Alternativa</h5>
<p>Usare i tipi <code>atomic</code> dove si userebbe <code>volatile</code> in un altro linguaggio. Usare un <code>mutex</code> per esempi più complicati.</p>
<h5 id="si-veda-anche-3">Si veda anche</h5>
<p><a href="#Rconc-volatile2">(rari) usi appropriati di <code>volatile</code></a></p>
<h3 id="cp.9-quando-possibile-utilizzare-i-tool-per-validare-il-proprio-codice-concorrente"><a name="Rconc-tools"></a>CP.9: Quando possibile utilizzare i tool per validare il proprio codice concorrente</h3>
<p>L’esperienza dimostra che il codice concorrente è estremamente difficile da ottenere correttamente e che il controllo in fase di compilazione, quelli a run-time, ed i test sono meno efficaci nel trovare gli errori sulla concorrenza rispetto a quelli che cercano errori nel codice sequenziale. Subdoli errori di concorrenza possono avere effetti drammaticamente negativi, tra cui la corruzione della memoria e i deadlock.</p>
<h5 id="esempio-252">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="note-251">Note</h5>
<p>La sicurezza del thread è impegnativa, spesso ha la meglio sui programmatori esperti: gli strumenti costituiscono una importante strategia per mitigare tali rischi. Ci sono molti tool “in giro”, sia commerciali che open-source, sia tool per la ricerca che per la produzione. Sfortunatamente le esigenze e i vincoli delle persone differiscono in modo così drammatico che non si possono formulare raccomandazioni specifiche, ma si può menzionare:</p>
<ul>
<li><p>Strumenti di imposizione [enforcement] statica: sia <a href="http://clang.llvm.org/docs/ThreadSafetyAnalysis.html">clang</a> e qualche più vecchia versione di <a href="https://gcc.gnu.org/wiki/ThreadSafetyAnnotation">GCC</a> hanno qualche supporto per l’annotazione statica delle proprietà di sicurezza del thread. L’uso coerente di questa tecnica trasforma molte classi di errori sulla sicurezza dei thread in errori di compilazione. Le annotazioni sono generalmente locali (rendendo una particolare variabile membro come protetta da un particolare mutex), e sono solitamente facili da imparare. Tuttavia, come con molti tool statici, possono spesso presentare falsi negativi; casi che avrebbero dovuto essere rilevati ma vengono autorizzati.</p></li>
<li><p>strumenti di imposizione [enforcement] dinamica: Il <a href="http://clang.llvm.org/docs/ThreadSanitizer.html">Thread Sanitizer</a> di Clang (aka TSAN) è un potente esempio di strumenti dinamici: esso cambia la compilazione e l’esecuzione del proprio programma aggiungendo un conteggio sull’accesso della memoria, identificando assolutamente i conflitti in una data esecuzione del codice binario. Il suo costo è sia in memoria (5-10x nella maggior parte dei casi) che in rallentamento della CPU (2-20x). Gli strumenti dinamici come questi sono migliori quando vengono applicati ai test di integrazione, [canary pushes], o unit di test che operano su thread multipli. Il carico di lavoro è importante: Quando TSAN identifica un problema, si tratta sempre di una vero e proprio confitto [data race], ma può identificare solo i conflitti visti in una data esecuzione.</p></li>
</ul>
<h5 id="imposizione-259">Imposizione</h5>
<p>Spetta al costruttore dell’applicazione decidere quali tool di supporto sono utili per una particolare applicazione.</p>
<h2 id="cp.con-concorrenza"><a name="SScp-con"></a>CP.con: Concorrenza</h2>
<p>Questa sezione si concentra sugli usi relativamente ad-hoc dei thread multipli che comunicano tramite dati condivisi.</p>
<ul>
<li>Per gli algoritmi paralleli, si veda <a href="#SScp-par">parallelismo</a></li>
<li>Per la comunicazione inter-task senza una esplicita condivisione, si veda <a href="#SScp-mess">messaging</a></li>
<li>Per il codice vettoriale parallelo, si veda <a href="#SScp-vec">vettorizzazione</a></li>
<li>Per la programmazione lock-free, si veda <a href="#SScp-free">lock free</a></li>
</ul>
<p>Riepilogo delle regole sulla concorrenza:</p>
<ul>
<li><a href="#Rconc-raii">CP.20: Usare il RAII, mai il semplice <code>lock()</code>/<code>unlock()</code></a></li>
<li><a href="#Rconc-lock">CP.21: Usare <code>std::lock()</code> o <code>std::scoped_lock</code> per acquisire <code>mutex</code> multipli</a></li>
<li><a href="#Rconc-unknown">CP.22: Mai chiamare codice sconosciuto mentre si tiene un lock (p.es., una callback)</a></li>
<li><a href="#Rconc-join">CP.23: Pensare ad un <code>thread</code> congiunto [joining] come contenitore con uno scope</a></li>
<li><a href="#Rconc-detach">CP.24: Pensare ad un <code>thread</code> come ad un contenitore globale</a></li>
<li><a href="#Rconc-joining_thread">CP.25: Preferire <code>gsl::joining_thread</code> a <code>std::thread</code></a></li>
<li><a href="#Rconc-detached_thread">CP.26: Non eseguire il <code>detach()</code> di un thread</a></li>
<li><a href="#Rconc-data-by-value">CP.31: Passare una piccola quantità di dati tra i thread per valore, anziché per riferimento o puntatore</a></li>
<li><a href="#Rconc-shared">CP.32: Per condividere la proprietà [ownership] tra <code>thread</code> non correlati, usare gli <code>shared_ptr</code></a></li>
<li><a href="#Rconc-switch">CP.40: Minimizzare il [context switching]</a></li>
<li><a href="#Rconc-create">CP.41: Minimizzare la creazione e la distruzione del thread</a></li>
<li><a href="#Rconc-wait">CP.42: Non eseguire un <code>wait</code> senza una condizione</a></li>
<li><a href="#Rconc-time">CP.43: Minimizzare il tempo trascorso nella sezione critica</a></li>
<li><a href="#Rconc-name">CP.44: Ricordarsi di dare un nome ai <code>lock_guard</code> e agli <code>unique_lock</code></a></li>
<li><a href="#Rconc-mutex">CP.50: Definire un <code>mutex</code> assieme ai dati che protegge. Usare <code>synchronized_value&lt;T&gt;</code> dove possibile</a></li>
<li>??? quando usare uno spinlock</li>
<li>??? quando usare <code>try_lock()</code></li>
<li>??? quando preferire <code>lock_guard</code> a <code>unique_lock</code></li>
<li>??? [Time multiplexing]</li>
<li>??? quando/come usare <code>new thread</code></li>
</ul>
<h3 id="cp.20-usare-il-raii-mai-il-semplice-lockunlock"><a name="Rconc-raii"></a>CP.20: Usare il RAII, mai il semplice <code>lock()</code>/<code>unlock()</code></h3>
<h5 id="motivo-281">Motivo</h5>
<p>Evitare brutti errori con i lock non rilasciati.</p>
<h5 id="esempio-cattivo-116">Esempio, cattivo</h5>
<pre><code>mutex mtx;

void do_stuff()
{
mtx.lock();
// ... fa qualcosa ...
mtx.unlock();
}</code></pre>
<p>Prima o poi, qualcuno dimenticherà il <code>mtx.unlock()</code>, piazzando un <code>return</code> nel <code>... fa qualcosa ...</code>, generando un’eccezione o qualcosa del genere.</p>
<pre><code>mutex mtx;

void do_stuff()
{
unique_lock&lt;mutex&gt; lck {mtx};
// ... fa qualcosa ...
}</code></pre>
<h5 id="imposizione-260">Imposizione</h5>
<p>Segnalare le chiamate del membro<code>lock()</code> e <code>unlock()</code>. ???</p>
<h3 id="cp.21-usare-stdlock-o-stdscoped_lock-per-acquisire-mutex-multipli"><a name="Rconc-lock"></a>CP.21: Usare <code>std::lock()</code> o <code>std::scoped_lock</code> per acquisire <code>mutex</code> multipli</h3>
<h5 id="motivo-282">Motivo</h5>
<p>Per evitare i deadlock sui <code>mutex</code> multipli.</p>
<h5 id="esempio-253">Esempio</h5>
<p>Questo provoca un deadlock:</p>
<pre><code>// thread 1
lock_guard&lt;mutex&gt; lck1(m1);
lock_guard&lt;mutex&gt; lck2(m2);

// thread 2
lock_guard&lt;mutex&gt; lck2(m2);
lock_guard&lt;mutex&gt; lck1(m1);</code></pre>
<p>Usare, invece <code>lock()</code>:</p>
<pre><code>// thread 1
lock(m1, m2);
lock_guard&lt;mutex&gt; lck1(m1, adopt_lock);
lock_guard&lt;mutex&gt; lck2(m2, adopt_lock);

// thread 2
lock(m2, m1);
lock_guard&lt;mutex&gt; lck2(m2, adopt_lock);
lock_guard&lt;mutex&gt; lck1(m1, adopt_lock);</code></pre>
<p>o (meglio, ma solo in C++17):</p>
<pre><code>// thread 1
scoped_lock&lt;mutex, mutex&gt; lck1(m1, m2);

// thread 2
scoped_lock&lt;mutex, mutex&gt; lck2(m2, m1);</code></pre>
<p>Qui, quelli che hanno scritto <code>thread1</code> e <code>thread2</code> non sono ancora d’accordo sull’ordine dei <code>mutex</code>, ma l’ordine non importa più.</p>
<h5 id="note-252">Note</h5>
<p>Nel codice reale, i <code>mutex</code> hanno raramente un nome per rammentare convenientemente al programmatore una relazione e un ordine di acquisizione previsti. Nel codice reale, i <code>mutex</code> non sempre sono convenientemente acquisiti su righe consecutive.</p>
<p>Nel C++17 è possibile scrivere semplicemente</p>
<pre><code>lock_guard lck1(m1, adopt_lock);</code></pre>
<p>e dedurre il tipo <code>mutex</code>.</p>
<h5 id="imposizione-261">Imposizione</h5>
<p>Rilevare l’acquisizione di <code>mutex</code> multipli. Questo è generalmente indecidibile, ma prendere semplici esempi (come quello precedente) è facile.</p>
<h3 id="cp.22-mai-chiamare-codice-sconosciuto-mentre-si-tiene-un-lock-p.es.-una-callback"><a name="Rconc-unknown"></a>CP.22: Mai chiamare codice sconosciuto mentre si tiene un lock (p.es., una callback)</h3>
<h5 id="motivo-283">Motivo</h5>
<p>Se non si sa cosa faccia un pezzo di codice, si rischia un deadlock.</p>
<h5 id="esempio-254">Esempio</h5>
<pre><code>void do_this(Foo* p)
{
lock_guard&lt;mutex&gt; lck {my_mutex};
// ... fa qualcosa ...
p-&gt;act(my_data);
// ...
}</code></pre>
<p>Se non si sa cosa fa <code>Foo::act</code> (forse è una funzione virtuale che invoca una classe membro derivata da una classe non ancora scritta), può chiamare <code>do_this</code> (ricorsivamente) provocando un deadlock su <code>my_mutex</code>. Forse si bloccherà su un mutex diverso e non tornerà in un tempo ragionevole, causando ritardi a qualsiasi codice che chiama <code>do_this</code>.</p>
<h5 id="esempio-255">Esempio</h5>
<p>Un esempio comune del problema di “chiamare codice ignoto” è una chiamata a una funzione che tenta di acquisire l’accesso allo stesso oggetto lockato. Tale problema può spesso essere risolto utilizzando un <code>recursive_mutex</code>. Per esempio:</p>
<pre><code>recursive_mutex my_mutex;

template&lt;typename Action&gt;
void do_something(Action f)
{
unique_lock&lt;recursive_mutex&gt; lck {my_mutex};
// ... fa qualcosa ...
f(this);    // f farà qualcosa con *this
// ...
}</code></pre>
<p>Se, come è probabile, <code>f()</code> richiama delle operazioni su <code>*this</code>, ci si deve assicurare che l’invariante dell’oggetto sia preso prima della chiamata.</p>
<h5 id="imposizione-262">Imposizione</h5>
<ul>
<li>Segnalare una chiamata a una funzione virtuale prendendo un <code>mutex</code> non ricorsivo</li>
<li>Segnalare la chiamata a una callback prendendo un <code>mutex</code> non ricorsivo</li>
</ul>
<h3 id="cp.23-pensare-ad-un-thread-congiunto-joining-come-contenitore-con-uno-scope"><a name="Rconc-join"></a>CP.23: Pensare ad un <code>thread</code> congiunto [joining] come contenitore con uno scope</h3>
<h5 id="motivo-284">Motivo</h5>
<p>Per mantenere la sicurezza del puntatore ed evitare i leak, si devono considerare quali puntatori vengono usati da un <code>thread</code>. Se un <code>thread</code> si unisce [joins], si possono tranquillamente passare i puntatori agli oggetti nello scope <code>thread</code> e degli scope racchiusi.</p>
<h5 id="esempio-256">Esempio</h5>
<pre><code>void f(int* p)
{
// ...
*p = 99;
// ...
}
int glob = 33;

void some_fct(int* p)
{
int x = 77;
joining_thread t0(f, &amp;x);           // OK
joining_thread t1(f, p);            // OK
joining_thread t2(f, &amp;glob);        // OK
auto q = make_unique&lt;int&gt;(99);
joining_thread t3(f, q.get());      // OK
// ...
}</code></pre>
<p>Un <code>gsl::joining_thread</code> è un <code>std::thread</code> con un distruttore che si unisce [joins] e che non può essere <code>detached()</code>. Per “OK” si intende che l’oggetto starà nello scope (“attivo”) finché un <code>thread</code> può usare un puntatore ad esso. Il fatto che i <code>thread</code> vengano eseguiti contemporaneamente qui non influisce sui problemi di durata o proprietà; questi <code>thread</code> possono essere visti come un solo oggetto funzione chiamato da <code>some_fct</code>.</p>
<h5 id="imposizione-263">Imposizione</h5>
<p>Assicurarsi che dei <code>joining_thread</code> non esegua il <code>detach()</code>. Successivamente, si applica la solita imposizione sul ciclo di vita [lifetime] e la proprietà [ownership] (per gli oggetti locali).</p>
<h3 id="cp.24-pensare-ad-un-thread-come-ad-un-contenitore-globale"><a name="Rconc-detach"></a>CP.24: Pensare ad un <code>thread</code> come ad un contenitore globale</h3>
<h5 id="motivo-285">Motivo</h5>
<p>Per mantenere la sicurezza del puntatore ed evitare i leak, si devono considerare quali puntatori vengono usati da un <code>thread</code>. Se un <code>thread</code> è staccato [detached], si possono tranquillamente passare puntatori a oggetti statici e sull’heap [free store] (solo).</p>
<h5 id="esempio-257">Esempio</h5>
<pre><code>void f(int* p)
{
// ...
*p = 99;
// ...
}

int glob = 33;

void some_fct(int* p)
{
int x = 77;
std::thread t0(f, &amp;x);           // bad
std::thread t1(f, p);            // bad
std::thread t2(f, &amp;glob);        // OK
auto q = make_unique&lt;int&gt;(99);
std::thread t3(f, q.get());      // bad
// ...
t0.detach();
t1.detach();
t2.detach();
t3.detach();
// ...
}</code></pre>
<p>Con “OK” si intende che l’oggetto rimarrà nello scope (“attivo”) fin quando un <code>thread</code> userà i puntatori ad esso. Con “bad” si intende che un <code>thread</code> può usare un puntatore dopo che l’oggetto puntato è stato distrutto. Il fatto che i <code>thread</code> vengano eseguiti contemporaneamente, qui non influisce sulla durata e la proprietà [ownership]; questi <code>thread</code> possono essere visti come un unico oggetto funzione chiamato da <code>some_fct</code>.</p>
<h5 id="note-253">Note</h5>
<p>Anche gli oggetti con una durata nello storage statico possono dare problemi se usati dai thread [detached]: se il thread continua fino alla fine del programma, potrebbe stare in esecuzione contemporaneamente alla distruzione di oggetti statici, e quindi l’accesso a tali oggetti potrebbe sollevare un conflitto [race].</p>
<h5 id="note-254">Note</h5>
<p>Questa regola è ridondante se <a href="#Rconc-detached_thread">non si esegue il <code>detach()</code></a> e si <a href="#Rconc-joining_thread">usa <code>gsl::joining_thread</code></a>. Tuttavia, la conversione del codice per seguire tali linee-guida potrebbe essere difficile e persino impossibile per le librerie di terze parti. In tali casi, la regola diventa essenziale per la sicurezza della durata e di quella del tipo.</p>
<p>In generale, non si può decidere se viene eseguito un <code>detach()</code> per un <code>thread</code>, ma i semplici casi comuni sono facili da rilevare. Se non è possibile dimostrare che un <code>thread</code> non esegue il <code>detach()</code>, si deve assumere che lo faccia e che sopravviva allo scope in cui è stato costruito; Dopo di ciò, si applica la solita imposizione sulla durata e la proprietà [ownership] (per gli oggetti globali).</p>
<h5 id="imposizione-264">Imposizione</h5>
<p>Segnalare i tentativi di passare variabii locali ad un thread di cui si può eseguire il <code>detach()</code>.</p>
<h3 id="cp.25-preferire-gsljoining_thread-a-stdthread"><a name="Rconc-joining_thread"></a>CP.25: Preferire <code>gsl::joining_thread</code> a <code>std::thread</code></h3>
<h5 id="motivo-286">Motivo</h5>
<p>Un <code>joining_thread</code> è un thread che si unisce [joins] alla fine del suo scope. I thread staccati [detached] sono difficili da monitorare. È più difficile garantire l’assenza di errori nei thread separati [detached] (e nei thread potenzialmente detached)</p>
<h5 id="esempio-cattivo-117">Esempio, cattivo</h5>
<pre><code>void f() { std::cout &lt;&lt; &quot;Hello &quot;; }

struct F {
void operator()() { std::cout &lt;&lt; &quot;parallel world &quot;; }
};

int main()
{
std::thread t1{f};      // f() eseguito in un thread separato
std::thread t2{F()};    // F()() eseguito in un thread separato
}  // evidenzia i bug</code></pre>
<h5 id="esempio-258">Esempio</h5>
<pre><code>void f() { std::cout &lt;&lt; &quot;Hello &quot;; }

struct F {
void operator()() { std::cout &lt;&lt; &quot;parallel world &quot;; }
};

int main()
{
std::thread t1{f};      // f() eseguito in un thread separato
std::thread t2{F()};    // F()() eseguito in un thread separato

t1.join();
t2.join();
}  // resta un brutto bug</code></pre>
<h5 id="esempio-cattivo-118">Esempio, cattivo</h5>
<p>Il codice che determina se usare <code>join()</code> o <code>detach()</code> può essere complicato e persino deciso nel thread o nelle funzioni che chiama o nelle funzioni chiamate dalle funzioni che creano un thread:</p>
<pre><code>void tricky(thread* t, int n)
{
// ...
if (is_odd(n))
t-&gt;detach();
// ...
}

void use(int n)
{
thread t { tricky, this, n };
// ...
// ... si esegue il join qui? ...
}</code></pre>
<p>Ciò complica seriamente l’analisi della durata, e, in casi non troppo improbabili, la rende addirittura impossibile. Ciò implica che non ci si può affidare con sicurezza agli oggetti locali in <code>use()</code> dal thread e riferirsi agli oggetti locali nel thread da <code>use()</code>.</p>
<h5 id="note-255">Note</h5>
<p>Creare “thread immortali” globali, racchiuderli in uno scope, o sull’heap [free store] piuttosto che eseguire il <code>detach()</code>. <a href="#Rconc-detached_thread">non eseguire il <code>detach</code></a>.</p>
<h5 id="note-256">Note</h5>
<p>A causa del vecchio codice e delle librerie di terze parti che usano <code>std::thread</code> questa regola può essere difficile da applicare.</p>
<h5 id="imposizione-265">Imposizione</h5>
<p>Segnalare l’uso di <code>std::thread</code>:</p>
<ul>
<li>Suggerire l’utilizzo di <code>gsl::joining_thread</code>.</li>
<li>Suggerire l’<a href="#Rconc-detached_thread">“l’esportazione della proprietà [exporting ownership]”</a> in uno scope circoscritto se si esegue il detach.</li>
<li>Segnalare con forza se non è chiaro se si esegue il join o il detach.</li>
</ul>
<h3 id="cp.26-non-eseguire-il-detach-di-un-thread"><a name="Rconc-detached_thread"></a>CP.26: Non eseguire il <code>detach()</code> di un thread</h3>
<h5 id="motivo-287">Motivo</h5>
<p>Spesso, la necessità di sopravvivere allo scope della propria creazione, riguarda l’attività dei <code>thread</code>, ma implementare quell’idea con <code>detach</code> rende più difficile monitorare e comunicare con il thread detached. In particolare, è più difficile (anche se non impossibile) garantire che il thread sia completato come previsto o che duri per il tempo previsto.</p>
<h5 id="esempio-259">Esempio</h5>
<pre><code>void heartbeat();

void use()
{
std::thread t(heartbeat);             // non eseguire il join; heartbeat  è destinato a funzionare per sempre
t.detach();
// ...
}</code></pre>
<p>Questo è un ragionevole uso di un thread, per cui solitamente si usa il <code>detach()</code>. Ci sono comunque dei problemi. Come si può monitorare un thread detached per vedere se è in esecuzione? Qualcosa potrebbe andare storto con heartbeat, e perdere un heartbeat può essere molto grave in un sistema per il quale è necessario. Quindi, è necessario comunicare col thread heartbeat (p.es., tramite uno stream di messaggi o eventi di notifica utilizzando una <code>condition_variable</code>).</p>
<p>Una alternativa, e solitamente una soluzione migliore, consiste nel controllarne la durata ponendolo in uno scope al di fuori del suo punto di creazione (o attivazione). Per esempio:</p>
<pre><code>void heartbeat();

gsl::joining_thread t(heartbeat);             // heartbeat è destinato a funzionare &quot;per sempre&quot;</code></pre>
<p>Questo heartbeat funzionerà (eccetto che per un errore, problemi hardware, ecc.) finché durerà il programma.</p>
<p>Talvolta, si deve separare il punto di creazione dal punto della proprietà [ownership]:</p>
<pre><code>void heartbeat();

unique_ptr&lt;gsl::joining_thread&gt; tick_tock {nullptr};

void use()
{
// heartbeat è destinato a funzionare finché tick_tock lives è in esecuzione
tick_tock = make_unique&lt;gsl::joining_thread&gt;(heartbeat);
// ...
}</code></pre>
<h4 id="imposizione-266">Imposizione</h4>
<p>Segnalare i <code>detach()</code>.</p>
<h3 id="cp.31-passare-una-piccola-quantità-di-dati-tra-i-thread-per-valore-anziché-per-riferimento-o-puntatore"><a name="Rconc-data-by-value"></a>CP.31: Passare una piccola quantità di dati tra i thread per valore, anziché per riferimento o puntatore</h3>
<h5 id="motivo-288">Motivo</h5>
<p>Copiare una piccola quantità di dati è più economico da copiare e da accedervi rispetto alla condivisione mediante un meccanismo di lock. La copia offre naturalmente una proprietà [ownership] esclusiva (semplifica il codice) ed elimina la possibilità di conflitti.</p>
<h5 id="note-257">Note</h5>
<p>Definire esattamente “piccola quantità” è impossibile.</p>
<h5 id="esempio-260">Esempio</h5>
<pre><code>string modify1(string);
void modify2(string&amp;);

void fct(string&amp; s)
{
auto res = async(modify1, s);
async(modify2, s);
}</code></pre>
<p>La chiamata a <code>modify1</code> implica la copia di due valori <code>string</code>; la chiamata a <code>modify2</code> no. D’altra parte, l’implementazione di <code>modify1</code> è esattamente come la si avrebbe scritta per il codice single-threaded, mentre l’implementazione di <code>modify2</code> necessiterà di una forma di lock per evitare conflitti. Se la stringa è breve (diciamo 10 caratteri), la chiamata a <code>modify1</code> può risultare sorprendentemente veloce; essenzialmente tutto il costo è nello scambio [switch] del <code>thread</code>. Se la stringa è lunga (diciamo 1,000,000 di caratteri), copiarla due volte non è una buona idea.</p>
<p>Si noti che questo argomento non ha nulla a che fare con <code>async</code> in quanto tale. Si applica ugualmente alle considerazioni sull’opportunità di utilizzare il passaggio dei messaggi o la memoria condivisa.</p>
<h5 id="imposizione-267">Imposizione</h5>
<p>???</p>
<h3 id="cp.32-per-condividere-la-proprietà-ownership-tra-thread-non-correlati-usare-gli-shared_ptr"><a name="Rconc-shared"></a>CP.32: Per condividere la proprietà [ownership] tra <code>thread</code> non correlati, usare gli <code>shared_ptr</code></h3>
<h5 id="motivo-289">Motivo</h5>
<p>Se i thread non sono correlati (ovvero, non si sa se stanno nello stesso scope o uno nella durata dell’altro) e devono condividere la stessa memoria sull’heap [free store]da cancellare, uno <code>shared_ptr</code> (o equivalente) è il solo modo sicuro per garantire il corretto ‘delete’.</p>
<h5 id="esempio-261">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="note-258">Note</h5>
<ul>
<li>Un oggetto statico (p.es. un globale) si può condividere perché non è posseduto nel senso che qualche thread è responsabile della sua cancellazione.</li>
<li>Un oggetto nel [free store] che non viene mail cancellato può essere condiviso.</li>
<li>Un oggetto posseduto [owned] da un thread può essere condiviso in modo sicuro con un altro purché questo secondo thread non sopravviva al proprietario.</li>
</ul>
<h5 id="imposizione-268">Imposizione</h5>
<p>???</p>
<h3 id="cp.40-minimizzare-il-context-switching"><a name="Rconc-switch"></a>CP.40: Minimizzare il [context switching]</h3>
<h5 id="motivo-290">Motivo</h5>
<p>I [context switch] sono costosi.</p>
<h5 id="esempio-262">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="imposizione-269">Imposizione</h5>
<p>???</p>
<h3 id="cp.41-minimizzare-la-creazione-e-la-distruzione-del-thread"><a name="Rconc-create"></a>CP.41: Minimizzare la creazione e la distruzione del thread</h3>
<h5 id="motivo-291">Motivo</h5>
<p>La creazione del thread è costosa.</p>
<h5 id="esempio-263">Esempio</h5>
<pre><code>void worker(Message m)
{
// elaborazione
}

void master(istream&amp; is)
{
for (Message m; is &gt;&gt; m; )
run_list.push_back(new thread(worker, m));
}</code></pre>
<p>Ciò genera un <code>thread</code> per ogni messaggio, e la <code>run_list</code> è presumibilmente fatta per distruggere quei task una volta completati.</p>
<p>Invece, si potrebbe avere una serie di thread di lavoro pre-creati che elaborano i messaggi</p>
<pre><code>Sync_queue&lt;Message&gt; work;

void master(istream&amp; is)
{
for (Message m; is &gt;&gt; m; )
work.put(m);
}

void worker()
{
for (Message m; m = work.get(); ) {
// process
}
}

void workers()  // imposta i thread di lavoro (nello specifico 4 thread di lavoro)
{
joining_thread w1 {worker};
joining_thread w2 {worker};
joining_thread w3 {worker};
joining_thread w4 {worker};
}</code></pre>
<h5 id="note-259">Note</h5>
<p>Se il proprio sistema ha un buon [thread pool], lo si usi. Se il proprio sistema ha una buona [message queue], la si usi.</p>
<h5 id="imposizione-270">Imposizione</h5>
<p>???</p>
<h3 id="cp.42-non-eseguire-un-wait-senza-una-condizione"><a name="Rconc-wait"></a>CP.42: Non eseguire un <code>wait</code> senza una condizione</h3>
<h5 id="motivo-292">Motivo</h5>
<p>Un <code>wait</code> senza una condizione può perdere un [wakeup] o svegliarsi semplicemente per scoprire che non ha nulla da fare.</p>
<h5 id="esempio-cattivo-119">Esempio, cattivo</h5>
<pre><code>std::condition_variable cv;
std::mutex mx;

void thread1()
{
while (true) {
// fa un po&#39; di lavoro ...
std::unique_lock&lt;std::mutex&gt; lock(mx);
cv.notify_one();    // attiva un altro thread
}
}

void thread2()
{
while (true) {
std::unique_lock&lt;std::mutex&gt; lock(mx);
cv.wait(lock);    // si potrebbe bloccare per sempre
// fa qualcosa ...
}
}</code></pre>
<p>Qui, se qualche altro <code>thread</code> ‘consuma’ la notifica di <code>thread1</code>, il <code>thread2</code> può aspettare per sempre.</p>
<h5 id="esempio-264">Esempio</h5>
<pre><code>template&lt;typename T&gt;
class Sync_queue {
public:
void put(const T&amp; val);
void put(T&amp;&amp; val);
void get(T&amp; val);
private:
mutex mtx;
condition_variable cond;    // questo controlla l&#39;accesso
list&lt;T&gt; q;
};

template&lt;typename T&gt;
void Sync_queue&lt;T&gt;::put(const T&amp; val)
{
lock_guard&lt;mutex&gt; lck(mtx);
q.push_back(val);
cond.notify_one();
}

template&lt;typename T&gt;
void Sync_queue&lt;T&gt;::get(T&amp; val)
{
unique_lock&lt;mutex&gt; lck(mtx);
cond.wait(lck, [this]{ return !q.empty(); });    // impedisce il risveglio spurio
val = q.front();
q.pop_front();
}</code></pre>
<p>Ora se la coda è vuota quando un thread esegue <code>get()</code> si attiva (p.es., perché un altro thread ha eseguito un <code>get()</code> prima di lui), e si disattiverà immediatamente, aspettando.</p>
<h5 id="imposizione-271">Imposizione</h5>
<p>Segnalare tutti i <code>wait</code> senza condizioni.</p>
<h3 id="cp.43-minimizzare-il-tempo-trascorso-nella-sezione-critica"><a name="Rconc-time"></a>CP.43: Minimizzare il tempo trascorso nella sezione critica</h3>
<h5 id="motivo-293">Motivo</h5>
<p>Meno tempo si passa per un <code>mutex</code> preso, minore è la possibilità che un altro <code>thread</code> debba aspettare, e le sospensioni e le riprese dei <code>thread</code> sono costose.</p>
<h5 id="esempio-265">Esempio</h5>
<pre><code>void do_something() // non buono
{
unique_lock&lt;mutex&gt; lck(my_lock);
do0();  // preparazione: non necessita di un lock
do1();  // transazione: necessita di un lock
do2();  // pulizia: non necessita del lock
}</code></pre>
<p>Qui, si tiene il lock per più tempo del necessario: Non si avrebbe dovuto tenere il lock prima di averne bisogno e lo si doveva rilasciare prima di iniziare la pulizia. Lo si può riscrivere in questo modo</p>
<pre><code>void do_something() // bad
{
do0();  // preparazione: non necessita di un lock
my_lock.lock();
do1();  // transazione: necessita di un lock
my_lock.unlock();
do2();  // pulizia: non necessita del lock
}</code></pre>
<p>Ma ciò compromette la sicurezza e e viola la regola di <a href="#Rconc-raii">usare il RAII</a> rule. Si aggiunga, invece, un blocco per la sezione critica:</p>
<pre><code>void do_something() // OK
{
do0();  // preparazione: non necessita di un lock
{
unique_lock&lt;mutex&gt; lck(my_lock);
do1();  // transazione: necessita di un lock
}
do2();  // pulizia: non necessita del lock
}</code></pre>
<h5 id="imposizione-272">Imposizione</h5>
<p>Impossibile in generale. Segnalare i <code>lock()</code> e gli <code>unlock()</code> “[naked]”.</p>
<h3 id="cp.44-ricordarsi-di-dare-un-nome-ai-lock_guard-e-agli-unique_lock"><a name="Rconc-name"></a>CP.44: Ricordarsi di dare un nome ai <code>lock_guard</code> e agli <code>unique_lock</code></h3>
<h5 id="motivo-294">Motivo</h5>
<p>Un oggetto locale senza nome è un temporaneo che esce immediatamente dallo scope.</p>
<h5 id="esempio-266">Esempio</h5>
<pre><code>unique_lock&lt;mutex&gt;(m1);
lock_guard&lt;mutex&gt; {m2};
lock(m1, m2);</code></pre>
<p>Questo sembra abbastanza innocente, ma non lo è.</p>
<h5 id="imposizione-273">Imposizione</h5>
<p>Segnalare tutti i <code>lock_guard</code> e gli <code>unique_lock</code> senza nome.</p>
<h3 id="cp.50-definire-un-mutex-assieme-ai-dati-che-protegge.-usare-synchronized_valuet-dove-possibile"><a name="Rconc-mutex"></a>CP.50: Definire un <code>mutex</code> assieme ai dati che protegge. Usare <code>synchronized_value&lt;T&gt;</code> dove possibile</h3>
<h5 id="motivo-295">Motivo</h5>
<p>Dovrebbe essere ovvio al lettore che i dati devono essere protetti e come lo sono. Ciò riduce la possibilità che venga bloccato il mutex sbagliato o che il mutex non venga bloccato.</p>
<p>L’uso di un <code>synchronized_value&lt;T&gt;</code> garantisce che i dati abbiano un mutex e che il giusto mutex venga bloccato quando si accede ai dati. Si veda la <a href="http://wg21.link/p0290">WG21 proposal</a> per aggiungere un <code>synchronized_value</code> ad una futura TS o revisione dello standard del C++.</p>
<h5 id="esempio-267">Esempio</h5>
<pre><code>struct Record {
std::mutex m;   // accetta questo mutex prima di accedere ad altri membri
// ...
};

class MyClass {
struct DataRecord {
// ...
};
synchronized_value&lt;DataRecord&gt; data; // Protegge i dati con un mutex
};</code></pre>
<h5 id="imposizione-274">Imposizione</h5>
<p>??? Possibile?</p>
<h2 id="cp.par-parallelismo"><a name="SScp-par"></a>CP.par: Parallelismo</h2>
<p>Con “parallelismo” ci si riferisce all’esecuzione di un’attività (più o meno) simultaneamente (“in parallelo con”) ad altri elementi di dati.</p>
<p>Riepilogo delle regole sul parallelismo:</p>
<ul>
<li>???</li>
<li>???</li>
<li>Laddove è appropriato, preferire gli algoritmi paralleli della libreria standard</li>
<li>Usare gli algoritmi progettati per il parallelismo, non quelli con una dipendenza non necessaria dalla valutazione lineare</li>
</ul>
<h2 id="cp.mess-passaggio-dei-messaggi"><a name="SScp-mess"></a>CP.mess: Passaggio dei messaggi</h2>
<p>Le funzioni della libreria standard sono piuttosto a basso livello, focalizzate sulle necessità vicine alla programmazione critica dell’hardware utilizzando i <code>thread</code>, i <code>mutex</code>, i tipi <code>atomici</code>, ecc. La maggior parte delle persone non dovrebbe lavorare a questo livello: è soggetto a errori e lo sviluppo è lento. Se possibile usare funzioni a più alto livello: librerie di [messaging], algoritmi paralleli e vettorizzazione. Questa sezione tratta il passaggio dei messaggi in modo che un programmatore non debba eseguire la sincronizzazione esplicita.</p>
<p>Riepilogo delle regole sul passaggio dei messaggi:</p>
<ul>
<li><a href="#Rconc-future">CP.60: Usare un <code>future</code> per restituire un valore da un task concorrente</a></li>
<li><a href="#Rconc-async">CP.61: Usare un <code>async()</code> per generare [spawn] un task concorrente</a></li>
<li>code di messaggi [message queues]</li>
<li>Librerie di [messaging]</li>
</ul>
<p>???? dovrebbe esserci un “usa X anziché <code>std::async</code>” dove X è qualcosa che userebbe un thread pool meglio specificato?</p>
<p>??? Vale la pena di usare <code>std::async</code> alla luce delle future (e già esistenti come librerie) funzioni di parallelismo? Cosa dovrebbero raccomandare le linee-guida se qualcuno vuole parallelizzare, ad esempio, <code>std::accumulate</code> (con l’ulteriore precondizione della commutatività), o il “merge sort”?</p>
<h3 id="cp.60-usare-un-future-per-restituire-un-valore-da-un-task-concorrente"><a name="Rconc-future"></a>CP.60: Usare un <code>future</code> per restituire un valore da un task concorrente</h3>
<h5 id="motivo-296">Motivo</h5>
<p>Un <code>future</code> preserva la solita semantica del return da una chiamata a una funzione per i task asincroni. Non c’è un lock esplicito e vengono gestiti semplicemente sia il corretto (valore) di ritorno che l’errore (eccezione) restituito.</p>
<h5 id="esempio-268">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="note-260">Note</h5>
<p>???</p>
<h5 id="imposizione-275">Imposizione</h5>
<p>???</p>
<h3 id="cp.61-usare-un-async-per-generare-spawn-un-task-concorrente"><a name="Rconc-async"></a>CP.61: Usare un <code>async()</code> per generare [spawn] un task concorrente</h3>
<h5 id="motivo-297">Motivo</h5>
<p>Un <code>future</code> preserva la solita semantica del return da una chiamata a una funzione per i task asincroni. Non c’è un lock esplicito e vengono gestiti semplicemente sia il corretto (valore) di ritorno che l’errore (eccezione) restituito.</p>
<h5 id="esempio-269">Esempio</h5>
<pre><code>int read_value(const std::string&amp; filename)
{
std::ifstream in(filename);
in.exceptions(std::ifstream::failbit);
int value;
in &gt;&gt; value;
return value;
}


void async_example()
{
try
{
auto v1 = std::async(std::launch::async, read_value, &quot;v1.txt&quot;);
auto v2 = std::async(std::launch::async, read_value, &quot;v2.txt&quot;);
std::cout &lt;&lt; v1.get() + v2.get() &lt;&lt; &#39;\n&#39;;
}
catch (std::ios_base::failure &amp; fail)
{
// gestire qui l&#39;eccezione
}
}</code></pre>
<h5 id="note-261">Note</h5>
<p>Sfortunatamente, <code>async()</code> non è perfetto. Per esempio, non c’è la garanzia che venga usato un pool di thread per ridurre la costruzione dei thread. Infatti, la maggior parte delle implementazioni attuali di <code>async()</code> non lo fanno. Tuttavia, <code>async()</code> è semplice e logicamente corretto, quindi fino a quando non arriva qualcosa di meglio e a meno che non sia veramente necessario ottimizzare per molti task asincroni, restiamo con <code>async()</code>.</p>
<h5 id="imposizione-276">Imposizione</h5>
<p>???</p>
<h2 id="cp.vec-vettorizzazione"><a name="SScp-vec"></a>CP.vec: Vettorizzazione</h2>
<p>La vettorizzazione è una tecnica per eseguire una serie di attività contemporaneamente senza introdurre una sincronizzazione esplicita. Un’operazione viene semplicemente applicata in parallelo agli elementi di una struttura dati (un vettore, un array, ecc.). La vettorizzazione ha la proprietà interessante che spesso non richiede modifiche non locali a un programma. Tuttavia, la vettorizzazione funziona meglio con strutture dati semplici e con algoritmi appositamente creati per abilitarlo.</p>
<p>Riepilogo delle regole sulla vettorizzazione:</p>
<ul>
<li>???</li>
<li>???</li>
</ul>
<h2 id="cp.free-programmazione-senza-lock"><a name="SScp-free"></a>CP.free: Programmazione senza lock</h2>
<p>La sincronizzazione con i <code>mutex</code> e con le <code>condition_variable</code> può risultare relativamente costosa. Inoltre, può provocare deadlock. Per le prestazioni e per eliminare la possibilità di deadlock, a volte si devono usare le complicate funzioni a basso-livello “lock-free” che si basano sul rapido accesso esclusivo (“atomico”) alla memoria. La programmazione lock-free si usa anche per implementare meccanismi di concorrenza a livello più alto come i <code>thread</code> e i <code>mutex</code>.</p>
<p>Riepilogo delle regole sulla programmazione lock-free:</p>
<ul>
<li><a href="#Rconc-lockfree">CP.100: Non utilizzare la programmazione lock-free a meno che non sia assolutamente necessario</a></li>
<li><a href="#Rconc-distrust">CP.101: Diffidare della combinazione hardware/compilatore</a></li>
<li><a href="#Rconc-literature">CP.102: Studiare attentamente la letteratura</a></li>
<li>come/quando usare l’atomicità</li>
<li>evitare l’inedia [starvation]</li>
<li>usare strutture dati lock-free anziché creare specifici accessi lock-free</li>
<li><a href="#Rconc-double">CP.110: Non scriversi il proprio “interblocco ricontrollato” [double-checked locking] per l’inizializzazione</a></li>
<li><a href="#Rconc-double-pattern">CP.111: Usare un pattern convenzionale se è veramente necessario il “double-checked locking”</a></li>
<li>come/quando confrontare e scambiare</li>
</ul>
<h3 id="cp.100-non-utilizzare-la-programmazione-lock-free-a-meno-che-non-sia-assolutamente-necessario"><a name="Rconc-lockfree"></a>CP.100: Non utilizzare la programmazione lock-free a meno che non sia assolutamente necessario</h3>
<h5 id="motivo-298">Motivo</h5>
<p>È soggetta a errori e richiede la conoscenza di un esperto delle funzionalità del linguaggio, dell’architettura della macchina e delle strutture dati.</p>
<h5 id="esempio-cattivo-120">Esempio, cattivo</h5>
<pre><code>extern atomic&lt;Link*&gt; head;        // la &#39;head&#39; condivisa di una lista collegata

Link* nh = new Link(data, nullptr);    // crea un link pronto per l&#39;inserimento
Link* h = head.load();                 // legge la &#39;head&#39; condivisa della lista

do {
if (h-&gt;data &lt;= data) break;        // in tal caso, inserisce altrove
nh-&gt;next = h;                      // l&#39;elemento successivo è la &#39;head&#39; precedente
} while (!head.compare_exchange_weak(h, nh));    // scrive nh in head o in h</code></pre>
<p>Trovare il bug. Sarebbe davvero difficile da trovare tramite i test. Si legga a proposito di “ABA problem”.</p>
<h5 id="eccezione-47">Eccezione</h5>
<p>Le <a href="#???">variabili atomiche</a> possono essere utilizzate in modo semplice e sicuro, purché si utilizzi il modello di memoria coerente sequenzialmente (memory_order_seq_cst), che è il default.</p>
<h5 id="note-262">Note</h5>
<p>Meccanismi di concorrenza di livello superiore, come i <code>thread</code> e i <code>mutex</code> vengono implementati con la programmazione lock-free.</p>
<p><strong>Alternativa</strong>: Usare strutture dati lock-free implementate da altri come parti di qualche libreria.</p>
<h3 id="cp.101-diffidare-della-combinazione-hardwarecompilatore"><a name="Rconc-distrust"></a>CP.101: Diffidare della combinazione hardware/compilatore</h3>
<h5 id="motivo-299">Motivo</h5>
<p>Le interfacce hardware di basso livello utilizzate nella programmazione lock-free sono tra le più difficili da implementare correttamente e tra le aree in cui si verificano i problemi più subdoli sulla portabilità. Se si sta seguendo una programmazione lock-free per le prestazioni, si devono controllare le regressioni.</p>
<h5 id="note-263">Note</h5>
<p>Il riordino delle istruzioni (statico e dinamico) ci rende difficile pensare in modo efficace a questo livello (specie se si usano modelli di memoria rilassati [relaxed memory models]). L’esperienza, i modelli (semi)formali e il [model checking] possono servire. Il test - spesso in misura estrema - è essenziale. “Non volare troppo vicino al sole”.</p>
<h5 id="imposizione-277">Imposizione</h5>
<p>Ci sono regole rigide per i test che coprono qualsiasi cambiamento nell’hardware, nel sistema operativo, nel compilatore e nelle librerie.</p>
<h3 id="cp.102-studiare-attentamente-la-letteratura"><a name="Rconc-literature"></a>CP.102: Studiare attentamente la letteratura</h3>
<h5 id="motivo-300">Motivo</h5>
<p>Ad eccezione di quelli atomici e di alcuni altri pattern standard, la programmazione lock-free è veramente un argomento per soli esperti. Si deve diventare esperti prima di cimentarsi in codice lock-free utilizzabile da altri.</p>
<h5 id="riferimenti">Riferimenti</h5>
<ul>
<li>Anthony Williams: C++ concurrency in action. Manning Publications.</li>
<li>Boehm, Adve, You Don’t Know Jack About Shared Variables or Memory Models , Communications of the ACM, Feb 2012.</li>
<li>Boehm, “Threads Basics”, HPL TR 2009-259.</li>
<li>Adve, Boehm, “Memory Models: A Case for Rethinking Parallel Languages and Hardware”, Communications of the ACM, August 2010.</li>
<li>Boehm, Adve, “Foundations of the C++ Concurrency Memory Model”, PLDI 08.</li>
<li>Mark Batty, Scott Owens, Susmit Sarkar, Peter Sewell, and Tjark Weber, “Mathematizing C++ Concurrency”, POPL 2011.</li>
<li>Damian Dechev, Peter Pirkelbauer, and Bjarne Stroustrup: Understanding and Effectively Preventing the ABA Problem in Descriptor-based Lock-free Designs. 13th IEEE Computer Society ISORC 2010 Symposium. May 2010.</li>
<li>Damian Dechev and Bjarne Stroustrup: Scalable Non-blocking Concurrent Objects for Mission Critical Code. ACM OOPSLA’09. October 2009</li>
<li>Damian Dechev, Peter Pirkelbauer, Nicolas Rouquette, and Bjarne Stroustrup: Semantically Enhanced Containers for Concurrent Real-Time Systems. Proc. 16th Annual IEEE International Conference and Workshop on the Engineering of Computer Based Systems (IEEE ECBS). April 2009.</li>
</ul>
<h3 id="cp.110-non-scriversi-il-proprio-interblocco-ricontrollato-double-checked-locking-per-linizializzazione"><a name="Rconc-double"></a>CP.110: Non scriversi il proprio “interblocco ricontrollato” [double-checked locking] per l’inizializzazione</h3>
<h5 id="motivo-301">Motivo</h5>
<p>Dal C++11, le variabili locali statiche vengono ora inizializzate in modo thread-safe. In combinazione con il modello RAII, le variabili locali statiche possono sostituire la necessità di scrivere il proprio blocco “double-checked” per l’inizializzazione. Anche con std::call_once can si può raggiungere lo stesso scopo. Utilizzare le variabili locali statiche del C++11 o std::call_once anziché scriversi il proprio blocco “double-checked” per l’inizializzazione.</p>
<h5 id="esempio-270">Esempio</h5>
<p>Esempio con std::call_once.</p>
<pre><code>void f()
{
static std::once_flag my_once_flag;
std::call_once(my_once_flag, []()
{
// fallo una sola volta
});
// ...
}</code></pre>
<p>Esempio cono le variabili locali “thread-safe” del C++11.</p>
<pre><code>void f()
{
// Supponendo che il compilatore sia conforme al C++11
static My_class my_object; // Constructor called only once
// ...
}

class My_class
{
public:
My_class()
{
// fallo una sola volta
}
};</code></pre>
<h5 id="imposizione-278">Imposizione</h5>
<p>??? È possibile rilevare l’idioma?</p>
<h3 id="cp.111-usare-un-pattern-convenzionale-se-è-veramente-necessario-il-double-checked-locking"><a name="Rconc-double-pattern"></a>CP.111: Usare un pattern convenzionale se è veramente necessario il “double-checked locking”</h3>
<h5 id="motivo-302">Motivo</h5>
<p>Il “double-checked locking” è facile da rovinare. Se è davvero necessario scrivere il proprio “double-checked locking”, nonostante le regole <a href="#Rconc-double">CP.110: Non scriversi il proprio “interblocco ricontrollato” [double-checked locking] per l’inizializzazione</a> e <a href="#Rconc-lockfree">CP.100: Non utilizzare la programmazione lock-free a meno che non sia assolutamente necessario</a>, farlo secondo un modello convenzionale.</p>
<p>Gli usi del pattern “double-checked locking” che non sono in volazione della <a href="#Rconc-double">CP.110: Non scriversi il proprio “interblocco ricontrollato” [double-checked locking] per l’inizializzazione</a>, si hanno quando un’azione “non-thread-safe” è sia difficile [hard] che rara, ed esiste un test veloce “thread-safe” utilizzabile per garantire che l’azione non è necessaria, ma non è utilizzabile per garantire il contrario.</p>
<h5 id="esempio-cattivo-121">Esempio, cattivo</h5>
<p>L’uso di volatile non rende il primo controllo “thread-safe”, si veda anche <a href="#Rconc-volatile2">CP.200: Usare <code>volatile</code> solo per comunicare con una memoria non-C++</a></p>
<pre><code>mutex action_mutex;
volatile bool action_needed;

if (action_needed) {
std::lock_guard&lt;std::mutex&gt; lock(action_mutex);
if (action_needed) {
take_action();
action_needed = false;
}
}</code></pre>
<h5 id="esempio-buono-22">Esempio, buono</h5>
<pre><code>mutex action_mutex;
atomic&lt;bool&gt; action_needed;

if (action_needed) {
std::lock_guard&lt;std::mutex&gt; lock(action_mutex);
if (action_needed) {
take_action();
action_needed = false;
}
}</code></pre>
<p>Un preciso ordine della memoria può essere d’aiuto dove il carico di acquisizione è più efficiente di quello sequenziale</p>
<pre><code>mutex action_mutex;
atomic&lt;bool&gt; action_needed;

if (action_needed.load(memory_order_acquire)) {
lock_guard&lt;std::mutex&gt; lock(action_mutex);
if (action_needed.load(memory_order_relaxed)) {
take_action();
action_needed.store(false, memory_order_release);
}
}</code></pre>
<h5 id="imposizione-279">Imposizione</h5>
<p>??? È possibile rilevare l’idioma?</p>
<h2 id="cp.etc-ecc.-regole-della-concorrenza"><a name="SScp-etc"></a>CP.etc: Ecc. regole della concorrenza</h2>
<p>Queste regole non sono facilmente categorizzabili:</p>
<ul>
<li><a href="#Rconc-volatile2">CP.200: Usare <code>volatile</code> solo per comunicare con una memoria non-C++</a></li>
<li><a href="#Rconc-signal">CP.201: ??? I “signal”</a></li>
</ul>
<h3 id="cp.200-usare-volatile-solo-per-comunicare-con-una-memoria-non-c"><a name="Rconc-volatile2"></a>CP.200: Usare <code>volatile</code> solo per comunicare con una memoria non-C++</h3>
<h5 id="motivo-303">Motivo</h5>
<p><code>volatile</code> è usato per far riferimento a oggetti condivisi con un codice “non-C++” o con un hardware che non segue il modello di memoria del C++.</p>
<h5 id="esempio-271">Esempio</h5>
<pre><code>const volatile long clock;</code></pre>
<p>Descrive un registro aggiornato costantemente da un orologio interno. <code>clock</code> è <code>volatile</code> perché il suo valore cambierà senza alcuna azione da parte del programma C++ che lo usa. Per esempio, leggendo <code>clock</code> die volte si hanno spesso due valori diversi, quindi è opportuno che l’ottimizzatore non ottimizzi la seconda lettura in questo codice:</p>
<pre><code>long t1 = clock;
// ... nessun uso di clock qui ...
long t2 = clock;</code></pre>
<p><code>clock</code> è <code>const</code> perché il programma non dovrebbe tentare di scrivere in <code>clock</code>.</p>
<h5 id="note-264">Note</h5>
<p>A meno che non si stia scrivendo il codice a livello più basso per gestire direttamente l’hardware, si consideri <code>volatile</code> una funzionalità esoterica che è meglio evitare.</p>
<h5 id="esempio-272">Esempio</h5>
<p>Solitamente il codice C++ riceve come <code>volatile</code> la memoria posseduta altrove (hardware o un altro linguaggio):</p>
<pre><code>int volatile* vi = get_hardware_memory_location();
// nota: qui si ha un puntatore alla memoria di qualcun altro
// volatile says &quot;treat this with extra respect&quot;</code></pre>
<p>A volte il codice C++ code alloca memoria <code>volatile</code> e la condivide con “qualcun altro” (hardware o un altro linguaggio) per sfuggire deliberatamente ad un puntatore [escaping a pointer]:</p>
<pre><code>static volatile long vl;
please_use_this(&amp;vl);   // strappare un riferimento a questo &quot;altrove [escape a reference to this to &quot;elsewhere&quot;] (non ilC++)</code></pre>
<h5 id="esempio-cattivo-122">Esempio, cattivo</h5>
<p>Le variabili locali <code>volatile</code> sono quasi sempre sbagliate – come si possono condividere con altri linguaggi o con l’hardware se sono temporanee? Lo stesso vale quasi altrettanto fortemente per le variabili membro, per lo stesso motivo.</p>
<pre><code>void f() {
volatile int i = 0; // bad, volatile local variable
// ecc.
}

class My_type {
volatile int i = 0; // sospetto, variabile membro volatile
// ecc.
};</code></pre>
<h5 id="note-265">Note</h5>
<p>In C++, diversamente da altri linguaggi, <code>volatile</code> non ha <a href="#Rconc-volatile">niente a che fare con la sincronizzazione</a>.</p>
<h5 id="imposizione-280">Imposizione</h5>
<ul>
<li>Segnalare le variabili membro e locali <code>volatile T</code>; quasi certamente si intendeva usare invece <code>atomic&lt;T&gt;</code>.</li>
<li>???</li>
</ul>
<h3 id="cp.201-signal"><a name="Rconc-signal"></a>CP.201: ??? Signal</h3>
<p>???Gestione dei signal di UNIX???. Potrebbe essere utile ricordare quando siano poco sicuri i async-signal-safe, e come comunicare con un gestore di signal (forse è meglio “non farlo affatto”)</p>
<h1 id="e-gestione-degli-errori"><a name="S-errors"></a>E: Gestione degli errori</h1>
<p>La gestione degli errori implica:</p>
<ul>
<li>Rilevare un errore</li>
<li>Trasmettere le informazioni su un errore a un codice per la sua gestione</li>
<li>Preservare uno stato valido del programma</li>
<li>Evitare perdite (leak) di risorse</li>
</ul>
<p>Non è possibile recuperare da tutti gli errori. Se il recuero da un errore non è possibile, è importante “uscire” rapidamente in un modo ben definito. Una strategia per la gestione degli errori deve essere semplice, altrimenti diventa fonte di errori anche peggiori. Anche il codice per gestire gli errori se non testato, o eseguito raramente, è esso stesso una sorgenti di molti bug.</p>
<p>Le regole sono fatte per aiutare a evitare i diversi tipi di errori:</p>
<ul>
<li>Violazione del tipo (p.es., uso improprio delle <code>union</code> e dei cast)</li>
<li>Perdita (leak) delle risorse (compresi i ‘memory leak’)</li>
<li>Errori sui limiti [bound]</li>
<li>Errori sul ciclo di vita (p.es., accesso ad un oggetto dopo il <code>delete</code>)</li>
<li>Errori di complessità (errori logici dati da espressioni o idee eccessivamente complesse)</li>
<li>Errori di interfaccia (p.es., un valore inatteso passato ad un’interfaccia)</li>
</ul>
<p>Riepilogo delle regole sulla gestione degli errori [error-handling]:</p>
<ul>
<li><p><a href="#Re-design">E.1: Sviluppare una strategia di gestione degli errori nelle prime fasi di un progetto</a></p></li>
<li><p><a href="#Re-throw">E.2: Generare un’eccezione per segnalare che una funzioni non può eseguire il proprio compito</a></p></li>
<li><p><a href="#Re-errors">E.3: Usare le eccezioni solamente per la gestione degli errori</a></p></li>
<li><p><a href="#Re-design-invariants">E.4: Progettarsi la propria strategia di gestione degli errori basandosi sugli invarianti</a></p></li>
<li><p><a href="#Re-invariant">E.5: Consentire ad un costruttore di stabilire un invariante, e sollevare un errore se non può</a></p></li>
<li><p><a href="#Re-raii">E.6: Usare il RAII per evitare i leak</a></p></li>
<li><p><a href="#Re-precondition">E.7: Dichiarare le proprie pre-condizioni</a></p></li>
<li><p><a href="#Re-postcondition">E.8: Dichiarare le proprie post-condizioni</a></p></li>
<li><p><a href="#Re-noexcept">E.12: Usare <code>noexcept</code> uscendo da una funzione quando un <code>throw</code> (un’eccezione) è impossibile o inaccettabile</a></p></li>
<li><p><a href="#Re-never-throw">E.13: Mai sollevare eccezioni quando si è i diretti proprietari [owner] di un oggetto</a></p></li>
<li><p><a href="#Re-exception-types">E.14: Usare tipi appositamente progettati o [user-defined] come eccezioni (non i tipi [built-in])</a></p></li>
<li><p><a href="#Re-exception-ref">E.15: Catturare le eccezioni da una gerarchia per riferimento</a></p></li>
<li><p><a href="#Re-never-fail">E.16: I distruttori, la de-allocazione e <code>swap</code> non devono mai fallire</a></p></li>
<li><p><a href="#Re-not-always">E.17: Non cercare di catturare tutte le eccezioni da tutte le funzioni</a></p></li>
<li><p><a href="#Re-catch">E.18: Minimizzare l’uso di <code>try</code>/<code>catch</code></a> espliciti</p></li>
<li><p><a href="#Re-finally">E.19: Usare un oggetto <code>final_action</code> per la pulizia [cleanup] se non è disponibile un gestore delle risorse adatto</a></p></li>
<li><p><a href="#Re-no-throw-raii">E.25: Se non è possibile sollevare eccezioni, simulare il RAII per la gestione delle risorse</a></p></li>
<li><p><a href="#Re-no-throw-crash">E.26: Se non è possibile sollevare eccezioni, si prenda in considerazione un veloce fallimento</a></p></li>
<li><p><a href="#Re-no-throw-codes">E.27: Se non è possibile sollevare eccezioni, si usino sistematicamente i codici di errore</a></p></li>
<li><p><a href="#Re-no-throw">E.28: Evitare la gestione degli errori basata su uno stato globale (p.es. <code>errno</code>)</a></p></li>
<li><p><a href="#Re-specifications">E.30: Non utilizzare le specifiche delle eccezioni</a></p></li>
<li><p><a href="#Re_catch">E.31: Ordinare in modo appropriato le proprie istruzioni <code>catch</code></a></p></li>
</ul>
<h3 id="e.1-sviluppare-una-strategia-di-gestione-degli-errori-nelle-prime-fasi-di-un-progetto"><a name="Re-design"></a>E.1: Sviluppare una strategia di gestione degli errori nelle prime fasi di un progetto</h3>
<h5 id="motivo-304">Motivo</h5>
<p>Una strategia coerente e completa per la gestione degli errori e i leak delle risorse è difficile da aggiornare in un sistema.</p>
<h3 id="e.2-generare-uneccezione-per-segnalare-che-una-funzioni-non-può-eseguire-il-proprio-compito"><a name="Re-throw"></a>E.2: Generare un’eccezione per segnalare che una funzioni non può eseguire il proprio compito</h3>
<h5 id="motivo-305">Motivo</h5>
<p>Per rendere la gestione degli errori sistematica, robusta e non-ripetitiva.</p>
<h5 id="esempio-273">Esempio</h5>
<pre><code>struct Foo {
vector&lt;Thing&gt; v;
File_handle f;
string s;
};

void use()
{
Foo bar {{Thing{1}, Thing{2}, Thing{monkey}}, {&quot;my_file&quot;, &quot;r&quot;}, &quot;Eccoci qui!&quot;};
// ...
}</code></pre>
<p>Qui, i costruttori <code>vector</code> e <code>string</code> potrebbero non essere in grado di allocare abbastanza memoria per i loro elementi, il costruttore di <code>vector</code> potrebbe non essere in grado di copiare le <code>Thing</code> nella sua lista degli inizializzatori, e <code>File_handle</code> potrebbe non essere in grado di aprire il file richiesto. In ogni caso, generano un errore per gestire il chiamante di <code>use()</code>. Se <code>use()</code> è in grado di gestire il fallimento nel costruire <code>bar</code> può assumere il controllo usando <code>try</code>/<code>catch</code>. in entrambi i casi, il costruttore di <code>Foo</code> distrugge correttamente i membri prima di passare il controllo a chiunque abbia tentato di creare un <code>Foo</code>. Si noti che non esiste alcun valore ritorno che potrebbe contenere un codice di errore.</p>
<p>Il costruttore <code>File_handle</code> potrebbe essere definito in questo modo:</p>
<pre><code>File_handle::File_handle(const string&amp; name, const string&amp; mode)
:f{fopen(name.c_str(), mode.c_str())}
{
if (!f)
throw runtime_error{&quot;File_handle: could not open &quot; + name + &quot; as &quot; + mode};
}</code></pre>
<h5 id="note-266">Note</h5>
<p>Si dice spesso che le eccezioni siano destinate a segnalare eventi e fallimenti eccezionali. Tuttavia, è un po ’circolare perché “cos’è eccezionale?” Esempi:</p>
<ul>
<li>Un prerequisito che non può essere soddisfatto</li>
<li>Un costruttore che non è in grado di costruire un oggetto (impossibile stabilire il proprio <a href="#Rc-struct">invariante</a> della classe)</li>
<li>Un errore [out-of-range] (p.es., <code>v[v.size()] = 7</code>)</li>
<li>Impossibilità di acquisire una risorsa (p.es., la rete non è attiva)</li>
</ul>
<p>Al contrario, la conclusione di un normale ciclo non è eccezionale. A meno che il loop non fosse destinato a essere infinito, la terminazione è normale e prevista.</p>
<h5 id="note-267">Note</h5>
<p>Nn usare un <code>throw</code> come un semplice modo alternativo per tornare da una funzione.</p>
<h5 id="eccezione-48">Eccezione</h5>
<p>Alcuni sistemi, come quelli fortemente real-time richiedono la garanzia che un’azione venga intrapresa entro un tempo costante massimo (solitamente breve) noto prima dell’avvio dell’esecuzione. Questi sistemi possono usare le eccezioni solo se c’è uno strumento di supporto che preveda con precisione il tempo massimo per riprendersi da un <code>throw</code>.</p>
<p><strong>Si veda anche</strong>: <a href="#Re-raii">RAII</a></p>
<p><strong>Si veda anche</strong>: <a href="#Sd-noexcept">discussione</a></p>
<h5 id="note-268">Note</h5>
<p>Prima di decidere che non ci si può permettere o che non piace la gestione degli errori basata sulle eccezioni, si dia uno sguardo alle <a href="#Re-no-throw-raii">alternative</a>; queste hanno le loro complessità e i loro problemi. Inoltre, per quanto possibile, effettuare delle misure prima di fare affermazioni sull’efficienza.</p>
<h3 id="e.3-usare-le-eccezioni-solamente-per-la-gestione-degli-errori"><a name="Re-errors"></a>E.3: Usare le eccezioni solamente per la gestione degli errori</h3>
<h5 id="motivo-306">Motivo</h5>
<p>Per mantenere la gestione degli errori separata dal “codice ordinario.” le implementazioni del C++ tendono ad essere ottimizzate in base al presupposto che le eccezioni siano rare.</p>
<h5 id="esempio-da-non-fare-3">Esempio, da non fare</h5>
<pre><code>// da non fare: l&#39;eccezione non è usata per la gestione degli errori
int find_index(vector&lt;string&gt;&amp; vec, const string&amp; x)
{
try {
for (gsl::index i = 0; i &lt; vec.size(); ++i)
if (vec[i] == x) throw i;  // trovato x
} catch (int i) {
return i;
}
return -1;   // non trovato
}</code></pre>
<p>Questo è più complicato e molto probabilmente gira molto più lentamente dell’alternativa ovvia. Non c’è niente di eccezionale nel trovare un valore in un <code>vector</code>.</p>
<h5 id="imposizione-281">Imposizione</h5>
<p>Dovrebbe essere euristico. Cercare i valori “persi [leaked]” delle istruzioni <code>catch</code>.</p>
<h3 id="e.4-progettarsi-la-propria-strategia-di-gestione-degli-errori-basandosi-sugli-invarianti"><a name="Re-design-invariants"></a>E.4: Progettarsi la propria strategia di gestione degli errori basandosi sugli invarianti</h3>
<h5 id="motivo-307">Motivo</h5>
<p>Per usare un oggetto esso deve essere in uno stato valido (definito formalmente o informalmente da un invariante) e per recuperare da un errore ogni oggetto non distrutto deve essere in uno stato valido.</p>
<h5 id="note-269">Note</h5>
<p>Un <a href="#Rc-struct">invariante</a> è una condizione logica per i membri di un oggetto che un costruttore deve stabilire affinché sia assunto dalle funzioni membro pubbliche.</p>
<h5 id="imposizione-282">Imposizione</h5>
<p>???</p>
<h3 id="e.5-consentire-ad-un-costruttore-di-stabilire-un-invariante-e-sollevare-un-errore-se-non-può"><a name="Re-invariant"></a>E.5: Consentire ad un costruttore di stabilire un invariante, e sollevare un errore se non può</h3>
<h5 id="motivo-308">Motivo</h5>
<p>Lasciare un oggetto senza il suo invariante stabilito vuol dire andare in cerca di guai. Non tutte le funzioni membro si possono chiamare.</p>
<h5 id="esempio-274">Esempio</h5>
<pre><code>class Vector {  // un vettore di double molto semplificato
// if elem != nullptr then elem punta a sz doubles
public:
Vector() : elem{nullptr}, sz{0}{}
Vector(int s) : elem{new double[s]}, sz{s} { /* initializza gli elementi */ }
~Vector() { delete [] elem; }
double&amp; operator[](int s) { return elem[s]; }
// ...
private:
owner&lt;double*&gt; elem;
int sz;
};</code></pre>
<p>L’invariante della classe - qui definito come commento - è stabilito dal suo costruttore. <code>new</code> solleva un errore se non può allocare la memoria richiesta. Gli operatori, in particolare l’operatore di indicizzazione [subscript], si basano sull’invariante.</p>
<p><strong>Si veda anche </strong>: <a href="#Rc-throw">Se un costruttore non è in grado di costruire un oggetto valido, generare un’eccezione</a></p>
<h5 id="imposizione-283">Imposizione</h5>
<p>Segnalare le classi con <code>private</code> definito senza un costruttore (public, protected, o private).</p>
<h3 id="e.6-usare-il-raii-per-evitare-i-leak"><a name="Re-raii"></a>E.6: Usare il RAII per evitare i leak</h3>
<h5 id="motivo-309">Motivo</h5>
<p>I leak sono generalmente inaccettabili. Il rilascio manuale delle risorse è soggetto a errori. Il RAII (“Resource Acquisition Is Initialization”) è il modo più semplice e sistematico per prevenire i leak.</p>
<h5 id="esempio-275">Esempio</h5>
<pre><code>void f1(int i)   // Non buono: possibile leak
{
int* p = new int[12];
// ...
if (i &lt; 17) throw Bad{&quot;in f()&quot;, i};
// ...
}</code></pre>
<p>Si potrebbe rilasciare la risorsa prima di sollevare l’eccezione:</p>
<pre><code>void f2(int i)   // Goffo e soggetto a errori: rilascio esplicito
{
int* p = new int[12];
// ...
if (i &lt; 17) {
delete[] p;
throw Bad{&quot;in f()&quot;, i};
}
// ...
}</code></pre>
<p>Questo è prolisso. Nel codice più complesso con più possibili <code>throw</code> il rilascio esplicito diventa ripetitivo e soggetto ad errori.</p>
<pre><code>void f3(int i)   // OK: la gestione delle risorse è fatta a mano (ma si veda in seguito)
{
auto p = make_unique&lt;int[]&gt;(12);
// ...
if (i &lt; 17) throw Bad{&quot;in f()&quot;, i};
// ...
}</code></pre>
<p>Si noti che questo funziona anche quando il <code>throw</code> è implicito perché avviene in una funzione chiamata:</p>
<pre><code>void f4(int i)   // OK: la gestione delle risorse è fatta a mano (ma si veda in seguito)
{
auto p = make_unique&lt;int[]&gt;(12);
// ...
helper(i);   // può eseguire throw
// ...
}</code></pre>
<p>A meno che non sia davvero necessaria la semantica del puntatore, utilizzare un oggetto con risorsa locale:</p>
<pre><code>void f5(int i)   // OK: gestione delle risorse fatta da un oggetto locale
{
vector&lt;int&gt; v(12);
// ...
helper(i);   // può eseguire throw
// ...
}</code></pre>
<p>È ancora più semplice e sicuro e spesso è più efficiente.</p>
<h5 id="note-270">Note</h5>
<p>Se non c’è alcun gestore delle risorse ovvio e per qualche motivo non è possibile definire un appropriato oggetto/handle, come ultima risorsa, le azioni di ripulitura [cleanup] possono essere rappresentate da un oggetto <a href="#Re-finally"><code>final_action</code></a>.</p>
<h5 id="note-271">Note</h5>
<p>Ma cosa si fa se si sta scrivendo un programma in cui non è possibile usare le eccezioni? Primo confutare quest’assunto; ci sono molti falsi miti contro le eccezioni. Si conoscono solo alcuni buoni motivi:</p>
<ul>
<li>Si è su un sistema talmente piccolo che il supporto delle eccezioni si prenderebbe gran parte dei 2K di memoria disponibile.</li>
<li>Si è su un sistema hard-real-time e non ci sono tool che ci garantiscano che un’eccezione venga gestita nel tempo richiesto.</li>
<li>Si è su un sistema con un sacco di codice pre-esistente che usa tantissimi puntatori difficili-da-capire (in particolare senza una strategia riconoscibile della proprietà [ownership]) quindi le eccezioni potrebbero causare leak.</li>
<li>L’implementazione dei meccanismi delle eccezioni C++ è irragionevolmente scarsa (lenta, richiede memoria, non funziona bene con le librerie linkate dinamicamente, ecc.). Ci si deve lamentare col proprio fornitore dell’implementazione; se nessuno si lamenta, non ci sarà nessun miglioramento.</li>
<li>Si verrà licenziati se sfiderà l’antica saggezza del proprio capo.</li>
</ul>
<p>Solo il primo, di questi motivi, è fondamentale, quindi laddove è possibile, usare le eccezioni per implementare il RAII, o progettarsi i propri oggetti per non fallire mai. Quando non si possono usare le eccezioni, simulare il RAII. Ovvero, controllare sistematicamente che gli oggetti sono ancora validi dopo la costruzione e che rilasceranno tutte le risorse nel distruttore. Una strategia consiste nell’aggiungere un’operazione <code>valid()</code> ad ogni handle delle risorse:</p>
<pre><code>void f()
{
vector&lt;string&gt; vs(100);   // non std::vector: aggiunto valid()
if (!vs.valid()) {
// gestire l&#39;errore o uscire
}

ifstream fs(&quot;foo&quot;);   // non std::ifstream: aggiunto valid()
if (!fs.valid()) {
// gestire l&#39;errore o uscire
}

// ...
} // i distruttori ripuliscono come al solito</code></pre>
<p>Ovviamente, questo aumenta la dimensione del codice, non consente la propagazione implicita delle “eccezioni” (i controlli di <code>valid()</code>), e i controlli di <code>valid()</code> si possono dimenticare. Preferire l’uso delle eccezioni.</p>
<p><strong>Si veda anche</strong>: <a href="#Re-noexcept">Uso di <code>noexcept</code></a></p>
<h5 id="imposizione-284">Imposizione</h5>
<p>???</p>
<h3 id="e.7-dichiarare-le-proprie-pre-condizioni"><a name="Re-precondition"></a>E.7: Dichiarare le proprie pre-condizioni</h3>
<h5 id="motivo-310">Motivo</h5>
<p>Per evitare errori di interfaccia.</p>
<p><strong>Si veda anche </strong>: <a href="#Ri-pre">regole sulla pre-condizione</a></p>
<h3 id="e.8-dichiarare-le-proprie-post-condizioni"><a name="Re-postcondition"></a>E.8: Dichiarare le proprie post-condizioni</h3>
<h5 id="motivo-311">Motivo</h5>
<p>Per evitare errori di interfaccia.</p>
<p><strong>Si veda anche </strong>: <a href="#Ri-post">regole della post-condizione</a></p>
<h3 id="e.12-usare-noexcept-uscendo-da-una-funzione-quando-un-throw-uneccezione-è-impossibile-o-inaccettabile"><a name="Re-noexcept"></a>E.12: Usare <code>noexcept</code> uscendo da una funzione quando un <code>throw</code> (un’eccezione) è impossibile o inaccettabile</h3>
<h5 id="motivo-312">Motivo</h5>
<p>Per rendere la gestione degli errori sistematica, solida ed efficiente.</p>
<h5 id="esempio-276">Esempio</h5>
<pre><code>double compute(double d) noexcept
{
return log(sqrt(d &lt;= 0 ? 1 : d));
}</code></pre>
<p>Qui, si sa che <code>compute</code> non solleverà eccezioni perché è composta da operazioni che non generano errori. Affermando che <code>compute</code> è <code>noexcept</code>, si informa compilatore e i lettori umani che si può semplificare la comprensione e la gestione di <code>compute</code>.</p>
<h5 id="note-272">Note</h5>
<p>Molte funzioni della libreria standard sono <code>noexcept</code> comprese tute quelle “ereditate” dalla Libreria Standard del C.</p>
<h5 id="esempio-277">Esempio</h5>
<pre><code>vector&lt;double&gt; munge(const vector&lt;double&gt;&amp; v) noexcept
{
vector&lt;double&gt; v2(v.size());
// ... fa qualcosa ...
}</code></pre>
<p>Qui il <code>noexcept</code> indica che non si è disposti o non si è in grado di gestire la situazione in cui non si può costruire il <code>vector</code> locale. Cioè, si considera l’esaurimento della memoria un grave errore di progettazione (al pari dei guasti hardware), quindi si è disposti a bloccare il programma se capita.</p>
<h5 id="note-273">Note</h5>
<p>Non usare le tradizionali <a href="#Re-specifications">specifiche delle eccezioni [exception-specification]</a>.</p>
<h5 id="si-veda-anche-4">Si veda anche</h5>
<p><a href="#Sd-noexcept">discussione</a>.</p>
<h3 id="e.13-mai-sollevare-eccezioni-quando-si-è-i-diretti-proprietari-owner-di-un-oggetto"><a name="Re-never-throw"></a>E.13: Mai sollevare eccezioni quando si è i diretti proprietari [owner] di un oggetto</h3>
<h5 id="motivo-313">Motivo</h5>
<p>Ci sarebbe un leak.</p>
<h5 id="esempio-278">Esempio</h5>
<pre><code>void leak(int x)   // da non fare: può essere un leak
{
auto p = new int{7};
if (x &lt; 0) throw Get_me_out_of_here{};  // può essere un leak di *p
// ...
delete p;   // si potrebbe non arrivare mai qui
}</code></pre>
<p>Un modo per evitare tali problemi è utilizzare i gestori delle risorse in modo coerente:</p>
<pre><code>void no_leak(int x)
{
auto p = make_unique&lt;int&gt;(7);
if (x &lt; 0) throw Get_me_out_of_here{};  // se necessario eseguirà delete di *p
// ...
// non c&#39;è bisogno del delete di p
}</code></pre>
<p>Un’altra soluzione (spesso migliore) sarebbe quella di utilizzare una variabile locale per evitare l’uso esplicito di puntatori:</p>
<pre><code>void no_leak_simplified(int x)
{
vector&lt;int&gt; v(7);
// ...
}</code></pre>
<h5 id="note-274">Note</h5>
<p>Se si hanno “cose” locali che richiedono la pulizia [cleanup], ma non sono rappresentate da un oggetto con un distruttore, tale pulizia dev’essere fatta anche prima di un <code>throw</code>. A volte, <a href="#Re-finally"><code>finally()</code></a> può rendere questa sistematicamente pulizia un po’ più gestibile.</p>
<h3 id="e.14-usare-tipi-appositamente-progettati-o-user-defined-come-eccezioni-non-i-tipi-built-in"><a name="Re-exception-types"></a>E.14: Usare tipi appositamente progettati o [user-defined] come eccezioni (non i tipi [built-in])</h3>
<h5 id="motivo-314">Motivo</h5>
<p>È improbabile che un tipo definito dall’utente si scontri con le eccezioni di altri.</p>
<h5 id="esempio-279">Esempio</h5>
<pre><code>void my_code()
{
// ...
throw Moonphase_error{};
// ...
}

void your_code()
{
try {
// ...
my_code();
// ...
}
catch(const Bufferpool_exhausted&amp;) {
// ...
}
}</code></pre>
<h5 id="esempio-da-non-fare-4">Esempio, da non fare</h5>
<pre><code>void my_code()     // Da non fare
{
// ...
throw 7;       // 7 significa &quot;luna calante&quot;
// ...
}

void your_code()   // Da non fare
{
try {
// ...
my_code();
// ...
}
catch(int i) {  // i == 7 significa &quot;buffer di input troppo piccolo&quot;
// ...
}
}</code></pre>
<h5 id="note-275">Note</h5>
<p>Le classi della libreria standard derivate da <code>exception</code> devono essere utilizzate solo come classi base o per le eccezioni che richiedono solo una “generica”. Come i tipi [built-in], il loro uso potrebbe collidere con gli usi altrui.</p>
<h5 id="esempio-da-non-fare-5">Esempio, da non fare</h5>
<pre><code>void my_code()   // Da non fare
{
// ...
throw runtime_error{&quot;luna calante&quot;};
// ...
}

void your_code()   // Da non fare
{
try {
// ...
my_code();
// ...
}
catch(const runtime_error&amp;) {   // runtime_error significa &quot;buffer di input troppo piccolo&quot;
// ...
}
}</code></pre>
<p><strong>Si veda anche la </strong>: <a href="#Sd-???">Discussione</a></p>
<h5 id="imposizione-285">Imposizione</h5>
<p>Catturare <code>throw</code> e <code>catch</code> di un tipo [built-in]. Forse avvisare di dover eseguire <code>throw</code> e <code>catch</code> utilizzando il tipo <code>exception</code> della libreria standard. Ovviamente, le eccezioni derivate dalla gerarchia <code>std::exception</code> vanno bene.</p>
<h3 id="e.15-catturare-le-eccezioni-da-una-gerarchia-per-riferimento"><a name="Re-exception-ref"></a>E.15: Catturare le eccezioni da una gerarchia per riferimento</h3>
<h5 id="motivo-315">Motivo</h5>
<p>Per evitare lo [slicing].</p>
<h5 id="esempio-280">Esempio</h5>
<pre><code>void f()
{
try {
// ...
}
catch (exception e) {   // da non fare: può provocare lo [slicing]
// ...
}
}</code></pre>
<p>Usare, invece, un riferimento:</p>
<pre><code>catch (exception&amp; e) { /* ... */ }</code></pre>
<p>o - generalmente ancor meglio - un riferimento <code>const</code>:</p>
<pre><code>catch (const exception&amp; e) { /* ... */ }</code></pre>
<p>La maggior parte dei gestori non modificano la propria eccezione e in generale <a href="#Res-const">si consiglia l’uso di <code>const</code></a>.</p>
<h5 id="note-276">Note</h5>
<p>Per rilanciare [rethrow] un’eccezione rilevata usare <code>throw;</code> non <code>throw e;</code>. Utilizzando <code>throw e;</code> si genererebbe una nuova copia di <code>e</code> ([sliced] nel tipo statico <code>std::exception</code>) anziché ri-sollevare l’eccezione originale di tipo <code>std::runtime_error</code>. (Ma si tengano in mente <a href="#Re-not-always">Non cercare di catturare tutte le eccezioni da tutte le funzioni</a> e <a href="#Re-catch">Minimizzare l’uso di <code>try</code>/<code>catch</code></a> espliciti).</p>
<h5 id="imposizione-286">Imposizione</h5>
<p>Segnalare le eccezioni per valore se i loro tipi fanno parte di una gerarchia (potrebbe richiedere l’analisi dell’intero programma per essere perfetta).</p>
<h3 id="e.16-i-distruttori-la-de-allocazione-e-swap-non-devono-mai-fallire"><a name="Re-never-fail"></a>E.16: I distruttori, la de-allocazione e <code>swap</code> non devono mai fallire</h3>
<h5 id="motivo-316">Motivo</h5>
<p>Non sappiamo come scrivere programmi affidabili se un distruttore, uno swap, o una de-allocazione della memoria fallisce; ovvero, se esce per un’eccezione o semplicemente non esegue l’azione richiesta.</p>
<h5 id="esempio-da-non-fare-6">Esempio, da non fare</h5>
<pre><code>class Connection {
// ...
public:
~Connection()   // Da non fare: pessimo distruttore
{
if (cannot_disconnect()) throw I_give_up{information};
// ...
}
};</code></pre>
<h5 id="note-277">Note</h5>
<p>Molti hanno provato a scrivere codice affidabile violando questa regola per esempio, come una connessione di rete che si “rifiuta di chiudersi”. Per quanto ne sappiamo, nessuno ha trovato un modo generale per farlo. Occasionalmente, per esempi molto specifici, è possibile cavarsela impostando un certo stato per una successiva pulizia. Per esempio, si potrebbe mettere un socket che non vuoe chiudersi in una lista dei “socket cattivi”, per poi esaminare la lista con una regolare scansione dello stato del sistema. Ogni esempio visto a questo proposito è soggetto a errori, specializzato e spesso bacato.</p>
<h5 id="note-278">Note</h5>
<p>La libreria standard presuppone che i distruttori, le funzioni di deallocazione (p.es., <code>operator delete</code>), e <code>swap</code> non emettano errori [throw]. Se lo fanno, gli invarianti basilari della libreria standard vengono infranti.</p>
<h5 id="note-279">Note</h5>
<p>Le funzioni di de-allocazione, compreso <code>operator delete</code>, devono essere <code>noexcept</code>. Le funzioni <code>swap</code> devono essere <code>noexcept</code>. La maggior parte dei distruttori sono implicitamente <code>noexcept</code> per default. Inoltre, <a href="#Rc-move-noexcept">creare le operazioni di [move] come <code>noexcept</code></a>.</p>
<h5 id="imposizione-287">Imposizione</h5>
<p>Catturare i distruttori, le operazioni di de-allocazione e gli <code>swap</code> che eseguono <code>throw</code>. Catturare tali operazioni che non sono <code>noexcept</code>.</p>
<p><strong>Si veda anche</strong>: <a href="#Sd-never-fail">discussione</a></p>
<h3 id="e.17-non-cercare-di-catturare-tutte-le-eccezioni-da-tutte-le-funzioni"><a name="Re-not-always"></a>E.17: Non cercare di catturare tutte le eccezioni da tutte le funzioni</h3>
<h5 id="motivo-317">Motivo</h5>
<p>Catturare un’eccezione in una funzione che non esegue una significativa azione di recupero comporta complessità e spreco. Lasciare che un’eccezione si propaghi fino a raggiunger una funzione che la possa gestire. Lasciare che le azioni di pulizia [cleanup] sul percorso attraversato sia gestita dal <a href="#Re-raii">RAII</a>.</p>
<h5 id="esempio-da-non-fare-7">Esempio, da non fare</h5>
<pre><code>void f()   // non buono
{
try {
// ...
}
catch (...) {
// nessuna azione
throw;   // propaga l&#39;eccezione
}
}</code></pre>
<h5 id="imposizione-288">Imposizione</h5>
<ul>
<li>Segnalare i blocchi-try nidificati.</li>
<li>Segnalare i file di codice sorgente con un rapporto troppo alto di blocchi-try-blocks a funzioni. (??? Problema: definire “troppo alto”)</li>
</ul>
<h3 id="e.18-minimizzare-luso-di-trycatch-espliciti"><a name="Re-catch"></a>E.18: Minimizzare l’uso di <code>try</code>/<code>catch</code> espliciti</h3>
<h5 id="motivo-318">Motivo</h5>
<p><code>try</code>/<code>catch</code> è prolisso e gli usi non banali sono soggetti a errori. <code>try</code>/<code>catch</code> può essere un segno di una gestione delle risorse non sistematica e/o di basso livello oppure soggetto a errori.</p>
<h5 id="esempio-cattivo-123">Esempio, Cattivo</h5>
<pre><code>void f(zstring s)
{
Gadget* p;
try {
p = new Gadget(s);
// ...
delete p;
}
catch (Gadget_construction_failure) {
delete p;
throw;
}
}</code></pre>
<p>Questo codice è disordinato. Potrebbe esserci un leak dal semplice puntatore nel blocco <code>try</code>. Non tutte le eccezioni vengono gestite. Il <code>deleting</code> di un oggetto che di cui è fallita la costruzione è quasi certamente un errore. Meglio:</p>
<pre><code>void f2(zstring s)
{
Gadget g {s};
}</code></pre>
<h5 id="alternative-4">Alternative</h5>
<ul>
<li>Gestori delle risorse appropriati e <a href="#Re-raii">RAII</a></li>
<li><a href="#Re-finally">utilizzare <code>finally</code></a></li>
</ul>
<h5 id="imposizione-289">Imposizione</h5>
<p>??? difficile, necessita di una euristica</p>
<h3 id="e.19-sare-un-oggetto-final_action-per-la-pulizia-cleanup-se-non-è-disponibile-un-gestore-delle-risorse-adatto"><a name="Re-finally"></a>E.19: sare un oggetto <code>final_action</code> per la pulizia [cleanup] se non è disponibile un gestore delle risorse adatto</h3>
<h5 id="motivo-319">Motivo</h5>
<p><code>finally</code> è meno prolisso più difficile che da sbagliare rispetto a <code>try</code>/<code>catch</code>.</p>
<h5 id="esempio-281">Esempio</h5>
<pre><code>void f(int n)
{
void* p = malloc(n);
auto _ = finally([p] { free(p); });
// ...
}</code></pre>
<h5 id="note-280">Note</h5>
<p><code>finally</code> non è disordinato come <code>try</code>/<code>catch</code>, ma resta una soluzione ad-hoc. Preferire <a href="#Re-raii">oggetti per la gestione delle risorse</a>. Considerare <code>finally</code> come ultima risorsa.</p>
<h5 id="note-281">Note</h5>
<p>L’uso di <code>finally</code> è un’alternativa sistematica e ragionevolmente pulita rispetto alla vecchia tecnica <a href="#Re-no-throw-codes"><code>goto exit;</code></a> per gestire la pulizia [cleanup] dove la gestione delle risorse non è sistematica.</p>
<h5 id="imposizione-290">Imposizione</h5>
<p>Euristica: Rilevare <code>goto exit;</code></p>
<h3 id="e.25-se-non-è-possibile-sollevare-eccezioni-simulare-il-raii-per-la-gestione-delle-risorse"><a name="Re-no-throw-raii"></a>E.25: Se non è possibile sollevare eccezioni, simulare il RAII per la gestione delle risorse</h3>
<h5 id="motivo-320">Motivo</h5>
<p>Anche senza eccezioni, il <a href="#Re-raii">RAII</a> è solitamente il modo migliore e più sistematico per gestire le risorse.</p>
<h5 id="note-282">Note</h5>
<p>La gestione degli errori con le eccezioni è il solo modo completo e sistematico per gestire errori non-locali nel C++. In particolare, la segnalazione non-intrusiva del fallimento della costruzione di un oggetto richiede un’eccezione. Segnalare gli errori in modo che non si possano ignorare richiede le eccezioni. Se non si possono usare eccezioni, si dovrebbero simulare al meglio.</p>
<p>La paura delle eccezioni è ingiustificata. Se utilizzato per circostanze eccezionali in un codice che non sia disseminato di puntatori e di complicate strutture di controllo, la gestione delle eccezioni è quasi sempre conveniente (nel tempo e nello spazio) e quasi sempre porta a un codice migliore. Ciò, ovviamente, presuppone una buona implementazione dei meccanismi di gestione delle eccezioni, che non è disponibile su tutti i sistemi. Ci sono anche casi in cui i problemi sopra indicati non si applicano, ma le eccezioni non possono essere utilizzate per altri motivi. Alcuni sistemi di [hard-real-time] sono un esempio: Un’operazione deve essere completata entro un tempo fisso sia con una risposta corretta che con un errore. In assenza di adeguati strumenti per la stima del tempo, è difficile da garantire questo per le eccezioni. Tali sistemi (p.es. software per il controllo aereo) generalmente vietano anche l’uso della memoria dinamica (heap).</p>
<p>Quindi, la principale linea-guida per la gestione degli errori è “usare le eccezioni e il <a href="#Re-raii">RAII</a>”. Questa sezione tratta i casi in cui o non si dispone di un’implementazione efficiente delle eccezioni o si fa un ingarbugliato codice vecchio stile (p.es., tantissimi puntatori, proprietà [ownership] mal definita, e tantissimi gestori degli errori non sistematici basati sul test dei codici di errori) in cui non è possibile introdurre una gestione delle eccezioni semplice e sistematica.</p>
<p>Prima di condannare le eccezioni o lamentarsi troppo del loro costo, si prendano in considerazione esempi d’uso dei <a href="#Re-no-throw-codes">codici di errore</a>. Considerare il costo e la complessità dell’uso dei codici di errore. Se si è preoccupati delle prestazioni, misurare.</p>
<h5 id="esempio-282">Esempio</h5>
<p>Si supponga di aver voluto scrivere</p>
<pre><code>void func(zstring arg)
{
Gadget g {arg};
// ...
}</code></pre>
<p>Se il <code>gadget</code> non è ben costruito, <code>func</code> esce con un’eccezione. Se non si possono generare eccezioni, si può simulare questo stile RAII della gestione delle risorse aggiungendo la funzione membro <code>valid()</code> a <code>Gadget</code>:</p>
<pre><code>error_indicator func(zstring arg)
{
Gadget g {arg};
if (!g.valid()) return gadget_construction_error;
// ...
return 0;   // zero indica &quot;buono&quot;
}</code></pre>
<p>Il problema è, ovviamente, che ora il chiamante deve ricordarsi di controllare il valore di ritorno.</p>
<p><strong>Si veda anche la </strong>: <a href="#Sd-???">Discussione</a></p>
<h5 id="imposizione-291">Imposizione</h5>
<p>Possibile (solo) per specifiche versioni di questa idea: p.es., test per i controlli sistematici di <code>valid()</code> dpo la costruzione del gestore delle risorse</p>
<h3 id="e.26-se-non-è-possibile-sollevare-eccezioni-si-prenda-in-considerazione-un-veloce-fallimento"><a name="Re-no-throw-crash"></a>E.26: Se non è possibile sollevare eccezioni, si prenda in considerazione un veloce fallimento</h3>
<h5 id="motivo-321">Motivo</h5>
<p>Se non si può recuperare per bene, si può almeno uscire prima di fare troppi ulteriori danni.</p>
<p><strong>Si veda anche </strong>: <a href="#Re-no-throw-raii">Simulare il RAII</a></p>
<h5 id="note-283">Note</h5>
<p>Se non si può essere sistematici sulla gestione degli errori, si consideri il “crash” come risposta a tutti gli errori che non si possono gestire localmente. Cioè, se non è possibile riprendersi da un errore nel contesto della funzione che l’ha rilevato, si chiama <code>abort()</code>, <code>quick_exit()</code>, o una funzione simile che attiverà qualche tipo di riavvio del sistema.</p>
<p>Nei sistemi con tantissimi processi e/o molti computer, ci si deve comunque aspettare e gestire dei crash fatali, ad esempio i guasti hardware. In questi casi, “crashando” si sta semplicemente lasciando la gestione degli errori al successivo livello del sistema.</p>
<h5 id="esempio-283">Esempio</h5>
<pre><code>void f(int n)
{
// ...
p = static_cast&lt;X*&gt;(malloc(n * sizeof(X)));
if (!p) abort();     // abortisce se la memoria è esaurita
// ...
}</code></pre>
<p>La maggior parte dei programmi non è comunque in grado di gestire adeguatamente l’esaurimento della memoria. Ciò equivale a</p>
<pre><code>void f(int n)
{
// ...
p = new X[n];    // emette un&#39;eccezione [throw] se la memoria è esaurita (per default, termina)
// ...
}</code></pre>
<p>Solitamente, è bene loggare il motivo del “crash” prima di uscire.</p>
<h5 id="imposizione-292">Imposizione</h5>
<p>Difficile</p>
<h3 id="e.27-se-non-è-possibile-sollevare-eccezioni-si-usino-sistematicamente-i-codici-di-errore"><a name="Re-no-throw-codes"></a>E.27: Se non è possibile sollevare eccezioni, si usino sistematicamente i codici di errore</h3>
<h5 id="motivo-322">Motivo</h5>
<p>L’uso sistematico di qualsiasi strategia per la gestione degli errori minimizza le possibilità di dimenticarsi di gestire un errore.</p>
<p><strong>Si veda anche </strong>: <a href="#Re-no-throw-raii">Simulare il RAII</a></p>
<h5 id="note-284">Note</h5>
<p>Ci sono diversi problemi da affrontare:</p>
<ul>
<li>Come trasmettere l’indicazione di un errore dall’esterno di una funzione?</li>
<li>Come si rilasciano tutte le risorse da una funzione prima di uscire per un errore?</li>
<li>Cosa usare per indicare un errore?</li>
</ul>
<p>In generale, la restituzione di un indicatore di errore implica la restituzione di due valori: Il risultato e l’indicatore dell’errore. L’indicatore dell’errore può far parte dell’oggetto, p.es. un oggetto può avere un indicatore <code>valid()</code> o si può ritornare una coppia di valori.</p>
<h5 id="esempio-284">Esempio</h5>
<pre><code>Gadget make_gadget(int n)
{
// ...
}

void user()
{
Gadget g = make_gadget(17);
if (!g.valid()) {
// gestione dell&#39;errore
}
// ...
}</code></pre>
<p>Questo approccio è del tipo <a href="#Re-no-throw-raii">gestione delle risorse RAII simulata</a>. La funzione <code>valid()</code> potrebbe restituire un <code>error_indicator</code> (p.es. un membro di un’enumerazione <code>error_indicator</code>).</p>
<h5 id="esempio-285">Esempio</h5>
<p>Cosa succede se non si può o non si vuole modificare il tipo <code>Gadget</code>? In questo caso si deve ritornare una coppia di valori. Per esempio:</p>
<pre><code>std::pair&lt;Gadget, error_indicator&gt; make_gadget(int n)
{
// ...
}

void user()
{
auto r = make_gadget(17);
if (!r.second) {
// gestione dell&#39;errore
}
Gadget&amp; g = r.first;
// ...
}</code></pre>
<p>Come mostrato, <code>std::pair</code> è un possibile tipo di ritorno. Qualcuno preferisce un tipo specifico. Per esempio:</p>
<pre><code>Gval make_gadget(int n)
{
// ...
}

void user()
{
auto r = make_gadget(17);
if (!r.err) {
// gestione dell&#39;errore
}
Gadget&amp; g = r.val;
// ...
}</code></pre>
<p>Uno dei motivi per preferire un tipo di ritorno specifico è quello di avere dei nomi per i suoi membri, piuttosto che i criptici <code>first</code> e <code>second</code> evitando confusione con altri utilizzi di <code>std::pair</code>.</p>
<h5 id="esempio-286">Esempio</h5>
<p>In generale, è necessario ripulire prima di uscire per un errore. Questo può risultare caotico:</p>
<pre><code>std::pair&lt;int, error_indicator&gt; user()
{
Gadget g1 = make_gadget(17);
if (!g1.valid()) {
return {0, g1_error};
}

Gadget g2 = make_gadget(17);
if (!g2.valid()) {
cleanup(g1);
return {0, g2_error};
}

// ...

if (all_foobar(g1, g2)) {
cleanup(g1);
cleanup(g2);
return {0, foobar_error};
// ...

cleanup(g1);
cleanup(g2);
return {res, 0};
}</code></pre>
<p>La simulazione del RAII può risultare complicata, specie nelle funzioni con più risorse e molteplici tipi di errori. Una tecnica non rara consiste nel raccogliere la pulizia alla fine della funzione per evitare ripetizioni (si noti che l’ulteriore scope attorno a <code>g2</code> non è desiderabile ma necessario per compilare la versione col <code>goto</code>):</p>
<pre><code>std::pair&lt;int, error_indicator&gt; user()
{
error_indicator err = 0;

Gadget g1 = make_gadget(17);
if (!g1.valid()) {
err = g1_error;
goto exit;
}

{
Gadget g2 = make_gadget(17);
if (!g2.valid()) {
err = g2_error;
goto exit;
}

if (all_foobar(g1, g2)) {
err = foobar_error;
goto exit;
}
// ...
}

exit:
if (g1.valid()) cleanup(g1);
if (g2.valid()) cleanup(g2);
return {res, err};
}</code></pre>
<p>Più grande è la funzione, più allettante diventa questa tecnica. <code>finally</code> può <a href="#Re-finally">semplificare un po’</a>. Inoltre, più grande è il programma, più diventa difficile diventa applicare sistematicamente una strategia di gestione degli errori basata su indicatori di errore.</p>
<p>Si deve <a href="#Re-throw">preferire la gestione degli errori basata sulle eccezioni</a> e si raccomanda di <a href="#Rf-single">fare funzioni brevi</a>.</p>
<p><strong>Si veda anche la </strong>: <a href="#Sd-???">Discussione</a></p>
<p><strong>Si veda anche</strong>: <a href="#Rf-out-multi">Ritornare valori multipli</a></p>
<h5 id="imposizione-293">Imposizione</h5>
<p>Difficile.</p>
<h3 id="e.28-evitare-la-gestione-degli-errori-basata-su-uno-stato-globale-p.es.-errno"><a name="Re-no-throw"></a>E.28: Evitare la gestione degli errori basata su uno stato globale (p.es. <code>errno</code>)</h3>
<h5 id="motivo-323">Motivo</h5>
<p>Lo stato globale è difficile da gestire ed è facile che ci si dimentichi di controllarlo. Quando è stata l’ultima volta che si è testato il valore di ritorno di <code>printf()</code>?</p>
<p><strong>Si veda anche </strong>: <a href="#Re-no-throw-raii">Simulare il RAII</a></p>
<h5 id="esempio-cattivo-124">Esempio, cattivo</h5>
<pre><code>int last_err;

void f(int n)
{
// ...
p = static_cast&lt;X*&gt;(malloc(n * sizeof(X)));
if (!p) last_err = -1;     // errore se si esaurisce la memoria
// ...
}</code></pre>
<h5 id="note-285">Note</h5>
<p>La gestione degli errori in stile C è basata sulla variabile globale <code>errno</code>, quindi è essenzialmente impossibile evitare completamente questo stile.</p>
<h5 id="imposizione-294">Imposizione</h5>
<p>Difficile.</p>
<h3 id="e.30-non-utilizzare-le-specifiche-delle-eccezioni"><a name="Re-specifications"></a>E.30: Non utilizzare le specifiche delle eccezioni</h3>
<h5 id="motivo-324">Motivo</h5>
<p>Le specifiche delle eccezioni [exception specification] indeboliscono la gestione degli errori, impongono un costo nel run-time, e sono state rimosse dallo standard del C++.</p>
<h5 id="esempio-287">Esempio</h5>
<pre><code>int use(int arg)
throw(X, Y)
{
// ...
auto x = f(arg);
// ...
}</code></pre>
<p>Se <code>f()</code> solleva un’eccezione diversa da <code>X</code> e da <code>Y</code> viene richiamato il gestore degli imprevisti, che per default termina. Questo va bene, ma mettiamo che si sia verificato che questo non avvenga e <code>f</code> viene modificato per sollevare una nuova eccezione <code>Z</code>, ci si ritrova con un crash tra le mani a meno di non cambiare <code>use()</code> (e ri-testare il tutto). Il problema è che <code>f()</code> può stare in una libreria di cui non si ha il controllo e la nuova eccezione è qualcosa con cui <code>use()</code> non può farci nulla o a cui non è in qualche modo interessata. Si può cambiare <code>use()</code> per passarle <code>Z</code>, ma poi si dovranno modificare i chiamanti di <code>use()</code>. E questo diventa subito ingestibile. In alternative, si può aggiungere un <code>try</code>-<code>catch</code> a <code>use()</code> per mappare <code>Z</code> in un’eccezione accettabile. Anche questo, diventa presto ingestibile. Si noti che le modifiche al set di eccezioni spesso avvengono al livello più basso di un sistema (p.es., a causa di modifiche ad una libreria di network o da qualche parte nel middleware), pertanto le modifiche “risalgono” per tutta la catena delle chiamate. In un codice di larghe dimensioni, ciò potrebbe significare che nessuno potrà aggiornarsi a una nuova versione di una libreria finché non viene siano modificati tutti gli utenti. Se <code>use()</code> fa parte di una libreria, potrebbe non essere possibile aggiornarla perché un cambiamento potrebbe implicare clienti sconosciuti.</p>
<p>La politica di far propagare le eccezioni fino a raggiungere una funzione potenzialmente in grado di gestirla si è dimostrata valida nel corso degli anni.</p>
<h5 id="note-286">Note</h5>
<p>No. Non sarebbe stato meglio se le specifiche delle eccezioni sarebbero state imposte staticamente. Per esempio, si veda <a href="#Stroustrup94">Stroustrup94</a>.</p>
<h5 id="note-287">Note</h5>
<p>Se non è possibile generare alcuna eccezione, si usa <a href="#Re-noexcept"><code>noexcept</code></a> o il suo equivalente <code>throw()</code>.</p>
<h5 id="imposizione-295">Imposizione</h5>
<p>Segnalare ogni specifica di eccezione [exception specification].</p>
<h3 id="e.31-ordinare-in-modo-appropriato-le-proprie-istruzioni-catch"><a name="Re_catch"></a>E.31: Ordinare in modo appropriato le proprie istruzioni <code>catch</code></h3>
<h5 id="motivo-325">Motivo</h5>
<p>Le istruzioni <code>catch</code> vengono valutate nell’ordine con cui appaiono e un’istruzione può nasconderne altre.</p>
<h5 id="esempio-288">Esempio</h5>
<pre><code>void f()
{
// ...
try {
// ...
}
catch (Base&amp; b) { /* ... */ }
catch (Derived&amp; d) { /* ... */ }
catch (...) { /* ... */ }
catch (std::exception&amp; e){ /* ... */ }
}</code></pre>
<p>Se <code>Derived</code> è derivato da <code>Base</code> il gestore <code>Derived</code> non verrà mai invocato. Il gestore “acchiappa tutto” garantisce che il gestore <code>std::exception</code> non sia mai invocato.</p>
<h5 id="imposizione-296">Imposizione</h5>
<p>Segnalare tutti i “gestori nascosti”.</p>
<h1 id="con-costanti-e-immutabilità"><a name="S-const"></a>Con: Costanti e immutabilità</h1>
<p>Non può esserci una condizione di conflitto su una costante. È più facile ragionare su un programma quando molti degli oggetti non possono cambiare i loro valori. Le interfacce che promettono “nessun cambiamento” degli oggetti passati come argomenti migliorano notevolmente la leggibilità.</p>
<p>Riepilogo delle regole sulle costanti:</p>
<ul>
<li><a href="#Rconst-immutable">Con.1: Per default, creare oggetti immutabili</a></li>
<li><a href="#Rconst-fct">Con.2: Per default, creare le funzioni membro <code>const</code></a></li>
<li><a href="#Rconst-ref">Con.3: Per default, passare puntatori e riferimenti <code>const</code></a></li>
<li><a href="#Rconst-const">Con.4: Utilizzare <code>const</code> per definire oggetti con valori che non cambiano dopo la costruzione</a></li>
<li><a href="#Rconst-constexpr">Con.5: Utilizzare <code>constexpr</code> per i valori calcolabili durante la compilazione</a></li>
</ul>
<h3 id="con.1-per-default-creare-oggetti-immutabili"><a name="Rconst-immutable"></a>Con.1: Per default, creare oggetti immutabili</h3>
<h5 id="motivo-326">Motivo</h5>
<p>Gli oggetti immutabili sono più facili da gestire, quindi si creino oggetti non-<code>const</code> solo quando se ne deve cambiare il valore. Si previene una modifica del valore accidentale o difficile da notare .</p>
<h5 id="esempio-289">Esempio</h5>
<pre><code>for (const int i : c) cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;    // solo lettura: const

for (int i : c) cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;          // BAD: solo lettura</code></pre>
<h5 id="eccezione-49">Eccezione</h5>
<p>Gli argomenti delle funzioni vengono cambiati raramente, ma altrettanto raramente dichiarati const. Per evitare confusione ed un sacco di falsi positivi, non imporre questa regola agli argomenti delle funzioni.</p>
<pre><code>void f(const char* const p); // pedante
void g(const int i);        // pedante</code></pre>
<p>Si noti che i parametro della funzione è una variabile locale, quindi le sue modifiche sono locali.</p>
<h5 id="imposizione-297">Imposizione</h5>
<ul>
<li>Segnalare le variabili non-<code>const</code> che non vengono modificate (eccetto i parametri per evitare molti falsi positivi)</li>
</ul>
<h3 id="con.2-per-default-creare-le-funzioni-membro-const"><a name="Rconst-fct"></a>Con.2: Per default, creare le funzioni membro <code>const</code></h3>
<h5 id="motivo-327">Motivo</h5>
<p>Una funzione membro dovrebbe essere segnata come <code>const</code> a meno che non modifiche lo stato osservabile dell’oggetto. Ciò fornisce una dichiarazione più precisa dello scopo del progetto, una migliore leggibilità, più errori rilevati dal compilatore e talvolta maggiori possibilità di ottimizzazione.</p>
<h5 id="esempio-cattivo-125">Esempio, cattivo</h5>
<pre><code>class Point {
int x, y;
public:
int getx() { return x; }    // BAD, dovrebbe essere const in quanto non modifica lo stato dell&#39;oggetto
// ...
};

void f(const Point&amp; pt) {
int x = pt.getx();          // ERRORE, non compila perché getx non è stato segnato come const
}</code></pre>
<h5 id="note-288">Note</h5>
<p>Non è intrinsecamente un male passare un puntatore o un riferimento a non-<code>const</code>, ma dovrebbe essere fatto solo quando si suppone che la funzione chiamata modifichi l’oggetto. Chi legge il codice deve presumere che una funzione che prende un “semplice” <code>T*</code> o <code>T&amp;</code> modificherà l’oggetto a cui ci si riferisce. Se non lo fa per adesso, potrebbe farlo in seguito senza obbligare la ricompilazione.</p>
<h5 id="note-289">Note</h5>
<p>Ci sono codice/librerie che propongono funzioni che dichiarano un <code>T*</code> anche se quelle funzioni non modificano quel <code>T</code>. Questo è un problema per chi modernizza il codice. Si può</p>
<ul>
<li>aggiornare la libreria affinché abbia i <code>const</code> corretti; soluzione preferita per il lungo-termine</li>
<li>Eseguire il “cast di <code>const</code>”; <a href="#Res-casts-const">meglio evitare</a></li>
<li>fornire una funzione wrapper</li>
</ul>
<p>Esempio:</p>
<pre><code>void f(int* p);   // vecchio codice: f() non modifica `*p`
void f(const int* p) { f(const_cast&lt;int*&gt;(p)); } // wrapper</code></pre>
<p>Si noti che la soluzione del wrapper è una patch che si dovrebbe usare solo quando la dichiarazione di <code>f()</code> non può essere modificata, p.es. perché sta i una libreria che non può essere modificata.</p>
<h5 id="note-290">Note</h5>
<p>Una funzione membro <code>const</code> può modificare il valore di un oggetto che sia <code>mutable</code> o a cui si acceda con un puntatore membro. Un uso comune è mantenere una cache anziché eseguire ripetutamente un calcolo complicato. Per esempio qui c’è una <code>Date</code> che mette in una cache (memoizza [!=memorizza]) la sua rappresentazione stringa per semplificarne i ripetuti usi:</p>
<pre><code>class Date {
public:
// ...
const string&amp; string_ref() const
{
if (string_val == &quot;&quot;) compute_string_rep();
return string_val;
}
// ...
private:
void compute_string_rep() const;    // calcola la rappresentazione stringa e la mette in in string_val
mutable string string_val;
// ...
};</code></pre>
<p>Un altro modo per dire che la proprietà <code>const</code> non è transitiva. È possibile per una funzione membro <code>const</code> modificare il valore di membri <code>mutable</code> e il valore di oggetti cui si accede tramite puntatori non-<code>const</code>. È compito della classe garantire che tale mutazione venga effettuata solo quando ha senso secondo la semantica (invarianti) che offre alla sua utenza.</p>
<p><strong>Si veda anche</strong>: <a href="#Ri-pimpl">Pimpl</a></p>
<h5 id="imposizione-298">Imposizione</h5>
<ul>
<li>Segnalare una funzione membro non segnata come <code>const</code>, ma che non esegue un’operazione non-<code>const</code> su alcuna variabile membro.</li>
</ul>
<h3 id="con.3-per-default-passare-puntatori-e-riferimenti-consts"><a name="Rconst-ref"></a>Con.3: Per default, passare puntatori e riferimenti <code>const</code>s</h3>
<h5 id="motivo-328">Motivo</h5>
<p>Per evitare che una funzione chiamata cambi valore inaspettatamente. È molto più facile gestire i programmi quando le funzioni chiamate non modificano lo stato.</p>
<h5 id="esempio-290">Esempio</h5>
<pre><code>void f(char* p);        // f modifica *p? (supponendo che lo faccia)
void g(const char* p);  // g non modifica *p</code></pre>
<h5 id="note-291">Note</h5>
<p>Non è intrinsecamente un male passare un puntatore o un riferimento a non-<code>const</code>, ma dovrebbe essere fatto solo quando si suppone che la funzione chiamata modifichi l’oggetto.</p>
<h5 id="note-292">Note</h5>
<p><a href="#Res-casts-const">Non eseguire il cast di <code>const</code></a>.</p>
<h5 id="imposizione-299">Imposizione</h5>
<ul>
<li>Segnalare la funzione che non modifica un oggetto passato per puntatore o riferimento non-<code>const</code></li>
<li>Segnalare una funzione che (utilizzando il cast) modifica un oggetto passato per puntatore o riferimento <code>const</code></li>
</ul>
<h3 id="con.4-utilizzare-const-per-definire-oggetti-con-valori-che-non-cambiano-dopo-la-costruzione"><a name="Rconst-const"></a>Con.4: Utilizzare <code>const</code> per definire oggetti con valori che non cambiano dopo la costruzione</h3>
<h5 id="motivo-329">Motivo</h5>
<p>Evitare sorprese dal modificare inaspettatamente i valori degli oggetti.</p>
<h5 id="esempio-291">Esempio</h5>
<pre><code>void f()
{
int x = 7;
const int y = 9;

for (;;) {
// ...
}
// ...
}</code></pre>
<p>Dato che <code>x</code> non è <code>const</code>, si deve presumere che venga modificato da qualche parte nel ciclo.</p>
<h5 id="imposizione-300">Imposizione</h5>
<ul>
<li>Segnalare le variabili non-<code>const</code> non modificate.</li>
</ul>
<h3 id="con.5-utilizzare-constexpr-per-i-valori-per-i-valori-calcolabili-durante-la-compilazione"><a name="Rconst-constexpr"></a>Con.5: Utilizzare <code>constexpr</code> per i valori per i valori calcolabili durante la compilazione</h3>
<h5 id="motivo-330">Motivo</h5>
<p>Migliori prestazioni, miglior controllo in fase di compilazione, valutazione garantita durante la compilazione, nessuna possibilità di conflitti.</p>
<h5 id="esempio-292">Esempio</h5>
<pre><code>double x = f(2);            // possibile la valutazione a run-time
const double y = f(2);      // possibile la valutazione a run-time
constexpr double z = f(2);  // errore a meno che f(2) non si possa valutare durante la compilazione</code></pre>
<h5 id="note-293">Note</h5>
<p>Cfr. F.4.</p>
<h5 id="imposizione-301">Imposizione</h5>
<ul>
<li>Segnalare le condizioni <code>const</code> con inizializzatori di espressioni costanti.</li>
</ul>
<h1 id="t-template-e-programmazione-generica"><a name="S-templates"></a>T: Template e programmazione generica</h1>
<p>La “programmazione generica” utilizza i tipi e gli algoritmi parametrizzati coi tipi, i valori e gli algoritmi. Nel C++, la programmazione generica è supportata dal meccanismo dei <code>template</code> del linguaggio.</p>
<p>Gli argomenti alle funzioni generiche sono caratterizzati da un insieme di requisiti sui tipi degli argomenti e sui valori coinvolti. Nel C++, questi requisiti sono espressi da predicati di compilazione chiamati concetti [concept].</p>
<p>I template si possono usare anche per la meta-programmazione; vale a dire, programmi che compongono il codice in fase di compilazione.</p>
<p>Una nozione centrale nella programmazione generica sono i “concetti”; vale a dire, i requisiti sugli argomenti dei template presenti come predicati in fase di compilazione. I “concetti” vengono definiti in una “Technical Specification” ISO: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf">concetti</a>. Una bozza di un insieme di concetti della libreria standard si può trovare in un altro TS ISO: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf">ranges</a> I concetti sono supportati nel GCC 6.1 e successivi. Di conseguenza, si commenta l’uso dei concetti negli esempi; cioè vengono usati solo come commenti formalizzati. Se si usa il GCC 6.1 o successivi, si possono de-commentare.</p>
<p>Riepilogo delle regole sui template:</p>
<ul>
<li><a href="#Rt-raise">T.1: Utilizzare i template per elevare il livello di astrazione del codice</a></li>
<li><a href="#Rt-algo">T.2: Utilizzare i template per esprimere gli algoritmi che si applicano a molti tipi di argomenti</a></li>
<li><a href="#Rt-cont">T.3: Utilizzare i template per esprimere contenitori e [range]</a></li>
<li><a href="#Rt-expr">T.4: Utilizzare i template per esprimere la gestione dell’albero sintattico</a></li>
<li><a href="#Rt-generic-oo">T.5: Combinare la tecnica generica e la OO per amplificane i punti di forza, non i loro costi</a></li>
</ul>
<p>Riepilogo delle regole sull’uso dei concetti:</p>
<ul>
<li><a href="#Rt-concepts">T.10: Specificare i concetti per tutti gli argomenti dei template</a></li>
<li><a href="#Rt-std-concepts">T.11: Quando possibile utilizzare i concetti standard</a></li>
<li><a href="#Rt-auto">T.12: Preferire i nomi dei concetti ad <code>auto</code> per le variabili locali</a></li>
<li><a href="#Rt-shorthand">T.13: Preferire la notazione abbreviata per i concetti semplici, con un argomento di un solo tipo</a></li>
<li>???</li>
</ul>
<p>Riepilogo delle regole sulla definizione dei concetti:</p>
<ul>
<li><a href="#Rt-low">T.20: Evitare “concetti” senza una semantica significativa</a></li>
<li><a href="#Rt-complete">T.21: Richiedere un set completo di operazioni per un concetto</a></li>
<li><a href="#Rt-axiom">T.22: Specificare gli assiomi per i concetti</a></li>
<li><a href="#Rt-refine">T.23: Differenziare un concetto speciale dal suo caso più generale aggiungendo nuovi schemi di utilizzo</a></li>
<li><a href="#Rt-tag">T.24: Usare classi tag o [trait] per differenziare i concetti che hanno solo una semantica diversa</a></li>
<li><a href="#Rt-not">T.25: Evitare i vincoli complementari [complementary constraints]</a></li>
<li><a href="#Rt-use">T.26: Preferire la definizione dei concetti in termini di schemi d’uso anziché la semplice sintassi</a></li>
<li><a href="#Rt-not">T.30: Usare con parsimonia la negazione del concetto (<code>!C&lt;T&gt;</code>) per esprimere piccole differenze</a></li>
<li><a href="#Rt-or">T.31: Usare con parsimonia la disgiunzione del concetto (<code>C1&lt;T&gt; || C2&lt;T&gt;</code>) per esprimere le alternative</a></li>
<li>???</li>
</ul>
<p>Riepilogo delle regole sull’interfaccia dei template:</p>
<ul>
<li><a href="#Rt-fo">T.40: Usare oggetti funzione per passare le operazioni agli algoritmi</a></li>
<li><a href="#Rt-essential">T.41: Richiedere solo le proprietà essenziali nei concetti di un template</a></li>
<li><a href="#Rt-alias">T.42: Usare gli alias dei template per semplificare la notazione e nascondere i dettagli implementativi</a></li>
<li><a href="#Rt-using">T.43: Preferire <code>using</code> a <code>typedef</code> per definire gli alias</a></li>
<li><a href="#Rt-deduce">T.44: Usare template di funzioni per dedurre i tipi degli argomenti della classe (dove fattibile)</a></li>
<li><a href="#Rt-regular">T.46: Richiedere che gli argomenti template siano almeno <code>Regolari</code> o <code>SemiRegolari</code></a></li>
<li><a href="#Rt-visible">T.47: Evitare i template senza vincoli molto evidenti con nomi comuni</a></li>
<li><a href="#Rt-concept-def">T.48: Se il compilatore non supporta i concetti, simularli con <code>enable_if</code></a></li>
<li><a href="#Rt-erasure">T.49: Dove possibile, evitare la [type-erasure]</a></li>
</ul>
<p>Riepilogo delle regole sulla definizione dei template:</p>
<ul>
<li><a href="#Rt-depend">T.60: Minimizzare le dipendenze dal contesto di un template</a></li>
<li><a href="#Rt-scary">T.61: Non sovra-parametrizzare i membri (PAUROSO)</a></li>
<li><a href="#Rt-nondependent">T.62: Porre i membri della classe template non-dipendenti in una classe base non-template</a></li>
<li><a href="#Rt-specialization">T.64: Usare la specializzazione per fornire implementazioni alternative di classi template</a></li>
<li><a href="#Rt-tag-dispatch">T.65: Usare il [tag dispatch] per fornire implementazioni alternative delle funzioni</a></li>
<li><a href="#Rt-specialization2">T.67: Usare la specializzazione per fornire implementazioni alternative per i tipi irregolari</a></li>
<li><a href="#Rt-cast">T.68: Usare <code>{}</code> anziché <code>()</code> nei template per evitare ambiguità</a></li>
<li><a href="#Rt-customization">T.69: All’interno di un template, non effettuare una chiamata di funzione non-membro non-qualificata a meno che non lo si intenda come un punto di personalizzazione</a></li>
</ul>
<p>Riepilogo delle regole sulla gerarchia dei template:</p>
<ul>
<li><a href="#Rt-hier">T.80: Non rendere template nativamente una gerarchia di classi</a></li>
<li><a href="#Rt-array">T.81: Non mischiare le gerarchie con gli array</a> // ??? da qualche parte nelle “gerarchie”</li>
<li><a href="#Rt-linear">T.82: Linearizzare una gerarchia quando le funzioni virtuali sono indesiderabili</a></li>
<li><a href="#Rt-virtual">T.83: Non dichiarare virtuale una funzione membro template</a></li>
<li><a href="#Rt-abi">T.84: Usare un nucleo implementativo non-template per fornire un’interfaccia ABI stabile</a></li>
<li><a href="#Rt-???">T.??: ????</a></li>
</ul>
<p>Riepilogo delle regole sui template variadici:</p>
<ul>
<li><a href="#Rt-variadic">T.100: Usare i template variadici quando c’è bisogno di una funzione che prende un numero variabile di argomenti di vari tipi</a></li>
<li><a href="#Rt-variadic-pass">T.101: ??? Come passare gli argomenti ad un template variadico ???</a></li>
<li><a href="#Rt-variadic-process">T.102: ??? Come processare gli argomenti in un template variadico ???</a></li>
<li><a href="#Rt-variadic-not">T.103: Non usare i template variadici per liste di argomenti omogenei</a></li>
<li><a href="#Rt-???">T.??: ????</a></li>
</ul>
<p>Riepilogo delle regole sulla meta-programmazione:</p>
<ul>
<li><a href="#Rt-metameta">T.120: Usare la meta-programmazione template solo quando è veramente necessario</a></li>
<li><a href="#Rt-emulate">T.121: Usare la meta-programmazione template soprattutto per emulare i concetti</a></li>
<li><a href="#Rt-tmp">T.122: Usare i template (solitamente alias di template) per elaborare i tipi in fase di compilazione</a></li>
<li><a href="#Rt-fct">T.123: Usare funzioni <code>constexpr</code> per elaborare i valori in fase di compilazione</a></li>
<li><a href="#Rt-std-tmp">T.124: Preferire l’uso delle funzioni TMP della libreria standard</a></li>
<li><a href="#Rt-lib">T.125: Se c’è bisogno di andare oltre le funzioni TMP della libreria standard, usare una libreria esistente</a></li>
<li><a href="#Rt-???">T.??: ????</a></li>
</ul>
<p>Riepilogo delle altre regole sui template:</p>
<ul>
<li><a href="#Rt-name">T.140: Dare un nome a tutte le funzioni potenzialmente riutilizzabili</a></li>
<li><a href="#Rt-lambda">T.141: Usare una lambda anonima se si necessita di un semplice oggetto funzione in un solo posto</a></li>
<li><a href="#Rt-var">T.142: Usare le variabili template per semplificare la notazione</a></li>
<li><a href="#Rt-nongeneric">T.143: Non scrivere involontariamente codice non-generico</a></li>
<li><a href="#Rt-specialize-function">T.144: Non specializzare le funzioni template</a></li>
<li><a href="#Rt-check-class">T.150: Verificare che a una classe corrisponda un concetto utilizzando <code>static_assert</code></a></li>
<li><a href="#Rt-???">T.??: ????</a></li>
</ul>
<h2 id="t.gp-programmazione-generica"><a name="SS-GP"></a>T.gp: Programmazione generica</h2>
<p>La “programmazione generica” utilizza i tipi e gli algoritmi parametrizzati coi tipi, i valori e gli algoritmi.</p>
<h3 id="t.1-utilizzare-i-template-per-elevare-il-livello-di-astrazione-del-codice"><a name="Rt-raise"></a>T.1: Utilizzare i template per elevare il livello di astrazione del codice</h3>
<h5 id="motivo-331">Motivo</h5>
<p>Generalità. Riutilizzo. Efficienza. Incoraggia la consistenza della definizione dei tipi utente.</p>
<h5 id="esempio-cattivo-126">Esempio, cattivo</h5>
<p>Concettualmente, i seguenti requisiti sono sbagliati perché quello che si vuole di <code>T</code> sono più che i semplici concetti di bassissimo livello del “può essere incrementato” o “può essere aggiunto”:</p>
<pre><code>template&lt;typename T&gt;
// requires l&#39;incrementabilità&lt;T&gt;
T sum1(vector&lt;T&gt;&amp; v, T s)
{
for (auto x : v) s += x;
return s;
}

template&lt;typename T&gt;
// requires Simple_number&lt;T&gt;
T sum2(vector&lt;T&gt;&amp; v, T s)
{
for (auto x : v) s = s + x;
return s;
}</code></pre>
<p>Supponendo che <code>Incrementable</code> non supporti <code>+</code> e che <code>Simple_number</code> non supporti <code>+=</code>, si hanno degli implementatori troppo particolari di <code>sum1</code> e <code>sum2</code>. E, in questo caso, perdendo un’opportunità di generalizzazione.</p>
<h5 id="esempio-293">Esempio</h5>
<pre><code>template&lt;typename T&gt;
// requires Arithmetic&lt;T&gt;
T sum(vector&lt;T&gt;&amp; v, T s)
{
for (auto x : v) s += x;
return s;
}</code></pre>
<p>Assumendo che <code>Arithmetic</code>richieda sia <code>+</code> che <code>+=</code>, si vincola l’utente di <code>sum</code> a fornire un tipo completamente aritmetico. Questo non è un requisito minimo, ma fornisce all’implementatore degli algoritmi la libertà necessaria e garantisce che si possa usare qualsiasi tipo <code>Arithmetic</code> per un’ampia varietà di algoritmi.</p>
<p>Per ulteriore generalità e riusabilità, si potrebbe anche usare un più generale concetto di <code>Container</code> o d <code>Range</code> anziché affidarsi ad un solo contenitore, <code>vector</code>.</p>
<h5 id="note-294">Note</h5>
<p>Se si definisce un modello per avere esattamente le sole operazioni richieste per una particolare implementazione di un singolo algoritmo (p.es., richiedere solo <code>+=</code> anziché anche <code>=</code> e <code>+</code>) e solo quelle, si hanno dei manutentori troppo vincolati. Lo scopo è quello di minimizzare i requisiti sugli argomenti template, ma i requisiti assolutamente minimali di un’implementazione raramente costituiscono un concetto significativo.</p>
<h5 id="note-295">Note</h5>
<p>I template si possono usare per esprimere essenzialmente qualsiasi cosa (sono Turing equivalenti), ma lo scopo della programmazione generica che si ha con i template) è quello di generalizzare efficientemente operazioni e/o algoritmi gli per un insieme di tipi con proprietà semantiche simili.</p>
<h5 id="note-296">Note</h5>
<p>I <code>requires</code> nei commenti sono utilizzi dei <code>concetti</code>. I “Concetti” sono definiti in una Specifica Tecnica ISO: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf">concetti</a>. I concetti sono supportati GCC 6.1 e successivi. Di conseguenza, si commenta l’uso dei concetti negli esempi; cioè vengono usati solo come commenti formalizzati. Se si usa il GCC 6.1 o successivi, si possono de-commentare.</p>
<h5 id="imposizione-302">Imposizione</h5>
<ul>
<li>Segnalare gli algoritmi con requisiti “eccessivamente semplici”, come l’uso diretto di specifici operatori senza un concetto.</li>
<li>Non segnalare la definizione degli stessi concetti “eccessivamente semplici”; questi possono semplicemente essere elementi costitutivi di concetti più utili.</li>
</ul>
<h3 id="t.2-utilizzare-i-template-per-esprimere-gli-algoritmi-che-si-applicano-a-molti-tipi-di-argomenti"><a name="Rt-algo"></a>T.2: Utilizzare i template per esprimere gli algoritmi che si applicano a molti tipi di argomenti</h3>
<h5 id="motivo-332">Motivo</h5>
<p>Generalità. Minimizzare la quantità di codice sorgente. Interoperabilità. Riutilizzo.</p>
<h5 id="esempio-294">Esempio</h5>
<p>Questa è la base della STL. Un singolo algoritmo <code>find</code> funziona facilmente con qualsiasi tipo di serie in input:</p>
<pre><code>template&lt;typename Iter, typename Val&gt;
// requires Input_iterator&lt;Iter&gt;
//       &amp;&amp; Equality_comparable&lt;Value_type&lt;Iter&gt;, Val&gt;
Iter find(Iter b, Iter e, Val v)
{
// ...
}</code></pre>
<h5 id="note-297">Note</h5>
<p>Non usare un template a meno che non si abbia una reale necessità per più di un tipo di argomento template. Non essere eccessivamente concisi.</p>
<h5 id="imposizione-303">Imposizione</h5>
<p>??? difficile, probabilmente necessita di un umano</p>
<h3 id="t.3-utilizzare-i-template-per-esprimere-contenitori-e-range"><a name="Rt-cont"></a>T.3: Utilizzare i template per esprimere contenitori e [range]</h3>
<h5 id="motivo-333">Motivo</h5>
<p>I contenitori necessitano di un tipo elemento, ed esprimerlo come un argomento template è generale, riutilizzabile e sicuro rispetto al tipo. Si evitano, inoltre, alternative fragili ed inefficienti. Convenzione: Questo è come fa la STL.</p>
<h5 id="esempio-295">Esempio</h5>
<pre><code>template&lt;typename T&gt;
// requires Regular&lt;T&gt;
class Vector {
// ...
T* elem;   // punta a sz Ts
int sz;
};

Vector&lt;double&gt; v(10);
v[7] = 9.9;</code></pre>
<h5 id="esempio-cattivo-127">Esempio, cattivo</h5>
<pre><code>class Container {
// ...
void* elem;   // punta a sz [size] elementi di qualche tipo
int sz;
};

Container c(10, sizeof(double));
((double*) c.elem)[7] = 9.9;</code></pre>
<p>Ciò non esprime direttamente l’intento del programmatore e nasconde la struttura del programma al sistema dei tipi e all’ottimizzatore.</p>
<p>Celando il <code>void*</code> dietro le macro semplicemente si nascondono i problemi e si introducono altre possibilità di confusione.</p>
<p><strong>Eccezioni</strong>: Se è necessaria un’interfaccia ABI stabile, potrebbe essere necessario fornire un’implementazione di base ed esprimere il template (type-safe) in questi termini. Cfr. <a href="#Rt-abi">Base stabile</a>.</p>
<h5 id="imposizione-304">Imposizione</h5>
<ul>
<li>Segnalare gli utilizzi dei <code>void*</code> e dei cast al di fuori del codice di implementazione di basso livello</li>
</ul>
<h3 id="t.4-utilizzare-i-template-per-esprimere-la-gestione-dellalbero-sintattico"><a name="Rt-expr"></a>T.4: Utilizzare i template per esprimere la gestione dell’albero sintattico</h3>
<h5 id="motivo-334">Motivo</h5>
<p>???</p>
<h5 id="esempio-296">Esempio</h5>
<pre><code>???</code></pre>
<p><strong>Eccezioni</strong>: ???</p>
<h3 id="t.5-combinare-la-tecnica-generica-e-la-oo-per-amplificane-i-punti-di-forza-non-i-loro-costi"><a name="Rt-generic-oo"></a>T.5: Combinare la tecnica generica e la OO per amplificane i punti di forza, non i loro costi</h3>
<h5 id="motivo-335">Motivo</h5>
<p>Le tecniche di programmazione generica e OO sono complementari.</p>
<h5 id="esempio-297">Esempio</h5>
<p>La statica aiuta la dinamica: Usare il polimorfismo statico per implementare dinamicamente le interfacce polimorfiche.</p>
<pre><code>class Command {
// funzioni virtuali pure
};

// implementazioni
template&lt;/*...*/&gt;
class ConcreteCommand : public Command {
// implementare le virtuali
};</code></pre>
<h5 id="esempio-298">Esempio</h5>
<p>La dinamica aiuta la statica: Offre un’interfaccia generica, comoda e vincolata staticamente, ma internamente distribuisce dinamicamente, offrendo un layout uniforme dell’oggetto. Tra gli esempi c’è la cancellazione [erasure] del tipo come con il ‘deleter’ del <code>std::shared_ptr</code> (ma <a href="#Rt-erasure">non abusare della cancellazione del tipo [type erasure]</a>).</p>
<h5 id="note-298">Note</h5>
<p>In una classe template, le funzioni non-virtuali vengono istanziate solo se vengono utilizzate – ma quelle virtuali vengono istanziate sempre. Questo può gonfiare la dimensione del codice, e può eccessivamente vincolare un tipo generico istanziando funzionalità che non saranno mai necessarie. È da evitare, anche se parti della libreria standard hanno commesso questo sbaglio.</p>
<h5 id="si-veda-anche-5">Si veda anche</h5>
<ul>
<li>rif ???</li>
<li>rif ???</li>
<li>rif ???</li>
</ul>
<h5 id="imposizione-305">Imposizione</h5>
<p>Si vedano i riferimenti a regole più specifiche.</p>
<h2 id="t.concepts-regole-sui-concetti"><a name="SS-concepts"></a>T.concepts: Regole sui concetti</h2>
<p>I “concetti” sono funzionalità per specificare i requisiti per gli argomenti template. È una <a href="#Ref-conceptsTS">ISO Technical Specification</a>, ma è attualmente supportata solo dal GCC. I concetti sono, tuttavia, cruciali nel pensare alla programmazione generica e sono alla base di tanto lavoro sulle future librerie C++ (sia standard che altre).</p>
<p>Questa sezione presuppone il supporto del concetto</p>
<p>Riepilogo delle regole sull’uso dei concetti:</p>
<ul>
<li><a href="#Rt-concepts">T.10: Specificare i concetti per tutti gli argomenti dei template</a></li>
<li><a href="#Rt-std-concepts">T.11: Quando possibile utilizzare i concetti standard</a></li>
<li><a href="#Rt-auto">T.12: Preferire i nomi dei concetti ad <code>auto</code></a></li>
<li><a href="#Rt-shorthand">T.13: Preferire la notazione abbreviata per i concetti semplici, con un argomento di un solo tipo</a></li>
<li>???</li>
</ul>
<p>Riepilogo delle regole sulla definizione dei concetti:</p>
<ul>
<li><a href="#Rt-low">T.20: Evitare “concetti” senza una semantica significativa</a></li>
<li><a href="#Rt-complete">T.21: Richiedere un set completo di operazioni per un concetto</a></li>
<li><a href="#Rt-axiom">T.22: Specificare gli assiomi per i concetti</a></li>
<li><a href="#Rt-refine">T.23: Differenziare un concetto speciale dal suo caso più generale aggiungendo nuovi schemi di utilizzo</a></li>
<li><a href="#Rt-tag">T.24: Usare classi tag o [trait] per differenziare i concetti che hanno solo una semantica diversa</a></li>
<li><a href="#Rt-not">T.25: Evitare vincoli gratuiti</a></li>
<li><a href="#Rt-use">T.26: Preferire la definizione dei concetti in termini di schemi d’uso anziché la semplice sintassi</a></li>
<li>???</li>
</ul>
<h2 id="t.con-use-uso-del-concetto"><a name="SS-concept-use"></a>T.con-use: Uso del concetto</h2>
<h3 id="t.10-specificare-i-concetti-per-tutti-gli-argomenti-dei-template"><a name="Rt-concepts"></a>T.10: Specificare i concetti per tutti gli argomenti dei template</h3>
<h5 id="motivo-336">Motivo</h5>
<p>Correttezza e leggibilità. Il significato supposto (sintattico e semantico) di un argomento template è fondamentale per l’interfaccia di un template. Un concetto migliora enormemente la documentazione e la gestione degli errori per il template. La specificare i concetti per gli argomenti template costituisce un potente strumento di progettazione.</p>
<h5 id="esempio-299">Esempio</h5>
<pre><code>template&lt;typename Iter, typename Val&gt;
//    requires Input_iterator&lt;Iter&gt;
//             &amp;&amp; Equality_comparable&lt;Value_type&lt;Iter&gt;, Val&gt;
Iter find(Iter b, Iter e, Val v)
{
// ...
}</code></pre>
<p>o equivalentemente e più succintamente:</p>
<pre><code>template&lt;Input_iterator Iter, typename Val&gt;
//    requires Equality_comparable&lt;Value_type&lt;Iter&gt;, Val&gt;
Iter find(Iter b, Iter e, Val v)
{
// ...
}</code></pre>
<h5 id="note-299">Note</h5>
<p>I “concetti” vengono definiti in una “Technical Specification” ISO: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf">concetti</a>. Una bozza di un insieme di concetti della libreria standard si può trovare in un altro TS ISO: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf">ranges</a> I concetti sono supportati nel GCC 6.1 e successivi. Di conseguenza, si commenta l’uso dei concetti negli esempi; cioè vengono usati solo come commenti formalizzati. Se si usa il GCC 6.1 o successivi, si possono de-commentare:</p>
<pre><code>template&lt;typename Iter, typename Val&gt;
requires Input_iterator&lt;Iter&gt;
&amp;&amp; Equality_comparable&lt;Value_type&lt;Iter&gt;, Val&gt;
Iter find(Iter b, Iter e, Val v)
{
// ...
}</code></pre>
<h5 id="note-300">Note</h5>
<p>Il semplice <code>typename</code> (o <code>auto</code>) è il concetto meno vincolante. Dovrebbe essere usato solo raramente quando non si può supporre altro che “è un tipo”. Ciò, generalmente, è necessario solo quando (come parte del codice di meta-programmazione dei template) si gestiscono alberi di espressioni pure, posponendo il controllo del tipo.</p>
<p><strong>Riferimenti</strong>: TC++PL4, Palo Alto TR, Sutton</p>
<h5 id="imposizione-306">Imposizione</h5>
<p>Segnalare i tipi di argomenti template senza concetti</p>
<h3 id="t.11-quando-possibile-utilizzare-i-concetti-standard"><a name="Rt-std-concepts"></a>T.11: Quando possibile utilizzare i concetti standard</h3>
<h5 id="motivo-337">Motivo</h5>
<p>I concetti “standard” (come quelli forniti dalle <a href="#S-GSL">GSL</a> e le <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf">Ranges TS</a>, e si spera presto dallo stesso standard ISO) evitano la fatica di idearsi i propri concetti, sono progettati meglio di quanto si farebbe in proprio frettolosamente, migliorando l’interoperabilità.</p>
<h5 id="note-301">Note</h5>
<p>A meno che non si stia creando una nuova libreria generica, la maggior parte dei concetti necessari sarà già stata definita dalla libreria standard.</p>
<h5 id="esempio-utilizzando-i-concetti-ts">Esempio (utilizzando i concetti TS)</h5>
<pre><code>template&lt;typename T&gt;
// da non definire: Sortable sta nelle GSL
concept Ordered_container = Sequence&lt;T&gt; &amp;&amp; Random_access&lt;Iterator&lt;T&gt;&gt; &amp;&amp; Ordered&lt;Value_type&lt;T&gt;&gt;;

void sort(Ordered_container&amp; s);</code></pre>
<p>Questo <code>Ordered_container</code> è abbastanza plausibile, ma è molto simile al concetto <code>Sortable</code> nella GSL (e nella Range TS). È migliore? È giusto? Riflette accuratamente i requisiti dello standard per <code>sort</code>? È meglio e più semplice usare semplicemente <code>Sortable</code>:</p>
<pre><code>void sort(Sortable&amp; s);   // migliore</code></pre>
<h5 id="note-302">Note</h5>
<p>L’insieme dei concetti “standard” si sta evolvendo nell’avvicinarsi ad uno standard ISO che includa i concetti.</p>
<h5 id="note-303">Note</h5>
<p>Progettare un concetto utile è impegnativo.</p>
<h5 id="imposizione-307">Imposizione</h5>
<p>Difficile.</p>
<ul>
<li>Cercare argomenti senza vincoli, template che usano concetti “insoliti”/non-standard, template che usano concetti “fatti in casa” senza assiomi.</li>
<li>Sviluppare un tool per scoprire i concetti (p.es., cfr.<a href="http://www.stroustrup.com/sle2010_webversion.pdf">un primo esperimento</a>).</li>
</ul>
<h3 id="t.12-preferire-i-nomi-dei-concetti-ad-auto-per-le-variabili-locali"><a name="Rt-auto"></a>T.12: Preferire i nomi dei concetti ad <code>auto</code> per le variabili locali</h3>
<h5 id="motivo-338">Motivo</h5>
<p><code>auto</code> è il concetto più debole. I nomi dei concetti convogliano più significato che il semplice <code>auto</code>.</p>
<h5 id="esempio-utilizzando-i-concetti-ts-1">Esempio (utilizzando i concetti TS)</h5>
<pre><code>vector&lt;string&gt; v{ &quot;abc&quot;, &quot;xyz&quot; };
auto&amp; x = v.front();     // bad
String&amp; s = v.front();   // buono (String è un concetto GSL)</code></pre>
<h5 id="imposizione-308">Imposizione</h5>
<ul>
<li>???</li>
</ul>
<h3 id="t.13-preferire-la-notazione-abbreviata-per-i-concetti-semplici-con-un-argomento-di-un-solo-tipo"><a name="Rt-shorthand"></a>T.13: Preferire la notazione abbreviata per i concetti semplici, con un argomento di un solo tipo</h3>
<h5 id="motivo-339">Motivo</h5>
<p>Leggibilità. Espressione diretta di un’idea.</p>
<h5 id="esempio-utilizzando-i-concetti-ts-2">Esempio (utilizzando i concetti TS)</h5>
<p>Per dire che “<code>T</code> è <code>Sortable [Ordinabile]</code>”:</p>
<pre><code>template&lt;typename T&gt;       // Corretto ma verboso: &quot;Il parametro è
//    requires Sortable&lt;T&gt;   // di tipo T che è il nome di un tipo
void sort(T&amp;);             // che sia Sortable&quot;

template&lt;Sortable T&gt;       // Meglio (supponendo il supporto per i concetti): &quot;Il parametro è di tipo T
void sort(T&amp;);             // che è Sortable&quot;

void sort(Sortable&amp;);      // Il migliore (supponendo il supporto per i concetti): &quot;Il parametro è Sortable&quot;</code></pre>
<p>Le versioni più brevi si adattano meglio al nostro modo di parlare. Si noti che per molti template non è necessario usare la parola-chiave <code>template</code>.</p>
<h5 id="note-304">Note</h5>
<p>I “concetti” vengono definiti in una “Technical Specification” ISO: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf">concetti</a>. Una bozza di un insieme di concetti della libreria standard si può trovare in un altro TS ISO: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf">ranges</a> I concetti sono supportati nel GCC 6.1 e successivi. Di conseguenza, si commenta l’uso dei concetti negli esempi; cioè vengono usati solo come commenti formalizzati. Se si usa un compilatore che supporta i concetti (p.es., GCC 6.1 o successivi), si può rimuovere il <code>//</code>.</p>
<h5 id="imposizione-309">Imposizione</h5>
<ul>
<li>Non fattibile a breve termine quando le persone convertono dalla notazione <code>&lt;typename T&gt;</code> e <code>&lt;class T</code>&gt;.</li>
<li>In seguito, le dichiarazioni che prima introducono un [typename] e poi lo vincolano con un concetto semplice, argomento-di-un-solo-tipo.</li>
</ul>
<h2 id="t.concepts.def-regole-sulla-definizione-dei-concetti"><a name="SS-concepts-def"></a>T.concepts.def: Regole sulla definizione dei concetti</h2>
<p>Definire dei buoni concetti non è banale. I “concept” hanno lo scopo di rappresentare concetti fondamentali in un dominio di applicazione (da cui il nome “concept”). Allo stesso modo, mettere insieme una serie di vincoli sintattici da utilizzare per gli argomenti di una classe o di un algoritmo non è ciò per cui i concetti sono stati progettati e non darà tutti i benefici del meccanismo.</p>
<p>Ovviamente, la definizione dei concetti sarà molto utile per il codice che ne utilizzi un’implementazione (ad esempio, il GCC 6.1 o successivi), ma la definizione dei concetti è di per sé una tecnica di progettazione utile e aiuta a rilevare errori concettuali e ripulire i concetti (sic!) di un implementazione.</p>
<h3 id="t.20-evitare-concetti-senza-una-semantica-significativa"><a name="Rt-low"></a>T.20: Evitare “concetti” senza una semantica significativa</h3>
<h5 id="motivo-340">Motivo</h5>
<p>I concetti hanno lo scopo di esprimere nozioni semantiche, come in “un numero”, “a intervallo [range]” di elementi, e “totalmente ordinato”. Semplici vincoli, come in “ha un operatore <code>+</code>” e “ha un operatore <code>&gt;</code>” non possono essere specificati in modo significativo in modo isolato e si dovrebbero usare solo come elementi costitutivi di concetti significativi, piuttosto che nel codice utente.</p>
<h5 id="esempio-cattivo-utilizzando-i-concetti-ts">Esempio, cattivo (utilizzando i concetti TS)</h5>
<pre><code>template&lt;typename T&gt;
concept Addable = has_plus&lt;T&gt;;    // bad; insufficiente

template&lt;Addable N&gt; auto algo(const N&amp; a, const N&amp; b) // usa due numeri
{
// ...
return a + b;
}

int x = 7;
int y = 9;
auto z = algo(x, y);   // z = 16

string xx = &quot;7&quot;;
string yy = &quot;9&quot;;
auto zz = algo(xx, yy);   // zz = &quot;79&quot;</code></pre>
<p>Forse era prevista la concatenazione. Più probabilmente, è stato un incidente. Definire il meno in modo equivalente farebbe accettare un insieme di tipi notevolmente diversi. Questo <code>Addable</code> viola la regola matematica che supponga che l’addizione sia commutativa: <code>a+b == b+a</code>.</p>
<h5 id="note-305">Note</h5>
<p>La capacità di specificare una semantica significativa è una caratteristica distintiva di un vero concetto, al contrario di un vincolo sintattico.</p>
<h5 id="esempio-utilizzando-i-concetti-ts-3">Esempio (utilizzando i concetti TS)</h5>
<pre><code>template&lt;typename T&gt;
// Gli operatori +, -, *, e/ per un numero si suppone che seguano le solite regole matematiche
concept Number = has_plus&lt;T&gt;
&amp;&amp; has_minus&lt;T&gt;
&amp;&amp; has_multiply&lt;T&gt;
&amp;&amp; has_divide&lt;T&gt;;

template&lt;Number N&gt; auto algo(const N&amp; a, const N&amp; b)
{
// ...
return a + b;
}

int x = 7;
int y = 9;
auto z = algo(x, y);   // z = 16

string xx = &quot;7&quot;;
string yy = &quot;9&quot;;
auto zz = algo(xx, yy);   // errore: string non è un Number</code></pre>
<h5 id="note-306">Note</h5>
<p>I concetti con più operazioni hanno una probabilità molto più bassa di abbinare accidentalmente un tipo rispetto a un concetto a singola-operazione.</p>
<h5 id="imposizione-310">Imposizione</h5>
<ul>
<li>Segnalare i <code>concept</code> a singola-operazione utilizzati al di fuori della definizione di altri <code>concept</code>.</li>
<li>Segnalare gli usi di <code>enable_if</code> che sembrano simulare <code>concept</code> a singola-operazione.</li>
</ul>
<h3 id="t.21-richiedere-un-set-completo-di-operazioni-per-un-concetto"><a name="Rt-complete"></a>T.21: Richiedere un set completo di operazioni per un concetto</h3>
<h5 id="motivo-341">Motivo</h5>
<p>Facilità di comprensione. Migliorata interoperabilità. Aiuta gli implementatori e i manutentori.</p>
<h5 id="note-307">Note</h5>
<p>Questa è una specifica variante della regola generale <a href="#Rt-low">un concetto deve avere un senso semantico</a>.</p>
<h5 id="esempio-cattivo-utilizzando-i-concetti-ts-1">Esempio, cattivo (utilizzando i concetti TS)</h5>
<pre><code>template&lt;typename T&gt; concept Subtractable = requires(T a, T, b) { a-b; };</code></pre>
<p>Questo non ha un senso semantico. C’è almeno bisogno di <code>+</code> per rendere <code>-</code> significativo e utile.</p>
<p>Esempi di set completi sono</p>
<ul>
<li><code>Aritmetica</code>: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code></li>
<li><code>Comparabile</code>: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code></li>
</ul>
<h5 id="note-308">Note</h5>
<p>Questa regola si applica a prescindere dal fatto che si utilizzi il supporto diretto del linguaggio per i concetti. È una regola di progettazione generale che si applica anche ai non-template:</p>
<pre><code>class Minimal {
// ...
};

bool operator==(const Minimal&amp;, const Minimal&amp;);
bool operator&lt;(const Minimal&amp;, const Minimal&amp;);

Minimal operator+(const Minimal&amp;, const Minimal&amp;);
// nessun altro operatore

void f(const Minimal&amp; x, const Minimal&amp; y)
{
if (!(x == y)) { /* ... */ }    // OK
if (x != y) { /* ... */ }       // sorpresa! errore

while (!(x &lt; y)) { /* ... */ }  // OK
while (x &gt;= y) { /* ... */ }    // sorpresa! errore

x = x + y;          // OK
x += y;             // sorpresa! errore
}</code></pre>
<p>Questo è il minimo, ma sorprende e vincola gli utenti. Potrebbe inoltre essere meno efficiente.</p>
<p>La regola supporta l’opinione secondo cui un concetto dovrebbe riflettere una serie (matematicamente) coerente di operazioni.</p>
<h5 id="esempio-300">Esempio</h5>
<pre><code>class Convenient {
// ...
};

bool operator==(const Convenient&amp;, const Convenient&amp;);
bool operator&lt;(const Convenient&amp;, const Convenient&amp;);
// ... e gli altri operatori di confronto ...

Minimal operator+(const Convenient&amp;, const Convenient&amp;);
// .. e gli altri operatori aritmetici ...

void f(const Convenient&amp; x, const Convenient&amp; y)
{
if (!(x == y)) { /* ... */ }    // OK
if (x != y) { /* ... */ }       // OK

while (!(x &lt; y)) { /* ... */ }  // OK
while (x &gt;= y) { /* ... */ }    // OK

x = x + y;     // OK
x += y;        // OK
}</code></pre>
<p>Definire tutti gli operatori può essere fastidioso, ma non difficile. Idealmente, la regola dovrebbe essere supportata dal linguaggio fornendo operatori di confronto di default.</p>
<h5 id="imposizione-311">Imposizione</h5>
<ul>
<li>Segnalare le classi che supportano sottoinsiemi “strani” di un insieme di operatori, p.es., <code>==</code> ma non <code>!=</code> oppure <code>+</code> ma non <code>-</code>. Sì, <code>std::string</code> è “strana”, ma è troppo tardi per cambiare.</li>
</ul>
<h3 id="t.22-specificare-gli-assiomi-per-i-concetti"><a name="Rt-axiom"></a>T.22: Specificare gli assiomi per i concetti</h3>
<h5 id="motivo-342">Motivo</h5>
<p>Un concetto significativo/utile ha un significato semantico. Esprimere queste semantiche in modo informale, semi-formale o formale rende il concetto comprensibile ai lettori e lo sforzo di esprimerlo può intercettare errori concettuali. La specifica della semantica è un potente strumento di progettazione.</p>
<h5 id="esempio-utilizzando-i-concetti-ts-4">Esempio (utilizzando i concetti TS)</h5>
<pre><code>template&lt;typename T&gt;
// Gli operatori +, -, *, e / per un numero si suppone che seguano le solite regole matematiche
// axiom(T a, T b) { a + b == b + a; a - a == 0; a * (b + c) == a * b + a * c; /*...*/ }
concept Number = requires(T a, T b) {
{a + b} -&gt; T;   // il risultato di a + b è convertibile in T
{a - b} -&gt; T;
{a * b} -&gt; T;
{a / b} -&gt; T;
}</code></pre>
<h5 id="note-309">Note</h5>
<p>Questo è un assioma in senso matematico: qualcosa che può essere assunto senza prove. In generale, gli assiomi non sono dimostrabili, e quando c’è una prova va spesso oltre le capacità di un compilatore. Un assioma può non essere generale, ma chi scrive il template può presumere che valga per tutti gli input effettivamente utilizzati (simile a una pre-condizione).</p>
<h5 id="note-310">Note</h5>
<p>In questo contesto gli assiomi sono espressioni Booleane. Per gli esempi si veda <a href="#S-references">Palo Alto TR</a>. Attualmente, il C++ non supporta gli assiomi (anche gli [ISO Concepts TS]), quindi ci si dovrà accontentare a lungo dei commenti. Appena sarà disponibile il supporto del linguaggio, si potranno rimuovere le <code>//</code> davanti all’assioma</p>
<h5 id="note-311">Note</h5>
<p>I concetti GSL hanno una semantica ben definita; si veda il [Palo Alto TR] e il [Ranges TS].</p>
<h5 id="eccezioni-utilizzando-i-concetti-ts">Eccezioni (utilizzando i concetti TS)</h5>
<p>Le prime versioni di un nuovo “concept” ancora in fase di sviluppo definiranno spesso semplici insiemi di vincoli senza una semantica ben specificata. Trovare una buona semantica può richiedere tempo e fatica. Un insieme incompleto di vincoli può essere ancora utilissimo:</p>
<pre><code>// bilanciatore per un albero binario generico
template&lt;typename Node&gt; concept bool Balancer = requires(Node* p) {
add_fixup(p);
touch(p);
detach(p);
}</code></pre>
<p>Quindi un <code>Balancer</code> deve fornire almeno tre operazioni su un albero <code>Node</code>, ma non si è ancora pronti a specificare una semantica dettagliata perché un nuovo tipo di albero bilanciato potrebbe richiedere più operazioni e la semantica generale precisa per tutti i nodi è difficile da definire nelle prime fasi della progettazione.</p>
<p>Un “concept” incompleto o senza una semantica ben specificata può ancora essere utile. Per esempio, consente alcuni controlli durante la sperimentazione iniziale. Tuttavia, non si deve supporre che sia stabile. Ogni nuovo caso d’uso può richiedere un tale concetto incompleto e da migliorare.</p>
<h5 id="imposizione-312">Imposizione</h5>
<ul>
<li>Cercare la parola “axiom” nei commenti per la definizione dei concept</li>
</ul>
<h3 id="t.23-differenziare-un-concetto-speciale-dal-suo-caso-più-generale-aggiungendo-nuovi-schemi-di-utilizzo."><a name="Rt-refine"></a>T.23: Differenziare un concetto speciale dal suo caso più generale aggiungendo nuovi schemi di utilizzo.</h3>
<h5 id="motivo-343">Motivo</h5>
<p>Altrimenti non possono essere distinti automaticamente dal compilatore.</p>
<h5 id="esempio-utilizzando-i-concetti-ts-5">Esempio (utilizzando i concetti TS)</h5>
<pre><code>template&lt;typename I&gt;
concept bool Input_iter = requires(I iter) { ++iter; };

template&lt;typename I&gt;
concept bool Fwd_iter = Input_iter&lt;I&gt; &amp;&amp; requires(I iter) { iter++; }</code></pre>
<p>Il compilatore può determinare il perfezionamento in base all’insieme di operazioni richieste (qui, il suffisso <code>++</code>). Ciò riduce l’onere per gli implementatori di questi tipi poiché non necessitano di dichiarazioni speciali per “agganciarsi al concetto”. Se due concetti hanno esattamente gli stessi requisiti, sono logicamente equivalenti (non c’è alcuna elaborazione [refinement]).</p>
<h5 id="imposizione-313">Imposizione</h5>
<ul>
<li>Segnalare un concetto che ha esattamente gli stessi requisiti di un altro concetto già visto (nessuno dei due è più elaborato [refined]). Per chiarire le ambiguità, si veda <a href="#Rt-tag">T.24</a>.</li>
</ul>
<h3 id="t.24-usare-classi-tag-o-trait-per-differenziare-i-concetti-che-hanno-solo-una-semantica-diversa."><a name="Rt-tag"></a>T.24: Usare classi tag o [trait] per differenziare i concetti che hanno solo una semantica diversa.</h3>
<h5 id="motivo-344">Motivo</h5>
<p>Due concetti che richiedono la stessa sintassi ma hanno semantica diversa portano ad un’ambiguità a meno che il programmatore non li differenzi.</p>
<h5 id="esempio-utilizzando-i-concetti-ts-6">Esempio (utilizzando i concetti TS)</h5>
<pre><code>template&lt;typename I&gt;    // iteratore che fornisce un accesso random
concept bool RA_iter = ...;

template&lt;typename I&gt;    // iteratore che fornisce accesso random a dati contigui
concept bool Contiguous_iter =
RA_iter&lt;I&gt; &amp;&amp; is_contiguous&lt;I&gt;::value;  // usa il [trait] is_contiguous</code></pre>
<p>Il programmatore (in una libreria) deve definire adeguatamente <code>is_contiguous</code> (un [trait]).</p>
<p>Avvolgere una classe [tag] in un concetto porta ad una semplice espressione di quest’idea:</p>
<pre><code>template&lt;typename I&gt; concept Contiguous = is_contiguous&lt;I&gt;::value;

template&lt;typename I&gt;
concept bool Contiguous_iter = RA_iter&lt;I&gt; &amp;&amp; Contiguous&lt;I&gt;;</code></pre>
<p>Il programmatore (in una libreria) deve definire adeguatamente <code>is_contiguous</code> (un [trait]).</p>
<h5 id="note-312">Note</h5>
<p>I [rait] possono essere classi [trait] o [trait] di tipi. Questi possono essere quelli definiti dall’utente o quelli della libreria standard. Preferire quelli della libreria standard.</p>
<h5 id="imposizione-314">Imposizione</h5>
<ul>
<li>Il compilatore segnala l’uso ambiguo di concetti identici.</li>
<li>Segnalare la definizione di concetti identici.</li>
</ul>
<h3 id="t.25-evitare-i-vincoli-complementari-complementary-constraints"><a name="Rt-not"></a>T.25: Evitare i vincoli complementari [complementary constraints]</h3>
<h5 id="motivo-345">Motivo</h5>
<p>Chiarezza. Manutenibilità. Le funzioni con requisiti complementari espressi usando la negazione sono fragili.</p>
<h5 id="esempio-utilizzando-i-concetti-ts-7">Esempio (utilizzando i concetti TS)</h5>
<p>Inizialmente, le persone proveranno a definire funzioni con requisiti complementari:</p>
<pre><code>template&lt;typename T&gt;
requires !C&lt;T&gt;    // bad
void f();

template&lt;typename T&gt;
requires C&lt;T&gt;
void f();</code></pre>
<p>Questo è migliore:</p>
<pre><code>template&lt;typename T&gt;   // template generale
void f();

template&lt;typename T&gt;   // specializzazione per concetto
requires C&lt;T&gt;
void f();</code></pre>
<p>Il compilatore sceglierà il modello non vincolato solo quando <code>C&lt;T&gt;</code> non è soddisfatto. Se non si vuole (o non si può) definire una versione non vincolata di <code>f()</code>, allora a si elimina [delete].</p>
<pre><code>template&lt;typename T&gt;
void f() = delete;</code></pre>
<p>Il compilatore selezionerà il sovraccarico [overload] ed solleverà un errore appropriato.</p>
<h5 id="note-313">Note</h5>
<p>I vincoli complementari sono purtroppo comuni nel codice di <code>enable_if</code>:</p>
<pre><code>template&lt;typename T&gt;
enable_if&lt;!C&lt;T&gt;, void&gt;   // bad
f();

template&lt;typename T&gt;
enable_if&lt;C&lt;T&gt;, void&gt;
f();</code></pre>
<h5 id="note-314">Note</h5>
<p>I requisiti complementari su uno dei requisiti sono talvolta (erroneamente) considerati gestibili. Tuttavia, per due o più requisiti, il numero di definizioni richieste può aumentare in modo esponenziale (2,4,8,16,…):</p>
<pre><code>C1&lt;T&gt; &amp;&amp; C2&lt;T&gt;
!C1&lt;T&gt; &amp;&amp; C2&lt;T&gt;
C1&lt;T&gt; &amp;&amp; !C2&lt;T&gt;
!C1&lt;T&gt; &amp;&amp; !C2&lt;T&gt;</code></pre>
<p>Ora le opportunità di errori si moltiplicano.</p>
<h5 id="imposizione-315">Imposizione</h5>
<ul>
<li>Segnalare le coppie di funzioni con i vincoli <code>C&lt;T&gt;</code> e <code>!C&lt;T&gt;</code></li>
</ul>
<h3 id="t.26-preferire-la-definizione-dei-concetti-in-termini-di-schemi-duso-anziché-la-semplice-sintassi"><a name="Rt-use"></a>T.26: Preferire la definizione dei concetti in termini di schemi d’uso anziché la semplice sintassi</h3>
<h5 id="motivo-346">Motivo</h5>
<p>La definizione è più leggibile e corrisponde direttamente a ciò che un utente deve scrivere. Le conversioni vengono prese in considerazione. Non si devono ricordare i nomi di tutti i [traits] del tipo.</p>
<h5 id="esempio-utilizzando-i-concetti-ts-8">Esempio (utilizzando i concetti TS)</h5>
<p>Si potrebbe essere tentati di definire un concetto <code>Equality</code> in questo modo:</p>
<pre><code>template&lt;typename T&gt; concept Equality = has_equal&lt;T&gt; &amp;&amp; has_not_equal&lt;T&gt;;</code></pre>
<p>Ovviamente, sarebbe meglio e più semplice usare lo standard <code>EqualityComparable</code>, ma - solo per fare un esempio - se si dovesse definire un tale concetto, si preferisca:</p>
<pre><code>template&lt;typename T&gt; concept Equality = requires(T a, T b) {
bool == { a == b }
bool == { a != b }
// axiom { !(a == b) == (a != b) }
// axiom { a = b; =&gt; a == b }  // =&gt; significa &quot;implica&quot;
}</code></pre>
<p>anziché definire due concetti insignificanti <code>has_equal</code> e <code>has_not_equal</code> solo cole degli [just helper] nella definizione di <code>Equality</code>. Per “insignificante” si intende che non si può specificare la semantica di <code>has_equal</code> in isolamento.</p>
<h5 id="imposizione-316">Imposizione</h5>
<p>???</p>
<h2 id="interfacce-dei-template"><a name="SS-temp-interface"></a>Interfacce dei template</h2>
<p>Nel corso degli anni, la programmazione con i template ha subito una debole distinzione tra l’interfaccia di un template e la sua implementazione. Prima dei concetti, quella distinzione non aveva un supporto linguistico diretto. Tuttavia, l’interfaccia per un template è un concetto critico - un contratto tra un utente e un implementatore - e dovrebbe essere progettato con cura.</p>
<h3 id="t.40-usare-oggetti-funzione-per-passare-le-operazioni-agli-algoritmi"><a name="Rt-fo"></a>T.40: Usare oggetti funzione per passare le operazioni agli algoritmi</h3>
<h5 id="motivo-347">Motivo</h5>
<p>Gli oggetti funzione possono trasportare più informazioni attraverso un’interfaccia che un “semplice” puntatore a una funzione. In generale, passare oggetti funzione ha prestazioni migliori che passare puntatori a funzioni.</p>
<h5 id="esempio-utilizzando-i-concetti-ts-9">Esempio (utilizzando i concetti TS)</h5>
<pre><code>bool greater(double x, double y) { return x &gt; y; }
sort(v, greater);                                    // puntatore a funzione: potenzialmente lento
sort(v, [](double x, double y) { return x &gt; y; });   // oggetto funzione
sort(v, std::greater&lt;&gt;);                             // oggetto funzione

bool greater_than_7(double x) { return x &gt; 7; }
auto x = find_if(v, greater_than_7);                 // puntatore a funzione: inflessibile
auto y = find_if(v, [](double x) { return x &gt; 7; }); // oggetto funzione: trasporta i dati necessari
auto z = find_if(v, Greater_than&lt;double&gt;(7));        // oggetto funzione: trasporta i dati necessari</code></pre>
<p>Naturalmente, si possono generalizzare quelle funzioni con <code>auto</code> o (quando e dove disponibili) i concetti. Per esempio:</p>
<pre><code>auto y1 = find_if(v, [](Ordered x) { return x &gt; 7; }); // richiede un tipo ordinato
auto z1 = find_if(v, [](auto x) { return x &gt; 7; });    // si spera che il tipo abbia un &gt;</code></pre>
<h5 id="note-315">Note</h5>
<p>Le lambda generano oggetti funzione.</p>
<h5 id="note-316">Note</h5>
<p>L’argomento delle prestazioni dipende dalla tecnologia del compilatore e di quella dell’ottimizzatore.</p>
<h5 id="imposizione-317">Imposizione</h5>
<ul>
<li>Segnalare gli argomenti template puntatori a funzione.</li>
<li>Segnalare i puntatori a funzione passati come argomenti a un template (si rischiano falsi positivi).</li>
</ul>
<h3 id="t.41-richiedere-solo-le-proprietà-essenziali-nei-concetti-di-un-template"><a name="Rt-essential"></a>T.41: Richiedere solo le proprietà essenziali nei concetti di un template</h3>
<h5 id="motivo-348">Motivo</h5>
<p>Mantenere le interfacce semplici e stabili.</p>
<h5 id="esempio-utilizzando-i-concetti-ts-10">Esempio (utilizzando i concetti TS)</h5>
<p>Si consideri, un <code>sort</code> dotato di un semplice (molto semplificato) supporto per il debug:</p>
<pre><code>void sort(Sortable&amp; s)  // ordina le sequenze di s
{
if (debug) cerr &lt;&lt; &quot;enter sort( &quot; &lt;&lt; s &lt;&lt;  &quot;)\n&quot;;
// ...
if (debug) cerr &lt;&lt; &quot;exit sort( &quot; &lt;&lt; s &lt;&lt;  &quot;)\n&quot;;
}</code></pre>
<p>Questo dovrebbe essere riscritto in:</p>
<pre><code>template&lt;Sortable S&gt;
requires Streamable&lt;S&gt;
void sort(S&amp; s)  // ordina le sequenze di s
{
if (debug) cerr &lt;&lt; &quot;enter sort( &quot; &lt;&lt; s &lt;&lt;  &quot;)\n&quot;;
// ...
if (debug) cerr &lt;&lt; &quot;exit sort( &quot; &lt;&lt; s &lt;&lt;  &quot;)\n&quot;;
}</code></pre>
<p>Dopotutto, non esiste nulla in <code>Sortable</code> che richiede il supporto di <code>iostream</code>. D’altra parte, nell’idea fondamentale dell’ordinamento non c’è nulla che dica qualcosa sul debug.</p>
<h5 id="note-317">Note</h5>
<p>Se si richiede che ogni operazione utilizzata sia elencata tra i requisiti, l’interfaccia diventa instabile: Ogni volta che cambiano le strutture di debug, la raccolta dei dati utilizzati, il supporto dei test, la segnalazione degli errori, ecc., si dovrebbe cambiare il template e si dovrebbe ricompilare ogni utilizzo del template. Questo è poco gestibile e, in alcuni ambienti, impossibile.</p>
<p>Al contrario, se si utilizza un’operazione nell’implementazione che non è garantita dal controllo concettuale, si potrebbe ricevere un successivo errore di compilazione.</p>
<p>Non utilizzando il controllo del concetto per le proprietà di un argomento template che non è considerato essenziale, se ne ritarda il controllo fino al tempo dell’istanziazione. Questo, lo si considera un utile compromesso.</p>
<p>Si noti che anche l’utilizzo di nomi non locali e non dipendenti (come <code>debug</code> e <code>cerr</code>) introduce dipendenze dal contesto che possono portare a “misteriosi” errori.</p>
<h5 id="note-318">Note</h5>
<p>Può essere difficile decidere quali proprietà di un tipo sono essenziali e quali no.</p>
<h5 id="imposizione-318">Imposizione</h5>
<p>???</p>
<h3 id="t.42-usare-gli-alias-dei-template-per-semplificare-la-notazione-e-nascondere-i-dettagli-implementativi"><a name="Rt-alias"></a>T.42: Usare gli alias dei template per semplificare la notazione e nascondere i dettagli implementativi</h3>
<h5 id="motivo-349">Motivo</h5>
<p>Leggibilità migliorata. Occultamento dell’implementazione. Si noti che gli alias dei template sostituiscono molti usi dei [trait] per calcolare un tipo. Si possono anche usare per avvolgere [wrap] un [trait].</p>
<h5 id="esempio-301">Esempio</h5>
<pre><code>template&lt;typename T, size_t N&gt;
class Matrix {
// ...
using Iterator = typename std::vector&lt;T&gt;::iterator;
// ...
};</code></pre>
<p>Questo evita all’utente di <code>Matrix</code> il dover conoscere che gli elementi sono memorizzati in un <code>vector</code> ed evita anche che l’utente digiti ripetutamente <code>typename std::vector&lt;T&gt;::</code>.</p>
<h5 id="esempio-302">Esempio</h5>
<pre><code>template&lt;typename T&gt;
void user(T&amp; c)
{
// ...
typename container_traits&lt;T&gt;::value_type x; // non buono, prolisso
// ...
}

template&lt;typename T&gt;
using Value_type = typename container_traits&lt;T&gt;::value_type;</code></pre>
<p>Ciò evita all’utente di <code>Value_type</code> il dover conoscere la tecnica usata per implementare i <code>value_type</code>.</p>
<pre><code>template&lt;typename T&gt;
void user2(T&amp; c)
{
// ...
Value_type&lt;T&gt; x;
// ...
}</code></pre>
<h5 id="note-319">Note</h5>
<p>Un uso semplice e comune potrebbe essere espresso: “[Wrap traits]!”</p>
<h5 id="imposizione-319">Imposizione</h5>
<ul>
<li>Segnalare l’uso di <code>typename</code> come disambiguatore all’esterno delle dichiarazioni <code>using</code>.</li>
<li>???</li>
</ul>
<h3 id="t.43-preferire-using-a-typedef-per-definire-gli-alias"><a name="Rt-using"></a>T.43: Preferire <code>using</code> a <code>typedef</code> per definire gli alias</h3>
<h5 id="motivo-350">Motivo</h5>
<p>Leggibilità migliorata: Con <code>using</code>, il nuovo nome viene prima anziché essere incorporato da qualche parte in una dichiarazione. Generalità: <code>using</code> si può usare per gli alias dei template, mentre i <code>typedef</code> non possono facilmente essere template. Uniformità: <code>using</code> è sintatticamente simile ad <code>auto</code>.</p>
<h5 id="esempio-303">Esempio</h5>
<pre><code>typedef int (*PFI)(int);   // OK, ma contorto

using PFI2 = int (*)(int);   // OK, preferito

template&lt;typename T&gt;
typedef int (*PFT)(T);      // errore

template&lt;typename T&gt;
using PFT2 = int (*)(T);   // OK</code></pre>
<h5 id="imposizione-320">Imposizione</h5>
<ul>
<li>Segnalare gli usi di <code>typedef</code>. Questo troverà molti “punti” :-(</li>
</ul>
<h3 id="t.44-usare-template-di-funzioni-per-dedurre-i-tipi-degli-argomenti-della-classe-dove-fattibile"><a name="Rt-deduce"></a>T.44: Usare template di funzioni per dedurre i tipi degli argomenti della classe (dove fattibile)</h3>
<h5 id="motivo-351">Motivo</h5>
<p>Scrivere esplicitamente i tipi degli argomenti template può risultare noioso e inutilmente verboso.</p>
<h5 id="esempio-304">Esempio</h5>
<pre><code>tuple&lt;int, string, double&gt; t1 = {1, &quot;Hamlet&quot;, 3.14};   // explicit type
auto t2 = make_tuple(1, &quot;Ophelia&quot;s, 3.14);         // meglio; tipo dedotto</code></pre>
<p>Si noti l’uso del suffisso <code>s</code> per assicurarsi che la stringa sia una <code>std::string</code>, anziché una stringa in stile C.</p>
<h5 id="note-320">Note</h5>
<p>Dato che si può banalmente scrivere una funzione <code>make_T</code>, lo stesso potrebbe fare il compilatore. Pertanto, le funzioni <code>make_T</code> potrebbero, in futuro, diventare ridondanti.</p>
<h5 id="eccezione-50">Eccezione</h5>
<p>A volte non c’è un buon modo per dedurre gli argomenti template e, a volte, si desidera specificare esplicitamente gli argomenti:</p>
<pre><code>vector&lt;double&gt; v = { 1, 2, 3, 7.9, 15.99 };
list&lt;Record*&gt; lst;</code></pre>
<h5 id="note-321">Note</h5>
<p>Si noti che il C++17 renderà ridondante questa regola consentendo agli argomenti del modello di essere dedotti direttamente dagli argomenti del costruttore: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r1.html">Deduzione del parametro template per i costruttori (Rev. 3)</a>. Per esempio:</p>
<pre><code>tuple t1 = {1, &quot;Hamlet&quot;s, 3.14}; // dedotto: tuple&lt;int, string, double&gt;</code></pre>
<h5 id="imposizione-321">Imposizione</h5>
<p>Segnalare gli usi dove un tipo specializzato esplicitamente coincide con i tipi degli argomenti usati.</p>
<h3 id="t.46-richiedere-che-gli-argomenti-template-siano-almeno-regolari-o-semiregolari"><a name="Rt-regular"></a>T.46: Richiedere che gli argomenti template siano almeno <code>Regolari</code> o <code>SemiRegolari</code></h3>
<h5 id="motivo-352">Motivo</h5>
<p>Leggibilità. Prevenire sorprese ed errori. La maggior parte utilizza comunque questo supporto.</p>
<h5 id="esempio-305">Esempio</h5>
<pre><code>class X {
public:
explicit X(int);
X(const X&amp;);            // copia
X operator=(const X&amp;);
X(X&amp;&amp;) noexcept;                 // sposta [move]
X&amp; operator=(X&amp;&amp;) noexcept;
~X();
// ... nessun altro costruttore ...
};

X x {1};    // va bene
X y = x;      // va bene
std::vector&lt;X&gt; v(10); // errore: nessun costruttore di default</code></pre>
<h5 id="note-322">Note</h5>
<p>Semiregolare richiede il costruttore di default.</p>
<h5 id="imposizione-322">Imposizione</h5>
<ul>
<li>Segnalare i tipi che non sono almeno <code>SemiRegolari</code>.</li>
</ul>
<h3 id="t.47-evitare-i-template-senza-vincoli-molto-evidenti-con-nomi-comuni"><a name="Rt-visible"></a>T.47: Evitare i template senza vincoli molto evidenti con nomi comuni</h3>
<h5 id="motivo-353">Motivo</h5>
<p>Un argomento template senza vincoli è una perfetta corrispondenza con qualsiasi cosa, quindi un tale template è preferibile a tipi più specifici che richiedono conversioni minori. Ciò è particolarmente fastidioso/pericoloso quando si usa l’ADL (Argument-Dependent Lookup). I nomi comuni rendono questo problema più probabile.</p>
<h5 id="esempio-306">Esempio</h5>
<pre><code>namespace Bad {
struct S { int m; };
template&lt;typename T1, typename T2&gt;
bool operator==(T1, T2) { cout &lt;&lt; &quot;Bad\n&quot;; return true; }
}

namespace T0 {
bool operator==(int, Bad::S) { cout &lt;&lt; &quot;T0\n&quot;; return true; }  // confronta con int

void test()
{
Bad::S bad{ 1 };
vector&lt;int&gt; v(10);
bool b = 1 == bad;
bool b2 = v.size() == bad;
}
}</code></pre>
<p>Stampa <code>T0</code> e <code>Bad</code>.</p>
<p>Ora l’<code>==</code> in <code>Bad</code> è stato progettato per causare problemi, ma nel codice reale, sarebbe stato individuato il problema? Il problema è che <code>v.size()</code> restituisce un intero <code>unsigned</code> in modo che sia necessaria una conversione per chiamare il <code>==</code> locale; l’<code>==</code> in <code>Bad</code> non richiede alcuna conversione. I tipi realistici, come gli iteratori nella libreria standard si possono realizzare per mostrare simili tendenze anti-sociali.</p>
<h5 id="note-323">Note</h5>
<p>Se un template senza vincoli è definito nello stesso namespace del tipo, tale template senza vincoli si può trovare per l’ADL (come avvenuto nell’esempio). Questo, è molto evidente.</p>
<h5 id="note-324">Note</h5>
<p>Questa regola non dovrebbe essere necessaria, ma il comitato non può accettare di escludere template non vincolati da ADL.</p>
<p>Purtroppo questo porterà a molti falsi positivi; la libreria standard la viola ampiamente, inserendo molti template non vincolati e tipi nel singolo namespace <code>std</code>.</p>
<h5 id="imposizione-323">Imposizione</h5>
<p>Segnalare i template definiti in un namespace dove sono definiti anche i tipi concreti (forse non fattibile finché non si avranno i concetti).</p>
<h3 id="t.48-se-il-compilatore-non-supporta-i-concetti-simularli-con-enable_if"><a name="Rt-concept-def"></a>T.48: Se il compilatore non supporta i concetti, simularli con <code>enable_if</code></h3>
<h5 id="motivo-354">Motivo</h5>
<p>Perché è il meglio che possiamo fare senza il supporto diretto del concetto. <code>enable_if</code> si può usare per definire condizionalmente le funzioni e per selezionare tra una serie di funzioni.</p>
<h5 id="esempio-307">Esempio</h5>
<pre><code>template &lt;typename T&gt;
enable_if_t&lt;is_integral_v&lt;T&gt;&gt;
f(T v)
{
// ...
}

// Equivalente a:
template &lt;Integral T&gt;
void f(T v)
{
// ...
}</code></pre>
<h5 id="note-325">Note</h5>
<p>Attenzione ai <a href="#%20T.25">vincoli complementari [complementary constraints]</a>. Il falso [overloading] del concetto utilizzando <code>enable_if</code> a volte costringe ad usare questa tecnica di progettazione soggetta a errori.</p>
<h5 id="imposizione-324">Imposizione</h5>
<p>???</p>
<h3 id="t.49-dove-possibile-evitare-la-type-erasure"><a name="Rt-erasure"></a>T.49: Dove possibile, evitare la [type-erasure]</h3>
<h5 id="motivo-355">Motivo</h5>
<p>La cancellazione del tipo [type erasure] comporta un ulteriore livello di indirezione nascondendo l’informazione sul tipo dietro una compilazione separata.</p>
<h5 id="esempio-308">Esempio</h5>
<pre><code>???</code></pre>
<p><strong>Eccezioni</strong>: La cancellazione del tipo [type erasure] è talvolta appropriata, come per <code>std::function</code>.</p>
<h5 id="imposizione-325">Imposizione</h5>
<p>???</p>
<h5 id="note-326">Note</h5>
<h2 id="t.def-definizioni-dei-template"><a name="SS-temp-def"></a>T.def: Definizioni dei template</h2>
<p>Una definizione di un template (classe o funzione) può contenere del codice arbitrario, quindi per coprire questo argomento, ci vorrebbe una completa revisione delle tecniche di programmazione C++. Tuttavia, questa sezione si concentra su ciò che è specifico per l’implementazione del template. In particolare, si concentra sulla dipendenza di una definizione di template dal suo contesto.</p>
<h3 id="t.60-minimizzare-le-dipendenze-dal-contesto-di-un-template"><a name="Rt-depend"></a>T.60: Minimizzare le dipendenze dal contesto di un template</h3>
<h5 id="motivo-356">Motivo</h5>
<p>Facilita la comprensione. Riduce al minimo gli errori da dipendenze impreviste. Facilita la creazione di tool.</p>
<h5 id="esempio-309">Esempio</h5>
<pre><code>template&lt;typename C&gt;
void sort(C&amp; c)
{
std::sort(begin(c), end(c)); // dipendenza necessaria e utile
}

template&lt;typename Iter&gt;
Iter algo(Iter first, Iter last) {
for (; first != last; ++first) {
auto x = sqrt(*first); // dipendenza potenzialmente sorprendente: quale sqrt()?
helper(first, x);      // dipendenza potenzialmente sorprendente:
// helper è scelto in base a first e x
TT var = 7;            // dipendenza potenzialmente sorprendente: quale TT?
}
}</code></pre>
<h5 id="note-327">Note</h5>
<p>I template solitamente appaiono nei file header quindi le loro dipendenze dal contesto sono più vulnerabili all’ordine degli <code>#include</code> che alle funzioni nei file <code>.cpp</code>.</p>
<h5 id="note-328">Note</h5>
<p>Avere un template che opera solo sui suoi argomenti sarebbe un modo per ridurre il numero delle dipendenze al minimo, ma sarebbe generalmente ingestibile. Per esempio, ul algoritmo solitamente usa altri algoritmi e invoca operazioni che non operano esclusivamente su argomenti. E non si cominci ad usare le macro!</p>
<p><strong>Si veda anche</strong>: <a href="#Rt-customization">T.69</a></p>
<h5 id="imposizione-326">Imposizione</h5>
<p>??? Difficile</p>
<h3 id="t.61-non-sovra-parametrizzare-i-membri-scary"><a name="Rt-scary"></a>T.61: Non sovra-parametrizzare i membri (“SCARY”)</h3>
<h5 id="motivo-357">Motivo</h5>
<p>Un membro che non dipende da un parametro template non può essere utilizzato se non per uno specifico argomento template. Questo ne limita l’uso e in genere aumenta la dimensione del codice.</p>
<h5 id="esempio-cattivo-128">Esempio, cattivo</h5>
<pre><code>template&lt;typename T, typename A = std::allocator{}&gt;
// requires Regular&lt;T&gt; &amp;&amp; Allocator&lt;A&gt;
class List {
public:
struct Link {   // non dipende da A
T elem;
T* pre;
T* suc;
};

using iterator = Link*;

iterator first() const { return head; }

// ...
private:
Link* head;
};

List&lt;int&gt; lst1;
List&lt;int, My_allocator&gt; lst2;</code></pre>
<p>Sembra abbastanza innocente, ma ora il <code>Link</code> dipende formalmente dall’allocatore (anche se non usa l’allocatore). Ciò impone istanze ridondanti che possono risultare sorprendentemente costose in alcuni scenari del mondo reale. In genere, la soluzione consiste nel rendere non locale quella che sarebbe stata una classe nidificata, con il proprio set minimo di parametri template.</p>
<pre><code>template&lt;typename T&gt;
struct Link {
T elem;
T* pre;
T* suc;
};

template&lt;typename T, typename A = std::allocator{}&gt;
// requires Regular&lt;T&gt; &amp;&amp; Allocator&lt;A&gt;
class List2 {
public:
using iterator = Link&lt;T&gt;*;

iterator first() const { return head; }

// ...
private:
Link* head;
};

List&lt;int&gt; lst1;
List&lt;int, My_allocator&gt; lst2;</code></pre>
<p>Alcuni hanno trovato l’idea che il <code>Link</code> non sia più nascosto nel pauroso [scary] elenco, quindi chiamiamo tale tecnica <a href="http://www.open-std.org/jtc1/sc22/WG21/docs/papers/2009/n2911.pdf">SCARY</a>. Da quel documento accademico: “L’acronimo SCARY descrive assegnazioni e inizializzazioni che Sembrano sbagliate (apparendo vincolate [Constrained] da parametri generici in conflitto), ma in realtà [Actually] funzionano con la giusta [Right] implementazione (non vincolata dal [bY] conflitto a causa di dipendenze minimizzate)”.</p>
<h5 id="imposizione-327">Imposizione</h5>
<ul>
<li>Segnalare i tipi membro che non dipendono da ogni argomento template</li>
<li>Segnalare le funzioni membro che non dipendono da ogni argomento template</li>
</ul>
<h3 id="t.62-porre-i-membri-della-classe-template-non-dipendenti-in-una-classe-base-non-template"><a name="Rt-nondependent"></a>T.62: Porre i membri della classe template non-dipendenti in una classe base non-template</h3>
<h5 id="motivo-358">Motivo</h5>
<p>Consentire ai membri della classe base di essere utilizzati senza specificare gli argomenti template e senza istanziare il template.</p>
<h5 id="esempio-310">Esempio</h5>
<pre><code>template&lt;typename T&gt;
class Foo {
public:
enum { v1, v2 };
// ...
};</code></pre>
<p>???</p>
<pre><code>struct Foo_base {
enum { v1, v2 };
// ...
};

template&lt;typename T&gt;
class Foo : public Foo_base {
public:
// ...
};</code></pre>
<h5 id="note-329">Note</h5>
<p>Una versione più generale di questa regola sarebbe “Se un membro della classe template dipende da solo N parametri template di M, lo si mette in una classe base con solo N parametri”. Per N == 1, si ha una scelta di una classe base di una classe nello scope circostante come in <a href="#Rt-scary">T.61</a>.</p>
<p>??? E sulle costanti? statica delle classi?</p>
<h5 id="imposizione-328">Imposizione</h5>
<ul>
<li>Flag ???</li>
</ul>
<h3 id="t.64-usare-la-specializzazione-per-fornire-implementazioni-alternative-di-classi-template"><a name="Rt-specialization"></a>T.64: Usare la specializzazione per fornire implementazioni alternative di classi template</h3>
<h5 id="motivo-359">Motivo</h5>
<p>Un template definisce un’interfaccia generale. La specializzazione offre un potente meccanismo per fornire implementazioni alternative di tale interfaccia.</p>
<h5 id="esempio-311">Esempio</h5>
<pre><code>??? specializzazione di string (==)

??? specializzazione della rappresentazione ?</code></pre>
<h5 id="note-330">Note</h5>
<p>???</p>
<h5 id="imposizione-329">Imposizione</h5>
<p>???</p>
<h3 id="t.65-usare-il-tag-dispatch-per-fornire-implementazioni-alternative-delle-funzioni"><a name="Rt-tag-dispatch"></a>T.65: Usare il [tag dispatch] per fornire implementazioni alternative delle funzioni</h3>
<h5 id="motivo-360">Motivo</h5>
<ul>
<li>Un template definisce un’interfaccia generale.</li>
<li>Il [tag dispatch] consente di selezionare le implementazioni in base a specifiche proprietà di un tipo di un argomento.</li>
<li>Prestazione.</li>
</ul>
<h5 id="esempio-312">Esempio</h5>
<p>Questa è una versione semplificata di <code>std::copy</code> (si ignora la possibilità di sequenze non contigue)</p>
<pre><code>struct pod_tag {};
struct non_pod_tag {};

template&lt;class T&gt; struct copy_trait { using tag = non_pod_tag; };   // T non è un &quot;Plain Old Data&quot;

template&lt;&gt; struct copy_trait&lt;int&gt; { using tag = pod_tag; };         // int è un &quot;Plain Old Data&quot;

template&lt;class Iter&gt;
Out copy_helper(Iter first, Iter last, Iter out, pod_tag)
{
// usa memmove
}

template&lt;class Iter&gt;
Out copy_helper(Iter first, Iter last, Iter out, non_pod_tag)
{
// usa un ciclo che chiama i costruttori copia
}

template&lt;class Itert&gt;
Out copy(Iter first, Iter last, Iter out)
{
return copy_helper(first, last, out, typename copy_trait&lt;Iter&gt;::tag{})
}

void use(vector&lt;int&gt;&amp; vi, vector&lt;int&gt;&amp; vi2, vector&lt;string&gt;&amp; vs, vector&lt;string&gt;&amp; vs2)
{
copy(vi.begin(), vi.end(), vi2.begin()); // usa memmove
copy(vs.begin(), vs.end(), vs2.begin()); // usa un ciclo che chiama i costruttori copia
}</code></pre>
<p>Questa è una tecnica generale e potente per la selezione dell’algoritmo in fase di compilazione.</p>
<h5 id="note-331">Note</h5>
<p>Quando diventerà ampiamente disponibile il <code>concept</code> tali alternative si potranno distinguere direttamente:</p>
<pre><code>template&lt;class Iter&gt;
requires Pod&lt;Value_type&lt;iter&gt;&gt;
Out copy_helper(In, first, In last, Out out)
{
// usa memmove
}

template&lt;class Iter&gt;
Out copy_helper(In, first, In last, Out out)
{
// usa un ciclo che chiama i costruttori copia
}</code></pre>
<h5 id="imposizione-330">Imposizione</h5>
<p>???</p>
<h3 id="t.67-usare-la-specializzazione-per-fornire-implementazioni-alternative-per-i-tipi-irregolari"><a name="Rt-specialization2"></a>T.67: Usare la specializzazione per fornire implementazioni alternative per i tipi irregolari</h3>
<h5 id="motivo-361">Motivo</h5>
<p>???</p>
<h5 id="esempio-313">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="imposizione-331">Imposizione</h5>
<p>???</p>
<h3 id="t.68-usare-anziché-nei-template-per-evitare-ambiguità"><a name="Rt-cast"></a>T.68: Usare <code>{}</code> anziché <code>()</code> nei template per evitare ambiguità</h3>
<h5 id="motivo-362">Motivo</h5>
<p><code>()</code> è vulnerabile alle ambiguità della grammatica.</p>
<h5 id="esempio-314">Esempio</h5>
<pre><code>template&lt;typename T, typename U&gt;
void f(T t, U u)
{
T v1(x);    // v1 è una funzione o una variabile?
T v2 {x};   // variabile
auto x = T(u);  // costruzione o cast?
}

f(1, &quot;asdf&quot;); // non buono: il cast da const char* a int</code></pre>
<h5 id="imposizione-332">Imposizione</h5>
<ul>
<li>segnalare gli inizializzatori <code>()</code></li>
<li>segnalare i cast in stile funzione</li>
</ul>
<h3 id="t.69-allinterno-di-un-template-non-effettuare-una-chiamata-di-funzione-non-membro-non-qualificata-a-meno-che-non-lo-si-intenda-come-un-punto-di-personalizzazione"><a name="Rt-customization"></a>T.69: All’interno di un template, non effettuare una chiamata di funzione non-membro non-qualificata a meno che non lo si intenda come un punto di personalizzazione</h3>
<h5 id="motivo-363">Motivo</h5>
<ul>
<li>Fornire solo la flessibilità prevista.</li>
<li>Evitare la vulnerabilità a cambiamenti accidentali dell’environment.</li>
</ul>
<h5 id="esempio-315">Esempio</h5>
<p>Ci sono tre modi principali per consentire al codice chiamante di personalizzare un template.</p>
<pre><code>template&lt;class T&gt;
// Chiama una funzione membro
void test1(T t)
{
t.f();    // richiede che T fornisca f()
}

template&lt;class T&gt;
void test2(T t)
// Chiama una funzione non-membro senza qualificazione
{
f(t);  // richiede che f(/*T*/) sia disponibile nello scope del chiamante o nel namespace di T
}

template&lt;class T&gt;
void test3(T t)
// Invoca un &quot;trait&quot;
{
test_traits&lt;T&gt;::f(t); // richiede la personalizzazione di test_traits&lt;&gt;
// per ottenere funzioni/tipi non di default
}</code></pre>
<p>Un [trait] è solitamente un alias di un tipo per calcolare un tipo, una funzione <code>constexpr</code> che calcola un valore, o un tradizionale template di [traits] per essere specializzato sul tipo dell’utente.</p>
<h5 id="note-332">Note</h5>
<p>Se si intende chiamare la propria funzione d’aiuto <code>helper(t)</code> con un valore <code>t</code> che dipende da un tipo di parametro template, si mette in un namespace <code>::detail</code> e si qualifica la chiamata come <code>detail::helper(t);</code>. Una chiamata non qualificata diventa un punto di personalizzazione in cui ogni funzione <code>helper</code> si può chiamare nel namespace dei tipi <code>t</code>; ciò può provocare problemi come <a href="#Rt-unconstrained-adl">invocare involontariamente funzioni template non vincolate</a>.</p>
<h5 id="imposizione-333">Imposizione</h5>
<ul>
<li>In un template, segnalare una chiamata non qualificata ad una funzione non-membro che passa una variabile di un tipo dipendente quando c’è una funzione non-membro con lo stesso nome nel namespace del template.</li>
</ul>
<h2 id="t.temp-hier-regole-sulla-gerarchia-e-i-template"><a name="SS-temp-hier"></a>T.temp-hier: Regole sulla gerarchia e i template:</h2>
<p>I template sono la spina dorsale del C++ per il supporto alla programmazione generica e la gerarchia di classi è la spina dorsale per il supporto della programmazione object-oriented. I due meccanismi del linguaggio si possono usare efficacemente in combinazione, ma è necessario evitare alcune insidie progettuali.</p>
<h3 id="t.80-non-rendere-template-nativamente-una-gerarchia-di-classi"><a name="Rt-hier"></a>T.80: Non rendere template nativamente una gerarchia di classi</h3>
<h5 id="motivo-364">Motivo</h5>
<p>Rendere template una gerarchia di classi con molte funzioni, specialmente molte funzioni virtuali, può portare a codice inutile [code bloat].</p>
<h5 id="esempio-cattivo-129">Esempio, cattivo</h5>
<pre><code>template&lt;typename T&gt;
struct Container {         // una interfaccia
virtual T* get(int i);
virtual T* first();
virtual T* next();
virtual void sort();
};

template&lt;typename T&gt;
class Vector : public Container&lt;T&gt; {
public:
// ...
};

Vector&lt;int&gt; vi;
Vector&lt;string&gt; vs;</code></pre>
<p>Probabilmente è una idea stupida definire un <code>sort</code> come funzione membro di un container, ma non è inaudito ed è un buon esempio di cosa non fare.</p>
<p>Detto questo, il compilatore non può sapere se viene chiamato <code>vector&lt;int&gt;::sort()</code>, quindi deve generare del codice per esso. Lo stesso per <code>vector&lt;string&gt;::sort()</code>. A meno che queste due funzioni non siano chiamate, questo è codice inutile [code bloat]. Si immagini cosa farebbe ad una gerarchia di classi con decine di classi derivate con molte istanze.</p>
<h5 id="note-333">Note</h5>
<p>In molti casi si può fornire un’interfaccia stabile evitando di parametrizzare una base; cfr. <a href="#Rt-abi">“base stabile”</a> e <a href="#Rt-generic-oo">OO e GP</a></p>
<h5 id="imposizione-334">Imposizione</h5>
<ul>
<li>Segnalare le funzioni virtuali che dipendono da un argomento template. ??? Falsi positivi</li>
</ul>
<h3 id="t.81-non-mischiare-le-gerarchie-con-gli-array"><a name="Rt-array"></a>T.81: Non mischiare le gerarchie con gli array</h3>
<h5 id="motivo-365">Motivo</h5>
<p>Un array di classi derivate può implicitamente “ridursi” ad un puntatore ad una classe base con risultati potenzialmente disastrosi.</p>
<h5 id="esempio-316">Esempio</h5>
<p>Si supponga che <code>Apple</code> e <code>Pear</code> siano due tipi di <code>Fruit</code>.</p>
<pre><code>void maul(Fruit* p)
{
*p = Pear{};     // mette un oggetto Pear in *p
p[1] = Pear{};   // mette un oggetto Pear in p[1]
}

Apple aa [] = { an_apple, another_apple };   // aa contiene tutti oggetti Apple (ovviamente!)

maul(aa);
Apple&amp; a0 = &amp;aa[0];   // un oggetto Pear?
Apple&amp; a1 = &amp;aa[1];   // un oggetto Pear?</code></pre>
<p>Probabilmente, <code>aa[0]</code> sarà un oggetto <code>Pear</code> (senza usare un cast!). Se <code>sizeof(Apple) != sizeof(Pear)</code> l’accesso a <code>aa[1]</code> non sarà allineato al giusto inizio di un oggetto nell’array. C’è una violazione del tipo e forse (probabilmente) una corruzione della memoria. Mai scrivere codice simile.</p>
<p>Si noti che <code>maul()</code> viola la <a href="#Rf-ptr">regola che <code>T*</code> punta ad in singolo oggetto</a>.</p>
<p><strong>Alternativa</strong>: Usare un contenitore appropriato (template):</p>
<pre><code>void maul2(Fruit* p)
{
*p = Pear{};   // mette un oggetto Pear in *p
}

vector&lt;Apple&gt; va = { an_apple, another_apple };   // va contiene tutti oggetti Apple (ovviamente!)

maul2(va);       // errore: non si può convertire un vector&lt;Apple&gt; in un Fruit*
maul2(&amp;va[0]);   // è stato richiesto

Apple&amp; a0 = &amp;va[0];   // un oggetto Pear?</code></pre>
<p>Si noti che l’assegnazione in <code>maul2()</code> viola la <a href="#Res-slice">regola del non provocare “slice”</a>.</p>
<h5 id="imposizione-335">Imposizione</h5>
<ul>
<li>Rilevare questo orrore!</li>
</ul>
<h3 id="t.82-linearizzare-una-gerarchia-quando-le-funzioni-virtuali-sono-indesiderabili"><a name="Rt-linear"></a>T.82: Linearizzare una gerarchia quando le funzioni virtuali sono indesiderabili</h3>
<h5 id="motivo-366">Motivo</h5>
<p>???</p>
<h5 id="esempio-317">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="imposizione-336">Imposizione</h5>
<p>???</p>
<h3 id="t.83-non-dichiarare-virtuale-una-funzione-membro-template"><a name="Rt-virtual"></a>T.83: Non dichiarare virtuale una funzione membro template</h3>
<h5 id="motivo-367">Motivo</h5>
<p>Il C++ non lo supporta. Nel caso, non si potrebbe generare le tabelle virtuali [vtbl] fino al momento del link. E, in generale, le implementazioni devono occuparsi del link dinamico.</p>
<h5 id="esempio-da-non-fare-8">Esempio, da non fare</h5>
<pre><code>class Shape {
// ...
template&lt;class T&gt;
virtual bool intersect(T* p);   // errore: il template non può essere virtuale
};</code></pre>
<h5 id="note-334">Note</h5>
<p>C’è bisogno di una regola perché le persone continuano a chiederlo</p>
<h5 id="alternativa-11">Alternativa</h5>
<p>Double dispatch, visitors, calcola quale funzione chiamare</p>
<h5 id="imposizione-337">Imposizione</h5>
<p>Il compilatore lo gestisce.</p>
<h3 id="t.84-usare-un-nucleo-implementativo-non-template-per-fornire-uninterfaccia-abi-stabile"><a name="Rt-abi"></a>T.84: Usare un nucleo implementativo non-template per fornire un’interfaccia ABI stabile</h3>
<h5 id="motivo-368">Motivo</h5>
<p>Migliora la stabilità del codice. Evita codice inutile [code bloat].</p>
<h5 id="esempio-318">Esempio</h5>
<p>Potrebbe essere una classe base:</p>
<pre><code>struct Link_base {   // stabile
Link_base* suc;
Link_base* pre;
};

template&lt;typename T&gt;   // un wrapper template per aggiungere la sicurezza del tipo
struct Link : Link_base {
T val;
};

struct List_base {
Link_base* first;   // il primo elemento (se c&#39;è)
int sz;             // il numero di elementi
void add_front(Link_base* p);
// ...
};

template&lt;typename T&gt;
class List : List_base {
public:
void put_front(const T&amp; e) { add_front(new Link&lt;T&gt;{e}); }   // cast implicito a Link_base
T&amp; front() { static_cast&lt;Link&lt;T&gt;*&gt;(first).val; }   // cast esplicito di nuovo a Link&lt;T&gt;
// ...
};

List&lt;int&gt; li;
List&lt;string&gt; ls;</code></pre>
<p>Ora c’è solo una copia delle operazioni degli elementi collegati e non di un elenco <code>List</code>. Le classi <code>Link</code> e <code>List</code> non fanno nulla altro che gestire il tipo.</p>
<p>Anziché usare un tipo “base” separato, un’altre comune tecnica consiste nello specializzare <code>void</code> o <code>void*</code> ed avere il template generale per <code>T</code> solo per i cast sicuri incapsulati da e per l’implementazione centrale di <code>void</code>.</p>
<p><strong>Alternativa</strong>: Usare un’implementazione <a href="#Ri-pimpl">Pimpl</a> [Pointer to IMPLementation].</p>
<h5 id="imposizione-338">Imposizione</h5>
<p>???</p>
<h2 id="t.var-regole-sui-template-variadici"><a name="SS-variadic"></a>T.var: Regole sui template variadici</h2>
<p>???</p>
<h3 id="t.100-usare-i-template-variadici-quando-cè-bisogno-di-una-funzione-che-prende-un-numero-variabile-di-argomenti-di-vari-tipi"><a name="Rt-variadic"></a>T.100: Usare i template variadici quando c’è bisogno di una funzione che prende un numero variabile di argomenti di vari tipi</h3>
<h5 id="motivo-369">Motivo</h5>
<p>Il template variadico è il meccanismo più generale, ed è sia efficiente che sicuro [type-safe]. Non usare i vararg del C.</p>
<h5 id="esempio-319">Esempio</h5>
<pre><code>??? printf</code></pre>
<h5 id="imposizione-339">Imposizione</h5>
<ul>
<li>Segnalare gli usi di <code>va_arg</code> nel codice utente.</li>
</ul>
<h3 id="t.101-coe-passare-gli-argomenti-ad-un-template-variadico"><a name="Rt-variadic-pass"></a>T.101: ??? Coe passare gli argomenti ad un template variadico ???</h3>
<h5 id="motivo-370">Motivo</h5>
<p>???</p>
<h5 id="esempio-320">Esempio</h5>
<pre><code>??? attenzione agli argomenti [move-only] e ai riferimenti</code></pre>
<h5 id="imposizione-340">Imposizione</h5>
<p>???</p>
<h3 id="t.102-come-processare-gli-argomenti-in-un-template-variadico"><a name="Rt-variadic-process"></a>T.102: Come processare gli argomenti in un template variadico</h3>
<h5 id="motivo-371">Motivo</h5>
<p>???</p>
<h5 id="esempio-321">Esempio</h5>
<pre><code>??? [forwarding], controllo del tipo, riferimenti</code></pre>
<h5 id="imposizione-341">Imposizione</h5>
<p>???</p>
<h3 id="t.103-non-usare-i-template-variadici-per-liste-di-argomenti-omogenei"><a name="Rt-variadic-not"></a>T.103: Non usare i template variadici per liste di argomenti omogenei</h3>
<h5 id="motivo-372">Motivo</h5>
<p>Ci sono modi piò precisi per indicare una sequenza omogenea, come <code>initializer_list</code>.</p>
<h5 id="esempio-322">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="imposizione-342">Imposizione</h5>
<p>???</p>
<h2 id="t.meta-meta-programmazione-template-tmp"><a name="SS-meta"></a>T.meta: Meta-programmazione template (TMP)</h2>
<p>I template forniscono un meccanismo generale per la programmazione in fase di compilazione.</p>
<p>La meta-programmazione è una programmazione dove almeno un input o un risultato è un tipo. I template durante la compilazione offrono una “tipizzazione dinamica” [duck typing] “Turing-equivalenti” (modulo memoria capacità). La sintassi e le tecniche necessarie sono piuttosto orrende.</p>
<h3 id="t.120-usare-la-meta-programmazione-template-solo-quando-è-veramente-necessario"><a name="Rt-metameta"></a>T.120: Usare la meta-programmazione template solo quando è veramente necessario</h3>
<h5 id="motivo-373">Motivo</h5>
<p>La meta-programmazione template è difficile da ottenere, rallenta la compilazione, ed è spesso difficilissima da manutenere. Tuttavia, ci sono esempi reali in cui la meta-programmazione template offre prestazioni migliori rispetto a qualsiasi altra alternativa a meno di usare il codice assembly ad un livello esperto. Ci sono anche esempi reali dove la meta-programmazione template esprime le idee fondamentali meglio del codice in esecuzione. Per esempio, se è necessario gestire l’AST ([Abstract Syntax Tree] durante la compilazione (p.es., per un opzionale operazione di riduzione [folding] di una matrice) potrebbe non esserci un altro modo in C++.</p>
<h5 id="esempio-cattivo-130">Esempio, cattivo</h5>
<pre><code>???</code></pre>
<h5 id="esempio-cattivo-131">Esempio, cattivo</h5>
<pre><code>enable_if</code></pre>
<p>Usare, invece, i concetti. Ma si veda <a href="#Rt-emulate">Come emulare i concetti se il linguaggio non lo supporta</a>.</p>
<h5 id="esempio-323">Esempio</h5>
<pre><code>??? buono</code></pre>
<p><strong>Alternativa</strong>: Se il risultato è un valore, anziché un tipo, usare una funzione <a href="#Rt-fct"><code>constexpr</code></a>.</p>
<h5 id="note-335">Note</h5>
<p>Se si ritiene di dover nascondere la meta-programmazione dei template nelle macro, probabilmente si è andati oltre.</p>
<h3 id="t.121-usare-la-meta-programmazione-template-soprattutto-per-emulare-i-concetti"><a name="Rt-emulate"></a>T.121: Usare la meta-programmazione template soprattutto per emulare i concetti</h3>
<h5 id="motivo-374">Motivo</h5>
<p>Finché i concetti non saranno generalmente disponibili, si dovranno emulare con la TMP. I casi d’uso che richiedono i concetti (p.es. l’overloading basato sui concetti) sono tra quelli più comuni (e semplici) utilizzi della TMP.</p>
<h5 id="esempio-324">Esempio</h5>
<pre><code>template&lt;typename Iter&gt;
/*requires*/ enable_if&lt;random_access_iterator&lt;Iter&gt;, void&gt;
advance(Iter p, int n) { p += n; }

template&lt;typename Iter&gt;
/*requires*/ enable_if&lt;forward_iterator&lt;Iter&gt;, void&gt;
advance(Iter p, int n) { assert(n &gt;= 0); while (n--) ++p;}</code></pre>
<h5 id="note-336">Note</h5>
<p>Tale codice è molto più semplice usando i concetti:</p>
<pre><code>void advance(RandomAccessIterator p, int n) { p += n; }

void advance(ForwardIterator p, int n) { assert(n &gt;= 0); while (n--) ++p;}</code></pre>
<h5 id="imposizione-343">Imposizione</h5>
<p>???</p>
<h3 id="t.122-usare-i-template-solitamente-alias-di-template-per-elaborare-i-tipi-in-fase-di-compilazione"><a name="Rt-tmp"></a>T.122: Usare i template (solitamente alias di template) per elaborare i tipi in fase di compilazione</h3>
<h5 id="motivo-375">Motivo</h5>
<p>La meta-programmazione template è l’unico modo essere supportato direttamente, e quasi un principio [half-way principled], per generare tipi in fase di compilazione.</p>
<h5 id="note-337">Note</h5>
<p>Le tecniche “trait” sono per lo più sostituite dagli alias dei template per calcolare i tipi e dalle funzioni <code>constexpr</code> per calcolare i valori.</p>
<h5 id="esempio-325">Esempio</h5>
<pre><code>??? ottimizzazione oggetto grande / oggetto piccolo</code></pre>
<h5 id="imposizione-344">Imposizione</h5>
<p>???</p>
<h3 id="t.123-usare-funzioni-constexpr-per-elaborare-i-valori-in-fase-di-compilazione"><a name="Rt-fct"></a>T.123: Usare funzioni <code>constexpr</code> per elaborare i valori in fase di compilazione</h3>
<h5 id="motivo-376">Motivo</h5>
<p>Una funzione è il modo più ovvio e conveniente per esprimere il calcolo di un valore. Spesso una funzione <code>constexpr</code> implica un minor tempo di compilazione rispetto alle alternative.</p>
<h5 id="note-338">Note</h5>
<p>Le tecniche “trait” sono per lo più sostituite dagli alias dei template per calcolare i tipi e dalle funzioni <code>constexpr</code> per calcolare i valori.</p>
<h5 id="esempio-326">Esempio</h5>
<pre><code>template&lt;typename T&gt;
// requires Number&lt;T&gt;
constexpr T pow(T v, int n)   // potenza/esponenziale
{
T res = 1;
while (n--) res *= v;
return res;
}

constexpr auto f7 = pow(pi, 7);</code></pre>
<h5 id="imposizione-345">Imposizione</h5>
<ul>
<li>Segnalare meta-programmi template che ottengono un valore. Questi dovrebbero essere sostituiti con funzioni <code>constexpr</code>.</li>
</ul>
<h3 id="t.124-preferire-luso-delle-funzioni-tmp-della-libreria-standard"><a name="Rt-std-tmp"></a>T.124: Preferire l’uso delle funzioni TMP della libreria standard</h3>
<h5 id="motivo-377">Motivo</h5>
<p>Le funzionalità definite nello standard, come <code>conditional</code>, <code>enable_if</code>, e <code>tuple</code>, sono portabili e si può supporre che siano note.</p>
<h5 id="esempio-327">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="imposizione-346">Imposizione</h5>
<p>???</p>
<h3 id="t.125-se-cè-bisogno-di-andare-oltre-le-funzioni-tmp-della-libreria-standard-usare-una-libreria-esistente"><a name="Rt-lib"></a>T.125: Se c’è bisogno di andare oltre le funzioni TMP della libreria standard, usare una libreria esistente</h3>
<h5 id="motivo-378">Motivo</h5>
<p>Ottenere servizi TMP non è facile e l’uso di una libreria ci rende parte (si spera di supporto) di una comunità. Scrivere il proprio “supporto TMP avanzato” solo se è veramente necessario.</p>
<h5 id="esempio-328">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="imposizione-347">Imposizione</h5>
<p>???</p>
<h2 id="altre-regole-dei-template"><a name="SS-temp-other"></a>Altre regole dei template</h2>
<h3 id="t.140-dare-un-nome-a-tutte-le-funzioni-potenzialmente-riutilizzabili"><a name="Rt-name"></a>T.140: Dare un nome a tutte le funzioni potenzialmente riutilizzabili</h3>
<h5 id="motivo-379">Motivo</h5>
<p>Documentazione, leggibilità, opportunità di riutilizzo.</p>
<h5 id="esempio-329">Esempio</h5>
<pre><code>struct Rec {
string name;
string addr;
int id;         // identificatore unico
};

bool same(const Rec&amp; a, const Rec&amp; b)
{
return a.id == b.id;
}

vector&lt;Rec*&gt; find_id(const string&amp; name);    // cerca tutti i record per &quot;name&quot;

auto x = find_if(vr.begin(), vr.end(),
[&amp;](Rec&amp; r) {
if (r.name.size() != n.size()) return false; // il nome da confrontare è in n
for (int i = 0; i &lt; r.name.size(); ++i)
if (tolower(r.name[i]) != tolower(n[i])) return false;
return true;
}
);</code></pre>
<p>Qui c’è una funzione nascosta (confronta “case insensitive” di stringhe), come spesso accade quando gli argomenti della lambda diventano grandi.</p>
<pre><code>bool compare_insensitive(const string&amp; a, const string&amp; b)
{
if (a.size() != b.size()) return false;
for (int i = 0; i &lt; a.size(); ++i) if (tolower(a[i]) != tolower(b[i])) return false;
return true;
}

auto x = find_if(vr.begin(), vr.end(),
[&amp;](Rec&amp; r) { compare_insensitive(r.name, n); }
);</code></pre>
<p>O forse (se si preferisce evitare il nome implicito legato a n):</p>
<pre><code>auto cmp_to_n = [&amp;n](const string&amp; a) { return compare_insensitive(a, n); };

auto x = find_if(vr.begin(), vr.end(),
[](const Rec&amp; r) { return cmp_to_n(r.name); }
);</code></pre>
<h5 id="note-339">Note</h5>
<p>Se funzioni, lambda o operatori.</p>
<h5 id="eccezione-51">Eccezione</h5>
<ul>
<li>Le lambda usate logicamente solo localmente, come un argomento di <code>for_each</code> e algoritmi simili per il controllo del flusso.</li>
<li>Le lambda come <a href="#???">inizializzatori</a></li>
</ul>
<h5 id="imposizione-348">Imposizione</h5>
<ul>
<li>(difficile) segnalare le lambda simili</li>
<li>???</li>
</ul>
<h3 id="t.141-usare-una-lambda-anonima-se-si-necessita-di-un-semplice-oggetto-funzione-in-un-solo-posto"><a name="Rt-lambda"></a>T.141: Usare una lambda anonima se si necessita di un semplice oggetto funzione in un solo posto</h3>
<h5 id="motivo-380">Motivo</h5>
<p>Questo rende il codice conciso e offre una località migliore delle alternative.</p>
<h5 id="esempio-330">Esempio</h5>
<pre><code>auto earlyUsersEnd = std::remove_if(users.begin(), users.end(),
[](const User &amp;a) { return a.id &gt; 100; });</code></pre>
<h5 id="eccezione-52">Eccezione</h5>
<p>Dare un nome ad una lambda può essere utile per chiarezza anche se viene usata una sola volta.</p>
<h5 id="imposizione-349">Imposizione</h5>
<ul>
<li>Cercare lambda identiche o quasi identiche (da sostituire con nomi di funzioni o nomi di lambda).</li>
</ul>
<h3 id="t.142-usare-le-variabili-template-per-semplificare-la-notazione"><a name="Rt-var"></a>T.142?: Usare le variabili template per semplificare la notazione</h3>
<h5 id="motivo-381">Motivo</h5>
<p>Leggibilità migliorata.</p>
<h5 id="esempio-331">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="imposizione-350">Imposizione</h5>
<p>???</p>
<h3 id="t.143-non-scrivere-involontariamente-codice-non-generico"><a name="Rt-nongeneric"></a>T.143: Non scrivere involontariamente codice non-generico</h3>
<h5 id="motivo-382">Motivo</h5>
<p>Generalità. Riusabilità. Non dettagliare gratuitamente; usare le funzioni più generali a disposizione.</p>
<h5 id="esempio-332">Esempio</h5>
<p>Usare <code>!=</code> anziché <code>&lt;</code> per confrontare iteratori; <code>!=</code> funziona per più oggetti perché non si basa sull’ordinamento.</p>
<pre><code>for (auto i = first; i &lt; last; ++i) {   // meno generico
// ...
}

for (auto i = first; i != last; ++i) {   // bene; più generico
// ...
}</code></pre>
<p>Ovviamente, il range-<code>for</code> è ancora meglio dove fa quello che si vuole.</p>
<h5 id="esempio-333">Esempio</h5>
<p>Usare la classe meno-derivata che abbia le funzionalità richieste.</p>
<pre><code>class Base {
public:
Bar f();
Bar g();
};

class Derived1 : public Base {
public:
Bar h();
};

class Derived2 : public Base {
public:
Bar j();
};

// male, a meno che non vi sia un motivo specifico per limitarsi ai soli oggetti Derived1
void my_func(Derived1&amp; param)
{
use(param.f());
use(param.g());
}

// bene, usa solo l&#39;interfaccia Base quindi ha ache fare solo con essa
void my_func(Base&amp; param)
{
use(param.f());
use(param.g());
}</code></pre>
<h5 id="imposizione-351">Imposizione</h5>
<ul>
<li>Segnalare i confronti di iteratori con <code>&lt;</code> anziché con <code>!=</code>.</li>
<li>Segnalare <code>x.size() == 0</code> quando è disponibile <code>x.empty()</code> o <code>x.is_empty()</code>. Controllare se vuoto, funziona per più contenitori rispetto a size(), perché alcui contenitori non conoscono la propria dimensione [size] o sono concettualmente di dimensioni illimitate.</li>
<li>Segnalare le funzioni che prendono un puntatore o un riferimento a un tipo multi-derivato ma usano solo funzioni del tipo base.</li>
</ul>
<h3 id="t.144-non-specializzare-le-funzioni-template"><a name="Rt-specialize-function"></a>T.144: Non specializzare le funzioni template</h3>
<h5 id="motivo-383">Motivo</h5>
<p>Non si può specializzare parzialmente una funzione template per le del linguaggio. Si può completamente specializzare una funzione template ma quasi certamente si vuole eseguire invece l’overload – perché le specializzazioni della funzione template non partecipa all’overloading, esse non agiscono come probabilmente si voleva. Raramente, si dovrebbe effettivamente specializzare delegando ad una classe template giustamente specializzata.</p>
<h5 id="esempio-334">Esempio</h5>
<pre><code>???</code></pre>
<p><strong>Eccezioni</strong>: Se c’è un motivo valido per specializzare una funzione template, basta scrivere una sola funzione template che delega ad una classe template, poi specializzare la classe template (inclusa la possibilità di scrivere specializzazioni parziali).</p>
<h5 id="imposizione-352">Imposizione</h5>
<ul>
<li>Segnalare tutte le specializzazioni di una funzione template. Usare l’overload, invece.</li>
</ul>
<h3 id="t.150-verificare-che-a-una-classe-corrisponda-un-concetto-utilizzando-static_assert"><a name="Rt-check-class"></a>T.150: Verificare che a una classe corrisponda un concetto utilizzando <code>static_assert</code></h3>
<h5 id="motivo-384">Motivo</h5>
<p>Se si vuole che ad una classe corrisponda un concetto, lo si verifichi prima possibile, evitando problemi agli utenti.</p>
<h5 id="esempio-335">Esempio</h5>
<pre><code>class X {
public:
X() = delete;
X(const X&amp;) = default;
X(X&amp;&amp;) = default;
X&amp; operator=(const X&amp;) = default;
// ...
};</code></pre>
<p>Da qualche parte, forse in un file di implementazione, lasciare che sia il compilatore a verificare le proprietà desiderate di <code>X</code>:</p>
<pre><code>static_assert(Default_constructible&lt;X&gt;);    // errore: X non ha un default constructor
static_assert(Copyable&lt;X&gt;);                 // errore: ci si è dimenticati di definire il costruttore di spostamento per X</code></pre>
<h5 id="imposizione-353">Imposizione</h5>
<p>Non fattibile.</p>
<h1 id="cpl-programmazione-c-style"><a name="S-cpl"></a>CPL: Programmazione C-style</h1>
<p>C e C++ sono linguaggi strettamente correlati. Entrambi provengono dal “C Classico” del 1978 e da allora si sono evoluti in comitati ISO. Sono stati fatti molti tentativi per renderli compatibili, ma nessuno dei due è un sottoinsieme dell’altro.</p>
<p>Riepilogo delle regole sul C:</p>
<ul>
<li><a href="#Rcpl-C">CPL.1: Preferire il C++ al C</a></li>
<li><a href="#Rcpl-subset">CPL.2: Se si deve usare il C, utilizzare il sotto-insieme comune al C e al C++, e compilare il codice C come C++</a></li>
<li><a href="#Rcpl-interface">CPL.3: Se si deve usare il C per le interfacce, usare il C++ nel codice chiamante utilizzando tali interfacce</a></li>
</ul>
<h3 id="cpl.1-preferire-il-c-al-c"><a name="Rcpl-C"></a>CPL.1: Preferire il C++ al C</h3>
<h5 id="motivo-385">Motivo</h5>
<p>Il C++ offre un miglior controllo sui tipi e un maggior supporto notazionale. Fornisce un supporto migliore per la programmazione ad alto livello e spesso genera codice più veloce.</p>
<h5 id="esempio-336">Esempio</h5>
<pre><code>char ch = 7;
void* pv = &amp;ch;
int* pi = pv;   // non C++
*pi = 999;      // sovrascrive sizeof(int) byte vicino a &amp;ch</code></pre>
<p>Le regole per il cast implicito da e verso <code>void*</code> in C sono subdole e non imposte. In particolare, questo esempio viola una regola contro la conversione in un tipo con un allineamento più rigoroso.</p>
<h5 id="imposizione-354">Imposizione</h5>
<p>Usare un compilatore C++.</p>
<h3 id="cpl.2-se-si-deve-usare-il-c-utilizzare-il-sotto-insieme-comune-al-c-e-al-c-e-compilare-il-codice-c-come-c"><a name="Rcpl-subset"></a>CPL.2: Se si deve usare il C, utilizzare il sotto-insieme comune al C e al C++, e compilare il codice C come C++</h3>
<h5 id="motivo-386">Motivo</h5>
<p>Tale sottoinsieme può essere compilato sia con compilatori C che C++ e, quando compilato come C++, controlla meglio i tipi del “C puro”.</p>
<h5 id="esempio-337">Esempio</h5>
<pre><code>int* p1 = malloc(10 * sizeof(int));                      // non C++
int* p2 = static_cast&lt;int*&gt;(malloc(10 * sizeof(int)));   // non C, C++ C-style
int* p3 = new int[10];                                   // non C
int* p4 = (int*) malloc(10 * sizeof(int));               // sia C che C++</code></pre>
<h5 id="imposizione-355">Imposizione</h5>
<ul>
<li><p>Segnalare se si usa una modalità di compilazione che compila il codice come C.</p>
<ul>
<li>Il compilatore C++ imporrà che il codice sia C++ sia valido a meno che non si utilizzino le opzioni per l’estensione all’uso del C.</li>
</ul></li>
</ul>
<h3 id="cpl.3-se-si-deve-usare-il-c-per-le-interfacce-usare-il-c-nel-codice-chiamante-utilizzando-tali-interfacce"><a name="Rcpl-interface"></a>CPL.3: Se si deve usare il C per le interfacce, usare il C++ nel codice chiamante utilizzando tali interfacce</h3>
<h5 id="motivo-387">Motivo</h5>
<p>Il C++ è più espressivo del C ed offre un supporto migliore per molti tipi di programmazione.</p>
<h5 id="esempio-338">Esempio</h5>
<p>Ad esempio, per utilizzare una libreria C di terze parti o un’interfaccia di sistemi C, definire l’interfaccia a basso livello nel sottinsieme comune al C e al C++ per un miglior controllo dei tipi. Quando possibile, incapsulare l’interfaccia di basso livello in un’interfaccia che segue le linee-guida del C++ (per migliorare astrazione, sicurezza della memoria e sicurezza delle risorse) ed usare questa interfaccia C++ nel codice C++.</p>
<h5 id="esempio-339">Esempio</h5>
<p>Si può chiamare il C dal C++:</p>
<pre><code>// in C:
double sqrt(double);

// in C++:
extern &quot;C&quot; double sqrt(double);

sqrt(2);</code></pre>
<h5 id="esempio-340">Esempio</h5>
<p>Si può chiamare il C++ dal C:</p>
<pre><code>// in C:
X call_f(struct Y*, int);

// in C++:
extern &quot;C&quot; X call_f(Y* p, int i)
{
return p-&gt;f(i);   // possibilmente una chiamata a funzione virtuale
}</code></pre>
<h5 id="imposizione-356">Imposizione</h5>
<p>Nessuna necessaria</p>
<h1 id="sf-file-sorgenti"><a name="S-source"></a>SF: File sorgenti</h1>
<p>Distinguere tra dichiarazioni (usate come interfacce) e definizioni (usate come implementazioni). Utilizzare i file di intestazione [header] per rappresentare le interfacce ed enfatizzare la struttura logica.</p>
<p>Riepilogo delle regole sui file sorgenti:</p>
<ul>
<li><p><a href="#Rs-file-suffix">SF.1: Usare un suffisso <code>.cpp</code> per i file del codice e <code>.h</code> per i file delle interfacce nei propri progetti se non si sta già seguendo un’altra convenzione</a></p></li>
<li><p><a href="#Rs-inline">SF.2: Un file <code>.h</code> potrebbe non contenere definizioni di oggetti o definizioni di funzioni non-inline</a></p></li>
<li><p><a href="#Rs-declaration-header">SF.3: Usare i file <code>.h</code> per tutte le dichiarazioni usate in più file sorgenti</a></p></li>
<li><p><a href="#Rs-include-order">SF.4: Includere in un file, i file <code>.h</code> prima di altre dichiarazioni</a></p></li>
<li><p><a href="#Rs-consistency">SF.5: Un file <code>.cpp</code> deve includere i(l) file <code>.h</code> che ne definiscono l’interfaccia</a></p></li>
<li><p><a href="#Rs-using">SF.6: Usare le direttive <code>using namespace</code> per la transizione, per le librerie di base (come la <code>std</code>), o (solamente) all’interno di uno scope locale</a></p></li>
<li><p><a href="#Rs-using-directive">SF.7: Non scrivere <code>using namespace</code> nello scope globale in un file header</a></p></li>
<li><p><a href="#Rs-guards">SF.8: Usare la protezione per gli <code>#include</code> per tutti i file <code>.h</code></a></p></li>
<li><p><a href="#Rs-cycles">SF.9: Evitare le dipendenze cicliche tra i file sorgenti</a></p></li>
<li><p><a href="#Rs-implicit">SF.10: Evitare dipendenze da nomi inclusi [<code>#include</code>] implicitamente</a></p></li>
<li><p><a href="#Rs-contained">SF.11: I file header devono essere autonomi [self-contained]</a></p></li>
<li><p><a href="#Rs-namespace">SF.20: Usare i <code>namespace</code> per esprimere le strutture logiche</a></p></li>
<li><p><a href="#Rs-unnamed">SF.21: Non usare un namespace senza nome (anonimo) in un header</a></p></li>
<li><p><a href="#Rs-unnamed2">SF.22: Usare un namespace senza nome (anonimo) per tutte le entità interne/non-esportate</a></p></li>
</ul>
<h3 id="sf.1-usare-un-suffisso-.cpp-per-i-file-del-codice-e-.h-per-i-file-delle-interfacce-nei-propri-progetti-se-non-si-sta-già-seguendo-unaltra-convenzione"><a name="Rs-file-suffix"></a>SF.1: Usare un suffisso <code>.cpp</code> per i file del codice e <code>.h</code> per i file delle interfacce nei propri progetti se non si sta già seguendo un’altra convenzione</h3>
<h5 id="motivo-388">Motivo</h5>
<p>È una convenzione di vecchia data. Ma la coerenza è più importante, quindi se il progetto utilizza qualcos’altro, lo si segua.</p>
<h5 id="note-340">Note</h5>
<p>Questa convenzione riflette un modello di uso comune: Gli header sono più spesso condivise col C per compilare sia come C++ che C, cghe tipicamente usa <code>.h</code>, ed è più facile dare un nome a tutti gli header <code>.h</code> anziché avere diverse estensioni solo per quegli header che si intendono usare col C. D’altra parte, i file delle di implementazione vengono raramente condivisi col C e quindi dovrebbero generalmente essere distinti dai file <code>.c</code>, quindi normalmente è meglio dare un nome a tutti i file C++ dell’implementazione con qualcos’altro (come <code>.cpp</code>).</p>
<p>I nomi specifici <code>.h</code> e <code>.cpp</code> non sono richiesti (solo raccomandati per default) e si utilizzano ampiamente altri nomi. Esempi sono <code>.hh</code>, <code>.C</code>, e <code>.cxx</code>. Usare questi nomi in modo equivalente. In questo documento, ci si riferisce a <code>.h</code> e <code>.cpp</code> come abbreviazioni per file header e file di implementazione, anche se l’effettiva estensione può essere diversa.</p>
<p>L’IDE utilizzato (se se ne usa uno) potrebbe essere più restrittivo sui suffissi.</p>
<h5 id="esempio-341">Esempio</h5>
<pre><code>// foo.h:
extern int a;   // una dichiarazione
extern void foo();

// foo.cpp:
int a;   // una definizione
void foo() { ++a; }</code></pre>
<p><code>foo.h</code> fornisce l’interfaccia a <code>foo.cpp</code>. Sarà meglio evitare le variabili globali.</p>
<h5 id="esempio-cattivo-132">Esempio, cattivo</h5>
<pre><code>// foo.h:
int a;   // una definizione
void foo() { ++a; }</code></pre>
<p>Scrivendo <code>#include &lt;foo.h&gt;</code> due volte in un programma, si ottiene un errore di due violazioni regola-della-mono-definizione [one-definition-rule violations].</p>
<h5 id="imposizione-357">Imposizione</h5>
<ul>
<li>Segnalare nomi di file non-convenzionali.</li>
<li>Controllare che <code>.h</code> e <code>.cpp</code> (ed equivalenti) seguano le regole seguenti.</li>
</ul>
<h3 id="sf.2-un-file-.h-potrebbe-non-contenere-definizioni-di-oggetti-o-definizioni-di-funzioni-non-inline"><a name="Rs-inline"></a>SF.2: Un file <code>.h</code> potrebbe non contenere definizioni di oggetti o definizioni di funzioni non-inline</h3>
<h5 id="motivo-389">Motivo</h5>
<p>L’inclusione di entità soggette alla regola della mono-definizione comporta errori del linker.</p>
<h5 id="esempio-342">Esempio</h5>
<pre><code>// file.h:
namespace Foo {
int x = 7;
int xx() { return x+x; }
}

// file1.cpp:
#include &lt;file.h&gt;
// ... altro ...

// file2.cpp:
#include &lt;file.h&gt;
// ... altro ...</code></pre>
<p>Linkando <code>file1.cpp</code> e <code>file2.cpp</code> si otterranno due errori del linker.</p>
<p><strong>Formulazione alternativa</strong>: Un file <code>.h</code> deve contenere solamente:</p>
<ul>
<li>degli <code>#include</code> di altri file <code>.h</code> (possibilmente con delle protezioni per gli include)</li>
<li>template</li>
<li>definizioni di classi</li>
<li>dichiarazioni di funzioni</li>
<li>dichiarazioni <code>extern</code></li>
<li>definizioni di funzioni <code>inline</code></li>
<li>definizioni <code>constexpr</code></li>
<li>definizioni <code>const</code></li>
<li>definizioni di alias <code>using</code></li>
<li>???</li>
</ul>
<h5 id="imposizione-358">Imposizione</h5>
<p>Controllare l’elenco positivo precedente.</p>
<h3 id="sf.3-usare-i-file-.h-per-tutte-le-dichiarazioni-usate-in-più-file-sorgenti"><a name="Rs-declaration-header"></a>SF.3: Usare i file <code>.h</code> per tutte le dichiarazioni usate in più file sorgenti</h3>
<h5 id="motivo-390">Motivo</h5>
<p>Manutenibilità. Leggibilità.</p>
<h5 id="esempio-cattivo-133">Esempio, cattivo</h5>
<pre><code>// bar.cpp:
void bar() { cout &lt;&lt; &quot;bar\n&quot;; }

// foo.cpp:
extern void bar();
void foo() { bar(); }</code></pre>
<p>Un manutentore di <code>bar</code> non può trovare tutte le dichiarazioni di <code>bar</code> se se ne deve cambiare il tipo. L’utente di <code>bar</code> non può sapere se l’interfaccia usata è completa e corretta. Nel migliore dei casi, verranno dei messaggi di errore (in ritardo) dal linker.</p>
<h5 id="imposizione-359">Imposizione</h5>
<ul>
<li>Segnalare le dichiarazioni di entità in altri file sorgenti non inserite in un <code>.h</code>.</li>
</ul>
<h3 id="sf.4-includere-in-un-file-i-file-.h-prima-di-altre-dichiarazioni"><a name="Rs-include-order"></a>SF.4: Includere in un file, i file <code>.h</code> prima di altre dichiarazioni</h3>
<h5 id="motivo-391">Motivo</h5>
<p>Ridurre le dipendenze dal contesto ed aumentare la leggibilità.</p>
<h5 id="esempio-343">Esempio</h5>
<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

// ... il mio codice qui ...</code></pre>
<h5 id="esempio-cattivo-134">Esempio, cattivo</h5>
<pre><code>#include &lt;vector&gt;

// ... il mio codice qui ...

#include &lt;algorithm&gt;
#include &lt;string&gt;</code></pre>
<h5 id="note-341">Note</h5>
<p>Questo vale sia per i file <code>.h</code> che i <code>.cpp</code>.</p>
<h5 id="note-342">Note</h5>
<p>C’è un argomento per isolare il codice dalle dichiarazioni e le macro nei file header <code>#include</code>ndo degli header <em>dopo</em> il codice che si vuol proteggere (come nell’esempio etichettato come “cattivo”). Tuttavia</p>
<ul>
<li>questo funziona solo per un file (a un livello): Usare questa tecnica negli header inclusi con altri header e la vulnerabilità riappare.</li>
<li>un namespace (un “namespace di implementazione”) pro proteggere da molte dipendenze dal contesto.</li>
<li>la totale protezione e flessibilità si ottiene con i mooduli.</li>
</ul>
<p><strong>Si veda anche</strong>:</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4592.pdf">Bozza di Lavoro, Estensioni al C++ per i Moduli [Working Draft, Extensions to C++ for Modules]</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0141r0.pdf">Moduli, Componentizzazione e Transizione [Modules, Componentization, and Transition]</a></li>
</ul>
<h5 id="imposizione-360">Imposizione</h5>
<p>Facile.</p>
<h3 id="sf.5-un-file-.cpp-deve-includere-il-file-.h-che-ne-definiscono-linterfaccia"><a name="Rs-consistency"></a>SF.5: Un file <code>.cpp</code> deve includere i(l) file <code>.h</code> che ne definiscono l’interfaccia</h3>
<h5 id="motivo-392">Motivo</h5>
<p>Questo consente al compilatore di fare un controllo di coerenza in anticipo.</p>
<h5 id="esempio-cattivo-135">Esempio, cattivo</h5>
<pre><code>// foo.h:
void foo(int);
int bar(long);
int foobar(int);

// foo.cpp:
void foo(int) { /* ... */ }
int bar(double) { /* ... */ }
double foobar(int);</code></pre>
<p>Gli errori non verranno rilevati fino al momento del link per un programma che chiama <code>bar</code> o <code>foobar</code>.</p>
<h5 id="esempio-344">Esempio</h5>
<pre><code>// foo.h:
void foo(int);
int bar(long);
int foobar(int);

// foo.cpp:
#include &lt;foo.h&gt;

void foo(int) { /* ... */ }
int bar(double) { /* ... */ }
double foobar(int);   // errore: tipo restituito sbagliato</code></pre>
<p>L’errore sul tipo restituito per <code>foobar</code> ora viene intercettato immediatamente quando si compila <code>foo.cpp</code>. L’errore sul tipo dell’argomento per <code>bar</code> non può essere intercettato fino al momento del link perché c’è la possibilità dell’overloading, ma l’uso sistematico dei file <code>.h</code> aumentano la la probabilità venga rilevato prima dal programmatore.</p>
<h5 id="imposizione-361">Imposizione</h5>
<p>???</p>
<h3 id="sf.6-usare-le-direttive-using-namespace-per-la-transizione-per-le-librerie-di-base-come-la-std-o-solamente-allinterno-di-uno-scope-locale"><a name="Rs-using"></a>SF.6: Usare le direttive <code>using namespace</code> per la transizione, per le librerie di base (come la <code>std</code>), o (solamente) all’interno di uno scope locale</h3>
<h5 id="motivo-393">Motivo</h5>
<p><code>using namespace</code> può portare a cnflitti con i nomi, quindi dovrebbe essere usato con parsimonia. Tuttavia, non è sempre possibile qualificare ogni nome da uno namespace nel codice utente (p.es., durante la transizione) e talvolta un namespace è così fondamentale e prevalente nel codice, che una qualificazione coerente sarebbe prolissa e distraente.</p>
<h5 id="esempio-345">Esempio</h5>
<pre><code>#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;algorithm&gt;

using namespace std;

// ...</code></pre>
<p>Qui (ovviamente), la libreria standard viene utilizzata in modo pervasivo e apparentemente non ne vengono usate altre, quindi richiedere <code>std::</code> ovunque può portare a distrazioni.</p>
<h5 id="esempio-346">Esempio</h5>
<p>L’utilizzo di <code>using namespace std;</code> lascia il programmatore la possibilità di andare in conflitto con un nome dalla libreria standard</p>
<pre><code>#include &lt;cmath&gt;
using namespace std;

int g(int x)
{
int sqrt = 7;
// ...
return sqrt(x); // errore
}</code></pre>
<p>Tuttavia, questo non favorisce particolarmente una soluzione dei conflitti senza un errori e quelli che usano <code>using namespace std</code> si suppone che sappiano di <code>std</code> e su questo rischio.</p>
<h5 id="note-343">Note</h5>
<p>Un file <code>.cpp</code> è una forma di scope locale. C’è poca differenza nelle probabilità di conflitti sui nomi tra un <code>.cpp</code> di N-righe contenente <code>using namespace X</code>, una funzione di N-righe contenente <code>using namespace X</code>, e M funzioni ciascuna contenente un <code>using namespace X</code> con N righe di codice in totale.</p>
<h5 id="note-344">Note</h5>
<p><a href="#Rs-using-directive">Non scrivere <code>using namespace</code> in un file header</a>.</p>
<h5 id="imposizione-362">Imposizione</h5>
<p>Segnalare direttive <code>using namespace</code> multiple per diversi namespace in un solo file sorgente.</p>
<h3 id="sf.7-non-scrivere-using-namespace-nello-scope-globale-in-un-file-header"><a name="Rs-using-directive"></a>SF.7: Non scrivere <code>using namespace</code> nello scope globale in un file header</h3>
<h5 id="motivo-394">Motivo</h5>
<p>Facendolo elimina la capacità di chi <code>#include</code> di chiarire efficacemente e usare alternative. Rende anche gli header inclusi [<code>#include</code>] dipendenti dall’ordine in quanto possono avere un significato diverso se inclusi in un ordine diverso.</p>
<h5 id="esempio-347">Esempio</h5>
<pre><code>// bad.h
#include &lt;iostream&gt;
using namespace std; // bad

// user.cpp
#include &quot;bad.h&quot;

bool copy(/*... alcuni parametri ...*/);    // alcune funzioni che si chiamano copy

int main() {
copy(/*...*/);    // ora si ha l&#39; overload di local ::copy e di std::copy, potrebbe esserci ambiguità
}</code></pre>
<h5 id="note-345">Note</h5>
<p>Un’eccezione è <code>using namespace std::literals;</code>. Questo è necessario per usare le stringhe letterali nei file header e date <a href="http://eel.is/c++draft/over.literal">le regole</a> - gli utenti sono tenuti a dare un nome ai propri UDL <code>operator""_x</code> - non collideranno con la libreria standard.</p>
<h5 id="imposizione-363">Imposizione</h5>
<p>Segnalare <code>using namespace</code> nello scope globale nel file header.</p>
<h3 id="sf.8-usare-la-protezione-per-gli-include-per-tutti-i-file-.h"><a name="Rs-guards"></a>SF.8: Usare la protezione per gli <code>#include</code> per tutti i file <code>.h</code></h3>
<h5 id="motivo-395">Motivo</h5>
<p>Per evitare che i file vengano inclusi [<code>#include</code>] più volte.</p>
<p>Per evitare le collisioni tra le protezioni degli include, non ci si limiti a dare un nome alla protezione dopo il nome del file. Assicurarsi di includere anche una chiave ed un buon differenziator, come il nome della libreria o del componente di cui fa parte il file header.</p>
<h5 id="esempio-348">Esempio</h5>
<pre><code>// file foobar.h:
#ifndef LIBRARY_FOOBAR_H
#define LIBRARY_FOOBAR_H
// ... dichiarazioni ...
#endif // LIBRARY_FOOBAR_H</code></pre>
<h5 id="imposizione-364">Imposizione</h5>
<p>Segnalare i <code>.h</code> senza le protezioni degli <code>#include</code>.</p>
<h5 id="note-346">Note</h5>
<p>Alcune implementazioni offrono delle estensioni come <code>#pragma once</code> come alternative alle protezioni degli include. Questo non è standard e non è portabile. Esso inietta la semantica del filesystem della macchina host nel proprio programma, oltre a legarsi ad un fornitore. La raccomandazione è quella di scrivere in C++ ISO: Cfr. <a href="#Rp-Cplusplus">regola P.2</a>.</p>
<h3 id="sf.9-evitare-le-dipendenze-cicliche-tra-i-file-sorgenti"><a name="Rs-cycles"></a>SF.9: Evitare le dipendenze cicliche tra i file sorgenti</h3>
<h5 id="motivo-396">Motivo</h5>
<p>La ciclicità complica la comprensione e rallenta la compilazione. Esse, inoltre, complicano la conversione per l’uso dei moduli supportati dal linguaggio (quando saranno disponibili).</p>
<h5 id="note-347">Note</h5>
<p>Eliminare le ciclicità; non limitarsi ad interromperli con le protezioni degli <code>#include</code>.</p>
<h5 id="esempio-cattivo-136">Esempio, cattivo</h5>
<pre><code>// file1.h:
#include &quot;file2.h&quot;

// file2.h:
#include &quot;file3.h&quot;

// file3.h:
#include &quot;file1.h&quot;</code></pre>
<h5 id="imposizione-365">Imposizione</h5>
<p>Segnalare tutte le ciclicità.</p>
<h3 id="sf.10-evitare-dipendenze-da-nomi-inclusi-include-implicitamente"><a name="Rs-implicit"></a>SF.10: Evitare dipendenze da nomi inclusi <code>#include</code> implicitamente</h3>
<h5 id="motivo-397">Motivo</h5>
<p>Evitare sorprese. Evitare di dover modificare gli <code>#include</code> se si modifica l’header di un <code>#include</code>. Evitare di diventare accidentalmente dipendenti dai dettagli dell’implementazione e da entità logicamente separate incluse in un header.</p>
<h5 id="esempio-349">Esempio</h5>
<pre><code>#include &lt;iostream&gt;
using namespace std;

void use()                  // KO
{
string s;
cin &gt;&gt; s;               // ok
getline(cin, s);        // errore: getline() non definito
if (s == &quot;surprise&quot;) {  // errore == non definito
// ...
}
}</code></pre>
<p><code>&lt;iostream&gt;</code> espone la definizione di <code>std::string</code> (“perché?” sembra un quiz divertente), ma non è necessario farlo, quindi include transitivamente tutto l’header di <code>&lt;string&gt;</code>, da cui la nota domanda del principiante “perché <code>getline(cin,s);</code> non funziona?” o anche delle eventuali "<code>string</code>he non si possono confrontare con <code>==</code>).</p>
<p>La soluzione è scrivere esplicitamente <code>#include &lt;string&gt;</code>:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

void use()
{
string s;
cin &gt;&gt; s;               // ok
getline(cin, s);        // ok
if (s == &quot;surprise&quot;) {  // ok
// ...
}
}</code></pre>
<h5 id="note-348">Note</h5>
<p>Alcuni header esistono precisamente per raggruppare un insieme di dichiarazioni coerenti provenienti da vari header. Per esempio:</p>
<pre><code>// basic_std_lib.h:

#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;vector&gt;</code></pre>
<p>ora un utente può ottenere questo insieme di dichiarazioni con un solo <code>#include</code>"</p>
<pre><code>#include &quot;basic_std_lib.h&quot;</code></pre>
<p>Questa regola contro l’inclusione implicita non intende impedire questo tipo di deliberate aggregazioni.</p>
<h5 id="imposizione-366">Imposizione</h5>
<p>Una imposizione richiederebbe la conoscenze di quello che in un header si vuole “esportare” agli utenti e quello che serve per l’implementazione. Nessuna soluzione davvero valida è possibile fino a quando non ci saranno i moduli.</p>
<h3 id="sf.11-i-file-header-devono-essere-autonomi-self-contained"><a name="Rs-contained"></a>SF.11: I file header devono essere autonomi [self-contained]</h3>
<h5 id="motivo-398">Motivo</h5>
<p>Usabilità, gli header dovrebbero essere semplici da usare e funzionare se inclusi da soli. Gli header dovrebbero incapsulare le funzionalità che forniscono. Evitare che i clienti di un header ne debbano gestire le dipendenze.</p>
<h5 id="esempio-350">Esempio</h5>
<pre><code>#include &quot;helpers.h&quot;
// helpers.h dipende da std::string ed include &lt;string&gt;</code></pre>
<h5 id="note-349">Note</h5>
<p>La mancata osservanza di ciò comporta errori difficili da diagnosticare per i clienti di un header.</p>
<h5 id="note-350">Note</h5>
<p>Un header dovrebbe includere tutte le sue dipendenze. Prestare attenzione all’utilizzo dei path relativi poiché le implementazioni C++ differiscono sul loro significato.</p>
<h5 id="imposizione-367">Imposizione</h5>
<p>Un test dovrebbe verificare che l’header stesso compili e che si compili anche un file cpp che includa il solo l’header.</p>
<h3 id="sf.20-usare-i-namespace-per-esprimere-le-strutture-logiche"><a name="Rs-namespace"></a>SF.20: Usare i <code>namespace</code> per esprimere le strutture logiche</h3>
<h5 id="motivo-399">Motivo</h5>
<p>???</p>
<h5 id="esempio-351">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="imposizione-368">Imposizione</h5>
<p>???</p>
<h3 id="sf.21-non-usare-un-namespace-senza-nome-anonimo-in-un-header"><a name="Rs-unnamed"></a>SF.21: Non usare un namespace senza nome (anonimo) in un header</h3>
<h5 id="motivo-400">Motivo</h5>
<p>È quasi sempre un errore menzionare un namespace senza nome in un file header.</p>
<h5 id="esempio-352">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="imposizione-369">Imposizione</h5>
<ul>
<li>Segnalare qualsiasi uso di un namespace anonimo in un file header.</li>
</ul>
<h3 id="sf.22-usare-un-namespace-senza-nome-anonimo-per-tutte-le-entità-internenon-esportate"><a name="Rs-unnamed2"></a>SF.22: Usare un namespace senza nome (anonimo) per tutte le entità interne/non-esportate</h3>
<h5 id="motivo-401">Motivo</h5>
<p>Niente all’esterno può dipendere da un’entità in un namespace annidato senza nome. Considerare di mettere ogni definizione in un file sorgente dell’implementazione, in un namespace senza nome, a meno che non definisca un’entità “esterna/esportata”.</p>
<h5 id="esempio-353">Esempio</h5>
<p>Una classe API e i suoi membri non possono stare in un namespace anonimo; ma ogni classe “helper” o funzione definita in un file sorgente dell’implementazione deve stare nello scope di un namespace senza nome.</p>
<pre><code>???</code></pre>
<h5 id="imposizione-370">Imposizione</h5>
<ul>
<li>???</li>
</ul>
<h1 id="sl-la-libreria-standard"><a name="S-stdlib"></a>SL: La Libreria Standard</h1>
<p>Usando il solo linguaggio, ogni attività risulta noiosa (in qualsiasi linguaggio). Utilizzando una libreria adatta ogni attività si semplifica.</p>
<p>La libreria standard è cresciuta gradualmente negli anni. La sua descrizione nello standard è ora più ampia di quella delle funzionalità del linguaggio. Quindi, probabilmente questa sezione delle linee-guida crescerà allo stesso modo uguagliando o superando tutto il resto.</p>
<p>&lt;&lt; ??? C’è bisogno di un altro livello nella numerazione delle regole??? &gt;&gt;</p>
<p>Riepilogo dei componenti della Libreria Standard C++:</p>
<ul>
<li><a href="#SS-con">SL.con: Contenitori</a></li>
<li><a href="#SS-string">SL.str: Stringhe</a></li>
<li><a href="#SS-io">SL.io: Iostream</a></li>
<li><a href="#SS-regex">SL.regex: Regex</a></li>
<li><a href="#SS-chrono">SL.chrono: Time</a></li>
<li><a href="#SS-clib">SL.C: La Libreria Standard del C</a></li>
</ul>
<p>Riepilogo delle regole sulla libreria standard:</p>
<ul>
<li><a href="#Rsl-lib">SL.1: Usare le librerie dove possibile</a></li>
<li><a href="#Rsl-sl">SL.2: Preferire la libreria standard ad altre librerie</a></li>
<li><a href="#sl-std">SL.3: Non aggiungere entità non-standard al namespace <code>std</code></a></li>
<li><a href="#sl-safe">SL.4: Usare la libreria standard in modo sicuro per i tipi [type-safe]</a></li>
<li>???</li>
</ul>
<h3 id="sl.1-usare-le-librerie-dove-possibile"><a name="Rsl-lib"></a>SL.1: Usare le librerie dove possibile</h3>
<h5 id="motivo-402">Motivo</h5>
<p>Si risparmia tempo. Non si re-inventa la ruota. Non si replica il lavoro di altri. Si approfitta del lavoro di altri quando apportano miglioramenti. Si aiutano altre persone quando si fanno dei miglioramenti.</p>
<h3 id="sl.2-preferire-la-libreria-standard-ad-altre-librerie"><a name="Rsl-sl"></a>SL.2: Preferire la libreria standard ad altre librerie</h3>
<h5 id="motivo-403">Motivo</h5>
<p>Molte persone conoscono la libreria standard. È più probabile che sia stabile, ben mantenuta e ampiamente disponibile rispetto al proprio codice o alla maggior parte delle altre librerie.</p>
<h3 id="sl.3-non-aggiungere-entità-non-standard-al-namespace-std"><a name="sl-std"></a>SL.3: Non aggiungere entità non-standard al namespace <code>std</code></h3>
<h5 id="motivo-404">Motivo</h5>
<p>L’aggiunta a <code>std</code> può modificare il significato di codice conforme agli standard. Le aggiunte a <code>std</code> possono creare conflitti con le future versioni dello standard.</p>
<h5 id="esempio-354">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="imposizione-371">Imposizione</h5>
<p>Possibile, ma disordinato e suscettibile di causare problemi con le piattaforme.</p>
<h3 id="sl.4-usare-la-libreria-standard-in-modo-sicuro-per-i-tipi-type-safe"><a name="sl-safe"></a>SL.4: Usare la libreria standard in modo sicuro per i tipi [type-safe]</h3>
<h5 id="motivo-405">Motivo</h5>
<p>Perché, ovviamente, infrangere questa regola può portare a comportamenti indefiniti, corruzione della memoria e tutti i tipi di altri pessimi errori.</p>
<h5 id="note-351">Note</h5>
<p>Questa è una meta-regola semi-filosofica, che necessita di molte regole concrete a supporto. È necessaria come di un ombrello per regole più specifiche.</p>
<p>Riepilogo delle regole più specifiche:</p>
<ul>
<li><a href="#sl-safe">SL.4: Usare la libreria standard in modo sicuro per i tipi [type-safe]</a></li>
</ul>
<h2 id="sl.con-contenitori"><a name="SS-con"></a>SL.con: Contenitori</h2>
<p>???</p>
<p>Riepilogo delle regole sui contenitori:</p>
<ul>
<li><a href="#Rsl-arrays">SL.con.1: Preferire l’uso dell’<code>array</code> o del <code>vector</code> della STL anziché l’array del C</a></li>
<li><a href="#Rsl-vector">SL.con.2: Preferire l’uso del <code>vector</code> della STL di default a meno che non ci sia un motivo per usare un contenitore differente</a></li>
<li><a href="#Rsl-bounds">SL.con.3: Evitare gli errori sui limiti [bound]</a></li>
<li><a href="#Rsl-copy">SL.con.4: Non usare <code>memset</code> o <code>memcpy</code> per gli argomenti che non siano facilmente copiabili</a></li>
</ul>
<h3 id="sl.con.1-preferire-luso-dellarray-o-del-vector-della-stl-anziché-larray-del-c"><a name="Rsl-arrays"></a>SL.con.1: Preferire l’uso dell’<code>array</code> o del <code>vector</code> della STL anziché l’array del C</h3>
<h5 id="motivo-406">Motivo</h5>
<p>Gli array del C sono meno sicuri e non hanno vantaggi rispetto a <code>array</code> e <code>vector</code>. Per un array a lunghezza fissa, si usa <code>std::array</code>, che non degenera in un puntatore quando viene passato ad una funzione e conosce la propria dimensione. Inoltre, come un gli array nativo, uno <code>std::array</code> allocato sullo stack tiene i suoi elementi sullo stack. Per un array a lunghezza variabile, si usa <code>std::vector</code>, che può inoltre modificare la sua dimensione a gestire l’allocazione della memoria.</p>
<h5 id="esempio-355">Esempio</h5>
<pre><code>int v[SIZE];                        // BAD

std::array&lt;int, SIZE&gt; w;             // ok</code></pre>
<h5 id="esempio-356">Esempio</h5>
<pre><code>int* v = new int[initial_size];     // BAD, proprietario del puntatore semplice [raw]
delete[] v;                         // BAD, delete manuale

std::vector&lt;int&gt; w(initial_size);   // ok</code></pre>
<h5 id="note-352">Note</h5>
<p>Usare <code>gsl::span</code> per i riferimenti non proprietari in un contenitore [container].</p>
<h5 id="note-353">Note</h5>
<p>Il confronto delle prestazioni tra un array a dimensione fissa allocato sullo stack rispetto ad un <code>vector</code> con gli elementi sull’heap [free store] è falsato. Si potrebbe anche confrontare uno <code>std::array</code> sullo stack rispetto all’accesso ad risultato di un <code>malloc()</code> tramite un puntatore. Per la maggior parte del codice, tra l’allocazione sullo stack e sull’heap [free-store] non importa, ma la praticità e la convenienza di <code>vector</code> sono importanti. Le persone che lavorano col codice per cui conta questa differenza sono abbastanza capaci di scegliere tra l’<code>array</code> e il <code>vector</code>.</p>
<h5 id="imposizione-372">Imposizione</h5>
<ul>
<li>Segnalare la dichiarazione di un array C in una funzione o una classe che dichiara anche un contenitore STL (per evitare un un numero eccessivo di avvisi per il codice ereditato non-STL). Per rsolvere: Modificare almeno l’array the in uno <code>std::array</code>.</li>
</ul>
<h3 id="sl.con.2-preferire-luso-del-vector-della-stl-di-default-a-meno-che-non-ci-sia-un-motivo-per-usare-un-contenitore-differente-container"><a name="Rsl-vector"></a>SL.con.2: Preferire l’uso del <code>vector</code> della STL di default a meno che non ci sia un motivo per usare un contenitore differente container</h3>
<h5 id="motivo-407">Motivo</h5>
<p><code>vector</code> e <code>array</code> sono i soli contenitori standard che offrono i seguenti vantaggi:</p>
<ul>
<li>L’accesso più rapido per scopi generici (l’accesso random, compreso l’essere compatibile con la vettorizzazione [vectorization-friendly]);</li>
<li>il più veloce pattern di accesso di default (da-inizio-alla-fine o dalla-fine-all-inizio è compatibile col prefetcher [prefetcher-friendly]);</li>
<li>il più basso spreco di spazio (il layout contiguo ha zero come spazio superfluo per ogni elemento, che lo rende [cache-friendly]).</li>
</ul>
<p>Solitamente è necessario aggiungere e togliere elementi dal contenitore, quindi si usa <code>vector</code> per default; se non si ha bisogno di modificare la dimensione del contenitore, si usa <code>array</code>.</p>
<p>Anche quando altri contenitori sembrano più adatti, come la <code>map</code> per una velocità di ricerca O(log N) o una <code>list</code> per l’efficienza delle inserzioni nel mezzo, un <code>vector</code> funzionerà ancora meglio dei contenitori con una dimensione fino a pochi KB.</p>
<h5 id="note-354">Note</h5>
<p>La <code>string</code> non dev’essere usata come contenitore per caratteri singoli. Una <code>string</code> è una stringa di testo; se si vuole un contenitore di caratteri, si usa <code>vector&lt;/*char_type*/&gt;</code> o <code>array&lt;/*char_type*/&gt;</code> instead.</p>
<h5 id="eccezioni-2">Eccezioni</h5>
<p>Se si ha una buona ragione per usare un altro contenitore, lo si usi. Per esempio:</p>
<ul>
<li><p>Se <code>vector</code> soddisfa le proprie esigenze ma non si ha la necessità che il contenitore sia variabile in ampiezza, usare, invece, <code>array</code>.</p></li>
<li><p>Se si vuole un contenitore per una ricerca in stile dizionario che garantisca ricerche O(K) o O(log N), il contenitore sarà più grande (più che qualche KB) e si eseguiranno frequenti inserimenti per cui mantenere lo spazio superfluo [overhead] di un <code>vector</code> ordinato non è fattibile, proseguire, invece, con l’uso di <code>unordered_map</code> o <code>map</code>.</p></li>
</ul>
<h5 id="note-355">Note</h5>
<p>Per inizializzare un vettore con un certo numero di elementi, usare l’inizializzazione <code>()</code>. Per inizializzare un vettore con una lista di elementi, usare l’inizializzazione <code>{}</code>.</p>
<pre><code>vector&lt;int&gt; v1(20);  // v1 ha 20 elementi col valore 0 (vector&lt;int&gt;{})
vector&lt;int&gt; v2 {20}; // v2 ha 1 elemento col valore 20</code></pre>
<p><a href="#Res-list">Preferire la sintassi dell’inizializzatore {}</a>.</p>
<h5 id="imposizione-373">Imposizione</h5>
<ul>
<li>Segnalare un <code>vector</code> le cui dimensioni non cambiano mai dopo la sua costruzione (o perché è <code>const</code> o perché con esso non si chiama alcuna funzione non-<code>const</code>). Per risolvere: Usare, invece, un <code>array</code>.</li>
</ul>
<h3 id="sl.con.3-evitare-gli-errori-sui-limiti-bound"><a name="Rsl-bounds"></a>SL.con.3: Evitare gli errori sui limiti [bound]</h3>
<h5 id="motivo-408">Motivo</h5>
<p>Leggere o scrivere oltre un intervallo allocato di elementi solitamente porta a brutti errori, risultati sbagliati, crash e violazioni della sicurezza.</p>
<h5 id="note-356">Note</h5>
<p>Le funzioni della libreria standard che si applicano a sequenze [range] di elementi hanno tutte (o potrebbero avere) uno spazio extra di sicurezza [bounds-safe overloads] che prende lo <code>span</code>. I tipi standard come <code>vector</code> si possono modificare per eseguire dei controlli sui limiti [bounds-check] sotto il profilo dei limiti (in modo compatibile, ad esempio aggiungendo i contratti [contract]), o usati con <code>at()</code>.</p>
<p>Idealmente, la garanzia di stare tra i limiti dovrebbe essere imposta staticamente. Per esempio:</p>
<ul>
<li>un range-<code>for</code> non può ciclare oltre i limiti del contenitore cui viene applicato</li>
<li>un <code>v.begin(),v.end()</code> viene facilmente identificato per stare sicuramente nei limiti</li>
</ul>
<p>Tali loop sono veloci come qualsiasi altro equivalente incontrollato/insicuro.</p>
<p>Spesso un semplice controllo preliminare può eliminare la necessità di verificare i singoli indici. Per esempio</p>
<ul>
<li>per <code>v.begin(),v.begin()+i</code> la <code>i</code> può essere facilmente controllata rispetto a <code>v.size()</code></li>
</ul>
<p>Questi cicli possono essere molto più veloci degli accessi agli elementi controllati singolarmente.</p>
<h5 id="esempio-cattivo-137">Esempio, cattivo</h5>
<pre><code>void f()
{
array&lt;int, 10&gt; a, b;
memset(a.data(), 0, 10);         // BAD, e contiene un errore della lunghezza (length = 10 * sizeof(int))
memcmp(a.data(), b.data(), 10);  // BAD, e contiene un errore della lunghezza (length = 10 * sizeof(int))
}</code></pre>
<p>Inoltre, <code>std::array&lt;&gt;::fill()</code> o <code>std::fill()</code> o anche un inizializzatore vuoto sono candidati migliori di <code>memset()</code>.</p>
<h5 id="esempio-buono-23">Esempio, buono</h5>
<pre><code>void f()
{
array&lt;int, 10&gt; a, b, c{};       // c è inizializzato a zero
a.fill(0);
fill(b.begin(), b.end(), 0);    // std::fill()
fill(b, 0);                     // std::fill() + Ranges TS

if ( a == b ) {
// ...
}
}</code></pre>
<h5 id="esempio-357">Esempio</h5>
<p>Se il codice utilizza una libreria standard non modificata, ci sono ancora soluzioni alternative che consentono l’uso di <code>std::array</code> e di <code>std::vector</code> in modo sicuro per i limiti. Il codice può chiamare la funzione membro <code>.at()</code> per ogni classe, che provocherà un’eccezione per <code>std::out_of_range</code>. In alternativa, il codice può chiamare la funzione libera <code>at()</code>, che darà una violazione [fail-fast] (o un’azione personalizzata) sui limiti.</p>
<pre><code>void f(std::vector&lt;int&gt;&amp; v, std::array&lt;int, 12&gt; a, int i)
{
v[0] = a[0];        // BAD
v.at(0) = a[0];     // OK (alternativa 1)
at(v, 0) = a[0];    // OK (alternativa 2)

v.at(0) = a[i];     // BAD
v.at(0) = a.at(i);  // OK (alternativa 1)
v.at(0) = at(a, i); // OK (alternativa 2)
}</code></pre>
<h5 id="imposizione-374">Imposizione</h5>
<ul>
<li>Segnalare un problema diagnostico per qualsiasi chiamata ad una funzione della libreria standard che non sia controllata per i limiti [bounds-checked]. ??? inserire un link ad un elenco di funzioni vietate</li>
</ul>
<p>Questa regola fa parte del <a href="#SS-bounds">profilo dei limiti [bounds profile]</a>.</p>
<h3 id="sl.con.4-non-usarememset-o-memcpy-per-gli-argomenti-che-non-siano-facilmente-copiabili"><a name="Rsl-copy"></a>SL.con.4: non usare<code>memset</code> o <code>memcpy</code> per gli argomenti che non siano facilmente copiabili</h3>
<h5 id="motivo-409">Motivo</h5>
<p>In questo modo si ingarbuglia la semantica degli oggetti (p.es., sovrascrivendo un <code>vptr</code>).</p>
<h5 id="note-357">Note</h5>
<p>Allo stesso modo per (w)memset, (w)memcpy, (w)memmove, e (w)memcmp</p>
<h5 id="esempio-358">Esempio</h5>
<pre><code>struct base {
virtual void update() = 0;
};

struct derived : public base {
void update() override {}
};


void f(derived&amp; a, derived&amp; b) // addio alle v-table
{
memset(&amp;a, 0, sizeof(derived));
memcpy(&amp;a, &amp;b, sizeof(derived));
memcmp(&amp;a, &amp;b, sizeof(derived));
}</code></pre>
<p>Definire invece le funzioni di inizializzazione, copia e confronto di default appropriate</p>
<pre><code>void g(derived&amp; a, derived&amp; b)
{
a = {};    // inizializza col default
b = a;     // copia
if (a == b) do_something(a, b);
}</code></pre>
<h5 id="imposizione-375">Imposizione</h5>
<ul>
<li>Segnalare l’uso di quelle funzioni per i tipi non facilmente copiabili</li>
</ul>
<p><strong>TODO Note</strong>:</p>
<ul>
<li>L’impatto sulla libreria standard richiederà uno stretto coordinamento con il WG21, se non altro per garantire la compatibilità anche se non sarà mai standardizzata.</li>
<li>Stiamo valutando la possibilità di specificare [bounds-safe overloads] per le funzioni stdlib (in particolare per la stdlib C) come <code>memcmp</code> e inserirle nel GSL.</li>
<li>Per le funzioni e i tipi stdlib come <code>vector</code> che non sono completamente [bounds-checked], l’obiettivo è che tali funzioni siano [bounds-checked] quando vengono chiamate dal codice col [bounds profile] attivato e incontrollate quando chiamate da codice ereditato, forse utilizzando i contratti (attualmente proposti da diversi membri del WG21).</li>
</ul>
<h2 id="sl.str-stringhe"><a name="SS-string"></a>SL.str: Stringhe</h2>
<p>La gestione del testo è un enorme argomento La <code>std::string</code> non lo copre tutto. Questa sezione cerca principalmente di chiarire la relazione di <code>std::string</code> con <code>char*</code>, <code>zstring</code>, <code>string_view</code> e <code>gsl::string_span</code>. Sulla questione importante dell’insieme dei caratteri non-ASCII e sulle codifiche (p.es., <code>wchar_t</code>, Unicode e UTF-8) se ne parlerà altrove.</p>
<p><strong>Si vade anche</strong>: <a href="#SS-regex">espressioni regolari</a></p>
<p>Qui, si usa “sequenza di caratteri” o “stringa” per rifrirsi ad una sequenza di caratteri che si intende leggere come testo (in qualche modo, forse). Non si considera ???</p>
<p>Sommario sulle stringhe:</p>
<ul>
<li><p><a href="#Rstr-string">SL.str.1: Usare <code>std::string</code> per avere sequenze di caratteri</a></p></li>
<li><p><a href="#Rstr-view">SL.str.2: Usare <code>std::string_view</code> o <code>gsl::string_span</code> per riferirsi alle sequenze di caratteri</a></p></li>
<li><p><a href="#Rstr-zstring">SL.str.3: Usare <code>zstring</code> o <code>czstring</code> per riferirsi a sequenze di caratteri in stile C, “zero-terminated”</a></p></li>
<li><p><a href="#Rstr-char*">SL.str.4: Usare <code>char*</code> per riferirsi ad un singolo carattere</a></p></li>
<li><p><a href="#Rstr-byte">SL.str.5: Usare <code>std::byte</code> per riferirsi ai valori dei byte che non necessariamente rappresentano caratteri</a></p></li>
<li><p><a href="#Rstr-locale">SL.str.10: Usare <code>std::string</code> quando c’è bisogno di eseguire operazioni sulle stringhe dipendenti dalla nazionalità</a></p></li>
<li><p><a href="#Rstr-span">SL.str.11: Usare <code>gsl::string_span</code> anziché <code>std::string_view</code> quando si deve mutare una stringa</a></p></li>
<li><p><a href="#Rstr-s">SL.str.12: Usare il suffisso <code>s</code> per le stringhe letterali intese come <code>string</code> della libreria standard</a></p></li>
</ul>
<p><strong>Si veda anche</strong>:</p>
<ul>
<li><a href="#Rf-range">F.24 span</a></li>
<li><a href="#Rf-zstring">F.25 zstring</a></li>
</ul>
<h3 id="sl.str.1-usare-stdstring-per-avere-sequenze-di-caratteri"><a name="Rstr-string"></a>SL.str.1: Usare <code>std::string</code> per avere sequenze di caratteri</h3>
<h5 id="motivo-410">Motivo</h5>
<p><code>string</code> gestisce correttamente l’allocazione, la proprietà [ownership], la copia, la graduale espansione ed offre varie operazioni utili.</p>
<h5 id="esempio-359">Esempio</h5>
<pre><code>vector&lt;string&gt; read_until(const string&amp; terminator)
{
vector&lt;string&gt; res;
for (string s; cin &gt;&gt; s &amp;&amp; s != terminator; ) // legge una parola
res.push_back(s);
return res;
}</code></pre>
<p>Si noti come <code>&gt;&gt;</code> e <code>!=</code> siano disponibili per <code>string</code> (come esempio di operazioni utili) e che non ci sono esplicite allocazioni, de-allocazioni o controlli dei limiti [range check] (è la <code>string</code> che se ne occupa).</p>
<p>Nel C++17, si può usare <code>string_view</code> come argomento, anziché <code>const string*</code> per dare una maggiore flessibilità ai chiamanti:</p>
<pre><code>vector&lt;string&gt; read_until(string_view terminator)   // C++17
{
vector&lt;string&gt; res;
for (string s; cin &gt;&gt; s &amp;&amp; s != terminator; ) // legge una parola
res.push_back(s);
return res;
}</code></pre>
<p>La <code>gsl::string_span</code> è l’alternativa corrente che offre la maggior parte dei vantaggi di <code>std::string_view</code> per esempi semplici:</p>
<pre><code>vector&lt;string&gt; read_until(string_span terminator)
{
vector&lt;string&gt; res;
for (string s; cin &gt;&gt; s &amp;&amp; s != terminator; ) // legge una parola
res.push_back(s);
return res;
}</code></pre>
<h5 id="esempio-cattivo-138">Esempio, cattivo</h5>
<p>Non usare stringhe in stile C per le operazioni che richiedono una gestione non banale della memoria</p>
<pre><code>char* cat(const char* s1, const char* s2)   // attenzione!
// restituisce s1 + &#39;.&#39; + s2
{
int l1 = strlen(s1);
int l2 = strlen(s2);
char* p = (char*) malloc(l1 + l2 + 2);
strcpy(p, s1, l1);
p[l1] = &#39;.&#39;;
strcpy(p + l1 + 1, s2, l2);
p[l1 + l2 + 1] = 0;
return p;
}</code></pre>
<p>Abbiamo capito bene? Il chiamante si ricorderà di eseguire il <code>free()</code> per il puntatore restituito? Questo codice supererà una test sulla sicurezza?</p>
<h5 id="note-358">Note</h5>
<p>Non dare per scontato che <code>string</code> sia pià lenta delle tecniche basso livello senza fare delle misure e si ricordi che non in tutto il codice sono importanti le prestazioni. <a href="#Rper-Knuth">Non ottimizzare prematuramente</a></p>
<h5 id="imposizione-376">Imposizione</h5>
<p>???</p>
<h3 id="sl.str.2-usare-stdstring_view-o-gslstring_span-per-riferirsi-alle-sequenze-di-caratteri"><a name="Rstr-view"></a>SL.str.2: Usare <code>std::string_view</code> o <code>gsl::string_span</code> per riferirsi alle sequenze di caratteri</h3>
<h5 id="motivo-411">Motivo</h5>
<p><code>std::string_view</code> e <code>gsl::string_span</code> forniscono un accesso semplice e (potenzialmente) sicuro alle sequenze di caratteri indipendentemente da come queste siano allocate e memorizzate.</p>
<h5 id="esempio-360">Esempio</h5>
<pre><code>vector&lt;string&gt; read_until(string_span terminator);

void user(zstring p, const string&amp; s, string_span ss)
{
auto v1 = read_until(p);
auto v2 = read_until(s);
auto v3 = read_until(ss);
// ...
}</code></pre>
<h5 id="note-359">Note</h5>
<p><code>std::string_view</code> (C++17) è a sola lettura.</p>
<h5 id="imposizione-377">Imposizione</h5>
<p>???</p>
<h3 id="sl.str.3-usare-zstring-o-czstring-per-riferirsi-a-sequenze-di-caratteri-in-stile-c-zero-terminated"><a name="Rstr-zstring"></a>SL.str.3: Usare <code>zstring</code> o <code>czstring</code> per riferirsi a sequenze di caratteri in stile C, “zero-terminated”</h3>
<h5 id="motivo-412">Motivo</h5>
<p>Leggibilità. Dichiarazione di intenti. Un semplice <code>char*</code> può essere un puntatore ad un solo carattere, un puntatore ad un array di caratteri, un puntatore ad una stringa C-style (zero-terminated), o anche ad un piccolo intero. Distinguere tra queste alternative evita incomprensioni e bug.</p>
<h5 id="esempio-361">Esempio</h5>
<pre><code>void f1(const char* s); // s è probabilmente una stringa</code></pre>
<p>Tutto quello che si sa è che si suppone essere o il nullptr o che punta ad almeno un carattere</p>
<pre><code>void f1(zstring s);     // s è una stringa C-style o il nullptr
void f1(czstring s);    // s è una stringa C-style costante o il nullptr
void f1(std::byte* s);  // s è un puntatore a un byte (C++17)</code></pre>
<h5 id="note-360">Note</h5>
<p>Non convertire una stringa C-style in <code>string</code> senza motivo.</p>
<h5 id="note-361">Note</h5>
<p>Come ogni altro “puntatore semplice [plain]”, una <code>zstring</code> non dovrebbe rappresentare la proprietà [ownership].</p>
<h5 id="note-362">Note</h5>
<p>Ci sono miliardi di righe di codice C++ “in giro”, la maggior parte usa <code>char*</code> e <code>const char*</code> senza documentarne l’intenzione. Queste vengono usate in un’ampia varietà di modi, come per rappresentare la proprietà [ownership] e come puntatori generici alla memoria (invece di <code>void*</code>). È difficile distinguere questi usi, quindi questa linea-guida è difficile da seguire. Questa è una delle principali fonti di bug nei programmi C e C++, quindi vale la pena seguire queste linee-guida ove possibile.</p>
<h5 id="imposizione-378">Imposizione</h5>
<ul>
<li>Segnalare gli usi di <code>[]</code> su un <code>char*</code></li>
<li>Segnalare gli usi di <code>delete</code> su un <code>char*</code></li>
<li>Segnalare gli usi di <code>free()</code> su un <code>char*</code></li>
</ul>
<h3 id="sl.str.4-usare-char-per-riferirsi-ad-un-singolo-carattere"><a name="Rstr-char*"></a>SL.str.4: Usare <code>char*</code> per riferirsi ad un singolo carattere</h3>
<h5 id="motivo-413">Motivo</h5>
<p>la varietà degli usi di <code>char*</code> nel codice corrente è una delle principali fonti di errori.</p>
<h5 id="esempio-cattivo-139">Esempio, cattivo</h5>
<pre><code>char arr[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;};

void print(const char* p)
{
cout &lt;&lt; p &lt;&lt; &#39;\n&#39;;
}

void use()
{
print(arr);   // errore a run-time; potenzialmente un pessimo errore
}</code></pre>
<p>L’array <code>arr</code> non è una stringa C-style perché non è terminata con zero [zero-terminated].</p>
<h5 id="alternativa-12">Alternativa</h5>
<p>Si vedano <a href="#Rstr-zstring"><code>zstring</code></a>, <a href="#Rstr-string"><code>string</code></a> e <a href="#Rstr-view"><code>string_span</code></a>.</p>
<h5 id="imposizione-379">Imposizione</h5>
<ul>
<li>Segnalare gli usi di <code>[]</code> su un <code>char*</code></li>
</ul>
<h3 id="sl.str.5-usare-stdbyte-per-riferirsi-ai-valori-dei-byte-che-non-necessariamente-rappresentano-caratteri"><a name="Rstr-byte"></a>SL.str.5: Usare <code>std::byte</code> per riferirsi ai valori dei byte che non necessariamente rappresentano caratteri</h3>
<h5 id="motivo-414">Motivo</h5>
<p>L’uso di <code>char*</code> per rappresentare un puntatore a qualcosa che non è necessariamente un carattere provoca confusione e disabilita preziose ottimizzazioni.</p>
<h5 id="esempio-362">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="note-363">Note</h5>
<p>C++17</p>
<h5 id="imposizione-380">Imposizione</h5>
<p>???</p>
<h3 id="sl.str.10-usare-stdstring-quando-cè-bisogno-di-eseguire-operazioni-sulle-stringhe-dipendenti-dalla-nazionalità"><a name="Rstr-locale"></a>SL.str.10: Usare <code>std::string</code> quando c’è bisogno di eseguire operazioni sulle stringhe dipendenti dalla nazionalità</h3>
<h5 id="motivo-415">Motivo</h5>
<p><code>std::string</code> supporta la funzionalità <a href="#Rstr-locale"><code>locale</code> della libreria standard</a></p>
<h5 id="esempio-363">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="note-364">Note</h5>
<p>???</p>
<h5 id="imposizione-381">Imposizione</h5>
<p>???</p>
<h3 id="sl.str.11-usare-gslstring_span-anziché-stdstring_view-quando-si-deve-mutare-una-stringa"><a name="Rstr-span"></a>SL.str.11: Usare <code>gsl::string_span</code> anziché <code>std::string_view</code> quando si deve mutare una stringa</h3>
<h5 id="motivo-416">Motivo</h5>
<p><code>std::string_view</code> è a sola lettura.</p>
<h5 id="esempio-364">Esempio</h5>
<p>???</p>
<h5 id="note-365">Note</h5>
<p>???</p>
<h5 id="imposizione-382">Imposizione</h5>
<p>Il compilatore segnalerà i tentativi di scrivere in una <code>string_view</code>.</p>
<h3 id="sl.str.12-usare-il-suffisso-s-per-le-stringhe-letterali-intese-come-string-della-libreria-standard"><a name="Rstr-s"></a>SL.str.12: Usare il suffisso <code>s</code> per le stringhe letterali intese come <code>string</code> della libreria standard</h3>
<h5 id="motivo-417">Motivo</h5>
<p>L’espressione diretta di un’idea minimizza gli errori.</p>
<h5 id="esempio-365">Esempio</h5>
<pre><code>auto pp1 = make_pair(&quot;Tokyo&quot;, 9.00);         // {stringa C-style,double} destinazione?
pair&lt;string, double&gt; pp2 = {&quot;Tokyo&quot;, 9.00};  // un po&#39; prolisso
auto pp3 = make_pair(&quot;Tokyo&quot;s, 9.00);        // {std::string,double}    // C++14
pair pp4 = {&quot;Tokyo&quot;s, 9.00};                 // {std::string,double}    // C++17</code></pre>
<h5 id="imposizione-383">Imposizione</h5>
<p>???</p>
<h2 id="sl.io-iostream"><a name="SS-io"></a>SL.io: Iostream</h2>
<p>Le <code>iostream</code> costituiscono una libreria di per lo streaming con un tipi sicuri, espandibile, con I/O formattato e non. Essa supporta molteplici strategie di buffering (e estensibili dall’utente) e diverse localizzazioni. Si può utilizzare per l’I/O convenzionale, la lettura e la scrittura in memoria (flussi [stream] di stringhe) e per le estensioni definite dall’utente, come lo streaming attraverso la rete (l’ASIO [Audio Streaming Input Output]: non ancora standardizzato).</p>
<p>Riepilogo delle regole sull’iostream:</p>
<ul>
<li><a href="#Rio-low">SL.io.1: Usare l’input a livello del carattere quando lo si deve fare</a></li>
<li><a href="#Rio-validate">SL.io.2: Quando si legge, considerare sempre l’input mal formattato</a></li>
<li><a href="#Rio-streams">SL.io.3: Preferire gli iostream per l’I/O</a></li>
<li><a href="#Rio-sync">SL.io.10: A meno che non si usi la famiglia delle funzioni <code>printf</code> chiamare <code>ios_base::sync_with_stdio(false)</code></a></li>
<li><a href="#Rio-endl">SL.io.50: Evitare <code>endl</code></a></li>
<li><a href="#???">???</a></li>
</ul>
<h3 id="sl.io.1-usare-linput-a-livello-del-carattere-quando-lo-si-deve-fare"><a name="Rio-low"></a>SL.io.1: Usare l’input a livello del carattere quando lo si deve fare</h3>
<h5 id="motivo-418">Motivo</h5>
<p>A meno che non si abbia realmente a che fare con i singoli caratteri, l’uso dell’input a livello del carattere porta il codice ad essere soggetto a errori e a una composizione di caratteri in token, potenzialmente inefficiente.</p>
<h5 id="esempio-366">Esempio</h5>
<pre><code>char c;
char buf[128];
int i = 0;
while (cin.get(c) &amp;&amp; !isspace(c) &amp;&amp; i &lt; 128)
buf[i++] = c;
if (i == 128) {
// ... gestisce una stringa troppo lunga ....
}</code></pre>
<p>Meglio (molto più semplice e forse più veloce):</p>
<pre><code>string s;
s.reserve(128);
cin &gt;&gt; s;</code></pre>
<p>e il <code>reserve(128)</code> probabilmente non serve.</p>
<h5 id="imposizione-384">Imposizione</h5>
<p>???</p>
<h3 id="sl.io.2-quando-si-legge-considerare-sempre-linput-mal-formattato"><a name="Rio-validate"></a>SL.io.2: Quando si legge, considerare sempre l’input mal formattato</h3>
<h5 id="motivo-419">Motivo</h5>
<p>Gli errori vengono gestiti meglio il prima possibile. Se l’input non è validato, ogni funzione dev’essere scritta per gestire dati errati (e questo non è pratico).</p>
<h5 id="esempio-367">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="imposizione-385">Imposizione</h5>
<p>???</p>
<h3 id="sl.io.3-preferire-gli-iostream-per-lio"><a name="Rio-streams"></a>SL.io.3: Preferire gli <code>iostream</code> per l’I/O</h3>
<h5 id="motivo-420">Motivo</h5>
<p>Gli <code>iostream</code> sono sicuri, flessibili ed espandibili.</p>
<h5 id="esempio-368">Esempio</h5>
<pre><code>// scrive un numero complesso:
complex&lt;double&gt; z{ 3, 4 };
cout &lt;&lt; z &lt;&lt; &#39;\n&#39;;</code></pre>
<p><code>complex</code> è un tipo “user-defined” ed il sui I/O è definito senza modificare la libreria <code>iostream</code>.</p>
<h5 id="esempio-369">Esempio</h5>
<pre><code>// legge un file di numeri complessi:
for (complex&lt;double&gt; z; cin &gt;&gt; z; )
v.push_back(z);</code></pre>
<h5 id="eccezione-53">Eccezione</h5>
<p>??? prestazioni ???</p>
<h5 id="discussione-liostream-rispetto-alla-famiglia-dei-printf">Discussione: L’<code>iostream</code> rispetto alla famiglia dei <code>printf()</code></h5>
<p>Viene frequentemente (e spesso correttamente) sottolineato che la famiglia dei <code>printf()</code> ha due vantaggi rispetto agli <code>iostream</code>: flessibilità nella formattazione e prestazioni. Ciò deve essere soppesato con i vantaggi degli <code>iostream</code> sull’estensibilità nel gestire tipi definiti dall’utente, la resilienza alle violazioni della sicurezza, la gestione implicita della memoria e la gestione <code>locale</code> (nazionalità).</p>
<p>Se c’è bisogno di I/O performante, si può quasi sempre far meglio di <code>printf()</code>.</p>
<p><code>gets()</code>, <code>scanf()</code> che usano <code>%s</code>, e <code>printf()</code> che usa <code>%s</code> sono rischi per la sicurezza (vulnerabile all’[overflow] e generalmente soggetti ad errori). Il C11 definisce delle “estensioni opzionali” che effettuano un controllo extra sui loro argomenti. Se presenti nella propria libreria C, <code>gets_s()</code>, <code>scanf_s()</code> e <code>printf_s()</code> costituiscono valide alternative, ma restano non sicure.</p>
<h5 id="imposizione-386">Imposizione</h5>
<p>Segnalare, opzionalmente, <code>&lt;cstdio&gt;</code> e <code>&lt;stdio.h&gt;</code>.</p>
<h3 id="sl.io.10-a-meno-che-non-si-usi-la-famiglia-delle-funzioni-printf-chiamare-ios_basesync_with_stdiofalse"><a name="Rio-sync"></a>SL.io.10: A meno che non si usi la famiglia delle funzioni <code>printf</code> chiamare <code>ios_base::sync_with_stdio(false)</code></h3>
<h5 id="motivo-421">Motivo</h5>
<p>Sincronizzare l’I/O degli <code>iostream</code> col <code>printf-style</code> può risultare costoso. <code>cin</code> e <code>cout</code> sono per default sincronizzati con <code>printf</code>.</p>
<h5 id="esempio-370">Esempio</h5>
<pre><code>int main()
{
ios_base::sync_with_stdio(false);
// ... usa gli iostream ...
}</code></pre>
<h5 id="imposizione-387">Imposizione</h5>
<p>???</p>
<h3 id="sl.io.50-evitare-endl"><a name="Rio-endl"></a>SL.io.50: Evitare <code>endl</code></h3>
<h5 id="motivo-422">Motivo</h5>
<p>Il manipolatore <code>endl</code> è per lo più equivalente a <code>'\n'</code> o <code>"\n"</code>; come viene comunemente usato, semplicemente rallenta l’output eseguendo dei <code>flush()</code> ridondanti. Questo rallentamento è significativo rispetto all’output in stile <code>printf</code>.</p>
<h5 id="esempio-371">Esempio</h5>
<pre><code>cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;    // due operazioni di output ed un flush
cout &lt;&lt; &quot;Hello, World!\n&quot;;          // una operazione di output e nessun flush</code></pre>
<h5 id="note-366">Note</h5>
<p>Per l’interazione <code>cin</code>/<code>cout</code> (e le equivalenti), non c’è alcun motivo per eseguire il flush; viene fatto automaticamente. Durante la scrittura in un file, c’è raramente bisogno di eseguire il <code>flush</code>.</p>
<h5 id="note-367">Note</h5>
<p>A parte il problema (occasionalmente importante) della performance, la scelta tra <code>'\n'</code> e <code>endl</code> è quasi soltanto estetica.</p>
<h2 id="sl.regex-regex"><a name="SS-regex"></a>SL.regex: Regex</h2>
<p><code>&lt;regex&gt;</code> è la libreria standard del C++ per le espressioni regolari. Essa supporta diverse convenzioni di modelli di espressioni regolari.</p>
<h2 id="sl.chrono-time"><a name="SS-chrono"></a>SL.chrono: Time</h2>
<p><code>&lt;chrono&gt;</code> (definita nel namespace <code>std::chrono</code>) fornisce la nozione di <code>time_point</code> e <code>duration</code> [durata] oltre alle funzioni per l’output del tempo secondo le varie unità. Fornisce i clock per registrare i <code>time_point</code>.</p>
<h2 id="sl.c-la-libreria-standard-del-c"><a name="SS-clib"></a>SL.C: La Libreria Standard del C</h2>
<p>???</p>
<p>Riepilogo delle regole sulla Libreria Standard del C:</p>
<ul>
<li><a href="#Rclib-jmp">S.C.1: Non usare setjmp/longjmp</a></li>
<li><a href="#???">???</a></li>
<li><a href="#???">???</a></li>
</ul>
<h3 id="sl.c.1-non-usare-setjmplongjmp"><a name="Rclib-jmp"></a>SL.C.1: Non usare setjmp/longjmp</h3>
<h5 id="motivo-423">Motivo</h5>
<p>un <code>longjmp</code> ignora i distruttori, invalidando tutta la gestione delle risorse basate sul RAII</p>
<h5 id="imposizione-388">Imposizione</h5>
<p>Segnalare tutte le ricorrenze di <code>longjmp</code> e <code>setjmp</code></p>
<h1 id="a-idee-architetturali"><a name="S-A"></a>A: Idee architetturali</h1>
<p>Questa sezione contiene idee sull’architettura a più alto livello e sulle librerie.</p>
<p>Riepilogo delle regole architetturali:</p>
<ul>
<li><a href="#Ra-stable">A.1: Separare il codice stabile da quello instabile</a></li>
<li><a href="#Ra-lib">A.2: Esprimere, in una libreria, le parti potenzialmente riutilizzabili</a></li>
<li><a href="#Ra-dag">A.4: Non ci dovrebbero essere ciclicità tra le librerie</a></li>
<li><a href="#???">???</a></li>
<li><a href="#???">???</a></li>
<li><a href="#???">???</a></li>
<li><a href="#???">???</a></li>
<li><a href="#???">???</a></li>
<li><a href="#???">???</a></li>
</ul>
<h3 id="a.1-separare-il-codice-stabile-da-quello-instabile"><a name="Ra-stable"></a>A.1: Separare il codice stabile da quello instabile</h3>
<p>L’isolamento del codice meno stabile ne facilita le unità di test, migliora l’interfaccia, il refactoring e l’eventuale [deprecation].</p>
<h3 id="a.2-esprimere-in-una-libreria-le-parti-potenzialmente-riutilizzabili"><a name="Ra-lib"></a>A.2: Esprimere, in una libreria, le parti potenzialmente riutilizzabili</h3>
<h5 id="motivo-424">Motivo</h5>
<h5 id="note-368">Note</h5>
<p>Una libreria è una collezione di dichiarazioni e definizioni mantenute, documentate e raggruppate assieme. Una libreria può essere un set di header (una “header-only library”) o un insieme di header pi+ un insieme di file oggetto. È possibile linkare staticamente o dinamicamente una libreria con un programma, o si può <code>#include</code>re una libreria “header-only”.</p>
<h3 id="a.4-non-ci-dovrebbero-essere-ciclicità-tra-le-librerie"><a name="Ra-dag"></a>A.4: Non ci dovrebbero essere ciclicità tra le librerie</h3>
<h5 id="motivo-425">Motivo</h5>
<ul>
<li>Una ciclicità complica il processo di compilazione.</li>
<li>Le ciclicità sono difficili da capire e possono introdurre indeterminismo (comportamento non specificato).</li>
</ul>
<h5 id="note-369">Note</h5>
<p>Una libreria può contenere riferimenti ciclici nella definizione dei propri componenti. Per esempio:</p>
<pre><code>???</code></pre>
<p>Tuttavia, una libreria non dovrebbe dipendere da un’altra che dipende da essa.</p>
<h1 id="nr-non-regole-e-leggende-myth"><a name="S-not"></a>NR: Non-Regole e leggende [myth]</h1>
<p>Questa sezione contiene regole e linee-guida che sono popolari altrove, ma che deliberatamente non si raccomandano. È ben noto che ci sono stati tempi e luoghi in cui queste regole avevano un senso, e le abbiamo usate noi stessi a volte. Tuttavia, nel contesto degli stili di programmazione che si raccomandano e si supportano con le linee-guida, queste “non regole” risulterebbero dannose.</p>
<p>Tuttora possono esserci contesti in cui le regole hanno senso.. Per esempio, la mancanza di un adeguato supporto di tool può rendere inadeguate le eccezioni nei sistemi in tempo reale, ma non c’è da fidarsi ciecamente della “saggezza popolare” (p.es, affermazioni non dimostrate sulla “efficienza”); questa “saggezza” potrebbe essere basata su informazioni vecchie di decenni e sperimentate con linguaggi dalle proprietà molto diverse da quelle del C++ (p.es., C o Java).</p>
<p>Gli argomenti positivi come alternative a queste non-regole sono indicate nelle regole proposte come “Alternative”.</p>
<p>Riepilogo delle non-regole:</p>
<ul>
<li><a href="#Rnr-top">NR.1: Non insistere sul fatto che tutte le dichiarazioni dovrebbero stare all’inizio di una funzione</a></li>
<li><a href="#Rnr-single-return">NR.2: Non insistere sul dover avere un’unica istruzione <code>return</code> in una funzione</a></li>
<li><a href="#Rnr-no-exceptions">NR.3: Non evitare le eccezioni</a></li>
<li><a href="#Rnr-lots-of-files">NR.4: Non insistere sul voler mettere ogni classe nel proprio file sorgente</a></li>
<li><a href="#Rnr-two-phase-init">NR.5: Non usare l’inizializzazione a due fasi [two-phase]</a></li>
<li><a href="#Rnr-goto-exit">NR.6: Non mettere tutte le operazioni di ripulitura alla fine di una funzione e il <code>goto exit</code></a></li>
<li><a href="#Rnr-protected-data">NR.7: Non rendere tutti i dati membro come <code>protected</code></a></li>
<li>???</li>
</ul>
<h3 id="nr.1-non-insistere-sul-fatto-che-tutte-le-dichiarazioni-dovrebbero-stare-allinizio-di-una-funzione"><a name="Rnr-top"></a>NR.1: Non insistere sul fatto che tutte le dichiarazioni dovrebbero stare all’inizio di una funzione</h3>
<h5 id="motivo-426">Motivo</h5>
<p>La regola “tutte le dichiarazioni all’inizio” è un retaggio di vecchi linguaggi di programmazione che non consentivano l’inizializzazione di variabili e costanti dopo un’istruzione. Ciò porta a programmi più lunghi e più errori causati da variabili non inizializzate o inizializzate erroneamente.</p>
<h5 id="esempio-cattivo-140">Esempio, cattivo</h5>
<pre><code>int use(int x)
{
int i;
char c;
double d;

// ... alcune cose ...

if (x &lt; i) {
// ...
i = f(x, d);
}
if (i &lt; x) {
// ...
i = g(x, c);
}
return i;
}</code></pre>
<p>Maggiore è la distanza tra la variabile non inizializzata e il suo utilizzo, maggiore è la probabilità di un bug. Fortunatamente, i compilatori rilevano molti errori “utilizzo prima dell’assegnazione”. Sfortunatamente, i compilatori non possono rilevare tutti questi errori e, sfortunatamente, i bug non sono sempre così facili da individuare come in questo piccolo esempio.</p>
<h5 id="alternativa-13">Alternativa</h5>
<ul>
<li><a href="#Res-always">Inizializzare sempre un oggetto</a></li>
<li><a href="#Res-introduce">ES.21: Non introdurre una variabile (o una costante) prima che ne sia necessario l’uso</a></li>
</ul>
<h3 id="nr.2-non-insistere-sul-dover-avere-ununica-istruzione-return-in-una-funzione"><a name="Rnr-single-return"></a>NR.2: Non insistere sul dover avere un’unica istruzione <code>return</code> in una funzione</h3>
<h5 id="motivo-427">Motivo</h5>
<p>La regola del return-unico può portare a un codice inutilmente contorto e alla necessità di variabili di stato extra. In particolare, la regola del return-unico rende più difficile concentrare il controllo degli errori all’inizio di una funzione.</p>
<h5 id="esempio-372">Esempio</h5>
<pre><code>template&lt;class T&gt;
//  requires Number&lt;T&gt;
string sign(T x)
{
if (x &lt; 0)
return &quot;negative&quot;;
else if (x &gt; 0)
return &quot;positive&quot;;
return &quot;zero&quot;;
}</code></pre>
<p>per usare un return unico si dovrebbe fare qualcosa del genere</p>
<pre><code>template&lt;class T&gt;
//  requires Number&lt;T&gt;
string sign(T x)        // non buono
{
string res;
if (x &lt; 0)
res = &quot;negative&quot;;
else if (x &gt; 0)
res = &quot;positive&quot;;
else
res = &quot;zero&quot;;
return res;
}</code></pre>
<p>Questo è sia più lungo che probabilmente meno efficiente. Più grande e complicata è la funzione, più contorte sono le soluzioni alternative. Naturalmente molte funzioni semplici avranno naturalmente solo un <code>return</code> a causa della loro logica intrinseca più semplice.</p>
<h5 id="esempio-373">Esempio</h5>
<pre><code>int index(const char* p)
{
if (!p) return -1;  // indicatore dell&#39;errore: in alternativa &quot;throw nullptr_error{}&quot;
// ... effettua una ricerca per trovare l&#39;indice per p
return i;
}</code></pre>
<p>Se si applicasse la regola, si otterrebbe qualcosa di simile</p>
<pre><code>int index2(const char* p)
{
int i;
if (!p)
i = -1;  // indicatore dell&#39;errore
else {
// ... effettua una ricerca per trovare l&#39;indice per p
}
return i;
}</code></pre>
<p>Si noti che è stata (deliberatamente) violata la regola contro le variabili non inizializzate perché questo stile porta solitamente a farlo. Inoltre, questo stile è una tentazione per usare la non-regola <a href="#Rnr-goto-exit">goto exit</a>.</p>
<h5 id="alternativa-14">Alternativa</h5>
<ul>
<li>Tenere le funzioni brevi e semplici</li>
<li>Sentirsi liberi di usare più istruzioni <code>return</code> (e sollevare [throw] eccezioni).</li>
</ul>
<h3 id="nr.3-non-evitare-le-eccezioni"><a name="Rnr-no-exceptions"></a>NR.3: Non evitare le eccezioni</h3>
<h5 id="motivo-428">Motivo</h5>
<p>Sembrano esserci quattro principali ragioni per non usare le eccezioni:</p>
<ul>
<li>le eccezioni sono inefficienti</li>
<li>le eccezioni portano a leak e ad errori</li>
<li>La prestazione di un’eccezione non è prevedibile</li>
<li>il supporto a run-time della gestione delle eccezioni occupa troppo spazio</li>
</ul>
<p>Non è possibile di risolvere questo problema soddisfacendo tutti. Dopotutto, le discussioni sulle eccezioni vanno avanti da oltre 40 anni. Alcuni linguaggi non si possono usare senza le eccezioni, ma altri non le supportano. Ciò porta a delle consolidate tradizioni sull’uso e il non-uso delle eccezioni e ad accesi dibattiti.</p>
<p>Tuttavia, si può descrivere brevemente il motivo per cui si considerano le eccezioni la migliore alternativa per la programmazione generale e per il contesto di queste linee-guida. Semplici argomenti a favore o contro spesso sono inconcludenti. Esistono applicazioni specializzate in cui le eccezioni possono essere inopportune (p.es., sistemi con un rigido real-time senza il supporto di stime affidabili dei costi della gestione degli errori).</p>
<p>Si considerino le principali obiezioni una per una</p>
<ul>
<li>Le eccezioni sono inefficienti: Rispetto a che? Durante il confronto, assicurarsi che venga gestita la stessa serie di errori e che siano gestiti in modo equivalente. In particolare, non confrontare un programma che termina immediatamente al primo errore con un programma che pulisce accuratamente le risorse prima di tener traccia di un errore. Sì, alcuni sistemi hanno implementazioni di gestione delle eccezioni scadenti; a volte, tali implementazioni ci obbligano a utilizzare altri approcci per la gestione degli errori, ma questo non è un problema fondamentale per le eccezioni. Quando si utilizza un argomento di efficienza - in qualsiasi contesto - fare attenzione a disporre di dati validi che forniscano effettivamente informazioni sul problema in esame.</li>
<li>Le eccezioni portano a leak e ed errori. Non lo fanno. Se il programma è un ammasso di puntatori senza una strategia globale per la gestione delle risorse, c’è un problema, qualunque cosa si faccia. Se il sistema è costituito da un milione di righe di tale codice, probabilmente non si sarà in grado di usare le eccezioni, ma questo è un problema per un uso eccessivo e indisciplinato dei puntatori, piuttosto che con le eccezioni. A nostro avviso, c’è bisogno del RAII per rendere la gestione degli errori basata sulle eccezioni semplice e sicura – più semplice e più sicura delle alternative.</li>
<li>Le prestazioni delle eccezioni non sono prevedibili. Se ci si trova in un sistema strettamente real-time in cui è necessario garantire il completamento di un’attività in un determinato tempo, si necessita di tool per avallare queste necessità. Per quanto si sa, tali tool non sono disponibili (almeno non per la maggior parte dei programmatori).</li>
<li>il supporto a run-time per la gestione delle eccezioni occupa troppo spazio Questo può essere il caso di piccoli sistemi (di solito sistemi embedded). Tuttavia, prima di abbandonare le eccezioni, considerare quanto spazio richiederebbe una gestione coerente degli errori utilizzando i codici di errore e quanto costerebbe la mancata rilevazione di un errore.</li>
</ul>
<p>Molti, forse la maggior parte, dei problemi con le eccezioni derivano da esigenze storiche di interagire con un codice vecchio e disordinato.</p>
<p>Gli argomenti fondamentali per l’uso delle eccezioni sono</p>
<ul>
<li>distinguono chiaramente tra un return cn errore e un return normale</li>
<li>Non possono essere dimenticati o ignorati</li>
<li>Possono essere usati sistematicamente</li>
</ul>
<p>Da ricordare</p>
<ul>
<li>Le eccezioni servono per segnalare errori (nel C++; altri linguaggi le possono usare per altri usi).</li>
<li>Le eccezioni non riguardano errori che possono essere gestiti localmente.</li>
<li>Non cercare di catturare ogni eccezione in ogni funzione (è noioso, goffo e porta a un codice lento).</li>
<li>Le eccezioni non riguardano gli errori che richiedono la chiusura immediata di u modulo/sistema dopo un errore irrecuperabile.</li>
</ul>
<h5 id="esempio-374">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="alternativa-15">Alternativa</h5>
<ul>
<li><a href="#Re-raii">RAII</a></li>
<li>Contratti/asserzioni: Usare <code>Expects</code> e <code>Ensures</code> del GSL (fino a quando non si avrà il supporto nel linguaggio per i contratti)</li>
</ul>
<h3 id="nr.4-non-insistere-sul-voler-mettere-ogni-classe-nel-proprio-file-sorgente"><a name="Rnr-lots-of-files"></a>NR.4: Non insistere sul voler mettere ogni classe nel proprio file sorgente</h3>
<h5 id="motivo-429">Motivo</h5>
<p>Il numero di file che risulta nel collocare ciascuna classe nel proprio file è difficile da gestire e può rallentare la compilazione. Classi singole costituiscono raramente delle buone unità logiche da manutenere e distribuire.</p>
<h5 id="esempio-375">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="alternativa-16">Alternativa</h5>
<ul>
<li>Usare i namespace contenenti insiemi di classi e funzioni logicamente correlati.</li>
</ul>
<h3 id="nr.5-non-usare-linizializzazione-a-due-fasi-two-phase"><a name="Rnr-two-phase-init"></a>NR.5: Non usare l’inizializzazione a due fasi [two-phase]</h3>
<h5 id="motivo-430">Motivo</h5>
<p>Suddividere in due l’inizializzazione, porta a invarianti più deboli, codice più complicato (gestire oggetti semi-costruiti) e ad errori (quando non si gestiscono correttamente gli oggetti semi-costruiti in modo coerente).</p>
<h5 id="esempio-cattivo-141">Esempio, cattivo</h5>
<pre><code>class Picture
{
int mx;
int my;
char * data;
public:
Picture(int x, int y)
{
mx = x,
my = y;
data = nullptr;
}

~Picture()
{
Cleanup();
}

bool Init()
{
// controlli invarianti
if (mx &lt;= 0 || my &lt;= 0) {
return false;
}
if (data) {
return false;
}
data = (char*) malloc(mx*my*sizeof(int));
return data != nullptr;
}

void Cleanup()
{
if (data) free(data);
data = nullptr;
}
};

Picture picture(100, 0); // qui picture non è ancora pronta all&#39;uso
// andrà in errore..
if (!picture.Init()) {
puts(&quot;Error, invalid picture&quot;);
}
// ora si ha un&#39;istanza di un oggetto picture non valido.</code></pre>
<h5 id="esempio-buono-24">Esempio, buono</h5>
<pre><code>class Picture
{
size_t mx;
size_t my;
vector&lt;char&gt; data;

static size_t check_size(size_t s)
{
// controlli invarianti
Expects(s &gt; 0);
return s;
}

public:
// ancor meglio sarebbe una classe per una Size 2D come parametro singolo
Picture(size_t x, size_t y)
: mx(check_size(x))
, my(check_size(y))
// ora si sa che x e y sono dimensioni valide
, data(mx * my * sizeof(int)) // solleverà un&#39;eccezione std::bad_alloc in caso di errore
{
// picture è pronta all&#39;uso
}
// il lavoro viene fatto dal distruttore [dtor] generato dal compilatore. (si veda anche C.21)
};

Picture picture1(100, 100);
// qui picture è pronta all&#39;uso...

// y non ha una dimensione valida,
// quindi per la violazione del contratto si chiamerà std::terminate
Picture picture2(100, 0);
// non si arriva qui...</code></pre>
<h5 id="alternativa-17">Alternativa</h5>
<ul>
<li>Stabilire sempre un invariante della classe in un costruttore.</li>
<li>Non definire un oggetto prima che sia necessario.</li>
</ul>
<h3 id="nr.6-non-mettere-tutte-le-operazioni-di-ripulitura-alla-fine-di-una-funzione-e-il-goto-exit"><a name="Rnr-goto-exit"></a>NR.6: Non mettere tutte le operazioni di ripulitura alla fine di una funzione e il <code>goto exit</code></h3>
<h5 id="motivo-431">Motivo</h5>
<p>Il <code>goto</code> è soggetto a errori. Questa è una tecnica pre-eccezioni per le risorse [RAII-like] e la gestione degli errori.</p>
<h5 id="esempio-cattivo-142">Esempio, cattivo</h5>
<pre><code>void do_something(int n)
{
if (n &lt; 100) goto exit;
// ...
int* p = (int*) malloc(n);
// ...
if (some_error) goto_exit;
// ...
exit:
free(p);
}</code></pre>
<p>e si trovi il bug.</p>
<h5 id="alternativa-18">Alternativa</h5>
<ul>
<li>Usare le eccezioni e il <a href="#Re-raii">RAII</a></li>
<li>per le risorse non-RAII, usare <a href="#Re-finally"><code>finally</code></a>.</li>
</ul>
<h3 id="nr.7-non-rendere-tutti-i-dati-membro-come-protected"><a name="Rnr-protected-data"></a>NR.7: Non rendere tutti i dati membro come <code>protected</code></h3>
<h5 id="motivo-432">Motivo</h5>
<p>I dati <code>protected</code> sono fonte di errori.. I dati <code>protected</code> possono essere modificati da una gran quantità di codice in vari punti. I dati <code>protected</code> sono l’equivalente dei dati globali nelle gerarchie di classi.</p>
<h5 id="esempio-376">Esempio</h5>
<pre><code>???</code></pre>
<h5 id="alternativa-19">Alternativa</h5>
<ul>
<li><a href="#Rh-protected">Rendere i dati membro <code>public</code> o (preferibilmente) <code>private</code></a></li>
</ul>
<h1 id="rf-riferimenti"><a name="S-references"></a>RF: Riferimenti</h1>
<p>Sono stati scritti molti standard di codifica, regole e linee-guida per il C++, specie per usi specifici del C++. Molti</p>
<ul>
<li>si concentrano su argomenti a basso libello, come l’ortografia e gli identificatori</li>
<li>sono scritti da principianti del C++</li>
<li>cercano principalmente di “impedire ai programmatori di fare cose insolite”</li>
<li>mirano alla portabilità tra più compilatori (alcuni hanno 10 anni)</li>
<li>sono scritti per preservare decenni di vecchio codice</li>
<li>mirano ad un singolo dominio applicativo</li>
<li>sono decisamente contro-producenti</li>
<li>vengono ignorati (devono essere ignorati dai programmatori per fare un buon lavoro)</li>
</ul>
<p>Un cattivo standard di codifica è peggio che non avere alcuno standard. Tuttavia, una serie di giuste linee-guida è molto meglio di nessuno standard: “La disciplina è liberatrice [Form is liberating]”.</p>
<p>Perché non si può semplicemente avere un linguaggio consenta tutto ciò si vuole e non ci permetta di tutto ciò che non si vuole (“un linguaggio perfetto”)? Fondamentalmente, perché i linguaggi a prezzi accessibili (e i tool accessori) servono anche a persone con esigenze diverse dalle proprie e soddisfano più esigenze di quelle che odierne. Inoltre, le esigenze cambiano col tempo ed è necessario un linguaggio “general-purpose” per potersi adattare. Un linguaggio che sia perfetto oggi potrebbe diventare restrittivo un domani.</p>
<p>Le linee-guida adattano l’utilizzo del linguaggio a specifiche necessità. Pertanto, non può esistere un unico stile di codifica per tutti. C’è da prevedere che diverse organizzazioni forniscano delle aggiunte, in genere con più restrizioni e regole di stile più rigide.</p>
<p>Sezioni sui riferimenti:</p>
<ul>
<li><a href="#SS-rules">RF.rules: Regole di codifica</a></li>
<li><a href="#SS-books">RF.books: Libri con linee-guida sulla codifica</a></li>
<li><a href="#SS-Cplusplus">RF.C++: Programmazione C++ (C++11/C++14/C++17)</a></li>
<li><a href="#SS-web">RF.web: Siti web</a></li>
<li><a href="#SS-vid">RS.video: Video sul “C++ moderno”</a></li>
<li><a href="#SS-man">RF.man: Manuali</a></li>
<li><a href="#SS-core">RF.core: Materiali sulle “Core Guidelines”</a></li>
</ul>
<h2 id="rf.rules-regole-di-codifica"><a name="SS-rules"></a>RF.rules: Regole di codifica</h2>
<ul>
<li><a href="https://www.autosar.org/fileadmin/user_upload/standards/adaptive/17-10/AUTOSAR_RS_CPP14Guidelines.pdf">Linee-guida AUTOSAR [AUTomotive Open System Architecture] per l’uso del linguaggio C++14 per sistemi critici e sicuri v17.10</a></li>
<li><a href="http://www.boost.org/development/requirements.html">Requisiti e linee-guida della libreria Boost</a>. ???.</li>
<li><a href="https://github.com/bloomberg/bde/wiki/CodingStandards.pdf">Bloomberg: BDE C++ Coding</a>. Pone una forte enfasi sull’organizzazione e il layout del codice.</li>
<li>Facebook: ???</li>
<li><a href="https://gcc.gnu.org/codingconventions.html">GCC Coding Conventions</a>. C++03 e (ragionevolmente) un po’ datate.</li>
<li><a href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a>. Orientata al C++03 e (anche) al codice più vecchio. Qui, gli esperti di Google, stanno collaborando attivamente per contribuire a migliorare queste Linee-guida e, si spera, per unire gli sforzi in modo che queste possano costituire un moderno insieme comune che potrebbero anche raccomandare.</li>
<li><a href="http://www.stroustrup.com/JSF-AV-rules.pdf">JSF++: JOINT STRIKE FIGHTER AIR VEHICLE C++ CODING STANDARDS</a>. Documento Numero 2RDU00001 Rev C. Dicembre 2005. Per il software per il controllo di aerei. Per li [hard-real-time]. Questo vuol dire che è necessariamente molto restrittivo (“se il programma fallisce qualcuno muore”). Ad esempio, non può avvenire nessuna allocazione o de-allocazione della memoria dopo io decollo dell’aereo (non è consentite nessun [overflow] della memoria né una frammentazione). Non è possibile utilizzare alcuna eccezione (perché non c’è alcun tool a disposizione che ne garantisca l’esecuzione subito, in un tempo prestabilito). Le librerie usate sono state approvate per applicazioni “mission critical”. Non deve sorprendere che ci sia qualche somiglianza con queste linee-guida perché Bjarne Stroustrup è stato uno degli autori della JSF++. Raccomandata, ma si noti che ha un focus molto specifico.</li>
<li>[<em>MISRA C++ 2008: Linee-guida per l’uso del linguaggio C++ in sistemi critici</em>] (https://www.misra.org.uk/Buyonline/tabid/58/Default.aspx).</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/C%2B%2B_Portability_Guide">Mozilla Portability Guide</a>. Come indica il nome, si pone lo scopo della portabilità tra molti (vecchi) compilatori. In quanto tale, è restrittivo.</li>
<li><a href="http://geosoft.no/development/cppstyle.html">Geosoft.no: C++ Programming Style Guidelines</a>. ???.</li>
<li><a href="http://www.possibility.com/Cpp/CppCodingStandard.html">Possibility.com: C++ Coding Standard</a>. ???.</li>
<li><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637">SEI CERT: Secure C++ Coding Standard</a>. Un set di regole ben fatto (con esempi e razionali) per il codice [security-sensitive]. Molte delle regole si applicano in generale.</li>
<li><a href="http://www.codingstandard.com/">High Integrity C++ Coding Standard</a>.</li>
<li><a href="http://llvm.org/docs/CodingStandards.html">llvm</a>. Abbastanza breve, basato sul C++14 e (non irragionevolmente) adattato al suo dominio.</li>
<li>???</li>
</ul>
<h2 id="rf.books-libri-con-linee-guida-sulla-codifica"><a name="SS-books"></a>RF.books: Libri con linee-guida sulla codifica</h2>
<ul>
<li><a href="#Meyers96">Meyers96</a> Scott Meyers: <em>More Effective C++</em>. Addison-Wesley 1996.</li>
<li><a href="#Meyers97">Meyers97</a> Scott Meyers: <em>Effective C++, Second Edition</em>. Addison-Wesley 1997.</li>
<li><a href="#Meyers01">Meyers01</a> Scott Meyers: <em>Effective STL</em>. Addison-Wesley 2001.</li>
<li><a href="#Meyers05">Meyers05</a> Scott Meyers: <em>Effective C++, Third Edition</em>. Addison-Wesley 2005.</li>
<li><a href="#Meyers15">Meyers15</a> Scott Meyers: <em>Effective Modern C++</em>. O’Reilly 2015.</li>
<li><a href="#SuttAlex05">SuttAlex05</a> Sutter and Alexandrescu: <em>C++ Coding Standards</em>. Addison-Wesley 2005. Più un insieme di meta-regole che un set di regole. Pre-C++11.</li>
<li><a href="#Stroustrup05">Stroustrup05</a> Bjarne Stroustrup: <a href="http://www.stroustrup.com/SELLrationale.pdf">A rationale for semantically enhanced library languages</a>. LCSD05. October 2005.</li>
<li><a href="#Stroustrup05">Stroustrup14</a> Stroustrup: <a href="http://www.stroustrup.com/Tour.html">A Tour of C++</a>. Addison Wesley 2014. Ogni capitolo termina con una sezione di consigli composta da una serie di raccomandazioni.</li>
<li><a href="#Stroustrup13">Stroustrup13</a> Stroustrup: <a href="http://www.stroustrup.com/4th.html">The C++ Programming Language (4th Edition)</a>. Addison Wesley 2013. Ogni capitolo termina con una sezione di consigli composta da una serie di raccomandazioni.</li>
<li>Stroustrup: <a href="http://www.stroustrup.com/Programming/PPP-style.pdf">Style Guide</a> for <a href="http://www.stroustrup.com/programming.html">Programming: Principles and Practice using C++</a>. Principalmente regole sui nomi e sul layout a basso livello Principalmente uno strumento didattico.</li>
</ul>
<h2 id="rf.c-programmazione-c-c11c14"><a name="SS-Cplusplus"></a>RF.C++: Programmazione C++ (C++11/C++14)</h2>
<ul>
<li><a href="http://www.stroustrup.com/4th.html">TC++PL4</a>: Una descrizione completa del linguaggio C++ e delle librerie standard per programmatori esperti.</li>
<li><a href="http://www.stroustrup.com/Tour.html">Tour++</a>: Una panoramica sul linguaggio C++ e sulle librerie standard per programmatori esperti.</li>
<li><a href="http://www.stroustrup.com/programming.html">Programming: Principles and Practice using C++</a>: Un libro di testo per principianti o quasi.</li>
</ul>
<h2 id="rf.web-siti-web"><a name="SS-web"></a>RF.web: Siti web</h2>
<ul>
<li><a href="https://isocpp.org">isocpp.org</a></li>
<li><a href="http://www.stroustrup.com">Il sito di Bjarne Stroustrup</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/">WG21</a></li>
<li><a href="http://www.boost.org">Boost</a><a name="Boost"></a></li>
<li><a href="http://www.adobe.com/open-source.html">Adobe open source</a></li>
<li><a href="http://pocoproject.org/">Librerie Poco</a></li>
<li>Sutter’s Mill?</li>
<li>???</li>
</ul>
<h2 id="rs.video-video-sul-c-moderno"><a name="SS-vid"></a>RS.video: Video sul “C++ moderno”</h2>
<ul>
<li>Bjarne Stroustrup: <a href="http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style">C++11 Style</a>. 2012.</li>
<li>Bjarne Stroustrup: <a href="http://channel9.msdn.com/Events/GoingNative/2013/Opening-Keynote-Bjarne-Stroustrup">The Essence of C++: With Examples in C++84, C++98, C++11, and C++14</a>. 2013</li>
<li>Tutti i discorsi dal <a href="https://isocpp.org/blog/2014/11/cppcon-videos-c9">CppCon ’14</a></li>
<li>Bjarne Stroustrup: <a href="https://www.youtube.com/watch?v=86xWVb4XIyE">The essence of C++</a> at the University of Edinburgh. 2014.</li>
<li>Bjarne Stroustrup: <a href="https://www.youtube.com/watch?v=_wzc7a3McOs">The Evolution of C++ Past, Present and Future</a>. CppCon 2016 [keynote].</li>
<li>Bjarne Stroustrup: <a href="https://www.youtube.com/watch?v=nesCaocNjtQ">Make Simple Tasks Simple!</a>. CppCon 2014 [keynote].</li>
<li>Bjarne Stroustrup: <a href="https://www.youtube.com/watch?v=1OEu9C51K2A">Writing Good C++14</a>. CppCon 2015 [keynote] sulle “Core Guidelines”.</li>
<li>Herb Sutter: <a href="https://www.youtube.com/watch?v=hEx5DNLWGgA">Writing Good C++14… By Default</a>. CppCon 2015 [keynote] sulle “Core Guidelines”.</li>
<li>CppCon 15</li>
<li>??? C++ Prossimo</li>
<li>??? Meeting sul C++</li>
<li>??? altro ???</li>
</ul>
<h2 id="rf.man-manuali"><a name="SS-man"></a>RF.man: Manuali</h2>
<ul>
<li>ISO C++ Standard C++11.</li>
<li>ISO C++ Standard C++14.</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf">ISO C++ Standard C++17</a>. Bozza del Comitato [Committee Draft].</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf">Palo Alto “Concepts” TR</a>.</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf">ISO C++ Concepts TS</a>.</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf">WG21 Ranges report</a>. Bozza [draft].</li>
</ul>
<h2 id="rf.core-materiali-sulle-core-guidelines"><a name="SS-core"></a>RF.core: Materiali sulle “Core Guidelines”</h2>
<p>Questa sezione contiene i materiali utilizzati per presentare le “Core guidelines” e le idee di fondo:</p>
<ul>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/tree/master/docs">La nostra documentazione</a></li>
<li>Stroustrup, Sutter, and Dos Reis: <a href="http://www.stroustrup.com/resource-model.pdf">A brief introduction to C++’s model for type- and resource-safety</a>. Un documento don moltissimi esempi.</li>
<li>Sergey Zubkov: <a href="https://www.youtube.com/watch?v=DyLwdl_6vmU">a Core Guidelines talk</a> e qui ci sono le<a href="http://2017.cppconf.ru/talks/sergey-zubkov">slide</a>. In Russo. 2017.</li>
<li>Neil MacIntosh: <a href="https://www.youtube.com/watch?v=_GhNnCuaEjo">The Guideline Support Library: One Year Later</a>. CppCon 2016.</li>
<li>Bjarne Stroustrup: <a href="https://www.youtube.com/watch?v=1OEu9C51K2A">Writing Good C++14</a>. CppCon 2015 [keynote].</li>
<li>Herb Sutter: <a href="https://www.youtube.com/watch?v=hEx5DNLWGgA">Writing Good C++14… By Default</a>. CppCon 2015 [keynote].</li>
<li>Peter Sommerlad: <a href="https://www.youtube.com/watch?v=fQ926v4ZzAM">C++ Core Guidelines - Modernize your C++ Code Base</a>. ACCU 2017.</li>
<li>Bjarne Stroustrup: <a href="https://www.youtube.com/watch?v=01zI9kV4h8c">No Littering!</a>. Bay Area ACCU 2016. Da un’idea del livello ambito dalle “Core Guidelines”.</li>
</ul>
<p>Si noti che sono disponibili le slide per le presentazioni al CppCon (i link con i video postati).</p>
<p>Sono benvenuti altri contributi a questo elenco.</p>
<h2 id="riconoscimenti"><a name="SS-ack"></a>Riconoscimenti</h2>
<p>Grazie alle molte persone che hanno contribuito a queste regole con , i suggerimenti, supportando le informazioni, con i riferimenti, ecc.:</p>
<ul>
<li>Peter Juhl</li>
<li>Neil MacIntosh</li>
<li>Axel Naumann</li>
<li>Andrew Pardoe</li>
<li>Gabriel Dos Reis</li>
<li>Zhuang, Jiangang (Jeff)</li>
<li>Sergey Zubkov</li>
</ul>
<p>e si veda l’elenco dei contributori su github.</p>
<h1 id="pro-profili"><a name="S-profile"></a>Pro: Profili</h1>
<p>Idealmente, si seguirebbero tutte le linee guida. Questo porterebbe a un codice più pulito, più regolare, meno soggetto a errori e spesso il più veloce. Sfortunatamente, ciò è generalmente impossibile perché si deve adattare il proprio codice ad altro codice di grandi dimensioni e utilizzare le librerie esistenti. Spesso, tale codice è stato scritto per decenni e non segue queste linee-guida. Si deve puntare ad una <a href="#S-modernizing">graduale adozione</a>.</p>
<p>Qualunque strategia di adozione graduale si adotti, si deve essere in grado di applicare una serie di linee-guida correlate per affrontare prima una serie di problemi e rimandare il resto a dopo. Un’idea simile di “linee-guida correlate” diventa importante quando alcune delle linee-guida, ma non tutte, vengono considerate rilevanti per una base di codice o se una serie di linee-guida specializzate deve essere applicata ad un’area applicativa specializzata. Un tale insieme di linee-guida correlate definisce un “profilo”. Lo scopo di queste linee-guida di essere coerenti in modo che aiutino a raggiungere uno specifico obiettivo, come “assenza di errori sui limiti [range]” o “sicurezza dei tipi statici”. Ciascun profilo viene progettato per eliminare una classe di errori. L’imposizione di regole “casuali”, prese singolarmente, risulta più nocivo per il codice anziché un netto miglioramento.</p>
<p>Un “profilo” è un sotto-insieme di regole deterministiche e portabilmente imponibili (cioè restrizioni) progettate per ottenere una specifica garanzia. “Deterministico” significa che richiedono solo analisi locali e potrebbero essere implementate in un compilatore (sebbene non debbano per forza esserlo). “Portabilmente imponibili” significa che sono come le regole del linguaggio, quindi i programmatori possono contare su diversi strumenti applicativi che danno la stessa risposta per lo stesso codice.</p>
<p>Il codice scritto per essere privo di “warning” utilizzando uno di questi profili del linguaggio è considerato essere conforme a quel profilo. Il codice conforme è considerato essere sicuro per costituzione secondo le proprietà della sicurezza designate da quel profilo. Il codice conforme non sarà la causa principale di errori per quelle proprietà, sebbene questi errori possono essere introdotti in un programma da altro codice, librerie e dall’ambiente esterno. Un profilo può anche aggiungere ulteriori tipi di librerie per essere facilmente conformi e incoraggiare il codice corretto.</p>
<p>Riepilogo dei profili:</p>
<ul>
<li><a href="#SS-type">Pro.type: Sicurezza del tipo [Type safety]</a></li>
<li><a href="#SS-bounds">Pro.bounds: Sicurezza dei limiti [Bounds safety]</a></li>
<li><a href="#SS-lifetime">Pro.lifetime: Sicurezza del ciclo di vita [Lifetime safety]</a></li>
</ul>
<p>In futuro, si prevede di definire molti più profili e di aggiungere più controlli ai profili esistenti. Tra i candidati ci sono:</p>
<ul>
<li>[narrowing] aritmetico promozioni/conversioni (probabilmente come parte di un profilo separato su un’aritmetica sicura [safe-arithmetic])</li>
<li>cast aritmetici da virgola mobile negativi a interi senza segno (idem)</li>
<li>comportamento indefinito selezionato: Si parte con l’elenco UB di Gabriel Dos Reis, sviluppato per il gruppo di studio del WG21</li>
<li>comportamento indeterminato selezionato: Soluzione dei problemi di portabilità.</li>
<li>violazioni di <code>const</code>: Già eseguite per lo più dai compilatori, ma si possono intercettare i cast inappropriati e il sotto-utilizzo di <code>const</code>.</li>
</ul>
<p>L’abilitazione di un profilo è definita dall’implementazione; in genere, è impostato nello strumento di analisi utilizzato.</p>
<p>Per sopprimere l’applicazione di un controllo del profilo, inserire un’annotazione <code>suppress</code> in un contratto del linguaggio. Per esempio:</p>
<pre><code>[[suppress(bounds)]] char* raw_find(char* p, int n, char x)    // cerca x in p[0]..p[n - 1]
{
// ...
}</code></pre>
<p>Ora <code>raw_find()</code> può mischiare la memoria al suo contenuto interno. Ovviamente, la soppressione dovrebbe essere rarissima.</p>
<h2 id="pro.safety-profilo-type-safety"><a name="SS-type"></a>Pro.safety: Profilo [Type-safety]</h2>
<p>Questo profilo semplifica la scrittura di codice che utilizzi correttamente i tipi ed eviti la confusione accidentale dei tipi. Lo fa concentrandosi sulla rimozione delle fonti primarie delle violazioni sui tipi, inclusi gli usi non sicuri di cast e unioni.</p>
<p>Per questa sezione, la sicurezza del tipo è definita come la proprietà che una variabile non venga usata in un modo che non rispetti le regole del tipo della sua definizione. La memoria a cui si accede come ad un tipo <code>T</code> non deve essere una memoria valida che effettivamente contenga un oggetto di un tipo non correlato <code>U</code>. Si noti che la sicurezza deve essere completa se combinata anche con la <a href="#SS-bounds">[Bounds safety]</a> e la <a href="#SS-lifetime">[Lifetime safety]</a>.</p>
<p>Un’implementazione di questo profilo deve riconoscere i seguenti schemi nel codice sorgente come non conformi ed emettere una diagnostica.</p>
<p>Riepilogo del profilo sulla sicurezza dei tipi [type safety]:</p>
<ul>
<li><a name="Pro-type-avoidcasts"></a>Type.1: <a href="#Res-casts">Evitare i cast</a>: <a name="Pro-type-reinterpretcast">a. </a>Non usare <code>reinterpret_cast</code>; Una versione rigorosa di <a href="#Res-casts">Evitare i cast</a> e <a href="#Res-casts-named">preferire i “named cast”</a>. <a name="Pro-type-arithmeticcast">b. </a>Non usare <code>static_cast</code> per i tipi aritmetici; Una versione rigorosa di <a href="#Res-casts">Evitare i cast</a> e <a href="#Res-casts-named">preferire i “named cast”</a>. <a name="Pro-type-identitycast">c. </a>Non eseguire il cast tra tipi di puntatori in cui il tipo di origine e il tipo di destinazione sono uguali; Una versione rigorosa di <a href="#Res-casts">Evitare i cast</a>. <a name="Pro-type-implicitpointercast">d. </a>Non eseguire il cast tra i tipi di puntatore quando la conversione potrebbe essere implicita; Una versione rigorosa di <a href="#Res-casts">Evitare i cast</a>.</li>
<li><a name="Pro-type-downcast"></a>Type.2: Non usare <code>static_cast</code> per il [downcast]: <a href="#Rh-dynamic_cast">Usare, invece, <code>dynamic_cast</code></a>.</li>
<li><a name="Pro-type-constcast"></a>Type.3: Non usare <code>const_cast</code> per eliminare il <code>const</code> (cioè per niente): <a href="#Res-casts-const">Non eliminare const</a>.</li>
<li><a name="Pro-type-cstylecast"></a>Type.4: Non usare cast <code>(T)espressione</code> in stile C o il funzionale <code>T(espressione)</code>: Preferire la <a href="#Res-construct">costruzione</a> o i <a href="#Res-cast-named">[named cast]</a>.</li>
<li><a name="Pro-type-init"></a>Type.5: Non usare una variabile prima che sia stata inizializzata: <a href="#Res-always">inizializzare sempre</a>.</li>
<li><a name="Pro-type-memberinit"></a>Type.6: Inizializzare sempre una variabile membro: <a href="#Res-always">inizializzare sempre</a>, forse utilizzando i <a href="#Rc-default0">costruttori di default</a> o gli <a href="#Rc-in-class-initializers">gli inizializzatori membro di default</a>.</li>
<li><a name="Pro-type-unon"></a>Type.7: Evitare le semplici [naked] union: <a href="#Ru-naked">Usare, invece, <code>variant</code></a>.</li>
<li><a name="Pro-type-varargs"></a>Type.8: Evitare i vararg: <a href="#F-varargs">Non usare gli argomenti <code>va_arg</code></a>.</li>
</ul>
<h5 id="impatto">Impatto</h5>
<p>Col profilo “type-safety” si può essere sicuri che ogni operazione venga applicata ad un oggetto valido. È possibile generare un’eccezione per indicare errori che non possono essere rilevati staticamente (al momento della compilazione). Si noti che questo “type-safety” può essere completo solo se c’è anche il <a href="#SS-bounds">[Bounds safety]</a> e il <a href="#SS-lifetime">[Lifetime safety]</a>. Senza tali garanzie, è possibile accedere a una parte della memoria indipendentemente da quale oggetto, oggetti o parti di oggetti vi siano memorizzati.</p>
<h2 id="pro.bounds-profilo-bound-safety"><a name="SS-bounds"></a>Pro.bounds: Profilo [bound safety]</h2>
<p>Questo profilo semplifica la scrittura di codice che operi entro i limiti dei blocchi di memoria allocati. Lo fa concentrandosi sulla rimozione delle principali fonti di violazioni dei limiti: l’aritmetica del puntatore e l’indicizzazione degli array. Una delle caratteristiche principali di questo profilo è quella di limitare i puntatori a far riferimento solo a singoli oggetti, non ad array.</p>
<p>Si definisce la sicurezza dei limiti [bounds-safety] come la proprietà che un programma non utilizzi un oggetto per accedere alla memoria al di fuori dell’intervallo assegnato per l’oggetto stesso. La “bounds safety” è completa solo se combinata con <a href="#SS-type">Type safety</a> e <a href="#SS-lifetime">Lifetime safety</a>, che coprono altre operazioni non sicure che permettono delle violazioni dei limiti.</p>
<p>Riepilogo del profilo [bounds safety]:</p>
<ul>
<li><a name="Pro-bounds-arithmetic"></a>Bounds.1: Non usare l’aritmetica dei puntatori. Utilizzare, invece, <code>span</code>: <a href="#Ri-array">Passare puntatori (solo) a singoli oggetti</a> e <a href="#Res-ptr">Semplificare l’aritmetica dei puntatori</a>.</li>
<li><a name="Pro-bounds-arrayindex"></a>Bounds.2: Indicizzare gli array solo con espressioni costanti: <a href="#Ri-array">Passare puntatori (solo) a singoli oggetti</a> e <a href="#Res-ptr">Semplificare l’aritmetica dei puntatori</a>.</li>
<li><a name="Pro-bounds-decay"></a>Bounds.3: Nessun decadimento da-array-a-puntatore: <a href="#Ri-array">Passare puntatori (solo) a singoli oggetti</a> e <a href="#Res-ptr">Semplificare l’aritmetica dei puntatori</a>.</li>
<li><a name="Pro-bounds-stdlib"></a>Bounds.4: Non utilizzare funzioni e tipi della libreria standard che non siano [bounds-checked]: <a href="#Rsl-bounds">Usare la libreria standard in modo [type-safe]</a>.</li>
</ul>
<h5 id="impatto-1">Impatto</h5>
<p>La sicurezza dei limiti implica che l’accesso a un oggetto - soprattutto array - non acceda oltre la memoria allocata per l’oggetto. Questo elimina una grande categoria di errori insidiosi e difficili da trovare, inclusi i famosi (infami) errori di “buffer overflow”. Ciò chiude le falle nella sicurezza così come un’importante fonte di corruzione della memoria (quando si scrive oltre i limiti). Anche se un accesso oltre i limiti è “solo in lettura”, può portare a violazioni degli invarianti (quando ciò a cui si accede non del tipo previsto) e a “misteriosi valori”.</p>
<h2 id="pro.lifetime-profilo-sulla-sicurezza-del-ciclo-di-vita-lifetime"><a name="SS-lifetime"></a>Pro.lifetime: Profilo sulla sicurezza del ciclo-di-vita [lifetime]</h2>
<p>L’accesso tramite un puntatore che non punta a nulla è una delle principali fonti di errori, ed è molto difficile da evitare in molti stili di programmazione C e C++ tradizionali. Per esempio, un puntatore può essere non inizializzato, il <code>nullptr</code>, puntare oltre i limiti di un array o a un oggetto cancellato.</p>
<p><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetime.pdf">Vedere le attuali specifiche di progetto qui.</a></p>
<p>Riepilogo del profilo [lifetime safety]:</p>
<ul>
<li><a name="Pro-lifetime-invalid-deref"></a>Lifetime.1: Non de-referenziare un puntatore probabilmente non valido: <a href="#Res-deref">rilevare e evitare</a>.</li>
</ul>
<h5 id="impatto-2">Impatto</h5>
<p>Una volta imposto completamente attraverso una combinazione di regole di stile, analisi statica e supporto della libreria, questo profilo</p>
<ul>
<li>elimina una delle principali fonti di pessimi errori in C++</li>
<li>elimina un’importante fonte di potenziali violazioni della sicurezza</li>
<li>migliora le prestazioni eliminando i controlli ridondanti e “paranoici”</li>
<li>aumenta la fiducia nella correttezza del codice</li>
<li>evita comportamenti indefiniti imponendo una regola chiave del linguaggio C++</li>
</ul>
<h1 id="gsl-libreria-di-supporto-alle-linee-guida"><a name="S-gsl"></a>GSL: Libreria di supporto alle linee-guida</h1>
<p>La GSL è una piccola libreria di funzionalità progettate per supportare questo insieme di linee-guida. Senza queste funzionalità, le linee-guida dovrebbero essere molto più restrittive sui dettagli del linguaggio.</p>
<p>La libreria di supporto alle “Core Guidelines” è definita nel namespace <code>gsl</code> e i nomi possono essere alias per la libreria standard e di altri nomi ben noti di librerie. L’utilizzo (in fase di compilazione) del riferimento indiretto [indirection] tramite il namespace <code>gsl</code> consente la sperimentazione e varianti locali delle funzionalità di supporto.</p>
<p>La GSL è “header only”, e si può trovare in <a href="https://github.com/Microsoft/GSL">GSL: Guidelines support library</a>. Le funzionalità della libreria di supporto sono progettate per essere estremamente leggere ([zero-overhead]) in modo da non imporre alcun “overhead” rispetto alle normali alternative. Ove fosse desiderabile, possono essere “munite” di ulteriori funzionalità (p.es., dei controlli) per attività come il debug.</p>
<p>Queste “Guidelines” usano tipi dallo standard (p.es., C++17) altre a quelli dalla GSL. Per esempio, si ipotizza un tipo <code>variant</code>, ma questo non è attualmente nella GSL. Alla fine, si usa <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0088r3.html">quello proposto nel C++17</a>.</p>
<p>Alcuni dei tipi della GSL elencati in seguito potrebbero non essere supportati nella libreria utilizzata per motivi tecnici quali le limitazioni delle attuali versioni del C++. Pertanto, consultare la documentazione GSL per ulteriori informazioni.</p>
<p>Riepilogo dei componenti della GSL:</p>
<ul>
<li><a href="#SS-views">GSL.view: Viste [Views]</a></li>
<li><a href="#SS-ownership">GSL.owner</a></li>
<li><a href="#SS-assertions">GSL.assert: Assertions</a></li>
<li><a href="#SS-utilities">GSL.util: Utilities</a></li>
<li><a href="#SS-gsl-concepts">GSL.concept: Concepts</a></li>
</ul>
<p>È pianificata una specifica semi-formale delle GSL per un “ISO C++ standard style”.</p>
<p>Si fa affidamento sulla Libreria Standard C++ ISO e si spera che parti della GSL vengano assorbite nella libreria standard.</p>
<h2 id="gsl.view-viste-views"><a name="SS-views"></a>GSL.view: Viste [Views]</h2>
<p>Questi tipi consentono all’utente di distinguere tra puntatori proprietari e non proprietari e tra puntatori a un singolo oggetto e puntatori al primo elemento di una sequenza.</p>
<p>Queste “viste” non sono mai proprietarie.</p>
<p>I riferimenti non sono mai proprietari (cfr. <a href="#Rr-ref">R.4</a>. Nota: I riferimenti hanno molte opportunità di sopravvivere agli oggetti cui si riferiscono (restituendo una variabile locale per riferimento, mantenendo un riferimento ad un elemento di un vettore che ha subito un <code>push_back</code>, un [binding] a <code>std::max(x, y + 1)</code>, ecc. Il profilo “Lifetime safety” punta a risolvere tali problemi, ma anche così <code>owner&lt;T&amp;&gt;</code> non ha senso e se ne scoraggia l’uso.</p>
<p>I nomi sono principalmente nello stile della libreria standard ISO (minuscole e underscore):</p>
<ul>
<li><code>T*</code> // Il <code>T*</code> non è proprietario, può essere nullo; si presume che punti ad un singolo elemento.</li>
<li><code>T&amp;</code> // Il <code>T&amp;</code> non è proprietario e non può mai essere un “riferimento nullo”; i riferimenti sono sempre dimensionati [bound] agli oggetti.</li>
</ul>
<p>La notazione del “raw-pointer” (p.es. <code>int*</code>) si suppone che abbia il suo significato più comune; vale a dire, un puntatore punta ad un oggetto, ma non lo possiede. I proprietari devono essere convertiti in gestori [handle] delle risorse (p.es., <code>unique_ptr</code> o <code>vector&lt;T&gt;</code>) o contrassegnati come <code>owner&lt;T*&gt;</code>.</p>
<ul>
<li><code>owner&lt;T*&gt;</code> // un <code>T*</code> che possiede l’oggetto puntato/riferito; può essere <code>nullptr</code>.</li>
</ul>
<p><code>owner</code> è usato per contrassegnare i puntatori proprietari nel codice che non può essere aggiornato per utilizzare gli handle appropriati delle risorse. Tra i motivi ci sono:</p>
<ul>
<li>Costo della conversione.</li>
<li>Il puntatore è usato con un ABI.</li>
<li>Il puntatore è parte dell’implementazione di un gestore di risorsa.</li>
</ul>
<p>Un <code>owner&lt;T&gt;</code> differisce da un gestore di risorsa per una <code>T</code> ma richiede comunque un esplicito<code>delete</code>.</p>
<p>Un <code>owner&lt;T&gt;</code> si suppone faccia riferimento ad un oggetto nel “free store” (heap).</p>
<p>Se qualcosa si suppone che non possa esser <code>nullptr</code>, lo si affermi così:</p>
<ul>
<li><p><code>not_null&lt;T&gt;</code> // <code>T</code> è solitamente il tipo del puntatore (p.es., <code>not_null&lt;int*&gt;</code> o <code>not_null&lt;owner&lt;Foo*&gt;&gt;</code>) che non può essere <code>nullptr</code>. <code>T</code> può essere un qualunque tipo per cui ha senso <code>==nullptr</code>.</p></li>
<li><p><code>span&lt;T&gt;</code> // <code>[p:p+n)</code>, costruttore da <code>{p, q}</code> e <code>{p, n}</code>; <code>T</code> è il tipo del puntatore</p></li>
<li><p><code>span_p&lt;T&gt;</code> // <code>{p, predicate}</code> <code>[p:q)</code> dove <code>q</code> è il primo elemento per cui <code>predicate(*p)</code> è vero</p></li>
<li><p><code>string_span</code> // <code>span&lt;char&gt;</code></p></li>
<li><p><code>cstring_span</code> // <code>span&lt;const char&gt;</code></p></li>
</ul>
<p>Uno <code>span&lt;T&gt;</code> si riferisce a zero o più <code>T</code> mutabili a meno che <code>T</code> sia un tipo <code>const</code>.</p>
<p>“L’aritmetica del puntatore” viene fatta meglio negli <code>span</code>. Un <code>char*</code> che punta a più di un <code>char</code> ma non è una stringa “C-style” (p.es., un puntatore in un buffer di input) deve essere rappresentato da uno <code>span</code>.</p>
<ul>
<li><code>zstring</code> // un <code>char*</code> che si suppone essere una stringa “C-style”; ovvero, una sequenza di <code>char</code> “zero-terminated” o un <code>nullptr</code></li>
<li><code>czstring</code> // un <code>const char*</code> che si suppone essere una stringa “C-style”; ovvero, una sequenza di <code>const</code> <code>char</code> o un <code>nullptr</code></li>
</ul>
<p>Logicamente, questi ultimi due alias non sono necessari, ma non siamo sempre logici e rendono esplicita la distinzione tra un puntatore a un <code>char</code> e un esplicito puntatore a una stringa “C-style”. Una sequenza di caratteri che non si presume essere terminata con uno zero dovrebbe essere un <code>char*</code>, anziché una <code>zstring</code>. I caratteri accentati sono opzionali.</p>
<p>Usare <code>not_null&lt;zstring&gt;</code> per stringhe “C-style” che non possono essere <code>nullptr</code>. ??? C’è bisogno di un nome per <code>not_null&lt;zstring&gt;</code>? ola sua bruttezza è una caratteristica?</p>
<h2 id="gsl.owner-puntatori-proprietari"><a name="SS-ownership"></a>GSL.owner: Puntatori proprietari</h2>
<ul>
<li><code>unique_ptr&lt;T&gt;</code> // proprietà unica: <code>std::unique_ptr&lt;T&gt;</code></li>
<li><code>shared_ptr&lt;T&gt;</code> // proprietà condivisa: <code>std::shared_ptr&lt;T&gt;</code> (un puntamento conteggiato)</li>
<li><code>stack_array&lt;T&gt;</code> // Un array allocato sullo stack-allocated array. Il numero degli elementi viene determinato alla costruzione e successivamente fissato. Gli elementi sono mutabili a meno che <code>T</code> non sia un tipo <code>const</code>.</li>
<li><code>dyn_array&lt;T&gt;</code> // ??? necessario ??? Un array allocato sull’heap. Il numero degli elementi viene determinato alla costruzione e successivamente fissato. Gli elementi sono mutabili a meno che <code>T</code> non sia un tipo <code>const</code>. Fondamentalmente uno <code>span</code> che alloca e possiede i suoi elementi.</li>
</ul>
<h2 id="gsl.assert-assertions"><a name="SS-assertions"></a>GSL.assert: Assertions</h2>
<ul>
<li><code>Expects</code> // asserzione di precondizione. Attualmente posto nel corpo delle funzioni. In seguito, dovrebbe essere spostato nelle dichiarazioni. // <code>Expects(p)</code> termina il programma a meno che <code>p == true</code> // <code>Expect</code> è sotto il controllo di alcune opzioni (imposizione, messaggio di errore, alternative all’uscita del programma)</li>
<li><code>Ensures</code> // asserzione di post-condizione. Attualmente posto nel corpo delle funzioni. In seguito, dovrebbe essere spostato nelle dichiarazioni.</li>
</ul>
<p>Attualmente queste asserzioni sono macro (che schifo!) e devono apparire (solamente) nelle definizioni delle funzioni in attesa delle decisioni del comitato sullo standard a proposito della sintassi dei contratti e delle asserzioni. Si veda <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf">the contract proposal</a>; che usa la sintassi degli attributi, per esempio, <code>Expects(p)</code> diventerà <code>[[expects: p]]</code>.</p>
<h2 id="gsl.util-utilities"><a name="SS-utilities"></a>GSL.util: Utilities</h2>
<ul>
<li><code>finally</code> // <code>finally(f)</code> crea una <code>final_action{f}</code> con un distruttore che invoca <code>f</code></li>
<li><code>narrow_cast</code> // <code>narrow_cast&lt;T&gt;(x)</code> è <code>static_cast&lt;T&gt;(x)</code></li>
<li><code>narrow</code> // <code>narrow&lt;T&gt;(x)</code> è <code>static_cast&lt;T&gt;(x)</code> se <code>static_cast&lt;T&gt;(x) == x</code> o solleva [throw] l’errore<code>narrowing_error</code></li>
<li><code>[[implicit]]</code> // “Marker” da mettere sui costruttori ad argomento singolo per crearli espressamente non-espliciti.</li>
<li><code>move_owner</code> // <code>p = move_owner(q)</code> significa <code>p = q</code> ma ???</li>
<li><code>joining_thread</code> // una versione in stile RAII di <code>std::thread</code> che esegue il join.</li>
<li><code>index</code> // un tipo da usare per indicizzare tutti i contenitori e gli array (al momento un alias di <code>ptrdiff_t</code>)</li>
</ul>
<h2 id="gsl.concept-concetti"><a name="SS-gsl-concepts"></a>GSL.concept: Concetti</h2>
<p>Questi concetti (tipi predicati) sono presi in prestito da “Andrew Sutton’s Origin library, the Range proposal, and the ISO WG21 Palo Alto TR”. È probabile che siano molto simili a ciò che diventerà una parte dello standard C++ ISO. La notazione è quella della ISO WG21 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf">Concepts TS</a>. La maggior parte dei concetti seguenti sono definiti in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf">the Ranges TS</a>.</p>
<ul>
<li><code>Range</code></li>
<li><code>String</code> // ???</li>
<li><code>Number</code> // ???</li>
<li><code>Sortable</code></li>
<li><code>EqualityComparable</code> // ???Si deve subire il “CaMelcAse”???</li>
<li><code>Convertible</code></li>
<li><code>Common</code></li>
<li><code>Boolean</code></li>
<li><code>Integral</code></li>
<li><code>SignedIntegral</code></li>
<li><code>SemiRegular</code> // ??? Copiabile?</li>
<li><code>Regular</code></li>
<li><code>TotallyOrdered</code></li>
<li><code>Function</code></li>
<li><code>RegularFunction</code></li>
<li><code>Predicate</code></li>
<li><code>Relation</code></li>
<li>…</li>
</ul>
<h3 id="gsl.ptr-i-concetti-di-puntatori-smart-smart-pointer"><a name="SS-gsl-smartptrconcepts"></a>GSL.ptr: I concetti di puntatori smart [smart pointer]</h3>
<ul>
<li><code>Pointer</code> // Un tipo con <code>*</code>, <code>-&gt;</code>, <code>==</code>, e costruzione di default (la costruzione di default si suppone essere un insieme di singoli valori “null”)</li>
<li><code>Unique_pointer</code> // Un tipo che corrisponde a <code>Pointer</code>, si può spostare [movable] e non è copiabile</li>
<li><code>Shared_pointer</code> // Un tipo che corrisponde a <code>Pointer</code> ed è copiabile</li>
</ul>
<h1 id="nl-regole-di-nomenclatura-e-layout"><a name="S-naming"></a>NL: Regole di nomenclatura e layout</h1>
<p>Una nomenclatura e un layout coerenti sono utili. Se non altro perché riducono questioni come “il mio stile è migliore del tuo”. Tuttavia, ci sono molti, molti e diversi stili in giro e le persone vi sono affezionate (pro e contro). Inoltre, la maggior parte dei progetti del mondo reale include codice proveniente da molte fonti, quindi spesso è impossibile standardizzare un solo stile per tutto il codice. Dopo molte richieste di assistenza da parte di utenti, presentiamo una serie di regole che utilizzabili se non si ha di meglio, ma il vero obiettivo è la coerenza, piuttosto che una determinata serie di regole. Gli IDE e i tool possono aiutare (ma anche ostacolare).</p>
<p>Regole sulla nomenclatura e il layout:</p>
<ul>
<li><a href="#Rl-comments">NL.1: Non scrivere nei commenti ciò che è chiaramente affermato nel codice</a></li>
<li><a href="#Rl-comments-intent">NL.2: Nei commenti dichiarare le intenzioni</a></li>
<li><a href="#Rl-comments-crisp">NL.3: Rendere i commenti all’essenziale</a></li>
<li><a href="#Rl-indent">NL.4: Mantenere uno stile coerente di indentazione</a></li>
<li><a href="#Rl-name-type">NL.5: Evitare di codificare il tipo nei nomi</a></li>
<li><a href="#Rl-name-length">NL.7: La lunghezza del nome deve essere proporzionale all’ampiezza del suo scope</a></li>
<li><a href="#Rl-name">NL.8: Usare uno stile coerente per i nomi</a></li>
<li><a href="#Rl-all-caps">NL.9: Usare il <code>TUTTO_IN_MAIUSCOLO</code> solo per i nomi delle macro</a></li>
<li><a href="#Rl-camel">NL.10: Preferire i nomi in “<code>underscore_style</code>”</a></li>
<li><a href="#Rl-literals">NL.11: Rendere leggibili i letterali</a></li>
<li><a href="#Rl-space">NL.15: Usare gli spazi con parsimonia</a></li>
<li><a href="#Rl-order">NL.16: Usare un ordine convenzionale per la dichiarazione dei membri di una classe</a></li>
<li><a href="#Rl-knr">NL.17: Usare il layout derivato dal K&amp;R</a></li>
<li><a href="#Rl-ptr">NL.18: Usare il layout dei dichiaratori in stile C++</a></li>
<li><a href="#Rl-misread">NL.19: Evitare nomi facilmente travisabili</a></li>
<li><a href="#Rl-stmt">NL.20: Non mettere due istruzioni sulla stessa riga</a></li>
<li><a href="#Rl-dcl">NL.21: Dichiarare un (solo) nome per ogni dichiarazione</a></li>
<li><a href="#Rl-void">NL.25: Non usare <code>void</code> come tipo di un argomento</a></li>
<li><a href="#Rl-const">NL.26: Usare la notazione convenzionale <code>const</code></a></li>
</ul>
<p>La maggior parte di queste regole sono estetiche e i programmatori hanno forti opinioni. Gli IDE tendono inoltre ad avere impostazioni predefinite e una gamma di alternative. Queste regole imposte di default a meno che non si abbiano motivi per fare diversamente.</p>
<p>Abbiamo osservato che la nomenclatura e il layout sono così personali e/o arbitrari che non si dovrebbe cercare di “legiferare” su di essi. Non si sta “legiferando” (si veda il paragrafo precedente). Tuttavia, ci sono state molte richieste per un insieme di convenzioni per la nomenclatura e il layout da utilizzare quando non ci sono vincoli esterni.</p>
<p>Le regole più specifiche e dettagliate sono più facili da applicare.</p>
<p>Queste regole somigliano fortemente alle raccomandazioni nella <a href="http://www.stroustrup.com/Programming/PPP-style.pdf">PPP Style Guide</a> scritta a supporto di <a href="http://www.stroustrup.com/programming.html">Programming: Principles and Practice using C++</a> di Stroustrup.</p>
<h3 id="nl.1-non-scrivere-nei-commenti-ciò-che-è-chiaramente-affermato-nel-codice"><a name="Rl-comments"></a>NL.1: Non scrivere nei commenti ciò che è chiaramente affermato nel codice</h3>
<h5 id="motivo-433">Motivo</h5>
<p>I compilatori non leggono i commenti. I commenti sono meno precisi del codice. I commenti vengono aggiornati quando si modifica il codice.</p>
<h5 id="esempio-cattivo-143">Esempio, cattivo</h5>
<pre><code>auto x = m * v1 + vv;   // moltiplica m con v1 e aggiunge vv al risultato</code></pre>
<h5 id="imposizione-389">Imposizione</h5>
<p>Creare un programma di AI che interpreti il testo umano e verifichi se ciò che si è detto si potrebbe esprimere meglio in C++.</p>
<h3 id="nl.2-nei-commenti-dichiarare-le-intenzioni"><a name="Rl-comments-intent"></a>NL.2: Nei commenti dichiarare le intenzioni</h3>
<h5 id="motivo-434">Motivo</h5>
<p>Il codice dice ciò che viene fatto non ciò che si vorrebbe fosse fatto. Spesso l’intenzione può essere espressa in modo più chiaro e conciso dell’implementazione.</p>
<h5 id="esempio-377">Esempio</h5>
<pre><code>void stable_sort(Sortable&amp; c)
// ordina c secondo quanto determinato da &lt;, tiene gli elementi uguali (definiti da  ==) nel
// loro ordine relativo originale
{
// ... qualche riga di codice non semplicissime ...
}</code></pre>
<h5 id="note-370">Note</h5>
<p>Se il commento e il codice non coincidono, è probabile che siano entrambi sbagliati.</p>
<h3 id="nl.3-rendere-i-commenti-allessenziale"><a name="Rl-comments-crisp"></a>NL.3: Rendere i commenti all’essenziale</h3>
<h5 id="motivo-435">Motivo</h5>
<p>La verbosità rallenta la comprensione e rende il codice più difficile da leggere sparpagliandolo nel file di origine.</p>
<h5 id="note-371">Note</h5>
<p>Usare un inglese chiaro. Si potrebbe scrivere un ottimo danese, ma molti programmatori non lo capirebbero; i manutentori del codice potrebbero non essere danesi. Evitare il gergo degli SMS e porre attenzione alla grammatica, la punteggiature e le maiuscole. Si punti alla professionalità, non ad essere alla “moda”.</p>
<h5 id="imposizione-390">Imposizione</h5>
<p>non possibile.</p>
<h3 id="nl.4-mantenere-uno-stile-coerente-di-indentazione"><a name="Rl-indent"></a>NL.4: Mantenere uno stile coerente di indentazione</h3>
<h5 id="motivo-436">Motivo</h5>
<p>Leggibilità. Evitare “errori stupidi”.</p>
<h5 id="esempio-cattivo-144">Esempio, cattivo</h5>
<pre><code>int i;
for (i = 0; i &lt; max; ++i); // bug in attesa che succeda
if (i == j)
return i;</code></pre>
<h5 id="note-372">Note</h5>
<p>Solitamente è una buona idea indentare sempre l’istruzione dopo <code>if (...)</code>, <code>for (...)</code>, e <code>while (...)</code>:</p>
<pre><code>if (i &lt; 0) error(&quot;negative argument&quot;);

if (i &lt; 0)
error(&quot;negative argument&quot;);</code></pre>
<h5 id="imposizione-391">Imposizione</h5>
<p>Usare un tool.</p>
<h3 id="nl.5-evitare-di-codificare-il-tipo-nei-nomi"><a name="Rl-name-type"></a>NL.5: Evitare di codificare il tipo nei nomi</h3>
<h5 id="motivazione">Motivazione</h5>
<p>Se i nomi rispecchiano i tipi anziché le funzionalità, diventa difficile cambiare i tipi utilizzati per fornire quella funzionalità. Inoltre, se il tipo di una variabile viene modificato, anche il codice che lo utilizza dovrà essere modificato. Ridurre al minimo le conversioni involontarie.</p>
<h5 id="esempio-cattivo-145">Esempio, cattivo</h5>
<pre><code>void print_int(int i);
void print_string(const char*);

print_int(1);          // ripetitivo, corrispondenza manuale del tipo
print_string(&quot;xyzzy&quot;); // ripetitivo, corrispondenza manuale del tipo</code></pre>
<h5 id="esempio-buono-25">Esempio, buono</h5>
<pre><code>void print(int i);
void print(string_view);    // funziona anche con qualsiasi sequenza simile a una stringa

print(1);              // chiaro, corrispondenza automatica del tipo
print(&quot;xyzzy&quot;);        // chiaro, corrispondenza automatica del tipo</code></pre>
<h5 id="note-373">Note</h5>
<p>I nomi con i tipi codificati sono prolissi e criptici.</p>
<pre><code>printS  // scrive una std::string
prints  // scrive una stringa C-style
printi  // scrive un int</code></pre>
<p>L’esigenza di tecniche come la notazione ungherese per codificare un tipo è stata necessaria nei linguaggi non tipizzati, ma risulta generalmente inutile e molto dannosa in un linguaggio fortemente tipizzato come il C++, perché le annotazioni non vengono aggiornate (i commenti sono come le verruche: marciscono) e interferiscono con il buon uso del linguaggio (utilizzare, invece, lo stesso nome e risolvere con l’[overload]).</p>
<h5 id="note-374">Note</h5>
<p>Certi stili usano prefissi molto generali (non specifici del tipo) per denotare l’uso generale di una variabile.</p>
<pre><code>auto p = new User();
auto p = make_unique&lt;User&gt;();
// nota: &quot;p&quot; non viene utilizzato per dire &quot;semplice puntatore al tipo User,&quot;
//       solo per dire genericamente &quot;questa è una indirezione&quot;

auto cntHits = calc_total_of_hits(/*...*/);
// nota: &quot;cnt&quot; non viene utilizzato per codificare un tipo,
//       solo per dire genericamente &quot;questo è l conteggio di qualcosa&quot;</code></pre>
<p>Ciò non è dannoso e non rientra in questa linea-guida poiché non codifica il tipo.</p>
<h5 id="note-375">Note</h5>
<p>Certi stili distinguono tra variabili membro, locali e globali.</p>
<pre><code>struct S {
int m_;
S(int m) :m_{abs(m)} { }
};</code></pre>
<p>Ciò non è dannoso e non rientra in questa linea-guida poiché non codifica il tipo.</p>
<h5 id="note-376">Note</h5>
<p>Come il C++, alcuni stili fanno distinzione tra i tipi e i non tipi. Per esempio, mettendo in maiuscolo i nomi dei tipi ma non i nomi delle funzioni e delle variabili.</p>
<pre><code>typename&lt;typename T&gt;
class HashTable {   // mappa la stringa su T
// ...
};

HashTable&lt;int&gt; index;</code></pre>
<p>Ciò non è dannoso e non rientra in questa linea-guida poiché non codifica il tipo.</p>
<h3 id="nl.7-la-lunghezza-del-nome-deve-essere-proporzionale-allampiezza-del-suo-scope"><a name="Rl-name-length"></a>NL.7: La lunghezza del nome deve essere proporzionale all’ampiezza del suo scope</h3>
<p><strong>Motivazione</strong>: Più grande è lo scope maggiori è la possibilità di confusione o di un conflitto involontario dei nomi.</p>
<h5 id="esempio-378">Esempio</h5>
<pre><code>double sqrt(double x);   // ritorna la radice quadrata di x; x deve essere non-negativo

int length(const char* p);  // ritorna il numero di caratteri in una stringa in stile C [zero-terminated]

int length_of_string(const char zero_terminated_array_of_char[])    // bad: prolisso

int g;      // bad: variabile globale con un nome criptico

int open;   // bad: variabile globale con un nome corto e troppo comune</code></pre>
<p>Usare <code>p</code> per un puntatore e <code>x</code> per una variabile in virgola mobile è una convenzione e non confonde in uno scope limitato.</p>
<h5 id="imposizione-392">Imposizione</h5>
<p>???</p>
<h3 id="nl.8-usare-uno-stile-coerente-per-i-nomi"><a name="Rl-name"></a>NL.8: Usare uno stile coerente per i nomi</h3>
<p><strong>Motivazione</strong>: La coerenza e lo stile della nomenclatura aumentano la leggibilità.</p>
<h5 id="note-377">Note</h5>
<p>Esistono molti stili e quando si utilizzano più librerie, non è possibile seguire tutte le diverse convenzioni. Scegliere uno “stile proprio”, ma lasciare le librerie “importate” col loro stile originale.</p>
<h5 id="esempio-379">Esempio</h5>
<p>Lo standard ISO, usa solo minuscole e numeri, le parole sono separate con gli [underscore]:</p>
<ul>
<li><code>int</code></li>
<li><code>vector</code></li>
<li><code>my_map</code></li>
</ul>
<p>Evitare i doppi [underscore] <code>__</code>.</p>
<h5 id="esempio-380">Esempio</h5>
<p><a href="http://www.stroustrup.com/Programming/PPP-style.pdf">Stroustrup</a>: Lo Standard ISO, ma con le maiuscole usate per i propri tipi e i propri concetti:</p>
<ul>
<li><code>int</code></li>
<li><code>vector</code></li>
<li><code>My_map</code></li>
</ul>
<h5 id="esempio-381">Esempio</h5>
<p>CamelCase: mette in maiuscolo l’iniziale di ogni parola in un identificatore multi-parole:</p>
<ul>
<li><code>int</code></li>
<li><code>vector</code></li>
<li><code>MyMap</code></li>
<li><code>myMap</code></li>
</ul>
<p>Alcune convenzioni mettono in maiuscolo la prima lettera, altre non lo fanno.</p>
<h5 id="note-378">Note</h5>
<p>Cercare di essere coerenti con l’uso di acronimi e sulle lunghezze degli identificatori:</p>
<pre><code>int mtbf {12};
int mean_time_between_failures {12}; // si valuti</code></pre>
<h5 id="imposizione-393">Imposizione</h5>
<p>Sarebbe possibile eccetto che per l’uso di librerie con diverse convenzioni.</p>
<h3 id="nl.9-usare-il-tutto_in_maiuscolo-solo-per-i-nomi-delle-macro"><a name="Rl-all-caps"></a>NL.9: Usare il <code>TUTTO_IN_MAIUSCOLO</code> solo per i nomi delle macro</h3>
<h5 id="motivo-437">Motivo</h5>
<p>Per evitare di confondere le macro con nomi che obbediscono alle regole sullo scope e sul tipo.</p>
<h5 id="esempio-382">Esempio</h5>
<pre><code>void f()
{
const int SIZE{1000};  // Bad, usare &#39;size&#39;, invece
int v[SIZE];
}</code></pre>
<h5 id="note-379">Note</h5>
<p>Questa regola si applica alle costanti simboliche non-macro:</p>
<pre><code>enum bad { BAD, WORSE, HORRIBLE }; // BAD</code></pre>
<h5 id="imposizione-394">Imposizione</h5>
<ul>
<li>Segnalare le macro con lettere minuscole</li>
<li>Segnalare le non-macro <code>TUTTE_IN_MAIUSCOLO</code></li>
</ul>
<h3 id="nl.10-preferire-i-nomi-in-underscore_style"><a name="Rl-camel"></a>NL.10: Preferire i nomi in “<code>underscore_style</code>”</h3>
<h5 id="motivo-438">Motivo</h5>
<p>L’utilizzo degli underscore per separare le parti dei nomi è lo stile originale del C e del C++ ed è usato nella Libreria Standard del C++.</p>
<h5 id="note-380">Note</h5>
<p>Questa è regola è un default valido solo se si può scegliere. Spesso, non si può scegliere e si deve seguire, per <a href="#Rl-name">coerenza</a>, uno stile prestabilito. La necessità di coerenza batte il gusto personale.</p>
<p>Questa è una raccomandazione per <a href="#S-naming">quando non si hanno vincoli o idee migliori</a>. Questa regola è stata aggiunta dopo molte richieste di regolamentazione.</p>
<h5 id="esempio-383">Esempio</h5>
<p><a href="http://www.stroustrup.com/Programming/PPP-style.pdf">Stroustrup</a>: Lo Standard ISO, ma con le maiuscole usate per i propri tipi e i propri concetti:</p>
<ul>
<li><code>int</code></li>
<li><code>vector</code></li>
<li><code>My_map</code></li>
</ul>
<h5 id="imposizione-395">Imposizione</h5>
<p>Impossibile.</p>
<h3 id="nl.15-usare-gli-spazi-con-parsimonia"><a name="Rl-space"></a>NL.15: Usare gli spazi con parsimonia</h3>
<h5 id="motivo-439">Motivo</h5>
<p>Troppi spazi ingrossano il testo e distraggono.</p>
<h5 id="esempio-cattivo-146">Esempio, cattivo</h5>
<pre><code>#include &lt; map &gt;

int main(int argc, char * argv [ ])
{
// ...
}</code></pre>
<h5 id="esempio-384">Esempio</h5>
<pre><code>#include &lt;map&gt;

int main(int argc, char* argv[])
{
// ...
}</code></pre>
<h5 id="note-381">Note</h5>
<p>Alcuni IDE hanno le proprie opinioni e aggiungono spazi inopportuni.</p>
<p>Questa è una raccomandazione per <a href="#S-naming">quando non si hanno vincoli o idee migliori</a>. Questa regola è stata aggiunta dopo molte richieste di regolamentazione.</p>
<h5 id="note-382">Note</h5>
<p>Sono ben accetti gli spazi ben posizionati come un aiuto significativo alla leggibilità. Non esagerare.</p>
<h3 id="nl.11-rendere-leggibili-i-letterali"><a name="Rl-literals"></a>NL.11: Rendere leggibili i letterali</h3>
<h5 id="motivo-440">Motivo</h5>
<p>Leggibilità.</p>
<h5 id="esempio-385">Esempio</h5>
<p>Usare i separatori dei decimali per evitare lunghe stringhe di numeri</p>
<pre><code>auto c = 299&#39;792&#39;458; // m/s2
auto q2 = 0b0000&#39;1111&#39;0000&#39;0000;
auto ss_number = 123&#39;456&#39;7890;</code></pre>
<h5 id="esempio-386">Esempio</h5>
<p>Usare suffissi letterali dove è necessario chiarire</p>
<pre><code>auto hello = &quot;Hello!&quot;s; // una std::string
auto world = &quot;world&quot;;   // una stringa C-style
auto interval = 100ms;  // usando &lt;chrono&gt;</code></pre>
<h5 id="note-383">Note</h5>
<p>I letterali non devono essere sparpagliati per tutto il codice come <a href="#Res-magic">“costanti magiche”</a>, ma è comunque una buona idea renderli leggibili dove sono definiti. È facile sbagliare con una lunga stringa di interi.</p>
<h5 id="imposizione-396">Imposizione</h5>
<p>Segnalare le lunghe sequenze di cifre. Il problema è definire “lunghe”; forse 7.</p>
<h3 id="nl.16-usare-un-ordine-convenzionale-per-la-dichiarazione-dei-membri-di-una-classe"><a name="Rl-order"></a>NL.16: Usare un ordine convenzionale per la dichiarazione dei membri di una classe</h3>
<h5 id="motivo-441">Motivo</h5>
<p>Un ordine convenzionale dei membri migliora la leggibilità.</p>
<p>Quando si dichiara una classe, utilizzare il seguente ordine</p>
<ul>
<li>tipi: classi, enum e alias (<code>using</code>)</li>
<li>costruttori, assegnazioni, distruttori</li>
<li>funzioni</li>
<li>dati</li>
</ul>
<p>Usare <code>public</code> prima di <code>protected</code> prima di <code>private</code>.</p>
<p>Questa è una raccomandazione per <a href="#S-naming">quando non si hanno vincoli o idee migliori</a>. Questa regola è stata aggiunta dopo molte richieste di regolamentazione.</p>
<h5 id="esempio-387">Esempio</h5>
<pre><code>class X {
public:
// interfaccia
protected:
// funzione [unchecked] usata dalle implementazioni di classi derivate
private:
// dettagli implementativi
};</code></pre>
<h5 id="esempio-388">Esempio</h5>
<p>A volte, l’ordine di default dei membri va in conflitto col desiderio di separare l’interfaccia pubblica dai dettagli implementativi. In questi casi, i tipi e le funzioni private si possono inserire con dati privati.</p>
<pre><code>class X {
public:
// interfaccia
protected:
// funzione [unchecked] usata dalle implementazioni di classi derivate
private:
// dettagli implementativi (tipi, funzioni e dati)
};</code></pre>
<h5 id="esempio-cattivo-147">Esempio, cattivo</h5>
<p>Evitare blocchi multipli di dichiarazioni di un tipo accesso (p.es., <code>public</code>) sparpagliati tra i blocchi di dichiarazioni con accessi diversi (p.es. <code>private</code>).</p>
<pre><code>class X {   // bad
public:
void f();
public:
int g();
// ...
};</code></pre>
<p>L’utilizzo di macro per dichiarare gruppi di membri spesso porta alla violazione di eventuali regole di ordinamento. Tuttavia, le macro nascondono comunque ciò che viene espresso.</p>
<h5 id="imposizione-397">Imposizione</h5>
<p>Segnalare le discrepanze dall’ordinamento suggerito. Ci sarà un sacco di vecchio codice che non segue questa regola.</p>
<h3 id="nl.17-usare-il-layout-derivato-dal-kr"><a name="Rl-knr"></a>NL.17: Usare il layout derivato dal K&amp;R</h3>
<h5 id="motivo-442">Motivo</h5>
<p>Questo è il layout originale del C e del C++. Conserva bene la spaziatura verticale. Distingue bene i diversi costrutti del linguaggio (come le funzioni e le classi).</p>
<h5 id="note-384">Note</h5>
<p>Nel contesto del C++, questo stile viene spesso chiamato “Stroustrup”.</p>
<p>Questa è una raccomandazione per <a href="#S-naming">quando non si hanno vincoli o idee migliori</a>. Questa regola è stata aggiunta dopo molte richieste di regolamentazione.</p>
<h5 id="esempio-389">Esempio</h5>
<pre><code>struct Cable {
int x;
// ...
};

double foo(int x)
{
if (0 &lt; x) {
// ...
}

switch (x) {
case 0:
// ...
break;
case amazing:
// ...
break;
default:
// ...
break;
}

if (0 &lt; x)
++x;

if (x &lt; 0)
something();
else
something_else();

return some_value;
}</code></pre>
<p>Si noti lo spazio tra l’<code>if</code> e la <code>(</code></p>
<h5 id="note-385">Note</h5>
<p>Usare righe diverse per ciascuna istruzione, le graffe di un <code>if</code>, e il body di un <code>for</code>.</p>
<h5 id="note-386">Note</h5>
<p>La <code>{</code> di una <code>class</code>e o di una <code>struct</code>, <em>non</em> sta su una riga a sé, ma la <code>{</code> per una funzione, sì.</p>
<h5 id="note-387">Note</h5>
<p>Iniziali in maiuscolo per i nomi dei tipi [user-defined] per distinguerli dai tipi della libreria standard.</p>
<h5 id="note-388">Note</h5>
<p>Non mettere le iniziali delle funzioni in maiuscolo.</p>
<h5 id="imposizione-398">Imposizione</h5>
<p>Se si desidera un’imposizione, si usi un IDE per riformattare.</p>
<h3 id="nl.18-usare-il-layout-dei-dichiaratori-in-stile-c"><a name="Rl-ptr"></a>NL.18: Usare il layout dei dichiaratori in stile C++</h3>
<h5 id="motivo-443">Motivo</h5>
<p>Il layout in stile C enfatizza l’uso in espressioni e grammatica, mentre quello in stile C++ porta l’attenzione sui tipi. L’uso negli argomenti delle espressioni non vale per i riferimenti.</p>
<h5 id="esempio-390">Esempio</h5>
<pre><code>T&amp; operator[](size_t);   // OK
T &amp;operator[](size_t);   // sembra strano
T &amp; operator[](size_t);   // indeciso</code></pre>
<h5 id="note-389">Note</h5>
<p>Questa è una raccomandazione per <a href="#S-naming">quando non si hanno vincoli o idee migliori</a>. Questa regola è stata aggiunta dopo molte richieste di regolamentazione.</p>
<h5 id="imposizione-399">Imposizione</h5>
<p>Impossibile di fronte alla storia.</p>
<h3 id="nl.19-evitare-nomi-facilmente-travisabili"><a name="Rl-misread"></a>NL.19: Evitare nomi facilmente travisabili</h3>
<h5 id="motivo-444">Motivo</h5>
<p>Leggibilità. Non tutti hanno schermi e stampanti che rendono facile distinguere tutti i caratteri. Si confondono facilmente le parole scritte in modo simile e leggermente errate.</p>
<h5 id="esempio-391">Esempio</h5>
<pre><code>int oO01lL = 6; // bad

int splunk = 7;
int splonk = 8; // bad: splunk e splonk si confondono facilmente</code></pre>
<h5 id="imposizione-400">Imposizione</h5>
<p>???</p>
<h3 id="nl.20-non-mettere-due-istruzioni-sulla-stessa-riga"><a name="Rl-stmt"></a>NL.20: Non mettere due istruzioni sulla stessa riga</h3>
<h5 id="motivo-445">Motivo</h5>
<p>Leggibilità. È davvero facile non vedere un’istruzione quando ce ne sono diverse in una riga.</p>
<h5 id="esempio-392">Esempio</h5>
<pre><code>int x = 7; char* p = 29;    // da non fare
int x = 7; f(x);  ++x;      // da non fare</code></pre>
<h5 id="imposizione-401">Imposizione</h5>
<p>Facile.</p>
<h3 id="nl.21-dichiarare-un-solo-nome-per-ogni-dichiarazione"><a name="Rl-dcl"></a>NL.21: Dichiarare un (solo) nome per ogni dichiarazione</h3>
<h5 id="motivo-446">Motivo</h5>
<p>Leggibilità. Ridurre al minimo la confusione con la sintassi del dichiaratore.</p>
<h5 id="note-390">Note</h5>
<p>Per i dettagli si veda <a href="#Res-name-one">ES.10</a>.</p>
<h3 id="nl.25-non-usare-void-come-tipo-di-un-argomento"><a name="Rl-void"></a>NL.25: Non usare <code>void</code> come tipo di un argomento</h3>
<h5 id="motivo-447">Motivo</h5>
<p>È prolisso ed è necessario solo dove conta la compatibilità col C..</p>
<h5 id="esempio-393">Esempio</h5>
<pre><code>void f(void);   // male

void g();       // meglio</code></pre>
<h5 id="note-391">Note</h5>
<p>Anche Dennis Ritchie ritenne che <code>void f(void)</code> fosse un abominio. Si poteva giustificare questo abominio in C quando i prototipi delle funzioni erano rari quindi vietare questo:</p>
<pre><code>int f();
f(1, 2, &quot;strano ma valido nel C89&quot;);   // da sperare che f() sia definita int f(a, b, c) char* c; { /* ... */ }</code></pre>
<p>avrebbe causato problemi maggiori, ma non nel 21° secolo e in C++.</p>
<h3 id="nl.26-usare-la-notazione-convenzionale-const"><a name="Rl-const"></a>NL.26: Usare la notazione convenzionale <code>const</code></h3>
<h5 id="motivo-448">Motivo</h5>
<p>La notazione convenzionale è più familiare a molti programmatori.. Coerenza in tantissimo codice esistente.</p>
<h5 id="esempio-394">Esempio</h5>
<pre><code>const int x = 7;    // OK
int const y = 9;    // bad

const int *const p = nullptr;   // OK, da puntatore costante a int costante
int const *const p = nullptr;   // bad, da puntatore costante a int costante</code></pre>
<h5 id="note-392">Note</h5>
<p>Sappiamo bene che si potrebbero portare esempi “cattivi” più logici di quelli contrassegnati con “OK”, ma questi confondono più gente, specialmente i principianti che si affidano al materiale didattico fatto con uno stile OK molto più comune e convenzionale.</p>
<p>Come sempre, si ricordi che l’obiettivo di queste regole di denominazione e layout è la coerenza e che l’estetica varia enormemente.</p>
<p>Questa è una raccomandazione per <a href="#S-naming">quando non si hanno vincoli o idee migliori</a>. Questa regola è stata aggiunta dopo molte richieste di regolamentazione.</p>
<h5 id="imposizione-402">Imposizione</h5>
<p>Segnalare l’utilizzo di <code>const</code> come suffisso di un tipo.</p>
<h1 id="faq-risposte-a-domande-frequenti"><a name="S-faq"></a>FAQ: Risposte a domande frequenti</h1>
<p>Questa sezione risponde alle domande più frequenti su queste linee-guida.</p>
<h3 id="faq.1-quali-sono-gli-obiettivi-di-queste-linee-guida"><a name="Faq-aims"></a>FAQ.1: Quali sono gli obiettivi di queste linee-guida?</h3>
<p>Cfr. <a href="#S-abstract">inizio pagina</a>. Questo è un progetto open source per manutenere delle linee-guida moderne e autorevoli per la scrittura di codice C++ con l’attuale C++ Standard (al momento il C++14). Le linee-guida sono progettate per essere moderne, applicabili alle macchine quando possibile e aperte a contributi e ai “fork” in modo che le organizzazioni possano facilmente incorporarle tra le proprie linee-guida aziendali di codifica.</p>
<h3 id="faq.2-quando-e-dove-è-stato-annunciato-questo-lavoro-per-la-prima-volta"><a name="Faq-announced"></a>FAQ.2: Quando e dove è stato annunciato questo lavoro per la prima volta?</h3>
<p>Fu annunciato da <a href="https://isocpp.org/blog/2015/09/stroustrup-cppcon15-keynote">Bjarne Stroustrup nel suo discorso di apertura del CppCon 2015, “Writing Good C++14”</a>. Si veda anche <a href="https://isocpp.org/blog/2015/09/bjarne-stroustrup-announces-cpp-core-guidelines">il post del bloa isocpp.org allegato</a>, e per la motivazione del tipo e le linee-guida sulla sicureza della memoria, si veda <a href="https://isocpp.org/blog/2015/09/sutter-cppcon15-day2plenary">l’intervento di Herb Sutter al CppCon 2015, “Writing Good C++14 … By Default”</a>.</p>
<h3 id="faq.3-chi-sono-gli-autori-e-i-manutentori-di-queste-linee-guida"><a name="Faq-maintainers"></a>FAQ.3: Chi sono gli autori e i manutentori di queste linee-guida?</h3>
<p>Gli autori e manutentori iniziali sono Bjarne Stroustrup e Herb Sutter e le linee-guida finora sono state sviluppate col contributo di esperti del CERN, di Microsoft, di Morgan Stanley e di diverse altre organizzazioni. Al momento del loro rilascio, le linee-guida sono in uno stato “0.6” e i contributi sono ben accetti. Come ha detto Stroustrup nel suo annuncio: “Abbiamo bisogno di aiuto!”</p>
<h3 id="faq.4-come-si-può-contribuire"><a name="Faq-contribute"></a>FAQ.4: Come si può contribuire?</h3>
<p>Si legga <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a>. Si apprezza l’aiuto volontario!</p>
<h3 id="faq.5-come-si-diventa-editoremanutentore"><a name="Faq-maintainer"></a>FAQ.5: Come si diventa editore/manutentore?</h3>
<p>Innanzitutto contribuendo tantissimo e col riconoscimento della coerente qualità dei propri contributi. Si legga <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a>. Si apprezza l’aiuto volontario!</p>
<h3 id="faq.6-queste-linee-guida-sono-state-approvate-dal-comitato-si-standardizzazione-iso-c-hanno-il-consenso-del-comitato"><a name="Faq-iso"></a>FAQ.6: Queste linee guida sono state approvate dal comitato si standardizzazione ISO C++? Hanno il consenso del comitato?</h3>
<p>No. Queste linee-guida sono al di fuori dello standard. Esse hanno lo scopo di servire lo standard ed essere mantenute come linee-guida correnti su come utilizzare efficacemente il C++ Standard. L’obiettivo è quello di mantenerle in sintonia con lo standard man mano che il comitato lo evolve.</p>
<h3 id="faq.7-se-queste-linee-guida-non-sono-approvate-dal-comitato-perché-stanno-in-github.comisocpp"><a name="Faq-isocpp"></a>FAQ.7: Se queste linee guida non sono approvate dal comitato, perché stanno in <code>github.com/isocpp</code>?</h3>
<p>Perché <code>isocpp</code> è lo “Standard C++ Foundation”; i repository del comitato stanno sotto <a href="https://github.com/cplusplus">github.com/<em>cplusplus</em></a>. Alcune organizzazioni neutrali devono possedere il copyright e la licenza per chiarire che questo non è dominato da nessuna persona o fornitore. L’ente naturale è la Fondazione, che esiste per promuovere l’uso e la comprensione aggiornata del C++ Standard moderno e il lavoro del comitato. Questo segue lo stesso schema che isocpp.org ha fatto per le <a href="https://isocpp.org/faq">C++ FAQ</a>, che iniziarono col lavoro di Bjarne Stroustrup, Marshall Cline, e Herb Sutter e che hanno contribuito allo stesso progetto ‘open’.</p>
<h3 id="faq.8-ci-sarà-una-versione-per-il-c98-di-queste-linee-guida-una-versione-per-il-c11"><a name="Faq-cpp98"></a>FAQ.8: Ci sarà una versione per il C++98 di queste Linee-guida? una versione per il C++11?</h3>
<p>No. Queste linee guida spiegano come utilizzare al meglio il C++14 Standard (e, se se ne ha un’implementazione, le Specifiche Tecniche dei Concetti) e scrivere il codice presupponendo che si disponga di un moderno compilatore conforme.</p>
<h3 id="faq.9-queste-linee-guida-propongono-nuove-funzionalità-del-linguaggio"><a name="Faq-language-extensions"></a>FAQ.9: Queste linee guida propongono nuove funzionalità del linguaggio?</h3>
<p>No. Queste linee guida spiegano come utilizzare al meglio il C++14 Standard + le “Concepts Technical Specification” e si limitano a raccomandare solo tali funzionalità.</p>
<h3 id="faq.10-quale-versione-di-markdown-utilizzano-queste-linee-guida"><a name="Faq-markdown"></a>FAQ.10: Quale versione di Markdown utilizzano queste linee-guida?</h3>
<p>Questi standard di codifica sono scritti usando <a href="http://commonmark.org">CommonMark</a> e <code>&lt;a&gt;</code> HTML anchors.</p>
<p>Si stanno prendendo in considerazione le seguenti estensioni da <a href="https://help.github.com/articles/github-flavored-markdown/">GitHub Flavored Markdown (GFM)</a>:</p>
<ul>
<li>blocchi di codice incorniciato (l’uso coerente dell’indentazione anziché le cornici è oggetto di discussione)</li>
<li>tabelle (ancora nessuna, ma ce ne sarà bisogno e questo sarà un’estensione della GFM)</li>
</ul>
<p>Evitare altri tag HTML ed altre estensioni.</p>
<p>Nota: Non si è ancora coerenti con questo stile.</p>
<h3 id="faq.50-che-cosè-la-gsl-libreria-di-supporto-alle-linee-guida-guidelines-support-library"><a name="Faq-gsl"></a>FAQ.50: Che cos’è la GSL (libreria di supporto alle linee-guida [guidelines support library])?</h3>
<p>La GSL è un piccolo insieme di tipi e alias descritti in queste linee-guida. Al momento della stesura di questo documento, le specifiche qui contenute sono troppo scarse; si prevede di aggiungere una specifica d’interfaccia in stile WG21 per garantire che le diverse applicazioni vadano d’accordo e di proporla come contributo per un’eventuale standardizzazione, soggetto come sempre a qualunque cosa il comitato decida di accettare/migliorare/modificare/rifiutare.</p>
<h3 id="faq.51-github.commicrosoftgsl-è-la-gsl"><a name="Faq-msgsl"></a>FAQ.51: <a href="https://github.com/Microsoft/GSL">github.com/Microsoft/GSL</a> è la GSL?</h3>
<p>No. Questa è solo una prima implementazione fornita da Microsoft. Altre implementazioni da parte di altri fornitori sono incoraggiate, così come “fork” e contributi a quella implementazione. Dopo una settimana dalla prima pubblicazione, ne esiste già almeno un’implementazione open-source GPLv3. C’è in programma la produzione di una specifica di interfaccia in stile WG21 per garantire che le diverse applicazioni vadano d’accordo.</p>
<h3 id="faq.52-perché-non-fornire-una-reale-implementazione-della-gsl-incon-queste-linee-guida"><a name="Faq-gsl-implementation"></a>FAQ.52: Perché non fornire una reale implementazione della GSL in/con queste linee-guida?</h3>
<p>C’è una certa riluttanza nel ‘benedire’ una particolare implementazione perché non si vuol far credere che ce ne sia una sola reprimendo inavvertitamente altre implementazioni. E se queste linee guida includessero un’implementazione, chiunque le avesse fornite potrebbe essere erroneamente considerato eccessivamente influente. Si preferisce seguire il consolidato approccio del comitato, ovvero specificare interfacce, non implementazioni. Contemporaneamente, però, si vuole almeno un’implementazione a disposizione; si spera che ce ne siano molte.</p>
<h3 id="faq.53-perché-i-tipi-gsl-non-sono-stati-proposti-tramite-boost"><a name="Faq-boost"></a>FAQ.53: Perché i tipi GSL non sono stati proposti tramite Boost?</h3>
<p>Perché si vogliono usare immediatamente e perché sono provvisori in quanto verranno eliminati appena esisteranno dei tipi che soddisfino gli stessi bisogni nella libreria standard.</p>
<h3 id="faq.54-la-gsl-libreria-di-supporto-delle-linee-guida-è-stata-approvata-dal-comitato-iso-dello-standard-del-c"><a name="Faq-gsl-iso"></a>FAQ.54: La GSL (libreria di supporto delle linee guida) è stata approvata dal comitato ISO dello standard del C++?</h3>
<p>No. La GSL esiste solo per fornire alcuni tipi e alias che attualmente non sono presenti nella libreria standard. Se il comitato decide sulle versioni standardizzate (di questi o di altri tipi che soddisfano le stessa necessità), si possono rimuovere dalla GSL.</p>
<h3 id="faq.55-se-si-stanno-usando-i-tipi-standard-quando-sono-disponibili-perché-la-string_span-della-gsl-è-diversa-dalla-string_view-del-library-fundamentals-1-technical-specification-and-c17-working-paper-perché-non-usare-semplicemente-la-string_view-approvata-dal-comitato"><a name="Faq-gsl-string-view"></a>FAQ.55: Se si stanno usando i tipi standard quando sono disponibili, perché la <code>string_span</code> della GSL è diversa dalla <code>string_view</code> del [Library Fundamentals 1 Technical Specification and C++17 Working Paper]? Perché non usare semplicemente la <code>string_view</code> approvata dal comitato?</h3>
<p>L’opinione sulla tassonomia delle viste per la Libreria Standard C++ è stato che “view” significa “read-only”, e “span” indica “read/write”. La <code>string_view</code>, a sola lettura [read-only], è stata la prima di questi componenti a completare il processo della standardizzazione, mentre <code>span</code> e <code>string_span</code> stanno, al momento, completando l’iter per la standardizzazione.</p>
<h3 id="faq.56-lowner-proprietario-è-lo-stesso-observer_ptr-proposto"><a name="Faq-gsl-owner"></a>FAQ.56: L’<code>owner</code> [proprietario] è lo stesso <code>observer_ptr</code> proposto?</h3>
<p>No. L’<code>owner</code> possiede, è un alias e si può applicare a qualsiasi tipo di indirezione. Lo scopo principale di <code>observer_ptr</code> è quello di indicare un puntatore <em>non</em>-proprietario.</p>
<h3 id="faq.57-lo-stack_array-è-lo-stesso-array-standard"><a name="Faq-gsl-stack-array"></a>FAQ.57: Lo <code>stack_array</code> è lo stesso <code>array</code> standard?</h3>
<p>No. <code>stack_array</code> è garantito che che sia allocato sullo stack. Sebbene uno <code>std::array</code> contenga il suo carico [storage] direttamente in se stesso, l’oggetto <code>array</code> può essere posto ovunque, anche nell’heap.</p>
<h3 id="faq.58-il-dyn_array-è-lo-stesso-di-vector-o-del-dynarray-proposto"><a name="Faq-gsl-dyn-array"></a>FAQ.58: Il <code>dyn_array</code> è lo stesso di <code>vector</code> o del <code>dynarray</code> proposto?</h3>
<p>No. <code>dyn_array</code> non è ridimensionabile ed è un modo sicuro per far riferimento ad un array di dimensioni fisse allocato sull’heap. A differenza di <code>vector</code>, è destinato a sostituire array-<code>new[]</code>. A differenza del <code>dynarray</code> che è stato proposto al comitato, questo non anticipa la magia del compilatore/linguaggio ad allocarlo in qualche modo sullo stack quando è membro di un oggetto allocato sullo stack; si riferisce semplicemente ad un array “dinamico” o basato sull’heap.</p>
<h3 id="faq.59-expects-è-lo-stesso-di-assert"><a name="Faq-gsl-expects"></a>FAQ.59: <code>Expects</code> è lo stesso di <code>assert</code>?</h3>
<p>No. È un segnaposto a supporto del linguaggio per le precondizioni del contratto.</p>
<h3 id="faq.60-ensures-è-lo-stesso-di-assert"><a name="Faq-gsl-ensures"></a>FAQ.60: <code>Ensures</code> è lo stesso di <code>assert</code>?</h3>
<p>No. È un segnaposto per il supporto linguistico per i post-condizioni del contratto.</p>
<h1 id="appendice-a-librerie"><a name="S-libraries"></a>Appendice A: Librerie</h1>
<p>Questa sezione elenca le librerie consigliate e ne raccomanda esplicitamente qualcuna.</p>
<p>??? Adatto per la guida generale? Probabilmente no ???</p>
<h1 id="appendice-b-modernizzazione-del-codice"><a name="S-modernizing"></a>Appendice B: Modernizzazione del codice</h1>
<p>Idealmente, si obbedisce a tutte le regole in tutto il codice. Realisticamente, si deve gestire tantissimo codice vecchio:</p>
<ul>
<li>codice scritto prima che le linee-guida fossero formulate e conosciute</li>
<li>librerie scritte con standard vecchi/diversi</li>
<li>codice scritto con “insoliti” vincoli</li>
<li>codice che semplicemente non si è riusciti a modernizzare</li>
</ul>
<p>Se si hanno milioni di righe di nuovo codice, l’impulso di “cambiare tutto in una volta” è solitamente poco realistico. Pertanto, c’è bisogno di un modo per modernizzare gradualmente il codice.</p>
<p>L’aggiornamento del codice più vecchio con uno stile moderno può risultare un compito scoraggiante. Spesso, il codice vecchio è sia disordinato (difficile da capire) che correttamente funzionante (per come è stato usato finora). Solitamente, il programmatore originale non c’è più e i casi di test sono incompleti. Il fatto che il codice sia disordinato aumenta notevolmente la fatica necessaria per fare qualsiasi modifica col rischio di introdurre degli errori. Spesso, il vecchio codice disordinato gira lentamente senza motivo perché richiede compilatori datati e non può sfruttare l’hardware più moderno. In molti casi, sarebbe opportuno il supporto di strumenti “modernizzatori” automatici per fare la maggior parte del lavoro di aggiornamento.</p>
<p>Lo scopo della modernizzazione del codice è quello di semplificare aggiungendo nuove funzionalità, facilitarne la manutenzione e migliorarne le prestazioni (throughput o latenza) utilizzando meglio l’hardware moderno. Rendere il codice “bello” o “seguire lo stile moderno” non sono di per sé buoni motivi per cambiare. Ci sono dei rischi impliciti per ogni modifica e costi impliciti (compreso il costo delle opportunità perse) nell’avere un codice obsoleto. La riduzione del costo dev’essere maggiore del rischio.</p>
<p>Ma come fare?</p>
<p>Non esiste un approccio alla modernizzazione del codice. Il modo migliore per farlo dipende dal codice, dalla pressione per gli aggiornamenti, l’esperienza degli sviluppatori e dagli strumenti a disposizione. Ecco alcune idee (molto generali):</p>
<ul>
<li>L’ideale è “aggiornare semplicemente tutto”. Questo offre il massimo beneficio nel tempo minimo. Nella maggior parte dei casi, è anche impossibile.</li>
<li>Si potrebbe convertire il codice per ogni modulo, ma qualsiasi regola che riguarda le interfacce (specie le ABI), come <a href="#SS-views">l’uso di <code>span</code></a>, non può essere fatto per ogni modulo, uno per volta.</li>
<li>Si potrebbe convertire il codice partendo “dal basso” con le regole che si stimano possano offrire maggiori benefici e/o meno problemi.</li>
<li>Si potrebbe iniziare concentrandosi sulle interfacce, p.es., assicurandosi di non perdere alcuna risorsa e che nessun puntatore venga usato in modo improprio. Si tratterebbe di una serie di modifiche in tutto il codice, ma che probabilmente apporterebbe notevoli vantaggi. Successivamente, si potrà gradualmente modernizzare il codice nascosto dietro quelle interfacce senza modificare il resto.</li>
</ul>
<p>Qualunque cosa si scelga di fare, si noti che i vantaggi maggiori derivano dalla massima conformità alle linee-guida. Le linee-guida non sono un insieme casuale di regole slegate tra cui sceglierne casualmente qualcuna, aspettandosi qualche miglioria.</p>
<p>Ci piacerebbe molto conoscere l’esperienza e gli strumenti utilizzati. La modernizzazione potrebbe essere molto più veloce, più semplice e sicura se supportata da tool per l’analisi o anche per la trasformazione.</p>
<h1 id="appendice-c-discussione"><a name="S-discussion"></a>Appendice C: Discussione</h1>
<p>Questa sezione contiene materiale supplementare sulle regole e sui gruppi di regole. In particolare, qui vengono presentate ulteriori motivazioni, esempi più estesi e le discussioni sulle alternative.</p>
<h3 id="discussione-definire-e-inizializzare-le-variabili-membro-nellordine-di-dichiarazione-del-membro"><a name="Sd-order"></a>Discussione: Definire e inizializzare le variabili membro nell’ordine di dichiarazione del membro</h3>
<p>Le variabili membro vengono sempre inizializzate nell’ordine in cui sono state dichiarate nella definizione della classe, quindi scriverle in questo ordine nella lista di inizializzazione del costruttore. Scriverle con un ordine diverso rende semplicemente il codice confuso perché non verrà eseguito nell’ordine visto e questo potrebbe rendere arduo la ricerca di bug dipendenti dall’ordine.</p>
<pre><code>class Employee {
string email, first, last;
public:
Employee(const char* firstName, const char* lastName);
// ...
};

Employee::Employee(const char* firstName, const char* lastName)
: first(firstName),
last(lastName),
// BAD: first e last non sono stati ancora costruiti
email(first + &quot;.&quot; + last + &quot;@acme.com&quot;)
{}</code></pre>
<p>In questo esempio, <code>email</code> verrà costruita prima di <code>first</code> e di <code>last</code> perché è dichiarata per prima. Questo vuol dire che il suo costruttore tenterà di usare <code>first</code> e <code>last</code> troppo presto – non solo prima che siano impostate con i loro valori, ma addirittura prima che vengano costruite.</p>
<p>Se la definizione della classe e il body del costruttore stanno in file separati, con l’andare del tempo l’influenza che ha l’ordine della dichiarazione delle variabili membro sulla correttezza del costruttore sarà sempre più difficile da individuare.</p>
<p><strong>Riferimenti</strong>:</p>
<p><a href="#Cline99">[Cline99]</a> §22.03-11, <a href="#Dewhurst03">[Dewhurst03]</a> §52-53, <a href="#Koenig97">[Koenig97]</a> §4, <a href="#Lakos96">[Lakos96]</a> §10.3.5, <a href="#Meyers97">[Meyers97]</a> §13, <a href="#Murray93">[Murray93]</a> §2.1.3, <a href="#Sutter00">[Sutter00]</a> §47</p>
<h3 id="discussione-uso-di-e-come-inizializzatori"><a name="Sd-init"></a>Discussione: Uso di <code>=</code>, <code>{}</code>, e <code>()</code> come inizializzatori</h3>
<p>???</p>
<h3 id="discussione-usare-una-funzione-factory-se-si-necessita-di-un-comportamento-virtuale-durante-linizializzazione"><a name="Sd-factory"></a>Discussione: Usare una funzione ‘factory’ se si necessita di un “comportamento virtuale” durante l’inizializzazione</h3>
<p>Se il proprio progetto richiede un [dispatch] virtuale in un costruttore o in un distruttore della classe derivata per funzioni come <code>f</code> e <code>g</code>, c’è bisogno di altre tecniche, come un post-costruttore – una funzione membro separata che il chiamante deve invocare per completare l’inizializzazione, che possa chiamare tranquillamente <code>f</code> e <code>g</code> perché è il normale funzionamento delle chiamate virtuali a funzioni membro. Alcune di queste tecniche sono mostrate nei Riferimenti. Ecco un elenco non esaustivo delle possibilità:</p>
<ul>
<li><em>Scaricabarile:</em> Basta documentare che il codice deve chiamare la funzione di post-inizializzazione subito dopo la costruzione di un oggetto.</li>
<li><em>Post-inizializzazione rimandata:</em> Lo si fa durante la prima chiamata ad una funzione membro. Un flag booleano nella classe base dirà se è già avvenuta la post-costruzione.</li>
<li><em>Usare la semantica della classe base virtuale:</em> Le regole del linguaggio impongono il costruttore della classe più derivata decida quale costruttore base verrà invocato; lo si può sfruttare a proprio vantaggio. (Cfr. <a href="#Taligent94">[Taligent94]</a>.)</li>
<li><em>Usare una funzione ‘factory’:</em> In questo modo si può facilmente forzare un’invocazione obbligatoria di una funzione di post-costruzione.</li>
</ul>
<p>Questo è un esempio dell’ultima opzione:</p>
<pre><code>class B {
public:
B() {
/* ... */
f(); // BAD: C.82: Non richiamare funzioni virtuali nei costruttori e nei distruttori
/* ... */
}

virtual void f() = 0;
};

class B {
protected:
class Token {};

public:
// il costruttore dev&#39;essere pubblico in modo che make_shared vi possa accedere.
// il livello di accesso protected si ottiene richiedendo un Token.
explicit B(Token) { /* ... */ }  // crea un oggetto non completamente inizializzato
virtual void f() = 0;

template&lt;class T&gt;
static shared_ptr&lt;T&gt; create()    // interfaccia per creare oggetti condivisi
{
auto p = make_shared&lt;T&gt;(typename T::Token{});
p-&gt;post_initialize();
return p;
}

protected:
virtual void post_initialize()   // chiamata subito dopo la costruzione
{ /* ... */ f(); /* ... */ } // OTTIMO: il dispatch virtuale è sicuro
}
};


class D : public B {                 // qualche classe derivata
protected:
class Token {};

public:
// il costruttore dev&#39;essere pubblico in modo che make_shared vi possa accedere.
// il livello di accesso protected si ottiene richiedendo un Token.
explicit D(Token) : B{ B::Token{} } {}
void f() override { /* ...  */ };

protected:
template&lt;class T&gt;
friend shared_ptr&lt;T&gt; B::create();
};

shared_ptr&lt;D&gt; p = D::create&lt;D&gt;();    // creazione di un oggetto D</code></pre>
<p>Questo progetto richiede il seguente disciplinare:</p>
<ul>
<li>Le classi derivate come la <code>D</code> non devono esporre un costruttore richiamabile pubblico. Altrimenti, gli utilizzatori di <code>D</code> potrebbero creare oggetti <code>D</code> che non richiamino <code>post_initialize</code>.</li>
<li>L’allocazione è limitata all’<code>operator new</code>. Tuttavia <code>B</code> può sovrascrivere [override] <code>new</code> (si vedano i Punti 45 e 46 in <a href="#SuttAlex05">SuttAlex05</a>).</li>
<li><code>D</code> deve definire un costruttore con gli stessi parametri selezionati da <code>B</code>. La definizione di vari [overload] di <code>create</code> può, tuttavia, attenuare questo problema; e gli [overload] possono anche essere template con i tipi degli argomenti.</li>
</ul>
<p>Se i precedenti requisiti sono soddisfatti, il progetto assicura che <code>post_initialize</code> sia stata chiamata per ogni oggetto derivato da <code>B</code>. <code>post_initialize</code> non deve essere virtuale; può tuttavia invocare liberamente funzioni virtuali.</p>
<p>In sintesi, nessuna tecnica di post-costruzione è perfetta. Le tecniche peggiori evitano tutto il problema richiedendo semplicemente al chiamante di invocare manualmente il post-costruttore. Anche i migliori richiedono una diversa sintassi per costruire oggetti (facile da controllare in fase di compilazione) e/o la cooperazione degli autori di classi derivate (impossibile da controllare in fase di compilazione).</p>
<p><strong>Riferimenti</strong>: <a href="#Alexandrescu01">[Alexandrescu01]</a> §3, <a href="#Boost">[Boost]</a>, <a href="#Dewhurst03">[Dewhurst03]</a> §75, <a href="#Meyers97">[Meyers97]</a> §46, <a href="#Stroustrup00">[Stroustrup00]</a> §15.4.3, <a href="#Taligent94">[Taligent94]</a></p>
<h3 id="discussione-rendere-pubblici-e-virtuali-i-distruttori-della-classe-base-o-protected-e-non-virtuali"><a name="Sd-dtor"></a>Discussione: Rendere pubblici e virtuali i distruttori della classe base, o protected e non virtuali</h3>
<p>La distruzione dovrebbe avere un comportamento virtuale? Cioè, dovrebbe essere consentita la distruzione tramite un puntatore a una classe <code>base</code>? Se sì, allora il distruttore della <code>base</code> deve essere pubblico per poter essere richiamabile e virtuale altrimenti chiamandolo si ottiene un comportamento indefinito. Se no, dovrebbe essere protected in modo che solo le classi derivate lo possano invocare nei loro distruttori, e non-virtuale perché non necessita di un comportamento virtuale.</p>
<h5 id="esempio-395">Esempio</h5>
<p>Il caso comune per una classe base è che si vogliono avere classi derivate pubblicamente e quindi il codice chiamante è quasi sicuro che usi qualcosa di simile a <code>shared_ptr&lt;base&gt;</code>:</p>
<pre><code>class Base {
public:
~Base();                   // BAD, non virtuale
virtual ~Base();           // OTTIMO
// ...
};

class Derived : public Base { /* ... */ };

{
unique_ptr&lt;Base&gt; pb = make_unique&lt;Derived&gt;();
// ...
} // ~pb invola il distruttore corretto solo quando ~Base è virtuale</code></pre>
<p>In casi più rari, come le classi di sistema [policy], la classe viene usata come classe base per comodità, non per avere un comportamento polimorfico. Si raccomanda che tali distruttori siano protected e non-virtuali:</p>
<pre><code>class My_policy {
public:
virtual ~My_policy();      // BAD, pubblico e virtuale
protected:
~My_policy();              // OTTIMO
// ...
};

template&lt;class Policy&gt;
class customizable : Policy { /* ... */ }; // nota: ereditarietà di private</code></pre>
<h5 id="note-393">Note</h5>
<p>Questa semplice linea-guida illustra un problema sottile e riguarda gli usi moderni dell’ereditarietà e dei principi di progettazione object-oriented .</p>
<p>Per una classe base <code>Base</code>, il codice chiamante potrebbe tentare di distruggere gli oggetti derivati tramite i puntatori a <code>Base</code>, come quando si usa un <code>unique_ptr&lt;Base&gt;</code>. Se il distruttore di <code>Base</code> è pubblico e non virtuale (il default), può essere accidentalmente chiamato su un puntatore che in effetti punta a un oggetto derivato, nel qual caso il comportamento della tentata cancellazione è indefinito. Questo stato di cose ha portato gli standard di codifica più vecchi a imporre un requisito generale secondo cui tutti i distruttori della classe base devono essere virtuali. Questo è eccessivo (anche se è capita spesso); invece, la regola dovrebbe essere quella di rendere virtuali i distruttori della classe base se e solo se sono pubblici.</p>
<p>Scrivere una classe base vuol dire definire un’astrazione (si vedano i punti dal 35 al 37). Si rammenti che per ogni funzione membro che contribuisce a questa astrazione, si deve decidere:</p>
<ul>
<li>Se deve comportarsi virtualmente o meno.</li>
<li>Se dev’essere pubblicamente disponibile a tutti i chiamanti tramite un puntatore a <code>Base</code> o altrimenti essere un dettaglio implementativo interno nascosto.</li>
</ul>
<p>Come descritto al punto 39, per una normale funzione membro, la scelta è tra il consentirle di essere chiamata tramite un puntatore a <code>Base</code> non-virtualmente (ma forse con un comportamento virtuale se essa invoca funzioni virtuali, come nei pattern “NVI” (Non-Virtual Interface) e il “Template Method”), virtualmente, o niente affatto. Il pattern NVI è una tecnica per evitare le funzioni virtuali pubbliche.</p>
<p>La distruzione può essere vista semplicemente come un’altra operazione, anche se con una semantica speciale che rende pericolose o sbagliate le chiamate non virtuali. Per un distruttore di una classe base, quindi, la scelta è tra il consentirgli di essere chiamato virtualmente tramite un puntatore a <code>Base</code> o per niente; il “non-virtualmente” non è un’opzione. Quindi, un distruttore di una classe base è virtuale se può essere chiamato (cioè è pubblico) altrimenti è non-virtuale.</p>
<p>Si noti che il pattern NVI non può essere applicato al distruttore perché i costruttori e i distruttori non possono effettuare chiamate virtuali [deep]. (Si vedano i Punti 39 e 55.)</p>
<p>Corollario: Quando si scrive una classe base, scrivere sempre esplicitamente un distruttore, poiché quello generato in modo implicito è pubblico e non-virtuale. Si può sempre usare <code>=default</code>per l’implementazione se va bene il body di default e si sta solo scrivendo la funzione per darle la giusta visibilità e virtualità.</p>
<h5 id="eccezione-54">Eccezione</h5>
<p>Alcune architetture di componenti (p.es., COM e CORBA) non usano un meccanismo standard per la cancellazione e adottano protocolli diversi per l’eliminazione degli oggetti. Seguire i pattern e gli idiomi locali, adattando questa linea-guida nel modo appropriato.</p>
<p>Si consideri anche questo caso raro:</p>
<ul>
<li><code>B</code> è sia una classe base che una classe concreta che può essere istanziata da sola, e quindi il distruttore deve essere pubblico per gli oggetti di <code>B</code> per essere creati e distrutti.</li>
<li>Eppure <code>B</code> non ha funzioni virtuali e non è pensata per essere usata polimorficamente, e quindi anche se il distruttore è pubblico non deve essere necessariamente virtuale.</li>
</ul>
<p>Quindi, anche se il distruttore deve essere pubblico, può esserci una grande pressione per non renderlo virtuale, poiché come prima funzione virtuale si avrebbe l’[overhead] del tipo a run-time, quando la funzionalità aggiunta non dovrebbe mai essere necessaria.</p>
<p>In questo raro caso, è possibile rendere pubblico e non virtuale il distruttore ma documentare chiaramente che gli oggetti ulteriormente derivati non devono essere usati polimorficamente come <code>B</code>’s. Questo è ciò che è stato fatto con <code>std::unary_function</code>.</p>
<p>In generale, tuttavia, evitare le classi di base concrete (cfr. Punto 35). Per esempio, la <code>unary_function</code> è un bundle-of-typedefs che non è mai stato concepito per essere istanziato da solo. Non ha davvero senso dargli un distruttore pubblico; un progetto migliore sarebbe quello di seguire il consiglio di questo punto e dargli un distruttore non-virtuale protected.</p>
<p><strong>Riferimenti</strong>: <a href="#CplusplusCS">[C++CS]</a> Item 50, <a href="#Cargill92">[Cargill92]</a> pagg. 77-79, 207, <a href="#Cline99">[Cline99]</a> §21.06, 21.12-13, <a href="#Henricson97">[Henricson97]</a> pp. 110-114, <a href="#Koenig97">[Koenig97]</a> Chapters 4, 11, <a href="#Meyers97">[Meyers97]</a> §14, <a href="#Stroustrup00">[Stroustrup00]</a> §12.4.2, <a href="#Sutter02">[Sutter02]</a> §27, <a href="#Sutter04">[Sutter04]</a> §18</p>
<h3 id="discussione-uso-di-noexcept"><a name="Sd-noexcept"></a>Discussione: Uso di noexcept</h3>
<p>???</p>
<h3 id="discussione-distruttori-de-allocazione-e-swap-non-devono-mai-fallire"><a name="Sd-never-fail"></a>Discussione: Distruttori, de-allocazione, e swap non devono mai fallire</h3>
<p>Non consentire mai la segnalazione di un errore da un distruttore, da una funzione di deallocazione di risorse (p.es., <code>operator delete</code>), o da una funzione <code>swap</code> tramite <code>throw</code>. È quasi impossibile scrivere un codice utile se queste operazioni possono fallire e anche se qualcosa va storto non ha quasi senso riprovare. In particolare, i tipi i cui distruttori possono generare un’eccezione sono severamente vietati dall’uso con la Libreria Standard C++. La maggior parte dei distruttori ora sono implicitamente <code>noexcept</code> per default.</p>
<h5 id="esempio-396">Esempio</h5>
<pre><code>class Nefarious {
public:
Nefarious()  { /* codice che potrebbe andare in errore [throw] */ }   // ok
~Nefarious() { /*  codice che potrebbe andare in errore [throw] */ }   // BAD, non dovrebbe eseguire [throw]
// ...
};</code></pre>
<ol type="1">
<li><p>Gli oggetti <code>Nefarious</code> sono difficili da usare in sicurezza anche come variabili locali:</p>
<pre><code>void test(string&amp; s)
{
Nefarious n;          // preparazione difficile
string copy = s;      // copia la stringa
} // distrugge la copia e poi n</code></pre>
<p>Qui, la copia di <code>s</code> potrebbe generare un errore [throw], e se lo fa e lo fa anche il distruttore di <code>n</code> il programma terminerà tramite <code>std::terminate</code> perché non possono essere propagate due eccezioni contemporaneamente.</p></li>
<li><p>Anche le classi basi o con membri <code>Nefarious</code> sono difficili da usare in sicurezza, perché i loro devono invocare il distruttore di <code>Nefarious</code> restando allo stesso modo avvelenati dal suo comportamento:</p>
<pre><code>class Innocent_bystander {
Nefarious member;     // oops, avvelena il distruttore della classe che lo racchiude
// ...
};

void test(string&amp; s)
{
Innocent_bystander i; // altri problemi nella preparazione
string copy2 = s;      // copia la stringa
} // distrugge la copia e poi i</code></pre>
<p>Qui, se la costruzione di <code>copy2</code> genera un errore [throws], si pone lo stesso problema perché ora anche il distruttore di <code>i</code> può generare un errore [throw] e se lo farà verrà invocato <code>std::terminate</code>.</p></li>
<li><p>Non è possibile creare in modo affidabile oggetti <code>Nefarious</code> globali o statici:</p>
<pre><code>static Nefarious n;       // oops, non si può intercettare alcuna eccezione del distruttore</code></pre></li>
<li><p>Non è possibile creare in modo affidabile array di <code>Nefarious</code>:</p>
<pre><code>void test()
{
std::array&lt;Nefarious, 10&gt; arr; // questa riga non può eseguire std::terminate(!)
}</code></pre>
<p>Il comportamento delle matrici è indefinito in presenza di distruttori che lanciano eccezioni [throw] perché non esiste un comportamento di rollback ragionevole che si possa escogitare. Basti pensare: Quale codice può generare il compilatore per costruire un <code>arr</code> dove, se il costruttore del quarto oggetto va in [throw], il codice deve arrendersi e nella sua modalità di pulizia cerca di chiamare i distruttori degli oggetti già costruiti … e uno o più di tali distruttori va in [throw]? Non esiste una risposta soddisfacente.</p></li>
<li><p>Si possono usare gli oggetti <code>Nefarious</code> nei contenitori standard:</p>
<pre><code>std::vector&lt;Nefarious&gt; vec(10);   // questa riga può eseguire std::terminate()</code></pre>
<p>La libreria standard proibisce l’esecuzione del [throw] in tutti i distruttori che usa. Non si possono memorizzare oggetti <code>Nefarious</code> nei contenitori standard o usarli con qualsiasi altra parte della libreria standard.</p></li>
</ol>
<h5 id="note-394">Note</h5>
<p>Queste sono funzioni chiave che non devono fallire perché sono necessarie per le due operazioni principali nella programmazione transazionale: eseguire il ripristino del lavoro se si verificano problemi durante l’elaborazione e “committare” il lavoro se tutto è ok. Se non è possibile tornare indietro in modo sicuro utilizzando le operazioni “no-fail”, è impossibile implementare il rollback “no-fail”. Se non è possibile eseguire il commit sicuro dei cambiamenti di stato utilizzando un’operazione “no-fail” (in particolare, ma non solo, <code>swap</code>), è impossibile implementare il commit “no-fail”.</p>
<p>Si tengano presenti i seguenti consigli e requisiti trovati nel C++ Standard:</p>
<blockquote>
<p>Se un distruttore viene chiamato durante lo svolgimento [unwinding] dello stack esce con un’eccezione, viene chiamato terminate (15.5.1). Quindi i distruttori dovrebbero generalmente catturare le eccezioni e non lasciarle propagare al di fuori del distruttore. –<a href="#Cplusplus03">[C++03]</a> §15.2(3)</p>
<p>Nessuna operazione del distruttore definita nella Libreria Standard C++ (compreso il distruttore di qualsiasi tipo utilizzato per creare un’istanza di un template della libreria standard) genererà un’eccezione. –<a href="#Cplusplus03">[C++03]</a> §17.4.4.8(3)</p>
</blockquote>
<p>Le funzioni di de-allocazione, compresi in particolare gli “overload” di <code>operator delete</code> e di <code>operator delete[]</code>, rientrano nella stessa categoria, poiché anch’esse vengono utilizzate durante la pulizia in generale e durante la gestione delle eccezioni in particolare, per eseguire il “rollback” del lavoro parziale che deve essere annullato. Oltre ai distruttori e alle funzioni di de-allocazione, le comuni tecniche [error-safety] si basano anche su operazioni <code>swap</code> che non falliscono mai – in questo caso, non perché vengono utilizzate per implementare un “rollback” garantito, ma perché vengono utilizzate per implementare un “commit” garantito. Ad esempio, ecco un’implementazione idiomatica dell’<code>operator=</code> per un tipo <code>T</code> che esegue la costruzione copia seguita da una chiamata “no-fail” a <code>swap</code>:</p>
<pre><code>T&amp; T::operator=(const T&amp; other) {
auto temp = other;
swap(temp);
return *this;
}</code></pre>
<p>(Si veda anche l’Item 56. ???)</p>
<p>Fortunatamente, quando si rilascia una risorsa, il margine di errore è decisamente più piccolo. Se si utilizzano le eccezioni come meccanismo di segnalazione degli errori, assicurarsi che tali funzioni gestiscano tutte le eccezioni e gli altri errori che la loro elaborazione interna potrebbe generare. (Per le eccezioni, semplicemente si racchiude tutto ciò che è sensibile in un blocco <code>try/catch(...)</code>). Questo è particolarmente importante perché un distruttore potrebbe essere chiamato in una situazione di crisi, come il fallimento nell’allocare una risorsa di sistema (p.es., memoria, file, lock, porte, finestre o altri oggetti).</p>
<p>Quando si utilizzano le eccezioni come meccanismo di gestione degli errori, documentare sempre questo comportamento dichiarando queste funzioni <code>noexcept</code>. (Si veda il Punto 75.)</p>
<p><strong>Riferimenti</strong>: <a href="#CplusplusCS">[C++CS]</a> Item 51; <a href="#Cplusplus03">[C++03]</a> §15.2(3), §17.4.4.8(3), <a href="#Meyers96">[Meyers96]</a> §11, <a href="#Stroustrup00">[Stroustrup00]</a> §14.4.7, §E.2-4, <a href="#Sutter00">[Sutter00]</a> §8, §16, <a href="#Sutter02">[Sutter02]</a> §18-19</p>
<h2 id="definire-la-copia-lo-spostamento-e-la-distruzione-in-modo-coerente"><a name="Sd-consistent"></a>Definire la copia, lo spostamento e la distruzione in modo coerente</h2>
<h5 id="motivo-449">Motivo</h5>
<p>???</p>
<h5 id="note-395">Note</h5>
<p>Se si definisce un costruttore copia, si deve anche definire un operatore di assegnazione copia.</p>
<h5 id="note-396">Note</h5>
<p>Se si definisce un costruttore di spostamento [move], si deve anche definire un operatore di assegnazione move.</p>
<h5 id="esempio-397">Esempio</h5>
<pre><code>class X {
public:
X(const X&amp;) { /* delle cose */ }

// BAD: impossibile anche definire un operatore di assegnazione copia

X(x&amp;&amp;) noexcept { /* stuff */ }

// BAD: impossibile anche definire un operatore di assegnazione move

// ...
};

X x1;
X x2 = x1; // ok
x2 = x1;   // trappola: o non riesce a compilare o fa qualcosa di sospetto</code></pre>
<p>Se si definisce un distruttore, non è necessario utilizzare l’operazione di copia o spostamento generata dal compilatore; probabilmente è necessario definire o sopprimere la copia e/o il [move].</p>
<pre><code>class X {
HANDLE hnd;
// ...
public:
~X() { /* cose personalizzate, come la chiusura di hnd */ }
// suspicious: sospetto: nessuna menzione alla copia o allo spostamento -- cosa succede a hnd?
};

X x1;
X x2 = x1; // trappola: o non riesce a compilare o fa qualcosa di sospetto
x2 = x1;   // trappola: o non riesce a compilare o fa qualcosa di sospetto</code></pre>
<p>Se si definisce la copia e qualsiasi base o membro ha un tipo che definisce un’operazione di spostamento, è necessario definire anche un’operazione di spostamento.</p>
<pre><code>class X {
string s; // definisce operazioni di spostamento più efficienti
// ... altri dati membro ...
public:
X(const X&amp;) { /* stuff */ }
X&amp; operator=(const X&amp;) { /* stuff */ }

// BAD: impossibile definire anche una costruzione &quot;move&quot; e un&#39;assegnazione di &quot;move&quot;
// (perché la &quot;roba&quot; personalizzata non è stata ripetuta qui?)
};

X test()
{
X local;
// ...
return local;  // trappola: sarà inefficiente e/o farà la cosa sbagliata
}</code></pre>
<p>Se si definisce o un costruttore copia, un operatore di assegnazione copia o un distruttore, probabilmente è necessario definire gli altri.</p>
<h5 id="note-397">Note</h5>
<p>Se si deve definire una di queste cinque funzioni, significa che serve qualcosa in più del comportamento di default – e che le cinque sono asimmetricamente correlate. Ecco come:</p>
<ul>
<li>Se si scrive/disabilita o il costruttore copia o l’operatore di assegnazione copia, c’è probabilmente bisogno di fare lo stesso per l’altra: se uno fa un lavoro “speciale”, probabilmente dovrebbe esserlo anche l’altro perché le due funzioni dovrebbero avere effetti simili. (Si veda il Punto 53, che sviluppa questo punto da solo).</li>
<li>Se si scrivono esplicitamente le funzioni di copia, probabilmente è necessario scrivere il distruttore: Se il lavoro “speciale” nel costruttore copia consiste anche nell’allocare o duplicare qualche risorsa (p.es., memoria, file, socket), si devono disallocarle nel distruttore.</li>
<li>Se si scrive esplicitamente il distruttore, probabilmente si deve esplicitamente scrivere o disabilitare la copia: Se si deve scrivere un distruttore un po’ più complicato, spesso è perché si deve manualmente rilasciare una risorsa contenuta nell’oggetto. Se è così, è probabile che tali risorse richiedano un’attenta duplicazione e quindi si deve fare attenzione a come gli oggetti vengono copiati e assegnati, oppure disabilitare completamente la copia.</li>
</ul>
<p>In molti casi, mantenere correttamente le risorse incapsulate utilizzando il oggetti “proprietari” RAII ", può eliminare la necessità di scrivere da soli queste operazioni. (Si veda il Punto 13.)</p>
<p>Preferire i membri speciali generati dal compilatore (compreso <code>=default</code>); solo questi possono essere classificati come “banali”, e almeno uno dei principali fornitori della libreria standard ottimizza le classi con membri speciali banali. È probabile che ciò diventi una pratica comune.</p>
<p><strong>Eccezioni</strong>: Quando una delle funzioni speciali viene dichiarata solo per renderle non pubbliche o virtuali, ma senza una semantica speciale, ciò non implica che le altre siano necessarie. In rari casi, le classi che hanno membri di tipi strani (come i riferimenti membro) non sono un’eccezione perché hanno una semantica di copia peculiare. In una classe che contiene un riferimento, è probabilmente necessario scrivere il costruttore copia e l’operatore di assegnazione, ma il distruttore predefinito fa già la cosa giusta. (Si noti che l’utilizzo di un riferimento membro è quasi sempre sbagliato).</p>
<p><strong>Riferimenti</strong>: <a href="#CplusplusCS">[C++CS]</a> Item 52; <a href="#Cline99">[Cline99]</a> §30.01-14, <a href="#Koenig97">[Koenig97]</a> §4, <a href="#Stroustrup00">[Stroustrup00]</a> §5.5, §10.4, <a href="#SuttHysl04b">[SuttHysl04b]</a></p>
<p>Riepilogo delle regole sulla gestione delle risorse:</p>
<ul>
<li><a href="#Cr-safety">Fornire una robusta sicurezza alle risorse; cioè, mai perdere [leak] niente che si ritenga possa essere una risorsa</a></li>
<li><a href="#Cr-never">Mai generare un’eccezione [throw] mentre si tiene una risorsa non di proprietà di un handle</a></li>
<li><a href="#Cr-raw">Un puntatore “semplice” o un riferimento non è mai un handle di una risorsa</a></li>
<li><a href="#Cr-outlive">Non lasciare mai che un puntatore sopravviva all’oggetto a cui punta</a></li>
<li><a href="#Cr-templates">Usare i template per esprimere i contenitori (ed altri gestori di risorse)</a></li>
<li><a href="#Cr-value-return">Restituire i contenitori per valore (basandosi, per efficienza, sullo spostamento [move] o sull’elisione della copia)</a></li>
<li><a href="#Cr-handle">Se una classe è un handle di una risorsa, necessita di un costruttore, un distruttore, e le operazioni di copia e/o spostamento</a></li>
<li><a href="#Cr-list">Se una classe è un contenitore, fornirle un costruttore con un elenco-di-inizializzatori</a></li>
</ul>
<h3 id="discussione-fornire-una-robusta-sicurezza-alle-risorse-cioè-mai-perdere-leak-niente-che-si-ritenga-possa-essere-una-risorsa"><a name="Cr-safety"></a>Discussione: Fornire una robusta sicurezza alle risorse; cioè, mai perdere [leak] niente che si ritenga possa essere una risorsa</h3>
<h5 id="motivo-450">Motivo</h5>
<p>Prevenire i leak. I leak possono provocare la degradazione delle prestazioni, errori misteriosi, crash di sistema, e violazioni della sicurezza.</p>
<p><strong>Formulazione alternativa</strong>: Fare in modo che ogni risorsa rappresentata come un oggetto di qualche classe gestisca il proprio ciclo di vita.</p>
<h5 id="esempio-398">Esempio</h5>
<pre><code>template&lt;class T&gt;
class Vector {
private:
T* elem;   // sz elementi nel free store, posseduti dall&#39;oggetto della classe
int sz;
// ...
};</code></pre>
<p>Questa classe è un gestore di risorsa. Gestisce il ciclo di vita delle <code>T</code>. Per farlo, <code>Vector</code> deve definire o cancellare<a href="???">l’insieme delle operazioni speciali</a> (costruttori, un distruttore, ecc.).</p>
<h5 id="esempio-399">Esempio</h5>
<pre><code>??? risorsa non-memoria &quot;strana&quot; ???</code></pre>
<h5 id="imposizione-403">Imposizione</h5>
<p>La tecnica base per evitare i leak consiste nell’avere ogni risorsa posseduta da un gestore della risorsa con un distruttore adatto. Un “checker” potrebbe trovare dei “semplici <code>new</code>”. Dato un elenco di funzioni di allocazione in stile C (p.es., <code>fopen()</code>), un “checker” potrebbe anche trovare usi che non sono gestiti da un handle della risorsa. In generale, i “puntatori semplici” si possono vedere con sospetto, segnalati e/o analizzati. Un elenco completo delle risorse non può essere generato senza un input umano (la definizione di “una risorsa” è necessariamente troppo generale), ma si può “parametrizzare” un tool con un elenco di risorse.</p>
<h3 id="discussione-mai-generare-uneccezione-throw-mentre-si-tiene-una-risorsa-non-di-proprietà-di-un-handle"><a name="Cr-never"></a>Discussione: Mai generare un’eccezione [throw] mentre si tiene una risorsa non di proprietà di un handle</h3>
<h5 id="motivo-451">Motivo</h5>
<p>Ci sarebbe un leak.</p>
<h5 id="esempio-400">Esempio</h5>
<pre><code>void f(int i)
{
FILE* f = fopen(&quot;a file&quot;, &quot;r&quot;);
ifstream is { &quot;another file&quot; };
// ...
if (i == 0) return;
// ...
fclose(f);
}</code></pre>
<p>Se <code>i == 0</code> l’handle del file per <code>a file</code> provoca un leak. D’altra parte, l’<code>ifstream</code> per <code>another file</code> verrà chiuderà correttamente il suo file (dopo la distruzione). Se è necessario utilizzare un puntatore esplicito, anziché un handle della risorsa con una semantica specifica, usare un <code>unique_ptr</code> o uno <code>shared_ptr</code> con un delete personalizzato:</p>
<pre><code>void f(int i)
{
unique_ptr&lt;FILE, int(*)(FILE*)&gt; f(fopen(&quot;a file&quot;, &quot;r&quot;), fclose);
// ...
if (i == 0) return;
// ...
}</code></pre>
<p>Meglio:</p>
<pre><code>void f(int i)
{
ifstream input {&quot;a file&quot;};
// ...
if (i == 0) return;
// ...
}</code></pre>
<h5 id="imposizione-404">Imposizione</h5>
<p>Un checker deve considerare sospetti tutti i “puntatori semplici”. Probabilmente un checker deve far riferimento ad un elenco delle risorse fornito da un umano. Come inizio [starters], sappiamo dei contenitori della libreria standard, <code>string</code> e smart pointer. L’utilizzo di <code>span</code> e <code>string_span</code> dovrebbe aiutare molto (non sono handle di risorse).</p>
<h3 id="discussione-un-puntatore-semplice-o-un-riferimento-non-è-mai-un-handle-di-una-risorsa"><a name="Cr-raw"></a>Discussione: Un puntatore “semplice” o un riferimento non è mai un handle di una risorsa</h3>
<h5 id="motivo-452">Motivo</h5>
<p>Essere in grado di distinguere i proprietari dalle viste.</p>
<h5 id="note-398">Note</h5>
<p>Questo è indipendente da come si “scrive” il puntatore: <code>T*</code>, <code>T&amp;</code>, <code>Ptr&lt;T&gt;</code> and <code>Range&lt;T&gt;</code> non sono proprietari [owner].</p>
<h3 id="discussione-non-lasciare-mai-che-un-puntatore-sopravviva-alloggetto-a-cui-punta"><a name="Cr-outlive"></a>Discussione: Non lasciare mai che un puntatore sopravviva all’oggetto a cui punta</h3>
<h5 id="motivo-453">Motivo</h5>
<p>Per evitare errori estremamente difficili da trovare. De-referenziare puntatore del genere porta a un comportamento indefinito e potrebbe violare il sistema dei tipi.</p>
<h5 id="esempio-401">Esempio</h5>
<pre><code>string* bad()   // davvero pessimo
{
vector&lt;string&gt; v = { &quot;This&quot;, &quot;will&quot;, &quot;cause&quot;, &quot;trouble&quot;, &quot;!&quot; };
// leak di un puntatore in un membro distrutto di un oggetto distrutto (v)
return &amp;v[0];
}

void use()
{
string* p = bad();
vector&lt;int&gt; xx = {7, 8, 9};
// comportamento indefinito: x potrebbe non essere la &quot;This&quot;
string x = *p;
// comportamento indefinito: non sappiamo che cosa (se c&#39;è) è allocato alla posizione p
*p = &quot;Evil!&quot;;
}</code></pre>
<p>Le <code>string</code>he di <code>v</code> vengono distrutte all’uscita da <code>bad()</code> e così anche lo stesso <code>v</code>. Il puntatore restituito punta alla memoria non allocata nel free store. Questa memoria (puntata da<code>p</code>) potrebbe essere stata riallocata al momento dell’esecuzione di <code>*p</code>. Potrebbe non esserci alcuna <code>string</code> da leggere e una scrittura in <code>p</code> potrebbe facilmente corrompere oggetti di tipo diverso.</p>
<h5 id="imposizione-405">Imposizione</h5>
<p>Molti compilatori già allertano per i casi semplici ed hanno le informazioni per fare altro. Si esamini qualsiasi puntatore restituito da una funzione sospetta. Usare i contenitori, gli handle delle risorse e le viste (p.es., <code>span</code> noti per non essere handle di risorse) per ridurre il numero di casi da esaminare. Per cominciare, si esamini ogni classe con un distruttore come handle di risorsa.</p>
<h3 id="discussione-usare-i-template-per-esprimere-i-contenitori-ed-altri-gestori-di-risorse"><a name="Cr-templates"></a>Discussione: Usare i template per esprimere i contenitori (ed altri gestori di risorse)</h3>
<h5 id="motivo-454">Motivo</h5>
<p>Per fornire staticamente una gestione di elementi [type-safe].</p>
<h5 id="esempio-402">Esempio</h5>
<pre><code>template&lt;typename T&gt; class Vector {
// ...
T* elem;   // punta a sz elementi di tipo T
int sz;
};</code></pre>
<h3 id="discussione-restituire-i-contenitori-per-valore-basandosi-per-efficienza-sullo-spostamento-move-o-sullelisione-della-copia"><a name="Cr-value-return"></a>Discussione: Restituire i contenitori per valore (basandosi, per efficienza, sullo spostamento [move] o sull’elisione della copia)</h3>
<h5 id="motivo-455">Motivo</h5>
<p>Semplificare il codice ed eliminare la necessità di una gestione esplicita della memoria. Portare un oggetto in uno scope più esterno, prolungandone così la durata.</p>
<p><strong>Si veda anche</strong>: <a href="#Rf-out">F.20, l’argomento generale sulla “restituzione” dei valori in output</a></p>
<h5 id="esempio-403">Esempio</h5>
<pre><code>vector&lt;int&gt; get_large_vector()
{
return ...;
}

auto v = get_large_vector(); //  il return per valore è ok, la maggior parte dei moderni compilatori farà la [copy elision]</code></pre>
<h5 id="eccezione-55">Eccezione</h5>
<p>Si vedano le Eccezioni in <a href="#Rf-out">F.20</a>.</p>
<h5 id="imposizione-406">Imposizione</h5>
<p>Controllare i puntatori e i riferimenti restituiti dalle funzioni e vedere se vengono assegnati a handle di risorse (p.es., a un <code>unique_ptr</code>).</p>
<h3 id="discussione-se-una-classe-è-un-handle-di-una-risorsa-necessita-di-un-costruttore-un-distruttore-e-le-operazioni-di-copia-eo-spostamento"><a name="Cr-handle"></a>Discussione: Se una classe è un handle di una risorsa, necessita di un costruttore, un distruttore, e le operazioni di copia e/o spostamento</h3>
<h5 id="motivo-456">Motivo</h5>
<p>Fornire il controllo completo della durata della risorsa. Fornire un insieme coerente di operazioni sulla risorsa.</p>
<h5 id="esempio-404">Esempio</h5>
<pre><code>??? Problemi con i puntatori</code></pre>
<h5 id="note-399">Note</h5>
<p>Se tutti i membri sono handle di risorse, affidarsi, ove possibile, alle operazioni speciali di default.</p>
<pre><code>template&lt;typename T&gt; struct Named {
string name;
T value;
};</code></pre>
<p>Ora <code>Named</code> ha un costruttore di default, un distruttore e delle efficienti operazioni di copia e spostamento, purché le abbia <code>T</code>.</p>
<h5 id="imposizione-407">Imposizione</h5>
<p>In generale, un tool non può sapere se una classe è un handle di una risorsa. Tuttavia, se una classe ha alcune delle <a href="#SS-ctor">operazioni di default</a>, dovrebbe avere tutto e se la classe ha un membro che è un handle di risorsa, dovrebbe essere considerata come handle di risorse.</p>
<h3 id="discussione-se-una-classe-è-un-contenitore-fornirle-un-costruttore-con-un-elenco-di-inizializzatori"><a name="Cr-list"></a>Discussione: Se una classe è un contenitore, fornirle un costruttore con un elenco-di-inizializzatori</h3>
<h5 id="motivo-457">Motivo</h5>
<p>Normalmente si ha bisogno di un insieme iniziale di elementi.</p>
<h5 id="esempio-405">Esempio</h5>
<pre><code>template&lt;typename T&gt; class Vector {
public:
Vector(std::initializer_list&lt;T&gt;);
// ...
};

Vector&lt;string&gt; vs { &quot;Nygaard&quot;, &quot;Ritchie&quot; };</code></pre>
<h5 id="imposizione-408">Imposizione</h5>
<p>Quando una classe è un contenitore? ???</p>
<h1 id="appendice-d-strumenti-tool-di-supporto"><a name="S-tools"></a>Appendice D: Strumenti [tool] di supporto</h1>
<p>Questa sezione contiene un elenco di tool che supportano direttamente l’adozione delle “C++ Core Guidelines”. Questo non intende essere un elenco esaustivo di strumenti utili alla scrittura di buon codice C++. Se un tool è specificatamente progettato per supportare e collegarsi alle “C++ Core Guidelines” è candidato per l’inclusione.</p>
<h3 id="tools-clang-tidy"><a name="St-clangtidy"></a>Tools: <a href="http://clang.llvm.org/extra/clang-tidy/checks/list.html">Clang-tidy</a></h3>
<p>Clang-tidy ha una serie di regole che specificamente impongono le “C++ Core Guidelines”. Queste regole vengono chiamate nel modello [pattern] <code>cppcoreguidelines-*</code>.</p>
<h3 id="tools-cppcorecheck"><a name="St-cppcorecheck"></a>Tools: <a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/using-the-cpp-core-guidelines-checkers">CppCoreCheck</a></h3>
<p>L’analisi del codice C++ del compilatore Microsoft contiene una serie di regole specificamente finalizzate all’applicazione delle “C++ Core Guidelines”.</p>
<h1 id="glossario"><a name="S-glossary"></a>Glossario</h1>
<p>Una definizione relativamente informale dei termini usati nelle linee-guida (basato sul glossario in <a href="http://www.stroustrup.com/programming.html">Programming: Principles and Practice using C++</a>)</p>
<p>Maggiori informazioni su molti argomenti riguardo al C++ si possono trovare sul sito della <a href="https://isocpp.org">Standard C++ Foundation</a>.</p>
<ul>
<li><em>ABI</em>: Application Binary Interface, una specifica per una data piattaforma hardware combinata col sistema operativo. In contrapposizione alle API.</li>
<li><em>classe astratta</em>: una classe che non può essere usata direttamente per creare oggetti; spesso usata per definire un’interfaccia per le classi derivate. Una classe viene resa astratta avendo una funzione virtuale pura o solo costruttori protetti.</li>
<li><em>astrazione</em>: una descrizione che ignora in modo selettivo o deliberato (nasconde) dei dettagli (p.es., i dettagli implementativi); ignoranza selettiva.</li>
<li><em>indirizzo</em>: un valore che consente di trovare un oggetto nella memoria del computer.</li>
<li><em>algoritmo</em>: una procedura o una formula per rislvere un problema; una serie finita di passaggi computazionali per produrre un risultato.</li>
<li><em>alias</em>: un modo alternativo per riferirsi ad un oggetto; spesso un nome, un puntatore o un riferimento.</li>
<li><em>API</em>: Application Programming Interface, un insieme di funzioni che formano la comunicazione tra i vari componenti software. In contrapposizione alla ABI.</li>
<li><em>applicazione</em>: un programma o un insieme di programmi che viene considerato un’entità dagli utenti.</li>
<li><em>approssimazione</em>: qualcosa (p.es., un valore o un progetto) che è quasi (un valore o un progetto) perfetto o ideale. Spesso un’approssimazione è il risultato di un compromesso con l’ideale.</li>
<li><em>argomento</em>: un valore passato ad una funzione o a un template, in cui vi si accede tramite un parametro.</li>
<li><em>array</em>: una sequenza omogenea di elementi, solitamente numerati, p.es., <code>[0:max)</code>.</li>
<li><em>asserzione</em>: un’istruzione inserita in un programma per affermare (asserire) che qualcosa deve sempre essere vero in questo punto del programma.</li>
<li><em>classe base</em>: una classe usata come base di una gerarchia di classi. In genere una classe base ha una o più funzioni virtuali.</li>
<li><em>bit</em>: l’unita elementare dell’informazione in un computer. Un bit può avere un valore di 0 o di 1.</li>
<li><em>bug</em>: un errore in un programma.</li>
<li><em>byte</em>: l’unità elementare di indirizzamento nella maggior parte dei computer. Solitamente, un byte contiene 8 bit.</li>
<li><em>classe</em>: un tipo definito dall’utente [user-defined] contenente dati membro, funzioni membro e tipi membro.</li>
<li><em>codice</em>: un programma o parte di esso; usato ambiguamente sia per il codice sorgente che per il codice oggetto.</li>
<li><em>compilatore</em>: un programma che trasforma il codice sorgente in codice oggetto.</li>
<li><em>complessità</em>: una nozione difficile-da-definire-precisamente della misura della difficoltà di costruire una soluzione ad un problema o della stessa soluzione. Talvolta la complessità è usata per indicare (semplicemente) una stima del numero di operazioni necessarie per eseguire un algoritmo.</li>
<li><em>computazione</em>: l’esecuzione di un certo codice, solitamente prendendo qualche input e producendo qualche output.</li>
<li><em>concetto</em>: (1) una nozione e un’idea; (2) un insieme di requisiti, solitamente per l’argomento di un template.</li>
<li><em>classe concreta</em>: una classe per la quale gli oggetti possono essere creati usando la solita sintassi della costruzione (p.es., sullo stack) e l’oggetto risultante si comporta in modo molto simile ad un <code>int</code> per quanto riguarda la copia, il confronto, e simili (al contrario di una classe base in una gerarchia).</li>
<li><em>costante</em>: un valore che non può essere cambiato (in un determinato scope); non mutabile.</li>
<li><em>costruttore</em>: un’operazione che inizializza (“costruisce”) un oggetto. In genere un costruttore stabilisce un invariante e spesso acquisisce le risorse necessarie per un oggetto per essere usate (che vengono poi generalmente rilasciate da un distruttore).</li>
<li><em>contenitore</em>: un oggetto che contiene elementi (atri oggetti).</li>
<li><em>copia</em>: un’operazione che rende due oggetti i cui valori se confrontati risultano uguali. Si veda anche spostamento [move].</li>
<li><em>correttezza</em>: un programma o parte di esso è corretto se soddisfa le sue specifiche. Sfortunatamente, una specifica può essere incompleta o incoerente, oppure può non rispondere alle aspettative degli utenti. Quindi, per produrre un codice accettabile, talvolta si deve fare di più che seguire semplicemente le specifiche formali.</li>
<li><em>costo</em>: il costo (p.es., in tempo del programmatore, in tempo di esecuzione o in spazio) per produrre un programma o eseguirlo. Idealmente, il costo dovrebbe essere in funzione della complessità.</li>
<li><em>punto di personalizzazione [customization point]</em>: ???</li>
<li><em>dati</em>: i valori usati in un calcolo.</li>
<li><em>debugging</em>: la ricerca e la rimozione di errori in un programma; di solito molto meno sistematico dei test.</li>
<li><em>dichiarazione</em>: la specifica di un nome col suo tipo in un programma.</li>
<li><em>definizione</em>: una dichiarazione di un’entità che fornisce tutte le informazioni necessarie per consentire ad un programma di usarla. Definizione semplificata: una dichiarazione che alloca memoria.</li>
<li><em>classe derivata</em>: una classe derivata da una o più classi base.</li>
<li><em>progetto [design]</em>: una descrizione generale di come un software dovrebbe operare per rispondere alle sue specifiche.</li>
<li><em>distruttore</em>: un’operazione implicitamente invocata (chiamata) quando un oggetto viene distrutto (p.es., uscendo dal suo scope). Spesso rilascia le risorse.</li>
<li><em>incapsulamento</em>: la protezione di qualcosa che deve essere privato (p.es., i dettagli implementativi) da accessi non autorizzati.</li>
<li><em>errore</em>: una discrepanza tra ciò che ragionevolmente ci si aspetta da un programma (spesso espresso come un requisito o una guida per l’utente) e quello che effettivamente fa il programma.</li>
<li><em>eseguibile</em>: un programma pronto a girare (ad essere eseguito) su un computer.</li>
<li><em>[feature creep]</em>: una tendenza ad aggiungere funzionalità in eccesso a un programma “per ogni evenienza”.</li>
<li><em>file</em>: un contenitore di informazioni permanenti in un computer.</li>
<li><em>numero in virgola mobile [floating-point]</em>: l’approssimazione in un computer di un numero reale, come ad esempio 7.93 e 10.78e-3.</li>
<li><em>funzione</em>: una unità di codice, con un nome, che può essere invocata (chiamata) da diverse parti di un programma; una unità logica di calcolo.</li>
<li><em>programmazione generica</em>: uno stile di programmazione incentrato sulla progettazione e un’efficiente implementazione degli algoritmi. Un algoritmo generico funzionerà con tutti i tipi di argomenti che risponderanno ai suoi requisiti. In C++, solitamente la programmazione generica usa i template.</li>
<li><em>variabile globale</em>: tecnicamente, un oggetto, con un nome, nello scope del namespace.</li>
<li><em>gestore [handle]</em>: una classe che consente l’accesso ad altro tramite un puntatore o un riferimento membro. Si veda anche risorsa, copia, spostamento [move].</li>
<li><em>header</em>: un file contenente le dichiarazioni usate per condividere le interfacce tra le parti di un programma.</li>
<li><em>occultamento [hiding]</em>: l’atto di impedire la visualizzazione o l’accesso diretto ad un’informazione. Per esempio, un nome da uno scope nidificato (interno) può evitare che lo stesso nome da uno scope più esterno (racchiuso) dell’essere usato direttamente.</li>
<li><em>ideale</em>: la versione perfetta di qualcosa per cui ci si sta occupando. Solitamente ci sono dei compromessi da fare e ci si accontenta di un’approssimazione.</li>
<li><em>implementazione</em>: (1) l’atto di scrivere e testare il codice; (2) il codice che implementa un programma.</li>
<li><em>loop infinito</em>: un ciclo [loop] dove la condizione di terminazione non diventa mai vera. Si veda iterazione.</li>
<li><em>ricorsione infinita</em>: una ricorsione che non finisce fino a quando la macchina non esaurisce la memoria per effettuare le chiamate. In realtà, questa ricorsione non è mai infinita ma viene interrotta da un errore hardware.</li>
<li><em>information hiding</em>: l’atto di separare l’interfaccia dall’implementazione, nascondendo così i dettagli dell’implementazione non destinati all’attenzione degli utenti e fornendo un’astrazione.</li>
<li><em>inizializzare</em>: dare ad un oggetto il suo primo (iniziale) valore.</li>
<li><em>input</em>: i valori usati da una elaborazione (p.es., gli argomenti d una funzione o i caratteri digitati su una tastiera).</li>
<li><em>intero [integer]</em>: un numero intero, come 42 e -99.</li>
<li><em>interfaccia</em>: una dichiarazione o una serie di dichiarazioni che specifica come un pezzo di codice (come una funzione o una classe) debba essere chiamato.</li>
<li><em>invariante</em>: qualcosa che deve essere sempre vero in un dato punto (o punti) di un programma; tipicamente usato per descrivere lo stato (l’insieme dei valori) di un oggetto o lo stato di un loop prima di entrare nelle istruzioni da ripetere.</li>
<li><em>iterazione</em>: l’atto di eseguire ripetutamente un pezzo di codice; si vada ricorsione.</li>
<li><em>iteratore</em>: un oggetto che identifica un elemento di una sequenza.</li>
<li><em>ISO</em>: International Organization for Standardization (Organizzazione Internazionale per la Standardizzazione). Il linguaggio C++ è uno standard ISO, ISO/IEC 14882. Ulteriori informazioni su <a href="http://iso.org">iso.org</a>.</li>
<li><em>libreria</em>: una raccolta di tipi, funzioni, classi, ecc. che implementano un insieme di servizi (astrazioni) destinate a essere potenzialmente utilizzate come parte di più programmi.</li>
<li><em>ciclo-di-vita [lifetime]</em>: il tempo dall’inizializzazione di un oggetto fino a quando diventa inutilizzabile (esce dallo scope, viene cancellato o il programma termina).</li>
<li><em>linker</em>: un programma che unisce file di codice oggetto e librerie formando un programma eseguibile.</li>
<li><em>letterale [literal]</em>: una notazione che indica direttamente un valore, così come 12 indica il valore intero di “dodici”.</li>
<li><em>ciclo [loop]</em>: un pezzo di codice eseguito ripetutamente; in C++, solitamente un’istruzione “for” o un’istruzione <code>while</code>.</li>
<li><em>spostamento [move]</em>: un’operazione ce trasferisce un valore da un oggetto ad un altro lasciandosi dietro un valore che rappresenti il “vuoto”. Si veda anche la copia.</li>
<li><em>mutabile [mutable]</em>: modificabile; l’opposto di immutabile, costante e invariabile.</li>
<li><em>oggetto</em>: (1) una regione di memoria inizializzata di un tipo noto che contiene un valore di quel tipo; (2) una regione di memoria.</li>
<li><em>codice oggetto</em>: l’output di un compilatore inteso come input per un linker (affinché il linker produca codice eseguibile).</li>
<li><em>file oggetto</em>: un file contenente codice oggetto.</li>
<li><em>programmazione object-oriented</em>: (OOP) uno stile di programmazione incentrato sulla progettazione e l’uso di classi e gerarchie di classi.</li>
<li><em>operazione</em>: qualcosa che può eseguire qualche azione, come una funzione o un operatore.</li>
<li><em>output</em>: i valori prodotti da una elaborazione (p.es., il risultato di una funzione o le righe di caratteri scritte sullo schermo).</li>
<li><em>overflow</em>: la produzione di un valore che non può essere memorizzato nella sua destinazione prevista.</li>
<li><em>overload</em>: la definizione di due funzioni o operatori con lo stesso nome ma tipi di argomenti diversi (operandi).</li>
<li><em>override</em>: definire una funzione in una classe derivata con lo stesso nome e tipi di argomenti di una funzione virtuale nella classe base, rendendo così la funzione richiamabile attraverso l’interfaccia definita dalla classe base.</li>
<li><em>proprietario [owner]</em>: un oggetto responsabile del rilascio di una risorsa.</li>
<li><em>paradigma</em>: un termine un po’ pretenzioso per uno stile di progettazione o programmazione; usato spesso con (l’errata) implicazione che esiste un paradigma che sia superiore a tutti gli altri.</li>
<li><em>parametro</em>: una dichiarazione di un input esplicito di una funzione o di un template. Quando viene chiamata, una funzione può accedere agli argomenti passati tramite i nomi dei suoi parametri.</li>
<li><em>puntatore</em>: (1) un valore usato per identificare un oggetto di un certo tipo nella memoria; (2) una variabile che contiene tale valore.</li>
<li><em>post-condizione</em>: una condizione che deve mantenuta all’uscita da un blocco di codice, come una funzione o un loop.</li>
<li><em>pre-condizione</em>: una condizione che deve mantenuta entrando in un blocco di codice, come una funzione o un loop.</li>
<li><em>programma</em>: codice (probabilmente corredato con dei dati) che è sufficientemente completo da poter essere eseguito da un computer.</li>
<li><em>programmazione</em>: l’arte di esprimere col codice delle soluzioni a dei problemi.</li>
<li><em>linguaggio di programmazione</em>: un linguaggio per esprimere programmi.</li>
<li><em>pseudo codice</em>: una descrizione di un calcolo scritto con una notazione informale anziché con un linguaggio di programmazione.</li>
<li><em>funzione virtuale pura</em>: una funzione virtuale che deve essere sovrascritta in una classe derivata.</li>
<li><em>RAII</em>: (“Resource Acquisition Is Initialization”) una tecnica di base per la gestione delle risorse basata sugli scope.</li>
<li><em>range</em>: una sequenza di valori che si possono descrivere con un punto iniziale ed uno finale. Per esempio, <code>[0:5)</code> indica i valori 0, 1, 2, 3, e 4.</li>
<li><em>ricorsione</em>: l’azione di una funzione che chiama se stessa; cfr. iterazione.</li>
<li><em>riferimento</em>: (1) un valore che descrive la locazione di un oggetto di un certo tipo nella memoria; (2) una variabile che contiene tale valore.</li>
<li><em>espressione regolare</em>: una notazione per i pattern in stringhe di caratteri.</li>
<li><em>regolare</em>: un tipo che si comporta come i tipi nativi come <code>int</code> e che può essere confrontato con <code>==</code>. In particolare, un oggetto di un tipo regolare può essere copiato, e il risultato della copia è un oggetto separato che risulta uguale al primo se si confrontano. Si veda anche <em>tipo semi-regolare</em>.</li>
<li><em>requisito</em>: (1) una descrizione del comportamento desiderato di un programma o di parte di un programma; (2) una descrizione delle assunzioni che una funzione o un template fa sui suoi argomenti.</li>
<li><em>risorsa</em>: qualcosa che viene acquisito e che deve poi essere rilasciato, come un handle di file, un lock o della memoria. Si veda anche handle, proprietario [owner].</li>
<li><em>arrotondamento</em>: conversione di un valore al valore matematicamente più vicino di un tipo meno preciso.</li>
<li><em>RTTI</em>: Run-Time Type Information. ???</li>
<li><em>scope</em>: la regione del testo di un programma (il codice sorgente) entro cui si può far riferimento ad un nome.</li>
<li><em>semi-regolare</em>: un tipo che si comporta quasi come i tipi nativi come <code>int</code>, ma forse senza un operatore <code>==</code>. Si veda anche <em>tipo regolare</em>.</li>
<li><em>sequenza</em>: elementi che si possono scorrere con un ordine lineare.</li>
<li><em>software</em>: una raccolta di pezzi di codice e dati correlati; spesso usato in modo intercambiabile con programma.</li>
<li><em>codice sorgente</em>: il codice prodotto da un programmatore e (in linea di principio) leggibile da altri programmatori.</li>
<li><em>file sorgente</em>: un file contenente il codice sorgente.</li>
<li><em>specifica</em>: una descrizione di quello che dovrebbe fare un pezzo di codice.</li>
<li><em>standard</em>: una definizione ufficialmente concordata di qualcosa, come un linguaggio di programmazione.</li>
<li><em>stato</em>: un insieme di valori.</li>
<li><em>STL</em>: i contenitori, gli iteratori e gli algoritmi facenti parte della libreria standard.</li>
<li><em>stringa</em>: una sequenza di caratteri.</li>
<li><em>stile</em>: un insieme di tecniche per la programmazione che portano ad un uso coerente delle funzionalità del linguaggio; talvolta usato in senso molto limitato per riferirsi solo alle regole di basso livello sulla nomenclatura e l’aspetto del codice.</li>
<li><em>sotto-tipo</em>: un tipo derivato; un tipo che ha tutte le proprietà di un altro tipo e probabilmente delle altre.</li>
<li><em>super-tipo</em>: un tipo base; un tipo che ha un sotto-insieme delle proprietà di un tipo.</li>
<li><em>sistema</em>: (1) un programma o un insieme di programmi per eseguire un’attività su un computer; (2) un’abbreviazione per “sistema operativo”, ovvero, l’ambiente di esecuzione fondamentale e gli strumenti [tool] per un computer.</li>
<li><em>TS</em>: <a href="https://www.iso.org/deliverables-all.html?type=ts">Technical Specification</a>, Una “Specifica Tecnica” indirizza un lavoro ancora in fase di sviluppo tecnico o dove si ritiene che ci sarà una futura possibilità, ma non immediata, per un riconoscimento in uno Standard Internazionale. Una Specifica Tecnica viene pubblicata per un uso immediato, ma fornisce anche un mezzo per ottenere dei feedback. Lo scopo è quello di essere eventualmente trasformato e ripubblicato come Standard Internazionale.</li>
<li><em>template</em>: una classe o una funzione parametrizzata con uno o più tipi o (durante la compilazione) con dei valori; il costrutto base del linguaggio C++ che supporta la programmazione generica.</li>
<li><em>testing</em>: una ricerca sistematica degli errori in un programma.</li>
<li><em>compromesso [trade-off]</em>: il risultato del bilanciamento tra diversi criteri di progettazione e implementazione.</li>
<li><em>troncamento</em>: la perdita di informazioni in una conversione da un tipo ad un altro che non può rappresentare esattamente il tipo da convertire.</li>
<li><em>tipo</em>: qualcosa che definisce l’insieme dei possibili valori e l’insieme delle possibili operazioni per un oggetto.</li>
<li><em>non-inizializzato</em>: lo stato (indefinito) di un oggetto prima che venga inizializzato.</li>
<li><em>unità</em>: (1) una misura standard che dà significato ad un valore (p.es., km per una distanza); (2) una parte distinta (p.es. con un nome) di un tutto più grande.</li>
<li><em>caso d’uso</em>: uno specifico uso (solitamente semplice) di un programma per testarne il funzionamento e mostrarne lo scopo.</li>
<li><em>valore</em>: un insieme di bit nella memoria interpretati secondo un tipo.</li>
<li><em>variabile</em>: un oggetto di un certo tipo con un nome; contiene un valore a meno che non sia non-inizializzato.</li>
<li><em>funzione virtuale</em>: una funzione membro che può essere sovrascritta in una classe derivata.</li>
<li><em>word</em>: una unità base di memoria in un computer, spesso l’unità usata per contenere un intero.</li>
</ul>
<h1 id="da-fare-to-do-proto-regole-non-classificate"><a name="S-unclassified"></a>Da-fare [To-do]: Proto-regole non classificate</h1>
<p>Questa è la lista delle cose da fare. Alla fine, le voci diventeranno regole o parti di esse. Oppure, si deciderà di non cambiare nulla e la voce verrà cancellata.</p>
<ul>
<li><p>Nessuna funzione friend distante</p></li>
<li><p>Si dovrebbe affrontare il progetto fisico (cosa c’è in un file) e quello su larga scala (librerie, gruppi di librerie)?</p></li>
<li><p>I namespace</p></li>
<li><p>Evitare di usare direttive negli scope globali (eccetto std ed altri namespace “fondamentali” (p.es. experimental))</p></li>
<li><p>Quanto devono essere granulari i namespace? Tutte le classi/funzioni progettate per funzionare assieme e rilasciate insieme (come definite in Sutter/Alexandrescu) oppure qualcosa di più restrittivo o più ampio?</p></li>
<li><p>Ci dovrebbero essere dei namespace inline (tipo <code>std::literals::*_literals</code>)?</p></li>
<li><p>Evitare le conversioni implicite</p></li>
<li><p>Le funzioni membro const dovrebbero essere [thread safe] … aka, ma io non cambio effettivamente la variabile, le assegno solo un valore la prima volta che la chiamo … argh</p></li>
<li><p>Inizializzare sempre le variabili, utilizzare le liste di inizializzazione per le variabili membro.</p></li>
<li><p>A chiunque scriva un’interfaccia pubblica che prenda o restituisca <code>void*</code> gli si dovrebbero tagliare le mani. Questa è stata la favorita per diversi anni. :)</p></li>
<li><p>Dove possibile usare <code>const</code> per: funzioni membro, variabili e (urrà) <code>const_iterators</code></p></li>
<li><p>Utilizzare <code>auto</code></p></li>
<li><p><code>(size)</code> rispetto a <code>{initializers}</code> rispetto a <code>{Extent{size}}</code></p></li>
<li><p>Non astrarre troppo [overabstract]</p></li>
<li><p>Mai passare un puntatore nello stack della chiamata</p></li>
<li><p>verso una funzione sottostante</p></li>
<li><p>Dovrebbero esserci delle linee-guida per scegliere tra i polimorfismi? SI. stile classico (funzioni virtuali, semantica del riferimento) rispetto allo “Sean Parent” (semantica del valore, [type-erased], cose come <code>std::function</code>) rispetto a CRTP/static [Curiously Recurring Template Pattern]? SI Forse anche rispetto a [tag dispatch]?</p></li>
<li><p>le chiamate virtuali dovrebbero essere bandite dai costruttori/distruttori nelle linee-guida? SI. Molte persone le bandiscono, anche se si pensa che siano un grande punto di forza del C++ ??? -preserving (D ha tanto deluso quando è andato verso Java). QUALE SARÀ UN BUON ESEMPIO?</p></li>
<li><p>Parlando di lambda, cosa peserebbe nella decisione tra lambda e classi (locali?) nelle chiamate di algoritmi e altri scenari sulle callback?</p></li>
<li><p>E parlando di <code>std::bind</code>, Stephen T. Lavavej lo critica così tanto che c’è da chiedersi se in futuro sparirà. Si dovrebbero invece consigliare le lambda?</p></li>
<li><p>Cosa fare con i leak di temporanei? : <code>p = (s1 + s2).c_str();</code></p></li>
<li><p>invalidazione di un puntatore/iteratore che ha a che fare con puntatori appesi [dangling]:</p>
<pre><code> void bad()
 {
 int* p = new int[700];
 int* q = &amp;p[7];
 delete p;

 vector&lt;int&gt; v(700);
 int* q2 = &amp;v[7];
 v.resize(900);

 // ... usa q e q2 ...
 }</code></pre></li>
<li><p>LSP [Liskov Substitution Principle]</p></li>
<li><p>ereditarietà privata rispetto ai membri</p></li>
<li><p>evitare come variabili membro di classi statiche (conflitti, variabili quasi-globali)</p></li>
<li><p>Usare protezioni con lock RAII (<code>lock_guard</code>, <code>unique_lock</code>, <code>shared_lock</code>), mai chiamare <code>mutex.lock</code> e <code>mutex.unlock</code> direttamente (RAII)</p></li>
<li><p>Preferire lock non-ricorsivi (spesso usati per aggirare cattive scelte [reasoning], [overhead])</p></li>
<li><p>Unire [join] i thread! (a causa di <code>std::terminate</code> nel distruttore se non è unito [joined] o staccato [detached] … c’è una buona ragione per staccare [detach] i thread?) – ??? potrebbe la libreria di supporto fornire un wrapper RAII per <code>std::thread</code>?</p></li>
<li><p>Se si devono acquisire due o più mutex contemporaneamente, usare <code>std::lock</code> (o un altro algoritmo per evitare i [deadlock]?)</p></li>
<li><p>Quando si usa una <code>condition_variable</code>, proteggere sempre la condizione con un mutex (il booleano atomico il cui valore è settato esternamente al mutex è sbagliato!), ed usare lo stesso mutex per la variabile della condizione stessa.</p></li>
<li><p>Mai usare <code>atomic_compare_exchange_strong</code> con <code>std::atomic&lt;user-defined-struct&gt;</code> (le differenze materia di riempimento, mentre <code>compare_exchange_weak</code> in un loop converge ad un riempimento stabile)</p></li>
<li><p>i singoli oggetti <code>shared_future</code> non sono [thread-safe]: due thread non possono aspettare per lo stesso oggetto <code>shared_future</code> (possono attendere su copie di <code>shared_future</code> che si riferiscono alo stesso stato condiviso)</p></li>
<li><p>I singoli oggetti <code>shared_ptr</code> non sono thread-safe: thread diversi possono chiamare funzioni membro non-<code>const</code> su <em>diversi</em> <code>shared_ptr</code> che fanno riferimento allo stesso oggetto condiviso, ma un thread non può chiamare una funzione membro non-<code>const</code> di un oggetto <code>shared_ptr</code> mentre un altro thread accede allo stesso oggetto <code>shared_ptr</code> (se o si deve fare, si consideri invece <code>atomic_shared_ptr</code>)</p></li>
<li><p>regole per l’aritmetica</p></li>
</ul>
<h1 id="bibliografia">Bibliografia</h1>
<ul>
<li><a name="Abrahams01"></a> [Abrahams01]: D. Abrahams. <a href="http://www.boost.org/community/exception_safety.html">Exception-Safety in Generic Components</a>.</li>
<li><a name="Alexandrescu01"></a> [Alexandrescu01]: A. Alexandrescu. Modern C++ Design (Addison-Wesley, 2001).</li>
<li><a name="Cplusplus03"></a> [C++03]: ISO/IEC 14882:2003(E), Programming Languages — C++ (updated ISO and ANSI C++ Standard including the contents of (C++98) plus errata corrections).</li>
<li><a name="CplusplusCS"></a> [C++CS]: ???</li>
<li><a name="Cargill92"></a> [Cargill92]: T. Cargill. C++ Programming Style (Addison-Wesley, 1992).</li>
<li><a name="Cline99"></a> [Cline99]: M. Cline, G. Lomow, and M. Girou. C++ FAQs (2ndEdition) (Addison-Wesley, 1999).</li>
<li><a name="Dewhurst03"></a> [Dewhurst03]: S. Dewhurst. C++ Gotchas (Addison-Wesley, 2003).</li>
<li><a name="Henricson97"></a> [Henricson97]: M. Henricson and E. Nyquist. Industrial Strength C++ (Prentice Hall, 1997).</li>
<li><a name="Koenig97"></a> [Koenig97]: A. Koenig and B. Moo. Ruminations on C++ (Addison-Wesley, 1997).</li>
<li><a name="Lakos96"></a> [Lakos96]: J. Lakos. Large-Scale C++ Software Design (Addison-Wesley, 1996).</li>
<li><a name="Meyers96"></a> [Meyers96]: S. Meyers. More Effective C++ (Addison-Wesley, 1996).</li>
<li><a name="Meyers97"></a> [Meyers97]: S. Meyers. Effective C++ (2nd Edition) (Addison-Wesley, 1997).</li>
<li><a name="Meyers15"></a> [Meyers15]: S. Meyers. Effective Modern C++ (O’Reilly, 2015).</li>
<li><a name="Murray93"></a> [Murray93]: R. Murray. C++ Strategies and Tactics (Addison-Wesley, 1993).</li>
<li><a name="Stroustrup94"></a> [Stroustrup94]: B. Stroustrup. The Design and Evolution of C++ (Addison-Wesley, 1994).</li>
<li><a name="Stroustrup00"></a> [Stroustrup00]: B. Stroustrup. The C++ Programming Language (Special 3rdEdition) (Addison-Wesley, 2000).</li>
<li><a name="Stroustrup05"></a> [Stroustrup05]: B. Stroustrup. <a href="http://www.stroustrup.com/SELLrationale.pdf">A rationale for semantically enhanced library languages</a>.</li>
<li><a name="Stroustrup13"></a> [Stroustrup13]: B. Stroustrup. <a href="http://www.stroustrup.com/4th.html">The C++ Programming Language (4th Edition)</a>. Addison Wesley 2013.</li>
<li><a name="Stroustrup14"></a> [Stroustrup14]: B. Stroustrup. <a href="http://www.stroustrup.com/Tour.html">A Tour of C++</a>. Addison Wesley 2014.</li>
<li><a name="Stroustrup15"></a> [Stroustrup15]: B. Stroustrup, Herb Sutter, and G. Dos Reis: <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Introduction%20to%20type%20and%20resource%20safety.pdf">A brief introduction to C++’s model for type- and resource-safety</a>.</li>
<li><a name="SuttHysl04b"></a> [SuttHysl04b]: H. Sutter and J. Hyslop. <a href="https://web.archive.org/web/20120926011837/http://www.drdobbs.com/collecting-shared-objects/184401839">Collecting Shared Objects</a> (C/C++ Users Journal, 22(8), August 2004).</li>
<li><a name="SuttAlex05"></a> [SuttAlex05]: H. Sutter and A. Alexandrescu. C++ Coding Standards. Addison-Wesley 2005.</li>
<li><a name="Sutter00"></a> [Sutter00]: H. Sutter. Exceptional C++ (Addison-Wesley, 2000).</li>
<li><a name="Sutter02"></a> [Sutter02]: H. Sutter. More Exceptional C++ (Addison-Wesley, 2002).</li>
<li><a name="Sutter04"></a> [Sutter04]: H. Sutter. Exceptional C++ Style (Addison-Wesley, 2004).</li>
<li><a name="Taligent94"></a> [Taligent94]: Taligent’s Guide to Designing Programs (Addison-Wesley, 1994).</li>
</ul>
</body>
</html>
